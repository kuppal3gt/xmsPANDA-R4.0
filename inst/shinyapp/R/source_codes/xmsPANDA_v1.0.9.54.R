options(warn=-1)
if(FALSE)
{
  #.libPaths(c("xmsPANDAv1.1/library", .libPaths()))
  
  options(keep.source.pkg=TRUE)
  
  suppressMessages(library(reshape2))
  suppressMessages(library(statmod))
  suppressMessages(library(rgl))
  suppressMessages(library(gplots))
  
  suppressMessages(library(cowplot))
  
  
  suppressMessages(library(WGCNA))
  suppressMessages(library(randomForest))
  suppressMessages(library(party))
  suppressMessages(library(qvalue))
  suppressMessages(library(fdrtool))
  
  
  suppressMessages(library(GeneNet))
  suppressMessages(library(glmnet))
  
  suppressMessages(library('KEGGREST'))
  
  
  suppressMessages(library(corpcor))
  
  suppressMessages(library(earth))
  
  suppressMessages(library(pROC))
  
  
  
  suppressMessages(library(RColorBrewer))
  
  suppressMessages(library(nlme))
  suppressMessages(library(multcomp))
  
  suppressMessages(library(pls))
  
  suppressMessages(library(igraph))
  
  suppressMessages(library(ROCR))
  
  suppressMessages(library(fastcluster)) #flashClust))
  
  #suppressMessages(library(data.table))
  
  suppressMessages(library(plyr))
  
  suppressMessages(library(mclust))
  
  suppressMessages(library(parallel))
  
  suppressMessages(library(RColorBrewer))
  
  suppressMessages(library(pcaMethods))
  
  suppressMessages(library(pamr))
  
  
  suppressMessages(library(GO.db))
  suppressMessages(library(mixOmics))
  suppressMessages(library(plsgenomics))
  suppressMessages(library(limma))
  suppressMessages(library(e1071))
  suppressMessages(library(RankAggreg))
  suppressMessages(library(lsmeans))
  suppressMessages(library(car))
  suppressMessages(library(CMA))
  suppressMessages(library(Boruta))
  suppressMessages(library(stepPlr))
  suppressMessages(library(impute))
  suppressMessages(library(ggpubr))
  #suppressMessages(library(extrafont))
  suppressMessages(library(sandwich))
  suppressMessages(library(cluster))
  suppressMessages(library(h2o))
  
  
  suppressMessages(library(tidyr))
  suppressMessages(library(parallel))
  suppressMessages(library(ggplot2))
  suppressMessages(library(genefilter))
  suppressMessages(library(raster))
  suppressMessages(library(RColorBrewer))
  #library(xmsPANDA)
  
  suppressMessages(library(gplots))
  #
  
}

runApp.xmsPANDALite <-
  function() {
    
    suppressMessages(library(shiny))
                     suppressMessages(library(shinyjs))
                                      suppressMessages(library(shinyBS))
                                                       suppressMessages(library(DT))
    
    appDir <- system.file("shinyappLite", package = "xmsPANDA")
    if (appDir == "") {
      stop("Could not find shinyappLite directory. Try re-installing `xmsPANDA`.", call. = FALSE)
    }
    
    shiny::runApp(appDir, display.mode = "normal")
  }


runApp.xmsPANDA <-
  function() {
    
    suppressMessages(library(shiny))
    suppressMessages(library(shinyjs))
    suppressMessages(library(shinyBS))
    suppressMessages(library(DT))
    
    appDir <- system.file("shinyapp", package = "xmsPANDA")
    if (appDir == "") {
      stop("Could not find shinyapp directory. Try re-installing `xmsPANDA`.", call. = FALSE)
    }
    
    shiny::runApp(appDir, display.mode = "normal")
  }

#generate mean, stdev, 95% CI for each variable
get_data_summary<-function(X=NA,Y=NA,feature_table_file=NA,parentoutput_dir=NA,
                               class_labels_file=NA,alphacol=0.3,col_vec=NA,pairedanalysis=FALSE,
                               point.cex.val=4,legendlocation="topright",pca.ellipse=TRUE,
                               ellipse.conf.level=0.95,filename="all",newdevice=FALSE,
                               lineplot.col.opt=c("grey57"),ylabel="Intensity",error.bar=TRUE,
                               cex.plots=0.8,
                               lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),
                               timeseries.lineplots=FALSE,name=NA,study.design="oneway",
                               alphabetical.order=TRUE,output.format="pdf",
                               multiple.figures.perpanel=TRUE,sizeval=1.5,plot.height=8,plot.width=8)
{
  
  
  cex.val=cex.plots
  
  suppressMessages(library(ggpubr))
  suppressMessages(library(ggplot2))
  
  analysistype=study.design
  
  if(is.na(parentoutput_dir)==TRUE){
    
    parentoutput_dir=getwd()
  }
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  }else{
    
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
  }else{
    
    classlabels<-Y
  }
  
  #addition start
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        name=Name
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          name=Name
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame(data_matrix)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  
  #addition end
  
  sample.col.opt=lineplot.col.opt
  
  par(mfrow=c(1,1),family="sans",cex=cex.val)
  
  #print("here")
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  mzvec<-data_matrix[,1]
  rtvec<-data_matrix[,2]
  
  rnames<-paste(mzvec,rtvec,sep="_")
  
  
  if(is.na(name[1])==TRUE){
    
    #mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
    rownames(data_m)<-as.character(rnames)
  }else{
    
    rownames(data_m)<-name
    
    rnames<-name
  }
  
  #  rownames(data_m)<-as.character(rnames)
  
  
  classlabels_orig<-classlabels
  
  if(analysistype=="onewayrepeat" | analysistype=="twowayrepeat" | analysistype=="onewayanovarepeat" | analysistype=="twowayanovarepeat"){
    
    pairedanalysis=TRUE
  }
  
  if(pairedanalysis==TRUE){
    
    # paireddesign=classlabels_orig[,2]
    
    #classlabels_orig<-classlabels_orig[,-c(2)]
  }
  
  if(dim(classlabels_orig)[2]>2){
    
    #classlabels_orig[,2]<-as.factor(paste("A",as.character(classlabels_orig[,2]),sep=""))
    #classlabels_orig[,3]<-as.factor(paste("B",as.character(classlabels_orig[,3]),sep=""))
    # print(head(classlabels_orig))
    
    if(analysistype=="twoway" | analysistype=="twowayrepeat" | analysistype=="twowayanova"){
      
      if(alphabetical.order==FALSE){
        classlabels_orig[,2] <- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
        classlabels_orig[,3] <- factor(classlabels_orig[,3], levels=unique(classlabels_orig[,3]))
        #t1=table(classlabels_orig[,3])
      }
      
      
      classgroup<-paste(classlabels_orig[,2],":",classlabels_orig[,3],sep="") #classlabels_orig[,2]:classlabels_orig[,3]
      do_pca_anova=FALSE
    }else{
      
      if(alphabetical.order==FALSE){
        classlabels_orig[,2] <- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
       
      }
      
      classgroup<-classlabels_orig[,2]
      do_pca_anova=TRUE
    }
    
    col_class_levels<-levels(as.factor(classlabels_orig[,2]))
  }else{
    
    if(alphabetical.order==FALSE){
      classlabels_orig[,2] <- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
     
    }
    
    classgroup<-classlabels_orig[,2]
    col_class_levels<-levels(as.factor(classlabels_orig[,2]))
    
    do_pca_anova=TRUE
  }
  
  
  
  
  
  
  
  
  
  class_labels_levels<-levels(as.factor(classgroup))
  ordered_labels<-classgroup
  
  class_label_alphabets<-paste("C",1:length(class_labels_levels),sep="") #c("A","B","C","D","E","F","G","H","I","J","K","L","M")
  
  if(newdevice==TRUE){
    
    fname<-paste("timeseriesplots",filename,".pdf",sep="")
    pdf(fname)
  }
  
  if(is.na(sample.col.opt)==FALSE)
  {
    if(sample.col.opt=="default"){
      
      col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
                 "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
                 "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
                 "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
      
    }else{
      if(sample.col.opt=="topo"){
        #col_vec<-topo.colors(256) #length(class_labels_levels))
        
        #col_vec<-col_vec[seq(1,length(col_vec),)]
        
        col_vec <- topo.colors(length(col_class_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="heat"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          
          col_vec <- heat.colors(length(col_class_levels), alpha=alphacol)
        }else{
          if(sample.col.opt=="rainbow"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            col_vec<-rainbow(length(col_class_levels), start = 0, end = alphacol)
            
            #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="terrain"){
              #col_vec<-heat.colors(256) #length(class_labels_levels))
              #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
              
              col_vec <- cm.colors(length(col_class_levels), alpha=alphacol)
            }else{
              if(is.na(sample.col.opt)==TRUE){
                col_vec<-c("black")
              }else{
                
                if(sample.col.opt=="colorblind"){
                  #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                  # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                  
                  if(length(col_class_levels)<9){
                    
                    col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                    
                  }else{
                    
                    #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                               "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                    
                  }
                  
                  
                }else{
                  
                  check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                  
                  if(length(check_brewer)>0){
                    
                    sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                    
                    col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(col_class_levels))
                    
                  }else{
                    
                    #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    if(sample.col.opt=="journal"){
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                 "#E64B3519","#4DBBD519","#631879E5","grey75")
                      if(length(class_labels_levels)<8){
                        col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                        
                        #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                        
                      }else{
                        if(length(class_labels_levels)<=28){
                          # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                          
                          col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                     "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                     "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                     
                                     "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                     "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                          
                        }else{
                          
                          
                          
                          
                          colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                          
                          col_vec<-col_vec[sample(col_vec)]
                          
                          
                        }
                      }
                      
                      
                      
                    }else{
                      #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                      
                     # if(length(sample.col.opt)==1){
                      #  col_vec <-rep(sample.col.opt,length(col_class_levels))
                      #}else{
                        
                       # colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(col_class_levels))
                        
                        ##savecolfunc,file="colfunc.Rda")
                        
                      #}
                      
                      if(length(sample.col.opt)==1){
                        col_vec <-rep(sample.col.opt,length(class_labels_levels))
                      }else{
                        
                        if(length(sample.col.opt)>=length(class_labels_levels)){
                          
                          col_vec <-sample.col.opt
                          col_vec <- rep(col_vec,length(class_labels_levels))
                          
                          
                        }else{
                          colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                        }
                        
                      }
                      
                      
                    }
                    
                  }
                  
                }
              }
            }
            
            
          }
          
        }
        
      }
    }
  }else{
    
    col_vec<-c("black")
    
  }
  
  #    print(class_labels_levels)
  
  ordered_labels={}
  num_samps_group<-new("list")
  num_samps_group[[1]]<-0
  groupwiseindex<-new("list")
  groupwiseindex[[1]]<-0
  
  
  col_vec=alpha(colour=col_vec,alpha=alphacol)
  
  class_col_vec=col_vec
  S<-new("list")
  for(c in 1:length(class_labels_levels))
  {
    
    classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
    
    num_samps_group[[c]]<-length(classlabels_index)
    groupwiseindex[[c]]<-classlabels_index
    
    
    
    
  }
  
  
  
  sampleclass<-{}
  patientcolors<-{}
  
  classlabels<-as.data.frame(classlabels)
  
  
  for(c in 1:length(class_labels_levels)){
    
    num_samps_group_cur=length(which(ordered_labels==class_labels_levels[c]))
    
    
    sampleclass<-c(sampleclass,rep(paste("Class",class_label_alphabets[c],sep=""),num_samps_group_cur))
    
    patientcolors <-c(patientcolors,rep(col_vec[c],num_samps_group[[c]]))
  }
  
  pca.cex.val=point.cex.val
  
  if(length(mzvec)>4){
    max_per_row<-3
    
    
    par_rows<-ceiling(9/max_per_row)
    
  }else{
    max_per_row<-length(mzvec)
    par_rows<-1
  }
  
  # The palette with black:
  #col_vec <- c("#E69F00","#000000","#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
  
  # To use for fills, add
  # scale_fill_manual(values=col_vec)
  
  # To use for line and point colors, add
  #scale_colour_manual(values=col_vec)
  
  file_ind<-0
  boxplots_fname<-paste("xyplots.pdf",sep="")
  
  if(dim(data_m)[1]>=1){
    
    
    t1<-table(classgroup)
    l1<-levels(classgroup)
    
    l1<-levels(as.factor(classgroup))
    
    
    patientcolors <- rep(col_vec[1:length(t1)], t1)
    
    
    get_pooled_sp<-function(n1,n2,S1,S2){a<-(n1-1)*S1;b<-(n2-1)*S2;c<-(n1+n2-2);return((a+b)/c)}
    
    
    class_levels<-levels(as.factor(classlabels_orig[,2]))
    
    
    df_matrix<-{}
    
    class_col_vec=col_vec
    
    if(dim(classlabels_orig)[2]>2){
      class_levels<-levels(as.factor(classlabels_orig[,2]))
      t1<-table(classlabels_orig[,3])
      
      
      myData<-cbind(as.data.frame(classgroup),as.data.frame(classlabels_orig[,2]),as.data.frame(classlabels_orig[,3]),t(data_m))
      
      myData<-as.data.frame(myData)
      
      #
      if(alphabetical.order==FALSE){
        myData[,2] <- factor(myData[,2], levels=unique(myData[,2]))
        myData[,3] <- factor(myData[,3], levels=unique(myData[,3]))
        t1=table(myData[,3])
      }
      
     
      
      
      
      
      myData_sum <- do.call(data.frame,aggregate(list(myData[,-c(1:3)]),
                                                 by = list(myData[,2],myData[,3]),
                                                 FUN = function(x){
                                                   
                                                   x<-as.numeric(as.character(x))
                                                   
                                                   c(mean = mean(x), sd = sd(x),n = length(x),se=sd(x)/sqrt(length(x)))
                                                   
                                                 }))
      
      
      
      label_inc_list<-seq(3,dim(myData_sum)[2],4)
     
      pch_vec<-c(19,17,23,22,13,0:12)
     
      if(output.format=="pdf"){
        
        par(mfrow=c(2,4),family="sans",cex=cex.val)
      }
      
  
      plot_res<-lapply(seq(3,dim(myData_sum)[2],4),function(pc)
      {
        
        df.summary<-myData_sum[,c(pc:(pc+3),1,2)] #cbind(xvec,classgroup,classlabels_orig[,2],classlabels_orig[,3])
        
        get_label_ind<-which(label_inc_list==pc)
        if(pairedanalysis==FALSE){
          
          
          if(error.bar==FALSE){
            #mzname<-paste(rnames[get_label_ind]," distribution in each group using ",filename," feats vs factors",sep="")
            
            
          }else{
            #mzname<-paste(rnames[get_label_ind]," distribution with 95% confidence interval in each group using ",filename," feats vs factors",sep="")
          }
        }else{
          
          if(error.bar==FALSE){
            mzname<-paste(rnames[get_label_ind]," distribution in each group using ",filename," feats vs time",sep="")
          }else{
            
            mzname<-paste(rnames[get_label_ind]," distribution 95% confidence interval in each group using ",filename," feats vs time",sep="")
          }
          
        }
        
        mzname<-rnames[get_label_ind]
        
        colnames(df.summary)<-c("Intensity","sd","number","se","Class","time")
        ymax = df.summary$Intensity + 1.96*df.summary$se
        
        ymin = df.summary$Intensity - 1.96*df.summary$se
        
        df_write_temp<-cbind(mzname,df.summary[,c(5,6,3,1,2,4)],ymin,ymax)
        colnames(df_write_temp)<-c("Name","Class","time","Number of subjects","mean","Std.deviation","Std.error","lower.limit.95%CI","upper.limit.95%CI")
        
        return(df_write_temp)    
      })
    }
    else
    {
      
      
      #one-way anova or one-way with repeated measures
      class_levels<-levels(as.factor(classgroup))
      t1<-table(classgroup)
      
      
      myData<-cbind(as.data.frame(classgroup),as.data.frame(classlabels_orig[,2]),t(data_m))
      #myData<-cbind(as.factor(classgroup),as.factor(classlabels_orig[,2]),t(data_m))
      
      myData<-as.data.frame(myData)
      
      #save(myData,classgroup,classlabels_orig,data_m,file="myData.Rda")
      
      if(alphabetical.order==FALSE){
        myData[,2] <- factor(myData[,2], levels=unique(myData[,2]))
        
        
      }
      
      myData_sum <- do.call(data.frame,aggregate(list(myData[,-c(1:2)]),
                                                 by = list(myData[,2]),
                                                 FUN = function(x){
                                                   
                                                   x<-as.numeric(as.character(x))
                                                   c(mean = mean(x), sd = sd(x),n = length(x),se=sd(x)/sqrt(length(x)))
                                                   
                                                 }))
      
      
      label_inc_list<-seq(2,dim(myData_sum)[2],4)
      
      ###savelabel_inc_list,file="label_inc_list.Rda")
      ###savernames,file="rnames.Rda")
      
      #savemyData_sum,classgroup,classlabels_orig,label_inc_list,rnames,file="myDatasum.Rda")
      plot_res<-lapply(seq(2,dim(myData_sum)[2],4),function(pc)
        #for(pc in seq(2,dim(myData_sum)[2],4))
      {
        
        #print("here 0705")
        #  print(pc)
        df.summary<-myData_sum[,c(pc:(pc+3),1)] #cbind(xvec,classgroup,classlabels_orig[,2],classlabels_orig[,3])
        
        get_label_ind<-which(label_inc_list==pc)
   
        
        
        mzname<-rnames[get_label_ind]
        colnames(df.summary)<-c("Intensity","sd","number","se","Class")
        df.summary<-as.data.frame(df.summary)
        
        #df.summary$Class<-as.numeric(as.factor(df.summary$Class))
        
        
        ymax = df.summary$Intensity + 1.96*df.summary$se
        
        ymin = df.summary$Intensity - 1.96*df.summary$se
        
        df_write_temp<-cbind(mzname,df.summary[,c(5,3,1,2,4)],ymin,ymax)
        
        colnames(df_write_temp)<-c("Name","Class","Number of subjects","mean","Std.deviation","Std.error","lower.limit.95%CI","upper.limit.95%CI")
        return(df_write_temp)
      })
      
    }
    
  #  save(plot_res,file="plot_res.Rda")
    var_sum_mat<-{}
    #for(i in 1:length(plot_res))
  #  {
   #   var_sum_mat<-rbind(var_sum_mat,plot_res[[i]])
      
    #}
    var_sum_mat<-ldply(plot_res,rbind)
    #print(getwd())
    
    if(dir.exists("Tables")){
    write.table(var_sum_mat,file="Tables/data_summary.txt",sep="\t",row.names=FALSE)
    }else{
      
      write.table(var_sum_mat,file="data_summary.txt",sep="\t",row.names=FALSE)
    }
  }
  
}


QRILCimpute<-function(dataSet.mvs, tune.sigma = 1)
{
  #samples in cols; features in rows
  
  nFeatures = dim(dataSet.mvs)[1]
  nSamples = dim(dataSet.mvs)[2]
  dataSet.imputed = dataSet.mvs
  QR.obj = list()
  
  cl<-makeCluster(detectCores()*0.5)
  clusterExport(cl,"quantile")
  clusterExport(cl,"lm")
  clusterEvalQ(cl,library(tmvtnorm))
  
  results<-parLapply(cl,1:nSamples,function(i,dataSet.mvs){
    #for (i in 1:nSamples) {
    curr.sample = dataSet.mvs[, i]
    pNAs = length(which(is.na(curr.sample)))/length(curr.sample)
    upper.q = 0.95
    q.normal = qnorm(seq(pNAs, upper.q, (upper.q - pNAs)/(upper.q * 10000)), mean = 0, sd = 1)
    q.curr.sample = quantile(curr.sample, probs = seq(0,upper.q, 1e-04), na.rm = T)
    temp.QR = lm(q.curr.sample ~ q.normal)
    QR.obj[[i]] = temp.QR
    mean.CDD = temp.QR$coefficients[1]
    sd.CDD = as.numeric(temp.QR$coefficients[2])
    data.to.imp = rtmvnorm(n = nFeatures, mean = mean.CDD,
                           sigma = sd.CDD * tune.sigma, upper = qnorm(pNAs,
                                                                      mean = mean.CDD, sd = sd.CDD), algorithm = c("gibbs"))
    curr.sample.imputed = curr.sample
    curr.sample.imputed[which(is.na(curr.sample))] = data.to.imp[which(is.na(curr.sample))]
    #dataSet.imputed[, i] = curr.sample.imputed
    #}
    return(curr.sample.imputed)
  },dataSet.mvs=dataSet.mvs)
  
  stopCluster(cl)
  
  
  ##list(dataSet.imputed, QR.obj)
  
  return(results)
}

RFimpute<-function(xmis, maxiter = 10, ntree = 100, variablewise = FALSE,
                   decreasing = FALSE, verbose = FALSE, mtry = floor(sqrt(ncol(xmis))),
                   replace = TRUE, classwt = NULL, cutoff = NULL, strata = NULL,
                   sampsize = NULL, nodesize = NULL, maxnodes = NULL, xtrue = NA,
                   parallelize = c("no", "variables", "forests"))
{
  
  n <- nrow(xmis)
  p <- ncol(xmis)
  if (!is.null(classwt))
    stopifnot(length(classwt) == p, typeof(classwt) == "list")
  if (!is.null(cutoff))
    stopifnot(length(cutoff) == p, typeof(cutoff) == "list")
  if (!is.null(strata))
    stopifnot(length(strata) == p, typeof(strata) == "list")
  if (!is.null(nodesize))
    stopifnot(length(nodesize) == 2)
  if (any(apply(is.na(xmis), 2, sum) == n)) {
    indCmis <- which(apply(is.na(xmis), 2, sum) == n)
    xmis <- xmis[, -indCmis]
    p <- ncol(xmis)
    cat("  removed variable(s)", indCmis, "due to the missingness of all entries\n")
  }
  parallelize <- match.arg(parallelize)
  if (parallelize %in% c("variables", "forests")) {
    if (getDoParWorkers() == 1) {
      stop("You must register a 'foreach' parallel backend to run 'missForest' in parallel. Set 'parallelize' to 'no' to compute serially.")
    }
    else if (verbose) {
      if (parallelize == "variables") {
        cat("  parallelizing over the variables of the input data matrix 'xmis'\n")
      }
      else {
        cat("  parallelizing computation of the random forest model objects\n")
      }
    }
    if (getDoParWorkers() > p) {
      stop("The number of parallel cores should not exceed the number of variables (p=",
           p, ")")
    }
  }
  ximp <- xmis
  xAttrib <- lapply(xmis, attributes)
  varType <- character(p)
  for (t.co in 1:p) {
    if (is.null(xAttrib[[t.co]])) {
      varType[t.co] <- "numeric"
      ximp[is.na(xmis[, t.co]), t.co] <- mean(xmis[, t.co],
                                              na.rm = TRUE)
    }
    else {
      varType[t.co] <- "factor"
      max.level <- max(table(ximp[, t.co]))
      class.assign <- sample(names(which(max.level == summary(ximp[,
                                                                   t.co]))), 1)
      if (class.assign != "NA's") {
        ximp[is.na(xmis[, t.co]), t.co] <- class.assign
      }
      else {
        while (class.assign == "NA's") {
          class.assign <- sample(names(which(max.level ==
                                               summary(ximp[, t.co]))), 1)
        }
        ximp[is.na(xmis[, t.co]), t.co] <- class.assign
      }
    }
  }
  NAloc <- is.na(xmis)
  noNAvar <- apply(NAloc, 2, sum)
  sort.j <- order(noNAvar)
  if (decreasing) 
    sort.j <- rev(sort.j)
  sort.noNAvar <- noNAvar[sort.j]
  nzsort.j <- sort.j[sort.noNAvar > 0]
  if (parallelize == "variables") {
    "%cols%" <- get("%dopar%")
    idxList <- as.list(isplitVector(nzsort.j, chunkSize = getDoParWorkers()))
  }
  Ximp <- vector("list", maxiter)
  iter <- 0
  k <- length(unique(varType))
  convNew <- rep(0, k)
  convOld <- rep(Inf, k)
  OOBerror <- numeric(p)
  names(OOBerror) <- varType
  if (k == 1) {
    if (unique(varType) == "numeric") {
      names(convNew) <- c("numeric")
    }
    else {
      names(convNew) <- c("factor")
    }
    convergence <- c()
    OOBerr <- numeric(1)
  }
  else {
    names(convNew) <- c("numeric", "factor")
    convergence <- matrix(NA, ncol = 2)
    OOBerr <- numeric(2)
  }
  stopCriterion <- function(varType, convNew, convOld, iter,
                            maxiter) {
    k <- length(unique(varType))
    if (k == 1) {
      (convNew < convOld) & (iter < maxiter)
    }
    else {
      ((convNew[1] < convOld[1]) | (convNew[2] < convOld[2])) &
        (iter < maxiter)
    }
  }
  while (stopCriterion(varType, convNew, convOld, iter, maxiter)) {
    if (iter != 0) {
      convOld <- convNew
      OOBerrOld <- OOBerr
    }
    cat("  missForest iteration", iter + 1, "in progress...")
    t.start <- proc.time()
    ximp.old <- ximp
    if (parallelize == "variables") {
      for (idx in idxList) {
        results <- foreach(varInd = idx, .packages = "randomForest") %cols%
          {
            obsi <- !NAloc[, varInd]
            misi <- NAloc[, varInd]
            obsY <- ximp[obsi, varInd]
            obsX <- ximp[obsi, seq(1, p)[-varInd]]
            misX <- ximp[misi, seq(1, p)[-varInd]]
            typeY <- varType[varInd]
            if (typeY == "numeric") {
              RF <- randomForest(x = obsX, y = obsY,
                                 ntree = ntree, mtry = mtry, replace = replace,
                                 sampsize = if (!is.null(sampsize))
                                   sampsize[[varInd]]
                                 else if (replace)
                                   nrow(obsX)
                                 else ceiling(0.632 * nrow(obsX)), nodesize = if (!is.null(nodesize))
                                   nodesize[1]
                                 else 1, maxnodes = if (!is.null(maxnodes))
                                   maxnodes
                                 else NULL)
              oerr <- RF$mse[ntree]
              misY <- predict(RF, misX)
            }
            else {
              obsY <- factor(obsY)
              summarY <- summary(obsY)
              if (length(summarY) == 1) {
                oerr <- 0
                misY <- factor(rep(names(summarY), length(misi)))
              }
              else {
                RF <- randomForest(x = obsX, y = obsY,
                                   ntree = ntree, mtry = mtry, replace = replace,
                                   classwt = if (!is.null(classwt))
                                     classwt[[varInd]]
                                   else rep(1, nlevels(obsY)), cutoff = if (!is.null(cutoff))
                                     cutoff[[varInd]]
                                   else rep(1/nlevels(obsY), nlevels(obsY)),
                                   strata = if (!is.null(strata))
                                     strata[[varInd]]
                                   else obsY, sampsize = if (!is.null(sampsize))
                                     sampsize[[varInd]]
                                   else if (replace)
                                     nrow(obsX)
                                   else ceiling(0.632 * nrow(obsX)), nodesize = if (!is.null(nodesize))
                                     nodesize[2]
                                   else 5, maxnodes = if (!is.null(maxnodes))
                                     maxnodes
                                   else NULL)
                oerr <- RF$err.rate[[ntree, 1]]
                misY <- predict(RF, misX)
              }
            }
            list(varInd = varInd, misY = misY, oerr = oerr)
          }
        for (res in results) {
          misi <- NAloc[, res$varInd]
          ximp[misi, res$varInd] <- res$misY
          OOBerror[res$varInd] <- res$oerr
        }
      }
    }
    else {
      for (s in 1:p) {
        varInd <- sort.j[s]
        if (noNAvar[[varInd]] != 0) {
          obsi <- !NAloc[, varInd]
          misi <- NAloc[, varInd]
          obsY <- ximp[obsi, varInd]
          obsX <- ximp[obsi, seq(1, p)[-varInd]]
          misX <- ximp[misi, seq(1, p)[-varInd]]
          typeY <- varType[varInd]
          if (typeY == "numeric") {
            if (parallelize == "forests") {
              xntree <- NULL
              RF <- foreach(xntree = idiv(ntree, chunks = getDoParWorkers()),
                            .combine = "combine", .multicombine = TRUE,
                            .packages = "randomForest") %dopar% {
                              randomForest(x = obsX, y = obsY, ntree = xntree,
                                           mtry = mtry, replace = replace, sampsize = if (!is.null(sampsize))
                                             sampsize[[varInd]]
                                           else if (replace)
                                             nrow(obsX)
                                           else ceiling(0.632 * nrow(obsX)), nodesize = if (!is.null(nodesize))
                                             nodesize[1]
                                           else 1, maxnodes = if (!is.null(maxnodes))
                                             maxnodes
                                           else NULL)
                            }
              OOBerror[varInd] <- mean((predict(RF) -
                                          RF$y)^2, na.rm = TRUE)
            }
            else {
              RF <- randomForest(x = obsX, y = obsY,
                                 ntree = ntree, mtry = mtry, replace = replace,
                                 sampsize = if (!is.null(sampsize))
                                   sampsize[[varInd]]
                                 else if (replace)
                                   nrow(obsX)
                                 else ceiling(0.632 * nrow(obsX)), nodesize = if (!is.null(nodesize))
                                   nodesize[1]
                                 else 1, maxnodes = if (!is.null(maxnodes))
                                   maxnodes
                                 else NULL)
              OOBerror[varInd] <- RF$mse[ntree]
            }
            misY <- predict(RF, misX)
          }
          else {
            obsY <- factor(obsY)
            summarY <- summary(obsY)
            if (length(summarY) == 1) {
              misY <- factor(rep(names(summarY), sum(misi)))
            }
            else {
              if (parallelize == "forests") {
                RF <- foreach(xntree = idiv(ntree, chunks = getDoParWorkers()),
                              .combine = "combine", .multicombine = TRUE,
                              .packages = "randomForest") %dopar%
                  {
                    randomForest(x = obsX, y = obsY,
                                 ntree = xntree, mtry = mtry, replace = replace,
                                 classwt = if (!is.null(classwt))
                                   classwt[[varInd]]
                                 else rep(1, nlevels(obsY)), cutoff = if (!is.null(cutoff))
                                   cutoff[[varInd]]
                                 else rep(1/nlevels(obsY), nlevels(obsY)),
                                 strata = if (!is.null(strata))
                                   strata[[varInd]]
                                 else obsY, sampsize = if (!is.null(sampsize))
                                   sampsize[[varInd]]
                                 else if (replace)
                                   nrow(obsX)
                                 else ceiling(0.632 * nrow(obsX)),
                                 nodesize = if (!is.null(nodesize))
                                   nodesize[2]
                                 else 5, maxnodes = if (!is.null(maxnodes))
                                   maxnodes
                                 else NULL)
                  }
                ne <- as.integer(predict(RF)) != as.integer(RF$y)
                ne <- ne[!is.na(ne)]
                OOBerror[varInd] <- sum(ne)/length(ne)
              }
              else {
                RF <- randomForest(x = obsX, y = obsY,
                                   ntree = ntree, mtry = mtry, replace = replace,
                                   classwt = if (!is.null(classwt))
                                     classwt[[varInd]]
                                   else rep(1, nlevels(obsY)), cutoff = if (!is.null(cutoff))
                                     cutoff[[varInd]]
                                   else rep(1/nlevels(obsY), nlevels(obsY)),
                                   strata = if (!is.null(strata))
                                     strata[[varInd]]
                                   else obsY, sampsize = if (!is.null(sampsize))
                                     sampsize[[varInd]]
                                   else if (replace)
                                     nrow(obsX)
                                   else ceiling(0.632 * nrow(obsX)), nodesize = if (!is.null(nodesize))
                                     nodesize[2]
                                   else 5, maxnodes = if (!is.null(maxnodes))
                                     maxnodes
                                   else NULL)
                OOBerror[varInd] <- RF$err.rate[[ntree,
                                                 1]]
              }
              misY <- predict(RF, misX)
            }
          }
          ximp[misi, varInd] <- misY
        }
      }
    }
    cat("done!\n")
    iter <- iter + 1
    Ximp[[iter]] <- ximp
    t.co2 <- 1
    for (t.type in names(convNew)) {
      t.ind <- which(varType == t.type)
      if (t.type == "numeric") {
        convNew[t.co2] <- sum((ximp[, t.ind] - ximp.old[,
                                                        t.ind])^2)/sum(ximp[, t.ind]^2)
      }
      else {
        dist <- sum(as.character(as.matrix(ximp[, t.ind])) !=
                      as.character(as.matrix(ximp.old[, t.ind])))
        convNew[t.co2] <- dist/(n * sum(varType == "factor"))
      }
      t.co2 <- t.co2 + 1
    }
    if (!variablewise) {
      NRMSE <- sqrt(mean(OOBerror[varType == "numeric"])/var(as.vector(as.matrix(xmis[,
                                                                                      varType == "numeric"])), na.rm = TRUE))
      PFC <- mean(OOBerror[varType == "factor"])
      if (k == 1) {
        if (unique(varType) == "numeric") {
          OOBerr <- NRMSE
          names(OOBerr) <- "NRMSE"
        }
        else {
          OOBerr <- PFC
          names(OOBerr) <- "PFC"
        }
      }
      else {
        OOBerr <- c(NRMSE, PFC)
        names(OOBerr) <- c("NRMSE", "PFC")
      }
    }
    else {
      OOBerr <- OOBerror
      names(OOBerr)[varType == "numeric"] <- "MSE"
      names(OOBerr)[varType == "factor"] <- "PFC"
    }
    if (any(!is.na(xtrue))) {
      err <- suppressWarnings(mixError(ximp, xmis, xtrue))
    }
    if (verbose) {
      delta.start <- proc.time() - t.start
      if (any(!is.na(xtrue))) {
        cat("    error(s):", err, "\n")
      }
      cat("    estimated error(s):", OOBerr, "\n")
      cat("    difference(s):", convNew, "\n")
      cat("    time:", delta.start[3], "seconds\n\n")
    }
  }
  if (iter == maxiter) {
    if (any(is.na(xtrue))) {
      out <- list(ximp = Ximp[[iter]], OOBerror = OOBferr)
    }
    else {
      out <- list(ximp = Ximp[[iter]], OOBerror = OOBerr,
                  error = err)
    }
  }
  else {
    if (any(is.na(xtrue))) {
      out <- list(ximp = Ximp[[iter - 1]], OOBerror = OOBerrOld)
    }
    else {
      out <- list(ximp = Ximp[[iter - 1]], OOBerror = OOBerrOld,
                  error = suppressWarnings(mixError(Ximp[[iter -
                                                            1]], xmis, xtrue)))
    }
  }
  class(out) <- "missForest"
  return(out)
}

do_TIC_norm<-function(data_m){
  
  
  sum_int<-apply(data_m,2,function(x){sum(x,na.rm=TRUE)})
  
  median_int<-apply(data_m,2,function(x){median(x,na.rm=TRUE)})
  
  data_m<-sweep(data_m,2,(sum_int/median_int),'/')
  return(data_m)
}


do_MSTUS_norm<-function(data_m,missing.val=0){
  
  total_sigs<-apply(data_m,1,function(x){
    if(is.na(missing.val)==FALSE){return(length(which(x>missing.val)))
    }else{
      return(length(which(is.na(x)==FALSE)))
    }})
  
  
  useful_metabs_1<-which(total_sigs>=dim(data_m)[2])
  
  useful_metabs_2<-which(total_sigs>=dim(data_m)[2]*0.95)
  
  if(length(useful_metabs_1)>0){
    
    data_useful<-data_m[useful_metabs_1,]
    
    
  }else{
    
    if(length(useful_metabs_2)>0){
      data_useful<-data_m[useful_metabs_2,]
      
    }else{
      useful_metabs_3<-which(total_sigs>=dim(data_m)[2]*0.9)
      
      if(length(useful_metabs_3)>0){
        
        data_useful<-data_m[useful_metabs_3,]
      }else{
        
        useful_metabs_4<-which(total_sigs>=dim(data_m)[2]*0.8)
        
        if(length(useful_metabs_4)>0){
          
          data_useful<-data_m[useful_metabs_4,]
        }
        
      }
    }
  }
  median_int<-apply(data_m,2,function(x){median(x,na.rm=TRUE)})
  sum_int<-apply(data_useful,2,function(x){sum(x,na.rm=TRUE)})
  
  data_m<-sweep(data_m,2,(sum_int/median_int),'/')
  
  return(data_m)
  
  
}


do_cubicspline_norm<-function(data_m){
  
  data_m<-normalize.qspline(data_m)
  return(data_m)
}

do_log2transform_norm<-function(data_m,log2.transform.constant=1){
  
  data_m<-log2(data_m+log2.transform.constant)
  return(data_m)
  
}




do_eigenms_norm<-function(data_m,classlabels,featselmethod=NA,feature_id_vector=NA,pairedanalysis=FALSE){
  
  cnames_1<-colnames(classlabels)
  
  if(dim(classlabels)[2]>2){
    
    if(is.na(featselmethod)==FALSE){
      if(featselmethod=="limma2way" | featselmethod=="limma2wayrepeat" | featselmethod=="lm2wayanova" | featselmethod=="lm2wayanovarepeat"){
        
        
        
        if(pairedanalysis==FALSE){
          treatment_vec<-as.factor(paste(classlabels[,2],":",classlabels[,3],sep=""))
        }else{
          treatment_vec<-as.factor(paste(classlabels[,3],":",classlabels[,4],sep=""))
          
        }
        
        
        
      }else{
        
        if(featselmethod=="limma1way" | featselmethod=="limma1wayrepeat" | featselmethod=="lm1wayanova" | featselmethod=="lm1wayanovarepeat"){
          check_factor2<-grep(cnames_1,pattern="Factor1")
          
          
          
          if(pairedanalysis==FALSE){
            treatment_vec<-as.factor(classlabels[,2])
          }else{
            treatment_vec<-as.factor(classlabels[,3])
            
          }
          
        }else{
          
          treatment_vec<-as.factor(classlabels[,2])
        }
        
        
        #treatment_vec<-as.factor(classlabels[,2])
        
      }
      
    }else{
      
      
      treatment_vec<-as.factor(classlabels[,2])
      
      
      
    }
    
    
  }else{
    
    treatment_vec<-as.factor(classlabels[,2])
  }
  edata<-data_m #log2(data_m+1)
  edata<-as.matrix(edata)
  
  #save(edata,treatment_vec,feature_id_vector,file="testeig.Rda")
  set.seed(123)
  
  if(is.na(feature_id_vector)==FALSE){
    ints_eig1 = eig_norm1(m=edata, treatment=treatment_vec, prot.info=cbind(paste('ID_',seq(1:nrow(data_m)), sep=''),feature_id_vector))
  }else{
    ints_eig1 = eig_norm1(m=edata, treatment=treatment_vec, prot.info=cbind(paste('ID_',seq(1:nrow(data_m)), sep=''),seq(1:nrow(data_m))))
    
  }
  
  set.seed(123)
  data_m = eig_norm2(rv=ints_eig1)
  data_m = data_m$norm_m
  return(data_m)
  
}


#classlabels: column A: ID; column B: Factor1
do_sva_norm<-function(data_m,classlabels,featselmethod=NA){
  
  
  edata<-(data_m)
  
  pdata<-classlabels
  
  cnames_1<-colnames(classlabels)
  
  if(dim(classlabels)[2]>2){
    
    if(is.na(featselmethod)==FALSE){
      if(featselmethod=="limma2way" | featselmethod=="limma2wayrepeat" | featselmethod=="lm2wayanova" | featselmethod=="lm2wayanovarepeat"){
        if(pairedanalysis==FALSE){
          treatment_vec<-as.factor(paste(classlabels[,2],":",classlabels[,3],sep=""))
        }else{
          treatment_vec<-as.factor(paste(classlabels[,3],":",classlabels[,4],sep=""))
          
        }
        
        
        
      }else{
        
        if(featselmethod=="limma1way" | featselmethod=="limma1wayrepeat" | featselmethod=="lm1wayanova" | featselmethod=="lm1wayanovarepeat"){
          check_factor2<-grep(cnames_1,pattern="Factor1")
          #if(length(check_factor2)>0)
          
          
          if(pairedanalysis==FALSE){
            treatment_vec<-as.factor(classlabels[,2])
          }else{
            treatment_vec<-as.factor(classlabels[,3])
            
          }
          
        }else{
          
          treatment_vec<-as.factor(classlabels[,2])
        }
        
        
        #treatment_vec<-as.factor(classlabels[,2])
        
      }
      
    }else{
      
      
      treatment_vec<-as.factor(classlabels[,2])
      
      
      
    }
    
    
  }else{
    
    treatment_vec<-as.factor(classlabels[,2])
  }
  
  classlabels<-as.matrix(classlabels)
  
  trainMod = model.matrix(~treatment_vec)
  trainMod0 = model.matrix(~1,data=pdata)
  
  edata<-as.matrix(edata)
  
  
  trainSv = sva(edata,trainMod,trainMod0)
  
  fsvaobj = fsva(dbdat=edata,mod=trainMod,sv=trainSv,newdat=edata)
  
  data_m<-(fsvaobj$db)
  
  return(data_m)
  
}


do_vst_norm_count <- function(countdata){
  library(DESeq)
  condition <- factor(rep("Class", ncol(countdata)))
  countdata <- newCountDataSet(countdata,condition )
  countdata <- estimateSizeFactors( countdata )
  cdsBlind <- DESeq::estimateDispersions( countdata, method="blind")
  vstdata <- varianceStabilizingTransformation( cdsBlind )
  return(exprs(vstdata))
}

do_quantile_norm<-function(data_m)
{
  data_m<-normalizeQuantiles(data_m)
  return(data_m)
  
  
}

do_vsn_norm<-function(data_m)
{
  
  data_m<-normalizeVSN(data_m)
  return(data_m)
  
  
}

do_loess_norm<-function(data_m)
{
  data_m<-normalizeCyclicLoess(data_m)
  return(data_m)
}



do_medcenter_norm<-function(data_m)
{
  colmedians=apply(data_m,1,function(x){median(x,na.rm=TRUE)})
  data_m=sweep(data_m,1,colmedians)
  return(data_m)
  
}

do_znormtransform_norm<-function(data_m)
{
  #autoscaling; z-scaling
  data_m<-scale(t(data_m))
  data_m<-t(data_m)
  return(data_m)
}



do_paretoscaling_norm<-function(data_m)
{
  #pareto scaling
  data_m <- apply(data_m, 1, function(x){(x - mean(x))/sqrt(sd(x))})
  
  data_m<-data_m/mean(abs(data_m))
  data_m<-data_m+1000
  data_m<-t(data_m)
  
  return(data_m)
  
}

do_rangescaling_norm<-function(data_m)
{
  #range scaling
  data_m <- apply(data_m,1,function(x){(x-min(x))/(max(x)-min(x))})
  
  data_m<-t(data_m)
  return(data_m)
}


get_fdr_adjusted_pvalue_child<-function(pvalues_vec,fdrmethod="BH")
{
  
  pvalues1=pvalues_vec
  if(fdrmethod=="none"){
    fdr_adjust_pvalue1<-pvalues1
    
  }
  
  if(fdrmethod=="BH"){
    fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BH")
    
  }else{
    if(fdrmethod=="ST"){
      
      fdr_adjust_pvalue1<-try(qvalue(pvalues1),silent=TRUE)
      
      if(is(fdr_adjust_pvalue1,"try-error")){
        
        fdr_adjust_pvalue1<-qvalue(pvalues1,lambda=max(pvalues1,na.rm=TRUE))
      }
      fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qvalues
      
    }else{
      if(fdrmethod=="Strimmer"){
        pdf("fdrtool.pdf")
        #par_rows=1
        #par(mfrow=c(par_rows,1))
        fdr_adjust_pvalue1<-suppressWarnings(fdrtool(as.vector(pvalues1),statistic="pvalue",verbose=FALSE))
        fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qval
        try(dev.off(),silent=TRUE)
      }else{
        
        if(fdrmethod=="BY"){
          fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BY")
          
        }else{
          if(fdrmethod=="bonferroni"){
            fdr_adjust_pvalue1<-p.adjust(pvalues1,method="bonferroni")
          }
        }
        
      }
    }
  }
  
  
  return(fdr_adjust_pvalue1)
  
}

get_fdr_adjusted_pvalue<-function(data_matrix,filename=NA,fdrmethod="BH")
{
  
  toMatch=c("P.value","p.value","pvalue","Pvalue","p-value","P-value")
  
  
  if(is.na(filename)==FALSE){
    f1<-read.table(filename,sep="\t",header=TRUE)
    
    pval_columns <- unique (grep(paste(toMatch,collapse="|"),colnames(f1),value=FALSE))
    
    cnames1<-colnames(f1)
    
    pvalues_matrix<-as.data.frame(f1[,pval_columns])
    
    colnames(pvalues_matrix)<-cnames1[pval_columns]
  }else{
    
    pval_columns <- unique (grep(paste(toMatch,collapse="|"),colnames(data_matrix),value=FALSE))
    
    cnames1<-colnames(data_matrix)
    
    pvalues_matrix<-as.data.frame(data_matrix[,pval_columns])
    
    colnames(pvalues_matrix)<-cnames1[pval_columns]
    
    
  }
  
  
  if(is.vector(pvalues_matrix)==TRUE){
    
    pvalues_matrix<-as.data.frame(pvalues_matrix)
    
    fdr_res<-get_fdr_adjusted_pvalue_child(pvalues_matrix[,1],fdrmethod)
    
  }else{
    
    if(ncol(pvalues_matrix)>=1){
      
      fdr_res<-apply(pvalues_matrix,2,get_fdr_adjusted_pvalue_child,fdrmethod)
      
    }
    
    
  }
  cnames1<-colnames(fdr_res)
  
  cnames1<-gsub(cnames1,pattern=paste(toMatch,collapse="|"),replacement="FDR.adjusted.pvalue")
  
  colnames(fdr_res)<-cnames1
  
  return(fdr_res)
}






plot_graph<-function(df,net_node_colors=c("orange", "green","blue","pink"),graphmethod="radial",label.cex=0.3,filename="",
                     net_node_shape=c("rectangle","circle","triangle","star","square","csquare","crectangle","vrectangle"),maxnodesperclass=100,
                     seednum=100,vertex.size=6,interactive=TRUE,Xname=NA,Yname=NA,Zname=NA,Wname=NA,classname=NA,layout.type="fr1",mtext.val=NA){
  
  df<-as.data.frame(df)
  
 
  df$from<-as.character(df$from)
  df$to<-as.character(df$to)
  
  df$weight<-as.numeric(df$weight)
 #save(df,file="df.Rda")
  
  if(length(which(df$weight==0))>0){
    
    df<-df[-which(df$weight==0),]
  }
  
  if(nrow(df)>0){
    
  df<-df[order(df$weight,df$to),] #decreasing=FALSE),]
  
  nodes_vec_class<-gsub(df$to,pattern="[0-9|_|\\.]*",replacement="") #c("X","Y","Z","W") #
  
  df$from<-gsub(df$from,pattern="X",replacement="")
  df$to<-gsub(df$to,pattern="Y",replacement="")
  
  
  dfall<-df
  
  
  t1<-c("X","Y","Z","W") #c(Xname,Yname,Zname,Wname) #levels(as.factor(nodes_vec_class))

  
  
  
  if(graphmethod=="BAM"){
    sg<-graphBAM(df)
    nodes_vec<-nodes(sg)
  }else{
    sg <- graph.data.frame(d = df, directed = FALSE)
    #sg <- graph.adjacency(df, mode="undirected", weighted=TRUE)
    nodes_vec<-V(sg)$name
  }
  nodes_vec_class<-gsub(nodes_vec,pattern="[0-9]*",replacement="")
  nodes_col_vec<-rep("#11BCFF99",length(nodes_vec))
  nodes_shape_vec<-rep("circle",length(nodes_vec))
  nodes_size_vec<-rep(vertex.size,length(nodes_vec))
  
  if(graphmethod=="BAM"){
    shapes_sel_vec<-c("circle","ellipse","box","rectangle")
  }else{
    
    # clips as a circle
    add_shape("triangle",plot=mytriangle) #, clip=shapes("circle")$clip,plot=mytriangle)
    # no clipping, edges will be below the vertices anyway
    add_shape("star", clip=shape_noclip,plot=mystar, parameters=list(vertex.norays=5))
    
    shapes_sel_vec<-net_node_shape  #c("triangle","sphere","rectangle","star")
  }
  
  for(t1_ind in 1:length(t1)){
    
    nodes_col_vec[which(nodes_vec_class==t1[t1_ind])]<-net_node_colors[t1_ind]
    
    nodes_shape_vec[which(nodes_vec_class==t1[t1_ind])]<-shapes_sel_vec[t1_ind]
    
    #nodes_size_vec[which(nodes_vec_class==t1[t1_ind])]<-3/t1_ind
    
  }
  
  nAttrs<-list()
  nAttrs$fillcolor<-nodes_col_vec
  names(nAttrs$fillcolor)<-nodes_vec #(sg)
  nAttrs$shape<-nodes_shape_vec
  names(nAttrs$shape)<-nodes_vec #(sg)
  #nAttrs$size<-nodes_size_vec
  #names(nAttrs$size)<-nodes_vec #(sg)
  # clips as a circle
  add_shape("triangle",plot=mytriangle) #, clip=shapes("circle")$clip,plot=mytriangle)
  # no clipping, edges will be below the vertices anyway
  add_shape("star", clip=shape_noclip,plot=mystar, parameters=list(vertex.norays=5))
  
  
  if(graphmethod=="radial"){
    edge_colors<-rep("blue",length(E(sg)$weight))
    edge_colors[which(E(sg)$weight>=0)]<-"red"
    
    V(sg)$color<-nodes_col_vec
    V(sg)$shape<-nodes_shape_vec
    V(sg)$label.cex<-label.cex
    
    V(sg)$vertex.size<-vertex.size
    E(sg)$color=edge_colors
    
    set.seed(seednum)
    
    if(FALSE){
      if(is.na(maxnodesperclass)==TRUE){
        cytoscape_fname<-paste(filename,"cytoscapeall.gml",sep="")
        rda_fname<-paste(filename,"all.Rda",sep="")
      }else{
        cytoscape_fname<-paste(filename,"cytoscapetop",maxnodesperclass,".gml",sep="")
        rda_fname<-paste(filename,"top",maxnodesperclass,".Rda",sep="")
      }
      fname1<-paste(filename,"_linkmatrix.Rda",sep="")
      #  ##save(df,file=fname1)
      ###save(sg,file=rda_fname)
      write.graph(sg, file =cytoscape_fname, format = "gml")
    }
    
    fname1<-paste("Tables/",filename,"_linkmatrix.txt",sep="")
    write.table(df,file=fname1,sep="\t",row.names=FALSE)
    
    {
      
      set.seed(seednum)
      
      l = get_layout(sg,layout.type=layout.type) #layout.fruchterman.reingold(sg, weights = (1 -abs(E(sg)$weight)))
      
      
      set.seed(seednum)
      
      check_plot<-plot.igraph(sg,layout=l,vertex.size=vertex.size,vertex.label=V(sg)$name,vertex.label.cex=label.cex,edge.color=edge_colors)
      
      
      if(is(check_plot,"try-error")){
        
        set.seed(seednum)
        sg$layout <- l
        set.seed(seednum)
        
        plot.igraph(sg,layout=l,vertex.size=vertex.size,vertex.label=V(sg)$name,vertex.label.cex=label.cex,edge.color=edge_colors) #,silent=TRUE)
        
        
      }
      #mtext("Red: +ve correlation; Blue: -ve correlation",side=1)
      
      if(is.na(classname)==TRUE){
        
        if(is.na(maxnodesperclass)==TRUE){
          
          if(is.na(mtext.val)==FALSE){
            mtext(mtext.val,side=3,line=3,cex=1,adj=NA)
          }else{
            mtext("Showing all pairwise correlations",side=3,line=3,cex=1,adj=NA)
          }
        }else{
          
          if(is.na(mtext.val)==FALSE){
            mtext(mtext.val,side=3,line=3,cex=1,adj=NA)
          }else{
          mtext(paste("Showing top ",maxnodesperclass," correlations",sep=""),side=3,line=3,cex=1,adj=NA)
          }
        }
        #mtext("Using all samples",side=3,line=3,cex=0.6,adj=NA)
      }else{
        
        mtext(paste("Using samples in class ",classname,sep=""),side=3,line=3,cex=0.6,adj=NA)
      }
      
      mtext("(Edges) Red: +ve correlation; Blue: -ve correlation",line=0,side=1,cex=0.8,adj=0)
      
      mtext_community<-paste("(Nodes) ",net_node_shape[1],": ",Xname,"; ",net_node_shape[2],": ",Yname,sep="")
      if(is.na(Zname)==FALSE){
        mtext_community<-paste(mtext_community,"; ",net_node_shape[3],": ",Zname,sep="")
        
      }
      if(is.na(Wname)==FALSE){
        mtext_community<-paste(mtext_community,"; ",net_node_shape[4],": ",Wname,sep="")
        
      }
      
      mtext(mtext_community,side=1,cex=0.8,line=1,adj=0)
      
      
      filename_text<-paste(filename,".png",sep="")
      try(mtext(filename_text,line=3,cex=0.6,col="brown",side=1,adj=0),silent=TRUE)
      
    }
    ###save(list=ls(),file="plot.Rda")
    nodes<-V(sg)$name
    nodes<-as.data.frame(nodes)
    links<-df[,c(1:2)]
    links<-as.data.frame(links)
    
    if(is.na(maxnodesperclass)==FALSE){
      if(interactive==TRUE){
        
        tkid <- tkplot(sg,canvas.width=1050, canvas.height=750)
        
        
        colnames(links)<-c("from","to")
        colnames(nodes)<-c("id")
        
        nodes$color.background<-"green"
        nodes_vec_class<-gsub(nodes[,1],pattern="[0-9]+",replacement="")
        nodes$shape<-"dot"
        nodes$type=nodes_vec_class
        nodes_vec_class<-unique(nodes_vec_class)
        
        for(i in 1:length(unique(nodes_vec_class))){
          
          nodes$shape[which(nodes$type==nodes_vec_class[i])] <- net_node_shape[i]
          nodes$color.background[which(nodes$type==nodes_vec_class[i])] <- net_node_colors[i]
        }
        
        nodes$shadow <- TRUE # Nodes will drop shadow
        nodes$title <- nodes$media # Text on click
        nodes$label <- nodes$type.label # Node label
        nodes$size <- vertex.size #nodes$audience.size # Node size
        nodes$borderWidth <- 2 # Node border width
        
        #nodes$color.background <- c("slategrey", "tomato", "gold")[nodes$type]
        nodes$color.border <- "black"
        #nodes$color.highlight.background <- "orange"
        #nodes$color.highlight.border <- "darkred"
        links$color <- edge_colors
        
        #network<-visNetwork(nodes, links)
        
        #vis##save(network, file = "network.html")
        
        
      }
    }
  }else{
    set.seed(seednum)
    plot(sg,nodeAttrs=nAttrs)
  }
  return(list(nodes=nodes,links=links,sg=sg,link_matrix=df,layout_matrix=l))
  }else{
    
    return(NULL)
  }
}

mytriangle <- function(coords, v=NULL, params) {
  vertex.color <- params("vertex", "color")
  if (length(vertex.color) != 1 && !is.null(v)) {
    vertex.color <- vertex.color[v]
  }
  vertex.size <- 1/200 * params("vertex", "size")
  if (length(vertex.size) != 1 && !is.null(v)) {
    vertex.size <- vertex.size[v]
  }
  
  symbols(x=coords[,1], y=coords[,2], bg=vertex.color,
          stars=cbind(vertex.size, vertex.size, vertex.size),
          add=TRUE, inches=FALSE)
}

get_layout<-function(sg,layout.type="fr1"){
  
  layout_type=layout.type
  if(layout_type=="fr1"){
    sg$layout = layout.fruchterman.reingold(sg, weights = (abs(E(sg)$weight)))
  }else{
    if(layout_type=="fr2"){
      sg$layout = layout.fruchterman.reingold(sg, weights = (1-abs(E(sg)$weight)))
    }else{
      if(layout_type=="fr"){
        
        sg$layout = layout_with_fr(sg)
        
      }else{
        if(layout_type=="lgl"){
          
          sg$layout = layout.lgl(sg)
        }else{
          if(layout_type=="kk"){
            
            sg$layout = layout_with_kk(sg)
          }else{
            
            if(layout_type=="drl"){
              
              sg$layout = layout_with_drl(sg)
            }else{
              
              if(layout_type=="tree"){
                
                sg$layout = layout_as_tree(sg)
              }else{
                
                if(layout_type=="circle"){
                  
                  sg$layout = layout_in_circle(sg)
                }else{
                  
                  if(layout_type=="sphere"){
                    
                    sg$layout = layout_on_sphere(sg)
                  }else{
                    
                    if(layout_type=="nicely"){
                      
                      sg$layout = layout_nicely(sg)
                    }else{
                      
                      if(layout_type=="graphopt"){
                        
                        sg$layout = layout_with_graphopt(sg)
                      }else{
                        
                        if(layout_type=="randomly"){
                          
                          sg$layout = layout_randomly(sg)
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          
          
        }
        
      }
      
    }
  }
  
  return(sg$layout)
}




diffRank<-function(adjMtrxSample1,adjMtrxSample2,degree.centrality.method="eigenvector",node_names=NA,class_labels=c(1,2),
                   plot_graph_bool=FALSE,label.cex=0.5,vertex.size=0.7,ignore.edge.weights=FALSE)
  {
  
  suppressMessages(library(igraph))
  
 #save(adjMtrxSample1,adjMtrxSample2,degree.centrality.method,node_names,ignore.edge.weights,class_labels,file="adj.Rda")
  #N is the number if genes in the sample.
  N=dim(adjMtrxSample1)[1];
  
  
  diag(adjMtrxSample1)<-0
  diag(adjMtrxSample2)<-0
  
  if(is.na(node_names)==FALSE){
    
    rownames(adjMtrxSample1)<-node_names
    colnames(adjMtrxSample1)<-node_names
    rownames(adjMtrxSample2)<-node_names
    colnames(adjMtrxSample2)<-node_names
    
  }
  
  if(ignore.edge.weights==FALSE){
  # Create a graph from the dataset; one graph for each condition.
  graph1=graph.adjacency(adjMtrxSample1, mode="undirected",weighted=TRUE)#, diag=FALSE )
  graph2=graph.adjacency(adjMtrxSample2, mode="undirected",weighted=TRUE)#, diag=FALSE )
  
  }else{
    graph1=graph.adjacency(adjMtrxSample1, mode="undirected")#, diag=FALSE )
    graph2=graph.adjacency(adjMtrxSample2, mode="undirected")#, diag=FALSE )
    
  }
  
  if(plot_graph_bool==TRUE){
    
    edge_colors<-rep("blue",length(E(graph1)$weight))
    edge_colors[which(E(graph1)$weight>=0)]<-"red"
   # V(sg)$color<-nodes_col_vec
    #V(sg)$shape<-nodes_shape_vec
    V(graph1)$label.cex<-label.cex
    
    V(graph1)$vertex.size<-vertex.size
    E(graph1)$color=edge_colors
    
    #E(graph1)$weight <- edge.betweenness(graph1)
    
    if(ignore.edge.weights==FALSE){
     
      
    c1 = cluster_fast_greedy(graph1,weights=abs(E(graph1)$weight)) #cluster_louvain(graph1,weights = NA)
    c2 = cluster_fast_greedy(graph2,weights=abs(E(graph2)$weight)) #cluster_louvain(graph2,weights=NA)
    }else{
      c1 = cluster_fast_greedy(graph1,weights=NA) #cluster_louvain(graph1,weights = NA)
      c2 = cluster_fast_greedy(graph2,weights=NA) 
      
    }
    #clustering coefficient
    cc1<-transitivity(graph1)
    
    cc2<-transitivity(graph2)
    plot.layout.type="circular"
    
    if(plot.layout.type=="circular"){
    #layout circular
    coords1<-layout_in_circle(graph1,order=V(graph1))
    coords2<-layout_in_circle(graph2,order=V(graph2))
    
      
    main_graph1=paste(class_labels[1],"\nclustering coefficient: ",round(cc1,3),sep="")
    main_graph2=paste(class_labels[2],"\nclustering coefficient: ",round(cc2,3),sep="")
    
    set.seed(555)
    plot.igraph(graph1,main=main_graph1,vertex.label=V(graph1)$name,vertex.label.cex=label.cex,edge.color=edge_colors,
                vertex.size=vertex.size,layout=coords1,vertex.color=membership(c1))
    
    edge_colors<-rep("blue",length(E(graph2)$weight))
    edge_colors[which(E(graph2)$weight>=0)]<-"red"
    
    # V(sg)$color<-nodes_col_vec
    #V(sg)$shape<-nodes_shape_vec
    V(graph2)$label.cex<-label.cex
    V(graph2)$vertex.size<-vertex.size
      E(graph2)$color=edge_colors
      set.seed(555)
      plot.igraph(graph2,main=main_graph2,vertex.label=V(graph2)$name,vertex.label.cex=label.cex,edge.color=edge_colors,
                  vertex.size=vertex.size,layout=coords2,vertex.color=membership(c2))
    }else{
      state_col = c("TssA" = "#E41A1C",    "TssAFlnk" = "#E41A1C",
                    "TxFlnk" = "#E41A1C",  "Tx" = "#E41A1C",
                    "TxWk" = "#E41A1C",    "EnhG" = "#E41A1C",
                    "Enh" = "#E41A1C",     "ZNF/Rpts" = "#E41A1C",
                    "Het" = "#377EB8",     "TssBiv" = "#377EB8",
                    "BivFlnk" = "#377EB8", "EnhBiv" = "#377EB8",
                    "ReprPC" = "#377EB8",  "ReprPCWk" = "#377EB8",
                    "Quies" = "black")
      
      # one for rows and one for columns
      state_col2 = c(state_col, state_col)
      names(state_col2) = c(rownames(mat), colnames(mat))
      
      colmat = rep(state_col2[rownames(mat)], n_states)
      colmat = rgb(t(col2rgb(colmat)), maxColorValue = 255)
      
      #qati = quantile(mat, 0.7)
      colmat[mat > 0.7] = paste0(colmat[mat > 0.7], "A0")
      colmat[mat <= (-0.7)] = paste0(colmat[mat <= (-0.7)], "20")
      dim(colmat) = dim(mat)
      gm1<-as_edgelist(graph1, names = FALSE)
      gm1<-cbind(gm1,as.matrix(E(graph1)$weight))
      colnames(gm1)<-c("X","Y","weight")
      gm1<-as.data.frame(gm1)
      set.seed(555)
      chordDiagram(gm1,annotationTrack = "grid", preAllocateTracks = list(track.height = 0.1))
      
      gm2<-as_edgelist(graph2, names = FALSE)
      gm2<-cbind(gm2,as.matrix(E(graph2)$weight))
      colnames(gm2)<-c("X","Y","weight")
      gm2<-as.data.frame(gm2)
      set.seed(555)
      chordDiagram(gm2,annotationTrack = "grid", preAllocateTracks = list(track.height = 0.1))
      
    } 
      set.seed(555)
      try(plot_dendrogram(c1,cex=label.cex),silent=TRUE)
      
      set.seed(555)
      try(plot_dendrogram(c2,cex=label.cex),silent=TRUE)
      
      #save(graph1,graph2,c1,c2,file="graphdebug.Rda")
      
  }
  
  if(degree.centrality.method=="betweenness"){
    
    betweennessGraph1=betweenness(graph1,directed = FALSE,weights=abs(E(graph1)$weight),normalized=TRUE);
    betweennessGraph2=betweenness(graph2,directed = FALSE,weights=abs(E(graph2)$weight),normalized=TRUE);
    solution=abs(betweennessGraph1-betweennessGraph2)
    
  }else{
    
    if(degree.centrality.method=="eigenvector"){
          #eigenvector
          eigenGraph1=eigen_centrality(graph1,directed = FALSE,weights=abs(E(graph1)$weight))$vector #,normalized=TRUE);
          eigenGraph2=eigen_centrality(graph2,directed = FALSE,weights=abs(E(graph2)$weight))$vector #,normalized=TRUE);
          solution=abs(eigenGraph1-eigenGraph2)
    }else{
        if(degree.centrality.method=="hybrid.DBC" | degree.centrality.method=="hybrid.DEC"){
          
          if(degree.centrality.method=="hybrid.DBC"){
            betweennessGraph1=betweenness(graph1,directed = FALSE,weights=abs(E(graph1)$weight),normalized=TRUE);
            betweennessGraph2=betweenness(graph2,directed = FALSE,weights=abs(E(graph2)$weight),normalized=TRUE);
            
            
            
            DBC=abs(betweennessGraph1-betweennessGraph2)
            
          }else{
            eigenGraph1=eigen_centrality(graph1,directed = FALSE,weights=abs(E(graph1)$weight))$vector #,normalized=TRUE);
            eigenGraph2=eigen_centrality(graph2,directed = FALSE,weights=abs(E(graph2)$weight))$vector #,normalized=TRUE);
            
            DBC=abs(eigenGraph1-eigenGraph2)
            
          }
          #Create and initialize Delta_C_i
          Delta_C_i=abs(adjMtrxSample1-adjMtrxSample2);
          
          
          Delta_C_i<-apply(Delta_C_i,1,function(x)
          {
            
            if(sum(x,na.rm=TRUE)==0)
            {
              x=rep(1/N,length(x))
            }
            x=x/sum(x)
            return(x)
            #})
          })
          
          #Delta_C_i<-do.call(rbind,Delta_C_i)
          Delta_C_i<-t(Delta_C_i)
          error=100;
          count=1;
          eps=0.001
          lambda=0.5
          
          
          # Create and initialize solution array to 1/N.
          # solution contains the ranks for all genes.
          solution=array(1/N,dim=c(N,1))
          solutionEachIteration=solution;
          
          # eps (EPSILON) is a value of the difference between 2 consecutive solutions to stop the iterations.
          # Do iterate while the difference between 2 consecutive solutions is not that much big (> eps).
          while(error > eps)
          {
            count=count+1;
            
            #Keep the previous solution
            formerSoulution=solution;
            
            #Find a new solution.
            for (v in 1:N){
              
              #solution<-lapply(1:N,function(v){
              s = sum(Delta_C_i[,v] * solution); # Solution, is the (Pi ) in this case
              solution[v]=(1-lambda) * DBC[v] + lambda * s;
              #solution[v]=(lambda) * DBC[v] + lambda * s + lambda*DEC[v];
              #res=(1-lambda) * DBC[v] + lambda * s;
              #return(res)
              #})
            }
            solution<-unlist(solution)
            solutionEachIteration=array(c(solutionEachIteration,solution),dim=c(N,count))
            
            #find the error to stop the iteration, the error in this case that there no significant difference between the old and the new solution
            error=sum((formerSoulution - solution)^2)
            
            
          }
        }
      
    }
  }

  
  
  
  
  #return(list(solution=solution,DBC=DBC,DeltaK=DeltaK,DeltaK1=Delta_C_i))
  ##save(solution,DBC,DeltaK,Delta_C_i,DEC,adjMtrxSample1,file="diffrank.Rda")
  return(solution)
}





runlogitreg<-function(X,Y,fdrmethod="BH",fdrthresh=0.05,pvalue.thresh=0.05,robust.estimate=FALSE){
  options(warn=-1)
  logistic_reg=TRUE
  res<-runlmreg(X=X,Y=Y,fdrmethod=fdrmethod,fdrthresh=fdrthresh,pvalue.thresh=pvalue.thresh,logistic_reg=TRUE,robust.estimate=robust.estimate)
  options(warn=0)
  return(res)
}


runlmreg<-function(X,Y,fdrmethod="BH",fdrthresh=0.05,pvalue.thresh=0.05,logistic_reg=FALSE,poisson_reg=FALSE,robust.estimate=FALSE){
  options(warn=-1)
  data_m_fc<-X[,-c(1:2)]
  
  classlabels_response_mat<-Y
  data_m_fc_withfeats<-X
  
  poisson_reg=FALSE
  rm(X)
  
  if(logistic_reg==FALSE){
    fileheader="lmreg"
  }else{
    fileheader="logitreg"
    
  }
  
  
  res1<-apply(data_m_fc,1,function(x){
    xvec<-x
    
    data_mat_anova<-cbind(xvec,classlabels_response_mat)
    
    cnames<-colnames(data_mat_anova)
    cnames[1]<-"Response"
    
    colnames(data_mat_anova)<-cnames
    
    
    
    anova_res<-diffexplmreg(dataA=data_mat_anova,logistic_reg=logistic_reg,poisson_reg=poisson_reg,robust.estimate=robust.estimate)
    
    return(anova_res)
  })
  
  
  
  main_pval_mat<-{}
  
  posthoc_pval_mat<-{}
  pvalues<-{}
  
  all_inf_mat<-{}
  
  #for(i in 1:length(res1))
  all_inf_mat<-lapply(1:length(res1),function(i)
  {
    
    main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
    pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
    
    cur_pvals<-t(res1[[i]]$mainpvalues)
    cur_est<-t(res1[[i]]$estimates)
    cur_stderr<-t(res1[[i]]$stderr)
    cur_tstat<-t(res1[[i]]$statistic)
    cur_res<-cbind(cur_pvals,cur_est,cur_stderr,cur_tstat)
    
    
    
    #all_inf_mat<-rbind(all_inf_mat,cur_res)
    
    return(cur_res)
    
  })
  
  cur_pvals<-t(res1[[1]]$mainpvalues)
  
  all_inf_mat<-do.call(rbind,all_inf_mat)
  
  pvalues=all_inf_mat[,1]
  
  pvalues<-replace(pvalues,which(is.na(pvalues)==TRUE),1)
  all_inf_mat[,1]=pvalues
  
  #cnames_1<-c(paste(colnames(cur_pvals),".pvalue",sep=""),paste(colnames(cur_pvals),".estimate",sep=""),paste(colnames(cur_pvals),".tstatistic",sep=""))
  
  cnames_1<-c(paste("P.value_",colnames(cur_pvals),sep=""),paste("Estimate_",colnames(cur_pvals),sep=""),paste("StdError_var_",colnames(cur_pvals),sep=""),paste("t-statistic_",colnames(cur_pvals),sep=""))
  
  # ##save(cnames_1,file="c1.Rda")
  ###save(data_allinf_withfeats,file="dA.Rda")
  ###save(all_inf_mat,file="dB.Rda")
  
  data_allinf_withfeats<-cbind(all_inf_mat,data_m_fc_withfeats)
  
  colnames(data_allinf_withfeats)<-c(cnames_1,colnames(data_m_fc_withfeats))
  
  if(fdrmethod=="BH"){
    fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
  }else{
    if(fdrmethod=="ST"){
      #fdr_adjust_pvalue<-qvalue(pvalues)
      #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
      
      
      fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
      
      if(is(fdr_adjust_pvalue,"try-error")){
        
        fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
      }
      
      fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
      
      
      
    }else{
      if(fdrmethod=="Strimmer"){
        pdf("fdrtool.pdf")
        
        fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
        fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
        try(dev.off(),silent=TRUE)
      }else{
        if(fdrmethod=="none"){
          #fdr_adjust_pvalue<-pvalues
          fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
        }else{
          if(fdrmethod=="BY"){
            fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
          }else{
            if(fdrmethod=="bonferroni"){
              fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
              
            }
          }
        }
      }
    }
    
    
    
  }
  
  
  
  cnames_tab<-colnames(data_m_fc_withfeats)
  #cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
  
  pvalues<-as.data.frame(pvalues)
  
  final.pvalues<-pvalues
  
  sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
  
  #data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
  
  #colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
  
  
  filename<-paste(fileheader,"results.allfeatures.txt",sep="")
  
  #data_allinf_withfeats<-cbind(fdr_adjust_pvalue,all_inf_mat,data_m_fc_withfeats)
  
  pval_columns<-grep(colnames(data_allinf_withfeats),pattern="P.value")
  
  fdr_adjusted_pvalue<-get_fdr_adjusted_pvalue(data_matrix=data_allinf_withfeats,fdrmethod=fdrmethod)
  
  #   data_allinf_withfeats1<-cbind(data_allinf_withfeats[,pval_columns],fdr_adjusted_pvalue,data_allinf_withfeats[,-c(pval_columns)])
  
  cnames_tab1<-c(cnames_tab[pval_columns],colnames(fdr_adjusted_pvalue),cnames_tab[-pval_columns])
  pval_columns<-grep(colnames(data_allinf_withfeats),pattern="P.value")
  
  fdr_adjusted_pvalue<-get_fdr_adjusted_pvalue(data_matrix=data_allinf_withfeats,fdrmethod=fdrmethod)
  
  data_allinf_withfeats<-cbind(data_allinf_withfeats[,pval_columns],fdr_adjusted_pvalue,data_allinf_withfeats[,-c(pval_columns)])
  
  cnames_tab1<-c(cnames_tab[pval_columns],colnames(fdr_adjusted_pvalue),cnames_tab[-pval_columns])
  
  
  
  write.table(data_allinf_withfeats, file=filename,sep="\t",row.names=FALSE)
  filename<-paste(fileheader,"results.selectedfeatures.txt",sep="")
  
  data_select_withfeats<-data_allinf_withfeats[sel.diffdrthresh,]
  
  write.table(data_select_withfeats, file=filename,sep="\t",row.names=FALSE)
  
  
  cnames_tab<-colnames(data_m_fc_withfeats)
  
  classlabels_response_mat<-as.data.frame(classlabels_response_mat)
  
  class_column_names<-colnames(classlabels_response_mat)
  
  # cnames_tab<-c(paste("P.value_var",1:dim(classlabels_response_mat)[2],sep=""),
  #paste("Estimate_var",1:dim(classlabels_response_mat)[2],sep=""), paste("StdError_var",1:dim(classlabels_response_mat)[2],sep=""),
  #paste("statistic_var",1:dim(classlabels_response_mat)[2],sep=""),cnames_tab)
  
  #cnames_1<-c(paste("P.value_",colnames(cur_pvals),sep=""),paste("Estimate_",colnames(cur_pvals),sep=""),paste("StdError_var_",colnames(cur_pvals),sep=""),paste("t-statistic_",colnames(cur_pvals),sep=""))
  
  
  if(ncol(classlabels_response_mat)>1){
    cnames_1<-c(paste("FDR.adjusted.P.value_",class_column_names,sep=""),paste("P.value_",class_column_names,sep=""),
                paste("Estimate_",class_column_names,sep=""), paste("StdError_",class_column_names,sep=""),
                paste("t-statistic_",class_column_names,sep=""))
  }else{
    cnames_1<-c(paste("FDR.adjusted.P.value",sep=""),paste("P.value",sep=""),
                paste("Estimate",sep=""), paste("StdError",sep=""),
                paste("t-statistic",sep=""))
    
  }
  
  
  # cnames_1<-c(paste("P.value_",colnames(cur_pvals),sep=""),paste("Estimate_",colnames(cur_pvals),sep=""),paste("StdError_",colnames(cur_pvals),sep=""),paste("t-statistic_",colnames(cur_pvals),sep=""))
  
  cnames_tab<-c(cnames_1,cnames_tab)
  
  
  colnames(data_allinf_withfeats)<-as.character(cnames_tab)
  
  write.table(data_allinf_withfeats, file=filename,sep="\t",row.names=FALSE)
  
  #data_allinf_withfeats<-data_allinf_withfeats[order(data_allinf_withfeats[,2]),]
  
  sel.diffdrthresh=which(sel.diffdrthresh==TRUE)
  sel.diffdrthresh<-sel.diffdrthresh[order(data_allinf_withfeats[sel.diffdrthresh,2])]
  
  options(warn=0)
  return(list("all"=data_allinf_withfeats,"selected"=data_select_withfeats,"selected.index"=sel.diffdrthresh))
  
}



#nested ensemble feature selection
#c("rf","rfe","limma","lasso","elasticnet","f.test")
nefs<-function(X=NA,Y=NA,feature_table_file=NA,class_labels_file=NA,feat.sel.methods=c("rf","rfe","pls","limma","lasso"),num.var.sel=10,prop.select.thresh=0.7,split.train.test=FALSE,train.pct=0.7,outloc,kfold=10,pca.ellipse=TRUE,Xtest=NA,Ytest=NA,rsdthresh=1,pls_vip_thresh=2,seedvalue=27611,learningsetmethod="CV",confounder.matrix=NA,fdrmethod="BH",fdrthresh=0.05,num.methods.sel=1,globalcor=FALSE,cor.method="spearman",networktype="complete",abs.cor.thresh=0.4,cor.fdrthresh=0.05,max.cor.num=100,net_node_colors=c("green","red"), net_legend=TRUE,niter=10,output.device.type="pdf",heatmap.col.opt="RdBu",boxplot.col.opt=c("white"),barplot.col.opt=c("grey57","grey90"),sample.col.opt="rainbow",mz.thresh=1,time.thresh=10,svm_kernel="radial",good_feats_index=NA,pvalue.thresh=0.05,plots.width=8,plots.height=8,plots.res=600, plots.type="cairo",num_nodes=2,ylabel="Intensity",cex.plots=0.7,tune_classifiers=FALSE,find.common.features=FALSE,aggregation.method="consensus",aggregation.max.iter=1000,add.pvalues=TRUE,add.jitter=TRUE,alphabetical.order=FALSE,boxplot.type="ggplot",balance.classes=FALSE,deeplearning=FALSE)
{
  
  options(warn=-1)
  
  suppressMessages(library(CMA))
  suppressMessages(library(h2o))
  suppressMessages(library(RankAggreg))
  suppressMessages(library(Boruta))
  suppressMessages(library(stepPlr))
  suppressMessages(library(glmnet))
  
  match_class_dist=TRUE
  analysistype="oneway"
  iter.quantile.thresh=prop.select.thresh
  #library(randomForest)
  #library(CMA)
  # importance=randomForest::importance
  #c("rfe","rf","limma","lasso","elasticnet","wilcox.test","pls","spls","ospls","opls","f.test","t.test")
  
  confounderfdrmethod=fdrmethod
  confounderfdrthresh=fdrthresh
  
  
  try(unlockBinding("importance", as.environment("package:ranger")),silent=TRUE)
  #assign("importance", importance, "package:randomForest")
  try(assign("importance", randomForest::importance, "package:ranger"),silent=TRUE)
  errortype="BER"
  tune_scda<-NA
  if(typeof(X)=="logical"){
    X<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }
  
  if(typeof(Y)=="logical"){
    Y<-read.table(class_labels_file,sep="\t",header=TRUE)
  }
  
  
  X<-as.data.frame(X)
  
  
  if(is.na(Xtest)==TRUE){
    
    test_data_check<-NA
  }else{
    test_data_check<-1
  }
  
  if(FALSE){
    cl<-makeCluster(num_nodes)
    
    clusterExport(cl,"do_rsd")
    
    feat_rsds<-parApply(cl,X[,-c(1:2)],1,do_rsd)
    
    stopCluster(cl)
    
    abs_feat_rsds<-abs(feat_rsds)
    
    good_metabs<-which(abs_feat_rsds>rsdthresh)
    if(length(good_metabs)>0){
      
      X<-X[good_metabs,]
    }else{
      
      stop("No features meet the defined rsd threshold.")
    }
    
  }
  
  Xorig<-X
  cnames1<-colnames(X)
  
  cnames1<-tolower(cnames1)
  
  check_name1<-grep(cnames1,pattern="name|Name")
  if(length(check_name1)>0){
    
    mzrt<-X$Name
    sampnames<-colnames(X[,-c(1)])
    mzrt_id<-X$Name
    #Transpose X and Xtrain; rows are samples; columns are metabs
    X<-t(X[,-c(1)])
    
  }else{
    mzrt<-X[,c(1:2)]
    
    sampnames<-colnames(X[,-c(1:2)])
    
    mzrt_id<-paste(X$mz,"_",X$time,sep="")
    
    #Transpose X and Xtrain; rows are samples; columns are metabs
    X<-t(X[,-c(1:2)])
  }
  
  
  if(num.var.sel>dim(Xorig)[1]){
    
    num.var.sel<-dim(Xorig)[1]
  }
  
  
  
  suppressWarnings(dir.create(outloc,showWarnings = FALSE))
  setwd(outloc)
  
  outloc=getwd()
  
  if(output.device.type!="pdf"){
    dir.create("Figures",showWarnings = FALSE)
  }
  fname<-"InputParameters.csv"
  
  
  nsamp<-dim(X)[1]
  
  Xtrain<-X
  Ytrain_mat<-Y
  Ytest_mat<-NA
  
  if(split.train.test==TRUE){
    if(nsamp<30){
      print("N is too small for train/test analysis. Continuing using all data as training set.")
      split.train.test=FALSE
      Xtrain<-X
      Y<-as.factor(Y[,2])
      Ytrain_mat<-Y
      Ytest_mat<-NA
    }else{
      
      
      test_data_check=1
      numtrain<-round(train.pct*nsamp)
      suppressMessages(library(CMA))
      set.seed(seedvalue)
      train_test_sets<-GenerateLearningsets(y=Y[,2],method="MCCV",ntrain=numtrain,niter=1,strat=TRUE,fold=kfold)
      allindex<-1:nsamp
      set.seed(seedvalue)
      train_index<-train_test_sets@learnmatrix[1,]
      check_index<-which(train_index==0)
      if(length(check_index)>0){
        train_index<-train_index[-check_index]
      }
      test_index<-allindex[-train_index]
      Ytrain_mat<-Y[train_index,]
      Ytest_mat<-Y[test_index,]
      Xtest<-X[test_index,]
      Ytest<-as.factor(Y[test_index,2])
      Y<-as.factor(Y[train_index,2])
      Ytrain<-Y
      Xtrain<-X[train_index,]
      print("Dim of train set")
      print(dim(Xtrain))
      print("Dim of test set")
      print(dim(Xtest))
      
      if(balance.classes==TRUE){
        
        data1=cbind(Ytrain,Xtrain)
        data1<-as.data.frame(data1)
        
        # colnames(data1)<-c("Ytrain",mzrt)
        ###save(data1,file="data.Rda")
        
        data1$Ytrain<-as.factor(data1$Ytrain)
        
        ## now using SMOTE to create a more "balanced problem"
        #newData <- SMOTE(Ytrain ~ ., data1, perc.over = 600,perc.under=100)
        
        colnames(data1)<-c("Ytrain",paste("var",seq(1,ncol(data1)-1),sep=""))
        newData <- ROSE(Ytrain ~ ., data1, seed = 1,N=nrow(data1)*2)$data
        print(table(newData$Ytrain))
        
        Xtrain<-newData[,-c(1)]
        Xtrain<-as.matrix(Xtrain)
        Ytrain<-newData[,c(1)]
        Y<-Ytrain
        Ytrain_mat<-cbind((rownames(Xtrain)),(Ytrain))
        Ytrain_mat<-as.data.frame(Ytrain_mat)
        print("new data")
        print(dim(Xtrain))
        print(dim(Ytrain_mat))
        print(length(Ytrain))
      }
      
      
      
      
      if(length(check_name1)>0){
        
        sampnames<-colnames(Xorig[,c(train_index+1)])
        sampnames_test<-colnames(Xorig[,c(test_index+1)])
      }else{
        sampnames<-colnames(Xorig[,c(train_index+2)])
        sampnames_test<-colnames(Xorig[,c(test_index+2)])
      }
      
      if(is.na(confounder.matrix)==FALSE){
        confounder.matrix<-confounder.matrix[train_index,]
      }
    }
    
  }else{
    
    Xtrain<-X
    Y<-as.factor(Y[,2])
    
    if(is.na(Xtest)==FALSE){
      
      Xtestorig<-Xtest
      
      mzrt_test<-Xtest[,c(1:2)]
      
      
      sampnames_test<-colnames(Xtest[,-c(1:2)])
      Xtest<-t(Xtest[,-c(1:2)])
      Ytest<-as.factor(Ytest[,2])
      
      #if(find.common.features==TRUE)
      {
        res1<-getVenn(dataA=mzrt,dataB=mzrt_test,name_a="train",name_b="test",time.thresh=time.thresh,mz.thresh=mz.thresh,xMSanalyzer.outloc=getwd())
        
        if(nrow(res1$common)<1){
          stop("No common features found.")
        }else{
          
          if(nrow(res1$common)!=nrow(mzrt)){
            #    print("Not all features were common between the train and test sets. Only using the common features for further analysis.")
            
          }
          
          #  print("Number of common features:")
          #print(nrow(res1$common))
          
          #print(head(res1$common))
          
          Xtrain<-Xtrain[,unique(res1$common$index.A)]
          
          #matching_train_data<-matching_train_data[order(matching_train_data$mz),]
          
          Xtest<-Xtest[,unique(res1$common$index.B)]
          
        }
        
      }
      
      
    }else{
      
      print("Using the training set as the test set")
      Xtest=Xtrain
      Ytest=Y
      sampnames_test<-colnames(Xorig[,-c(1:2)])
    }
    
  }
  
  X<-(Xtrain)
  
  svm_acc<-{}
  class_levels<-levels(as.factor(Y))
  
  
  if(learningsetmethod=="bootstrap"){
    
    niter=1000
  }else{
    niter=niter
  }
  
  if(is.na(Xtest)==FALSE)
  {
    #save(Xtrain,file="Xtrain.Rda")
    #save(Xtest,file="Xtest.Rda")
    #save(Y,file="Y.Rda")
    #save(Ytest,file="Ytest.Rda")
    
    if(ncol(Xtrain)!=ncol(Xtest)){
      
      stop("The train and test sets should have same number of variables.")
      
    }
  }
  
  suppressMessages(library(CMA))
  importance<-randomForest::importance
  set.seed(seedvalue)
  fiveCV10iter<-GenerateLearningsets(y=Y,method=learningsetmethod,fold=kfold,niter=niter,strat=TRUE)
  
  ###save(fiveCV10iter,file="fiveCV10iter.Rda")
  
  feat_sel_matrix<-matrix(nrow=dim(X)[2],ncol=length(feat.sel.methods),0)
  
  #  ##save(feat_sel_matrix,file="feat_sel_matrix.Rda")
  
  #  ##save(feat.sel.methods,file="feat.sel.methods.Rda")
  if(is.na(good_feats_index)==TRUE){
    
    if(is.na(feat.sel.methods)==FALSE){
      
      X1orig=X
      Y1orig=Y
      
      for(m in 1:length(feat.sel.methods)){
        
        X=X1orig
        Y=Y1orig
        method=feat.sel.methods[m]
        
        v1<-matrix(ncol=dim(fiveCV10iter@learnmatrix)[1],nrow=dim(X)[2],0)
        
        rank_matrix<-matrix(nrow=dim(fiveCV10iter@learnmatrix)[1],ncol=dim(X)[2],0)
        
        #rank_matrix<-{}
        ranked_list_2<-{}
        
        if(method=="pls" || method=="spls" || method=="opls" || method=="ospls" || method=="rfboruta" || method=="rferadial" || method=="lmreg" || method=="lmregrobust" || method=="logitreg" || method=="logitregrobust" || method=="poissonregrobust" || method=="poissonreg"){
          
          #changing here
          for(i in 1:dim(fiveCV10iter@learnmatrix)[1]){
            
            
            X=X1orig
            Y=Y1orig
            temptrain<-t(X[fiveCV10iter@learnmatrix[i,],])
            tempclass<-Y[fiveCV10iter@learnmatrix[i,]]
            
            classlabels_sub<-cbind(paste("S",rep(1,length(tempclass)),sep=""),tempclass)
            
            classlabels_sub<-as.data.frame(classlabels_sub)
            
            if(method=="rfboruta"){
              
              varimp_res<-do_rf_boruta(X=temptrain,classlabels=tempclass,maxRuns=1000)
              
              varindex<-which(varimp_res>0)
              
              if(length(varindex)>0){
                v1[varindex,i]<-1
                
              }
              
              
            }else{
              
              if(method=="rferadial"){
                
                ranked_var_list<-diffexpsvmrfe(x=temptrain,y=tempclass,svmkernel="radial")
                
                
                varindex<-which(varimp_res<num.var.sel)
                if(length(varindex)>0){
                  v1[varindex,i]<-1
                  
                }
                
              }else{
                
                if(method=="lmreg"){
                  
                  lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh)
                  
                  varindex<-lmregres$selected.index
                  if(length(varindex)>0){
                    v1[varindex,i]<-1
                    
                  }
                  
                  
                }else{
                  
                  if(method=="logitreg"){
                    
                    lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh,logistic_reg=TRUE)
                    
                    varindex<-lmregres$selected.index
                    if(length(varindex)>0){
                      v1[varindex,i]<-1
                      
                    }
                    
                    
                  }else{
                    
                    if(method=="lmregrobust"){
                      
                      lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh,robust.estimate=TRUE)
                      
                      varindex<-lmregres$selected.index
                      if(length(varindex)>0){
                        v1[varindex,i]<-1
                        
                      }
                      
                      
                    }else{
                      if(method=="logitregrobust"){
                        
                        lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh,robust.estimate=TRUE,logistic_reg=TRUE)
                        
                        varindex<-lmregres$selected.index
                        if(length(varindex)>0){
                          v1[varindex,i]<-1
                          
                        }
                        
                        
                      }
                      
                    }
                    
                    
                  }
                  
                  
                }
              }
            }
            
            
            if(method=="spls"){
              sparseselect=TRUE
            }else{
              sparseselect=FALSE
            }
            
            var_rsd<-apply(temptrain,1,do_rsd)
            
            
            temptrain<-temptrain #[-which(var_rsd<1),]
            
            X=t(temptrain)
            Y=tempclass
            rownames(X)<-seq(1,nrow(X)) #colnames(temptrain)
            #Y=as.vector(Y)
            
            #Y<-t(Y)
            
            
            if(ncol(X)>0){
              numcomp<-5
              #return(list(X=X,Y=Y,numcomp=numcomp,kfold=kfold))
              
              set.seed(123)
              opt_comp<-pls.lda.cv(Xtrain=X, Ytrain=Y,  ncomp=c(1:numcomp), nruncv=kfold, alpha=2/3, priors=NULL)
              
              if(method=="ospls"){
                
                Ytemp<-as.numeric(Y)
                leukemia.pls <- plsr(Ytemp ~ X, ncomp = opt_comp, validation = "LOO")
                ww <- leukemia.pls$loading.weights[,1]
                pp <- leukemia.pls$loadings[,1]
                w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
                t.ortho <- X %*% w.ortho
                
                p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
                Xcorr <- X - tcrossprod(t.ortho, p.ortho)
                
                
                
                X<-Xcorr
                method="spls"
              }
              
              if(method=="opls"){
                
                Ytemp<-as.numeric(Y)
                leukemia.pls <- plsr(Ytemp ~ X, ncomp = opt_comp, validation = "LOO")
                ww <- leukemia.pls$loading.weights[,1]
                pp <- leukemia.pls$loadings[,1]
                w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
                t.ortho <- X %*% w.ortho
                
                p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
                Xcorr <- X - tcrossprod(t.ortho, p.ortho)
                
                
                
                X<-Xcorr
                method="pls"
              }
              
              
              
              
              #opt_comp<-plsres1$opt_comp
              max_comp_sel<-opt_comp
              if(method=="spls"){
                
                keep_X_vec=rep(num.var.sel,opt_comp)
                
                linn.pls <- splsda(X, Y,ncomp=opt_comp,keepX=keep_X_vec)
                
                linn.vip<-linn.pls$loadings$X
                
                
                if(opt_comp>1){
                  
                  #abs
                  vip_res1<-abs(linn.vip)
                  
                  if(max_comp_sel>1){
                    vip_res1<-apply(vip_res1,1,mean)
                    
                  }else{
                    
                    vip_res1<-vip_res1[,c(1)]
                  }
                }else{
                  
                  vip_res1<-abs(linn.vip)
                }
                
                pls_vip<-vip_res1 #(plsres1$vip_res)
                
                
                #based on loadings for sPLS
                #feat_sel_matrix[which(pls_vip!=0),i]<-1 #pls_vip!=0 & rand_pls_sel_fdr<fdrthresh
                varindex<-which(pls_vip!=0)
                if(length(varindex)>0){
                  v1[varindex,i]<-1
                }
                
                
              }else{
                
                
                
                linn.pls <- plsda(X, Y,ncomp=opt_comp)
                
                linn.vip<-vip(linn.pls)
                #write.table(linn.vip,file="linn.vip.txt",sep="\t",row.names=TRUE)
                
                
                if(opt_comp>1){
                  vip_res1<-(linn.vip)
                  if(max_comp_sel>1){
                    vip_res1<-apply(vip_res1,1,mean)
                  }else{
                    
                    vip_res1<-vip_res1[,c(1)]
                  }
                }else{
                  
                  vip_res1<-linn.vip
                }
                
                
                
                #vip_res1<-plsres1$vip_res
                pls_vip<-vip_res1
                
                pls_vip_order<-pls_vip[order(pls_vip,decreasing=TRUE)]
                
                pls_vip_thresh<-min(pls_vip_order[1:num.var.sel])[1]
                
                rank_matrix[i,]<-t(order(pls_vip,decreasing=TRUE))
                
                
                ###save(rank_matrix,file="rank_matrix.Rda")
                # ##save(pls_vip,file="pls_vip.Rda")
                ###save(ranked_list,file="ranked_list.Rda")
                
                ###save(ranked_list_2,file="ranked_list_2.Rda")
                
                
                
                #print(pls_vip_thresh)
                #pls
                varindex<-which(pls_vip>=pls_vip_thresh)
                if(length(varindex)>0){
                  v1[varindex,i]<-1
                }
              }
            }
          }
          
          ranked_list<-rank_matrix
          for(rnum in 1:nrow(ranked_list)){
            
            ranked_list_2<-rbind(ranked_list_2,t(mzrt_id[ranked_list[rnum,]]))
            
          }
          
          
        }else{
          
          
          #set.seed(27611)
          set.seed(seedvalue)
          if(method=="rf"){
            g1<-GeneSelection(X=X,y=Y,learningsets=fiveCV10iter,method=method,trace=FALSE,seed = 100)
          }else{
            
            g1<-GeneSelection(X=X,y=Y,learningsets=fiveCV10iter,method=method,trace=FALSE)
          }
          gmatrix<-{}
          
          # ##save(g1,file="g1.Rda")
          ranked_list<-{}
          rank_matrix<-g1@rankings[[1]]
          
          v1<-matrix(nrow=dim(X)[2],ncol=dim(rank_matrix)[1],0)
          
          #    ##save(rank_matrix,file="rank_matrix.Rda")
          ###save(mzrt,file="mzrt.Rda")
          
          X<-Xtrain
          
          ranked_list<-g1@rankings[[1]]
          
          for(rnum in 1:nrow(ranked_list)){
            
            ranked_list_2<-rbind(ranked_list_2,t(mzrt_id[ranked_list[rnum,]]))
            
          }
          for(i in 1:dim(rank_matrix)[1]){
            
            varindex<-{}
            varindex1<-toplist(g1,iter=i,k=num.var.sel,show=FALSE)
            
            if(length(g1@rankings)>1){
              
              varindex<-c(varindex,varindex1[g1@rankings][,1])
              
            }else{
              varindex<-varindex1[,1]
            }
            
            varindex<-unique(varindex)
            
            
            v1[varindex,i]<-1
            
          }
        } #end else
        
        
        
        
        ###save(v1,file="v1.Rda")
        
        #hist(svm_acc,main="Inner test set accuracy distribution",col="brown")
        
        #iter.quantile.thresh: means that value is 1 in (1-iter.quantile.thresh)% or more sets;
        stability_measure<-apply(v1,1,function(x){length(which(x==1))/length(x)})  #quantile(x,iter.quantile.thresh)})
        
        stability_matrix<-stability_measure
        if(m==1){
          stability_matrix_1<-cbind(mzrt,stability_measure)
        }else{
          
          stability_matrix_1<-cbind(stability_matrix_1,stability_measure)
        }
        
        max_varsel=num.var.sel
        
        
        
        if(aggregation.method=="consensus"){
          
          feat_sel_matrix[which(stability_matrix>=iter.quantile.thresh),m]<-1
        }else{
          
          if(aggregation.method=="RankAggreg"){
            r1<-RankAggreg(x=ranked_list_2,k=max_varsel,verbose=TRUE,distance="Spearman",method="CE",maxIter=aggregation.max.iter)
          }else{
            
            if(aggregation.method=="RankAggregGA"){
              r1<-RankAggreg(x=ranked_list_2,k=max_varsel,verbose=TRUE,distance="Spearman",method="GA",maxIter=aggregation.max.iter)
            }else{
              
              
              feat_sel_matrix[which(stability_matrix==1),m]<-1
              
            }
          }
          # ##save(stability_matrix_1,file="stability_matrix1.Rda")
          
          stability_matrix_1<-as.data.frame(stability_matrix_1)
          #  ##save(r1,file="r1.Rda")
          
          if(length(check_name1)>0){
            
            colnames(stability_matrix_1)<-c("Name","stability_measure")
            mz_rt_all<-stability_matrix_1$Name
          }else{
            mz_rt_all<-paste(stability_matrix_1$mz,"_",stability_matrix_1$time,sep="")
          }
          
          common_row_index<-which(mz_rt_all%in%r1$top.list)
          
          
          feat_sel_matrix[common_row_index,m]<-1
          
          
          
        }
        
      }
      
      X=X1orig
      Y=Y1orig
      
      
      
    }else{
      
      feat_sel_matrix<-matrix(nrow=dim(Xtrain)[1],ncol=length(feat.sel.methods),1)
      
    }
    
    
    if(length(feat.sel.methods)>1){
      feat_sel_matrix<-apply(feat_sel_matrix,1,sum)
      
      
    }
    
    if(num.methods.sel>length(feat.sel.methods)){
      
      num.methods.sel=length(feat.sel.methods)
    }
    
    if(length(check_name1)>0){
      
      colnames(stability_matrix_1)<-c("mzrt",feat.sel.methods)
      
    }else{
      
      colnames(stability_matrix_1)<-c("mz","time",feat.sel.methods)
    }
    
    #pdf("Results.pdf")
    
    #hist(stability_measure,main="Stability measure distribution",col="brown")
    write.table(stability_matrix_1,file="stability_matrix.txt",sep="\t",row.names=FALSE)
    
    good_feats_index<-which(feat_sel_matrix>=num.methods.sel)
    
    if(FALSE){
      if(is.na(pvalue.thresh)==FALSE){
        
        
        
        
        numcores<-num_nodes #round(detectCores()*0.5)
        
        cl <- parallel::makeCluster(getOption("cl.cores", numcores))
        
        clusterExport(cl,"diffexponewayanova",envir = .GlobalEnv)
        
        clusterExport(cl,"anova",envir = .GlobalEnv)
        
        
        clusterExport(cl,"TukeyHSD",envir = .GlobalEnv)
        
        clusterExport(cl,"aov",envir = .GlobalEnv)
        
        
        #res1<-apply(data_m_fc,1,function(x){
        res1<-parApply(cl,X,2,function(x,classlabels_response_mat){
          xvec<-x
          
          
          data_mat_anova<-cbind(xvec,classlabels_response_mat)
          
          data_mat_anova<-as.data.frame(data_mat_anova)
          cnames<-colnames(data_mat_anova)
          
          cnames[1]<-"Response"
          
          colnames(data_mat_anova)<-c("Response","Factor1")
          
          #print(data_mat_anova)
          
          data_mat_anova$Factor1<-as.factor(data_mat_anova$Factor1)
          
          anova_res<-diffexponewayanova(dataA=data_mat_anova)
          
          
          
          return(anova_res)
        },Y)
        
        stopCluster(cl)
        main_pval_mat<-{}
        
        posthoc_pval_mat<-{}
        pvalues<-{}
        
        
        
        for(i in 1:length(res1)){
          
          
          main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
          pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
          posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthocfactor1)
          
        }
        
        pvalues<-unlist(pvalues)
        
        good_feats_index<-which(feat_sel_matrix>=num.methods.sel & pvalues<pvalue.thresh)
        if(length(good_feats_index)<1){
          stop("No features selected.")
        }
        
      }
      
    }
    good_feats<-Xtrain[,good_feats_index]
    
    
    if(length(check_name1)>0){
      mzrt_sub<-mzrt[good_feats_index]
    }else{
      mzrt_sub<-mzrt[good_feats_index,]
    }
    good_feats<-t(good_feats)
    
    
    
    cnames_1<-colnames(good_feats)
    
    
    #colnames(good_feats)<-sampnames
    
    
    good_feats<-cbind(mzrt_sub,good_feats)
    
    
    
    ###save(sampnames_test,mzrt_sub,good_feats,Xtest,X,Y,Xtrain,mzrt,good_feats_index,file="good_feats_index.Rda")
    
    if(is.na(Xtest)==FALSE){
      good_feats_test<-Xtest[,good_feats_index]
      good_feats_test<-t(good_feats_test)
      colnames(good_feats_test)<-sampnames_test
      good_feats_test<-cbind(mzrt_sub,good_feats_test)
    }else{
      good_feats_test<-NA
      Ytest_mat<-NA
    }
    
    
  }else{
    pdf("Results.pdf")
    
    good_feats<-Xtrain[,good_feats_index]
    
    
    
    mzrt_sub<-mzrt[good_feats_index,]
    
    good_feats<-t(good_feats)
    
    
    
    cnames_1<-colnames(good_feats)
    
    
    colnames(good_feats)<-sampnames
    
    
    good_feats<-cbind(mzrt_sub,good_feats)
    
    if(is.na(Xtest)==FALSE){
      good_feats_test<-Xtest[,good_feats_index]
      good_feats_test<-t(good_feats_test)
      colnames(good_feats_test)<-sampnames_test
      good_feats_test<-cbind(mzrt_sub,good_feats_test)
    }else{
      good_feats_test<-NA
      Ytest_mat<-NA
    }
    
  }
  
  print("Number of features selected")
  print(length(good_feats_index))
  
  #    #save(good_feats,Xtrain,good_feats_test,Xtest,Ytest,Y,good_feats_index,stability_matrix_1,file="feat.sel.res.Rda")
  
  
  if(length(good_feats_index)>1){
    
    X<-X[,good_feats_index]
    
    if(is.na(Xtest)==FALSE){
      
      Xtest<-Xtest[,good_feats_index]
    }
    
    #  #save(X,Y,fiveCV10iter,Xtest,Ytest,good_feats_test,Ytest,file="acc.Rda")
    
    return(list("selected.features.index"=good_feats_index,"train.select"=X,"test.select"=Xtest,"stability_matrix"=stability_matrix_1,"feat.sel.matrix"=feat_sel_matrix,train.class=Ytrain_mat,test.class=Ytest_mat))
  }
}



#c("rf","rfe","limma","lasso","elasticnet","f.test")
diffexp.biomarkers<-function(X=NA,Y=NA,feature_table_file=NA,class_labels_file=NA,
                              feat.sel.methods=c("rf","rfe","pls","limma","lasso"),num.var.sel=10,prop.select.thresh=0.7,
                              split.train.test=FALSE,train.pct=0.7,outloc,kfold=10,pca.ellipse=TRUE,Xtest=NA,Ytest=NA,
                              rsdthresh=1,pls_vip_thresh=2,seedvalue=27611,learningsetmethod="CV",confounder.matrix=NA,
                              fdrmethod="BH",fdrthresh=0.05,num.methods.sel=1,globalcor=FALSE,
                              cor.method="spearman",networktype="complete",abs.cor.thresh=0.4,
                              cor.fdrthresh=0.05,max.cor.num=100,net_node_colors=c("green","red"),
                              net_legend=TRUE,niter=10,output.device.type="pdf",
                              heatmap.col.opt="RdBu",boxplot.col.opt=c("white"),
                              barplot.col.opt=c("grey57","grey90"),sample.col.opt="rainbow",
                              mz.thresh=1,time.thresh=10,svm_kernel="radial",
                              good_feats_index=NA,pvalue.thresh=0.05,plots.width=8,
                              plots.height=8,plots.res=600, plots.type="cairo",
                              num_nodes=2,ylabel="Intensity",cex.plots=0.7,tune_classifiers=FALSE,
                              find.common.features=FALSE,aggregation.method="consensus",
                              aggregation.max.iter=1000,add.pvalues=TRUE,add.jitter=TRUE,
                              alphabetical.order=FALSE,boxplot.type="ggplot",
                             balance.classes=FALSE,deeplearning=FALSE,alpha.col=1,ggplot.type1=NA,
                             hca_type="two-way",multiple.figures.perpanel = FALSE,     
                             hca.labRow.value = FALSE, hca.labCol.value = FALSE,                   
                             similarity.matrix = "correlation")
{
  
  options(warn=-1)
  
  suppressMessages(library(CMA))
  suppressMessages(library(h2o))
  suppressMessages(library(RankAggreg))
  suppressMessages(library(Boruta))
  suppressMessages(library(stepPlr))
  suppressMessages(library(glmnet))
  
  match_class_dist=TRUE
  analysistype="oneway"
  labRow.value=hca.labRow.value
  labCol.value=hca.labCol.value
  iter.quantile.thresh=prop.select.thresh
  #library(randomForest)
  #library(CMA)
  # importance=randomForest::importance
  #c("rfe","rf","limma","lasso","elasticnet","wilcox.test","pls","spls","ospls","opls","f.test","t.test")
  
  confounderfdrmethod=fdrmethod
  confounderfdrthresh=fdrthresh
  
  
  try(unlockBinding("importance", as.environment("package:ranger")),silent=TRUE)
  #assign("importance", importance, "package:randomForest")
  try(assign("importance", randomForest::importance, "package:ranger"),silent=TRUE)
  errortype="BER"
  tune_scda<-NA
  if(typeof(X)=="logical"){
    X<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }
  
  if(typeof(Y)=="logical"){
    Y<-read.table(class_labels_file,sep="\t",header=TRUE)
  }
  
  
  X<-as.data.frame(X)
  
  
  if(is.na(Xtest)==TRUE){
    
    test_data_check<-NA
  }else{
    test_data_check<-1
  }
  
  if(FALSE){
    cl<-makeCluster(num_nodes)
    
    clusterExport(cl,"do_rsd")
    
    feat_rsds<-parApply(cl,X[,-c(1:2)],1,do_rsd)
    
    stopCluster(cl)
    
    abs_feat_rsds<-abs(feat_rsds)
    
    good_metabs<-which(abs_feat_rsds>rsdthresh)
    if(length(good_metabs)>0){
      
      X<-X[good_metabs,]
    }else{
      
      stop("No features meet the defined rsd threshold.")
    }
    
  }
  
  Xorig<-X
  cnames1<-colnames(X)
  
  cnames1<-tolower(cnames1)
  
  check_name1<-grep(cnames1,pattern="name|Name")
  if(length(check_name1)>0){
    
    mzrt<-X$Name
    sampnames<-colnames(X[,-c(1)])
    mzrt_id<-X$Name
    #Transpose X and Xtrain; rows are samples; columns are metabs
    X<-t(X[,-c(1)])
    
  }else{
    mzrt<-X[,c(1:2)]
    
    sampnames<-colnames(X[,-c(1:2)])
    
    mzrt_id<-paste(X$mz,"_",X$time,sep="")
    
    #Transpose X and Xtrain; rows are samples; columns are metabs
    X<-t(X[,-c(1:2)]) 
  }
  
  
  if(num.var.sel>dim(Xorig)[1]){
    
    num.var.sel<-dim(Xorig)[1]
  }
  
  
  
  suppressWarnings(dir.create(outloc,showWarnings = FALSE))
  setwd(outloc)
  
  outloc=getwd()
  
  if(output.device.type!="pdf"){
    dir.create("Figures",showWarnings = FALSE)
  }
  fname<-"InputParameters.csv"
  
  
  nsamp<-dim(X)[1]
  
  Xtrain<-X
  Ytrain_mat<-Y
  Ytest_mat<-NA
  
  if(split.train.test==TRUE){
    if(nsamp<30){
      print("N is too small for train/test analysis. Continuing using all data as training set.")
      split.train.test=FALSE
      Xtrain<-X
      Y<-as.factor(Y[,2])
      Ytrain_mat<-Y
      Ytest_mat<-NA
    }else{
      
      suppressMessages(library(CMA))
      test_data_check=1 
      numtrain<-round(train.pct*nsamp)
      set.seed(seedvalue)
      train_test_sets<-GenerateLearningsets(y=Y[,2],method="MCCV",ntrain=numtrain,niter=1,strat=TRUE,fold=kfold)
      allindex<-1:nsamp
      set.seed(seedvalue)
      train_index<-train_test_sets@learnmatrix[1,]
      check_index<-which(train_index==0)
      if(length(check_index)>0){
        train_index<-train_index[-check_index]
      }
      test_index<-allindex[-train_index]
      Ytrain_mat<-Y[train_index,]
      Ytest_mat<-Y[test_index,]
      Xtest<-X[test_index,]
      Ytest<-as.factor(Y[test_index,2])
      Y<-as.factor(Y[train_index,2])
      Ytrain<-Y
      Xtrain<-X[train_index,]
      print("Dim of train set")
      print(dim(Xtrain))
      print("Dim of test set")
      print(dim(Xtest))
      
      if(balance.classes==TRUE){
        
        data1=cbind(Ytrain,Xtrain)
        data1<-as.data.frame(data1)
        
        # colnames(data1)<-c("Ytrain",mzrt)
        ###save(data1,file="data.Rda")
        
        data1$Ytrain<-as.factor(data1$Ytrain)
        
        ## now using SMOTE to create a more "balanced problem"
        #newData <- SMOTE(Ytrain ~ ., data1, perc.over = 600,perc.under=100)
        
        colnames(data1)<-c("Ytrain",paste("var",seq(1,ncol(data1)-1),sep=""))
        newData <- ROSE(Ytrain ~ ., data1, seed = 1,N=nrow(data1)*2)$data
        print(table(newData$Ytrain))
        
        Xtrain<-newData[,-c(1)]
        Xtrain<-as.matrix(Xtrain)
        Ytrain<-newData[,c(1)]
        Y<-Ytrain
        Ytrain_mat<-cbind((rownames(Xtrain)),(Ytrain))
        Ytrain_mat<-as.data.frame(Ytrain_mat)
        print("new data")
        print(dim(Xtrain))
        print(dim(Ytrain_mat))
        print(length(Ytrain))
      }
      
      
      
      
      if(length(check_name1)>0){
        
        sampnames<-colnames(Xorig[,c(train_index+1)])
        sampnames_test<-colnames(Xorig[,c(test_index+1)])
      }else{
        sampnames<-colnames(Xorig[,c(train_index+2)])
        sampnames_test<-colnames(Xorig[,c(test_index+2)])
      }
      
      if(is.na(confounder.matrix)==FALSE){
        confounder.matrix<-confounder.matrix[train_index,]
      }
    }
    
  }else{
    
    Xtrain<-X
    Y<-as.factor(Y[,2])
    
    if(is.na(Xtest)==FALSE){
      
      Xtestorig<-Xtest
      
      mzrt_test<-Xtest[,c(1:2)]
      
      
      sampnames_test<-colnames(Xtest[,-c(1:2)])
      Xtest<-t(Xtest[,-c(1:2)])
      Ytest<-as.factor(Ytest[,2])
      
      #if(find.common.features==TRUE)
      {
        res1<-getVenn(dataA=mzrt,dataB=mzrt_test,name_a="train",name_b="test",time.thresh=time.thresh,mz.thresh=mz.thresh,xMSanalyzer.outloc=getwd())
        
        if(nrow(res1$common)<1){
          stop("No common features found.")
        }else{
          
          if(nrow(res1$common)!=nrow(mzrt)){
            #    print("Not all features were common between the train and test sets. Only using the common features for further analysis.")
            
          }
          
          #  print("Number of common features:")
          #print(nrow(res1$common))
          
          #print(head(res1$common))
          
          Xtrain<-Xtrain[,unique(res1$common$index.A)]
          
          #matching_train_data<-matching_train_data[order(matching_train_data$mz),]
          
          Xtest<-Xtest[,unique(res1$common$index.B)]
          
        }
        
      }
      
      
    }else{
      
      print("Using the training set as the test set")
      Xtest=Xtrain
      Ytest=Y
      sampnames_test<-colnames(Xorig[,-c(1:2)])
    }
    
  }
  
  X<-(Xtrain)
  
  svm_acc<-{}
  class_levels<-levels(as.factor(Y))
  
  
  if(learningsetmethod=="bootstrap"){
    
    niter=1000
  }else{
    niter=niter
  }
  
  if(is.na(Xtest)==FALSE)
  {
    #   #save(Xtrain,file="Xtrain.Rda")
    ##save(Xtest,file="Xtest.Rda")
    ##save(Y,file="Y.Rda")
    ##save(Ytest,file="Ytest.Rda")
    
    if(ncol(Xtrain)!=ncol(Xtest)){
      
      stop("The train and test sets should have same number of variables.")
      
    }
  }
  suppressMessages(library(CMA))
  importance<-randomForest::importance
  set.seed(seedvalue)
  fiveCV10iter<-GenerateLearningsets(y=Y,method=learningsetmethod,fold=kfold,niter=niter,strat=TRUE)
  
  ###save(fiveCV10iter,file="fiveCV10iter.Rda")
  
  feat_sel_matrix<-matrix(nrow=dim(X)[2],ncol=length(feat.sel.methods),0)
  
  #  ##save(feat_sel_matrix,file="feat_sel_matrix.Rda")
  
  #  ##save(feat.sel.methods,file="feat.sel.methods.Rda")
  if(is.na(good_feats_index)==TRUE){
    
    if(is.na(feat.sel.methods)==FALSE){
      
      X1orig=X
      Y1orig=Y
      
      for(m in 1:length(feat.sel.methods)){
        
        X=X1orig
        Y=Y1orig
        method=feat.sel.methods[m]
        
        v1<-matrix(ncol=dim(fiveCV10iter@learnmatrix)[1],nrow=dim(X)[2],0)
        
        rank_matrix<-matrix(nrow=dim(fiveCV10iter@learnmatrix)[1],ncol=dim(X)[2],0)
        
        #rank_matrix<-{}
        ranked_list_2<-{}
        
        if(method=="pls" || method=="spls" || method=="opls" || method=="ospls" || method=="rfboruta" || method=="rferadial" || method=="lmreg" || method=="lmregrobust" || method=="logitreg" || method=="logitregrobust" || method=="poissonregrobust" || method=="poissonreg"){
          
          #changing here
          for(i in 1:dim(fiveCV10iter@learnmatrix)[1]){
            
            
            X=X1orig
            Y=Y1orig
            temptrain<-t(X[fiveCV10iter@learnmatrix[i,],])
            tempclass<-Y[fiveCV10iter@learnmatrix[i,]]
            
            classlabels_sub<-cbind(paste("S",rep(1,length(tempclass)),sep=""),tempclass)
            
            classlabels_sub<-as.data.frame(classlabels_sub)
            
            if(method=="rfboruta"){
              
              varimp_res<-do_rf_boruta(X=temptrain,classlabels=tempclass,maxRuns=1000)
              
              varindex<-which(varimp_res>0)
              
              if(length(varindex)>0){
                v1[varindex,i]<-1
                
              }
              
              
            }else{
              
              if(method=="rferadial"){
                
                ranked_var_list<-diffexpsvmrfe(x=temptrain,y=tempclass,svmkernel="radial")
                
                
                varindex<-which(varimp_res<num.var.sel)
                if(length(varindex)>0){
                  v1[varindex,i]<-1
                  
                }
                
              }else{
                
                if(method=="lmreg"){
                  
                  lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh)
                  
                  varindex<-lmregres$selected.index
                  if(length(varindex)>0){
                    v1[varindex,i]<-1
                    
                  }
                  
                  
                }else{
                  
                  if(method=="logitreg"){
                    
                    lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh,logistic_reg=TRUE)
                    
                    varindex<-lmregres$selected.index
                    if(length(varindex)>0){
                      v1[varindex,i]<-1
                      
                    }
                    
                    
                  }else{
                    
                    if(method=="lmregrobust"){
                      
                      lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh,robust.estimate=TRUE)
                      
                      varindex<-lmregres$selected.index
                      if(length(varindex)>0){
                        v1[varindex,i]<-1
                        
                      }
                      
                      
                    }else{
                      if(method=="logitregrobust"){
                        
                        lmregres<-runlmreg(X=temptrain,Y=tempclass,pvalue.thresh=pvalue.thresh,fdrmethod=fdrmethod,fdrthresh=fdrthresh,robust.estimate=TRUE,logistic_reg=TRUE)
                        
                        varindex<-lmregres$selected.index
                        if(length(varindex)>0){
                          v1[varindex,i]<-1
                          
                        }
                        
                        
                      }
                      
                    }
                    
                    
                  }
                  
                  
                }
              }
            }
            
            
            if(method=="spls"){
              sparseselect=TRUE
            }else{
              sparseselect=FALSE
            }
            
            var_rsd<-apply(temptrain,1,do_rsd)
            
            
            temptrain<-temptrain #[-which(var_rsd<1),]
            
            X=t(temptrain)
            Y=tempclass
            rownames(X)<-seq(1,nrow(X)) #colnames(temptrain)
            #Y=as.vector(Y)
            
            #Y<-t(Y)
            
            
            if(ncol(X)>0){
              numcomp<-5
              #return(list(X=X,Y=Y,numcomp=numcomp,kfold=kfold))
              
              set.seed(123)
              opt_comp<-pls.lda.cv(Xtrain=X, Ytrain=Y,  ncomp=c(1:numcomp), nruncv=kfold, alpha=2/3, priors=NULL)
              
              if(method=="ospls"){
                
                Ytemp<-as.numeric(Y)
                leukemia.pls <- plsr(Ytemp ~ X, ncomp = opt_comp, validation = "LOO")
                ww <- leukemia.pls$loading.weights[,1]
                pp <- leukemia.pls$loadings[,1]
                w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
                t.ortho <- X %*% w.ortho
                
                p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
                Xcorr <- X - tcrossprod(t.ortho, p.ortho)
                
                
                
                X<-Xcorr
                method="spls"
              }
              
              if(method=="opls"){
                
                Ytemp<-as.numeric(Y)
                leukemia.pls <- plsr(Ytemp ~ X, ncomp = opt_comp, validation = "LOO")
                ww <- leukemia.pls$loading.weights[,1]
                pp <- leukemia.pls$loadings[,1]
                w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
                t.ortho <- X %*% w.ortho
                
                p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
                Xcorr <- X - tcrossprod(t.ortho, p.ortho)
                
                
                
                X<-Xcorr
                method="pls"
              }
              
              
              
              
              #opt_comp<-plsres1$opt_comp
              max_comp_sel<-opt_comp
              if(method=="spls"){
                
                keep_X_vec=rep(num.var.sel,opt_comp)
                
                linn.pls <- splsda(X, Y,ncomp=opt_comp,keepX=keep_X_vec)
                
                linn.vip<-linn.pls$loadings$X
                
                
                if(opt_comp>1){
                  
                  #abs
                  vip_res1<-abs(linn.vip)
                  
                  if(max_comp_sel>1){
                    vip_res1<-apply(vip_res1,1,mean)
                    
                  }else{
                    
                    vip_res1<-vip_res1[,c(1)]
                  }
                }else{
                  
                  vip_res1<-abs(linn.vip)
                }
                
                pls_vip<-vip_res1 #(plsres1$vip_res)
                
                
                #based on loadings for sPLS
                #feat_sel_matrix[which(pls_vip!=0),i]<-1 #pls_vip!=0 & rand_pls_sel_fdr<fdrthresh
                varindex<-which(pls_vip!=0)
                if(length(varindex)>0){
                  v1[varindex,i]<-1
                }
                
                
              }else{
                
                
                
                linn.pls <- plsda(X, Y,ncomp=opt_comp)
                
                linn.vip<-vip(linn.pls)
                #write.table(linn.vip,file="linn.vip.txt",sep="\t",row.names=TRUE)       
                
                
                if(opt_comp>1){
                  vip_res1<-(linn.vip)
                  if(max_comp_sel>1){
                    vip_res1<-apply(vip_res1,1,mean)
                  }else{
                    
                    vip_res1<-vip_res1[,c(1)]
                  }
                }else{
                  
                  vip_res1<-linn.vip
                }
                
                
                
                #vip_res1<-plsres1$vip_res
                pls_vip<-vip_res1
                
                pls_vip_order<-pls_vip[order(pls_vip,decreasing=TRUE)]
                
                pls_vip_thresh<-min(pls_vip_order[1:num.var.sel])[1]
                
                rank_matrix[i,]<-t(order(pls_vip,decreasing=TRUE))
                
                
                ###save(rank_matrix,file="rank_matrix.Rda")
                # ##save(pls_vip,file="pls_vip.Rda")
                ###save(ranked_list,file="ranked_list.Rda")
                
                ###save(ranked_list_2,file="ranked_list_2.Rda")
                
                
                
                #print(pls_vip_thresh)
                #pls
                varindex<-which(pls_vip>=pls_vip_thresh)
                if(length(varindex)>0){
                  v1[varindex,i]<-1
                }
              }
            }
          }
          
          ranked_list<-rank_matrix        
          for(rnum in 1:nrow(ranked_list)){
            
            ranked_list_2<-rbind(ranked_list_2,t(mzrt_id[ranked_list[rnum,]]))
            
          }
          
          
        }else{
          
          
          #set.seed(27611)
          set.seed(seedvalue)
          if(method=="rf"){
            g1<-GeneSelection(X=X,y=Y,learningsets=fiveCV10iter,method=method,trace=FALSE,seed = 100)
          }else{
            
            g1<-GeneSelection(X=X,y=Y,learningsets=fiveCV10iter,method=method,trace=FALSE)
          }
          gmatrix<-{}
          
          # ##save(g1,file="g1.Rda")
          ranked_list<-{}
          rank_matrix<-g1@rankings[[1]]
          
          v1<-matrix(nrow=dim(X)[2],ncol=dim(rank_matrix)[1],0)
          
          #    ##save(rank_matrix,file="rank_matrix.Rda")
          ###save(mzrt,file="mzrt.Rda")
          
          X<-Xtrain
          
          ranked_list<-g1@rankings[[1]]
          
          for(rnum in 1:nrow(ranked_list)){
            
            ranked_list_2<-rbind(ranked_list_2,t(mzrt_id[ranked_list[rnum,]]))
            
          }
          for(i in 1:dim(rank_matrix)[1]){
            
            varindex<-{}
            varindex1<-toplist(g1,iter=i,k=num.var.sel,show=FALSE)
            
            if(length(g1@rankings)>1){
              
              varindex<-c(varindex,varindex1[g1@rankings][,1])
              
            }else{
              varindex<-varindex1[,1]
            }
            
            varindex<-unique(varindex)
            
            
            v1[varindex,i]<-1
            
          }
        } #end else
        
        
        
        
        ###save(v1,file="v1.Rda")
        
        #hist(svm_acc,main="Inner test set accuracy distribution",col="brown")
        
        #iter.quantile.thresh: means that value is 1 in (1-iter.quantile.thresh)% or more sets;
        stability_measure<-apply(v1,1,function(x){length(which(x==1))/length(x)})  #quantile(x,iter.quantile.thresh)})
        
        stability_matrix<-stability_measure
        if(m==1){
          stability_matrix_1<-cbind(mzrt,stability_measure)
        }else{
          
          stability_matrix_1<-cbind(stability_matrix_1,stability_measure)
        }
        
        max_varsel=num.var.sel
        
        
        
        if(aggregation.method=="consensus"){
          
          feat_sel_matrix[which(stability_matrix>=iter.quantile.thresh),m]<-1
        }else{
          
          if(aggregation.method=="RankAggreg"){
            r1<-RankAggreg(x=ranked_list_2,k=max_varsel,verbose=TRUE,distance="Spearman",method="CE",maxIter=aggregation.max.iter)
          }else{
            
            if(aggregation.method=="RankAggregGA"){
              r1<-RankAggreg(x=ranked_list_2,k=max_varsel,verbose=TRUE,distance="Spearman",method="GA",maxIter=aggregation.max.iter)
            }else{
              
              
              feat_sel_matrix[which(stability_matrix==1),m]<-1
              
            }
          }
          # ##save(stability_matrix_1,file="stability_matrix1.Rda")
          
          stability_matrix_1<-as.data.frame(stability_matrix_1)
          #  ##save(r1,file="r1.Rda")
          
          if(length(check_name1)>0){
            
            colnames(stability_matrix_1)<-c("Name","stability_measure")
            mz_rt_all<-stability_matrix_1$Name
          }else{
            mz_rt_all<-paste(stability_matrix_1$mz,"_",stability_matrix_1$time,sep="")
          }
          
          common_row_index<-which(mz_rt_all%in%r1$top.list)
          
          
          feat_sel_matrix[common_row_index,m]<-1
          
          
          
        }
        
      }
      
      X=X1orig
      Y=Y1orig
      
      
      
    }else{
      
      feat_sel_matrix<-matrix(nrow=dim(Xtrain)[1],ncol=length(feat.sel.methods),1)
      
    }
    
    
    if(length(feat.sel.methods)>1){
      feat_sel_matrix<-apply(feat_sel_matrix,1,sum)
      
      
    }
    
    if(num.methods.sel>length(feat.sel.methods)){
      
      num.methods.sel=length(feat.sel.methods)
    }
    
    if(length(check_name1)>0){
      
      colnames(stability_matrix_1)<-c("mzrt",feat.sel.methods)
      
    }else{
      
      colnames(stability_matrix_1)<-c("mz","time",feat.sel.methods)
    }
    
    pdf("Results.pdf")
    
    #hist(stability_measure,main="Stability measure distribution",col="brown")
    write.table(stability_matrix_1,file="stability_matrix.txt",sep="\t",row.names=FALSE)
    
    good_feats_index<-which(feat_sel_matrix>=num.methods.sel)
    
    if(FALSE){
      if(is.na(pvalue.thresh)==FALSE){
        
        
        
        
        numcores<-num_nodes #round(detectCores()*0.5)
        
        cl <- parallel::makeCluster(getOption("cl.cores", numcores))
        
        clusterExport(cl,"diffexponewayanova",envir = .GlobalEnv)
        
        clusterExport(cl,"anova",envir = .GlobalEnv)
        
        
        clusterExport(cl,"TukeyHSD",envir = .GlobalEnv)
        
        clusterExport(cl,"aov",envir = .GlobalEnv)
        
        
        #res1<-apply(data_m_fc,1,function(x){
        res1<-parApply(cl,X,2,function(x,classlabels_response_mat){
          xvec<-x
          
          
          data_mat_anova<-cbind(xvec,classlabels_response_mat)
          
          data_mat_anova<-as.data.frame(data_mat_anova)
          cnames<-colnames(data_mat_anova)
          
          cnames[1]<-"Response"
          
          colnames(data_mat_anova)<-c("Response","Factor1")
          
          #print(data_mat_anova)
          
          data_mat_anova$Factor1<-as.factor(data_mat_anova$Factor1)
          
          anova_res<-diffexponewayanova(dataA=data_mat_anova)
          
          
          
          return(anova_res)
        },Y)
        
        stopCluster(cl)
        main_pval_mat<-{}
        
        posthoc_pval_mat<-{}
        pvalues<-{}
        
        
        
        for(i in 1:length(res1)){
          
          
          main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
          pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
          posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthocfactor1)
          
        }
        
        pvalues<-unlist(pvalues)
        
        good_feats_index<-which(feat_sel_matrix>=num.methods.sel & pvalues<pvalue.thresh)
        if(length(good_feats_index)<1){
          stop("No features selected.")
        }
        
      }
      
    }
    good_feats<-Xtrain[,good_feats_index]
    
    
    if(length(check_name1)>0){
      mzrt_sub<-mzrt[good_feats_index]
    }else{
      mzrt_sub<-mzrt[good_feats_index,]
    }
    good_feats<-t(good_feats)
    
    
    
    cnames_1<-colnames(good_feats)
    
    
    #colnames(good_feats)<-sampnames
    
    
    good_feats<-cbind(mzrt_sub,good_feats)
    
    
    
    ###save(sampnames_test,mzrt_sub,good_feats,Xtest,X,Y,Xtrain,mzrt,good_feats_index,file="good_feats_index.Rda")
    
    if(is.na(Xtest)==FALSE){
      good_feats_test<-Xtest[,good_feats_index]
      good_feats_test<-t(good_feats_test)
      colnames(good_feats_test)<-sampnames_test
      good_feats_test<-cbind(mzrt_sub,good_feats_test)
    }else{
      good_feats_test<-NA
      Ytest_mat<-NA
    }
    
    
  }else{
    pdf("Results.pdf")
    
    good_feats<-Xtrain[,good_feats_index]
    
    
    
    mzrt_sub<-mzrt[good_feats_index,]
    
    good_feats<-t(good_feats)
    
    
    
    cnames_1<-colnames(good_feats)
    
    
    colnames(good_feats)<-sampnames
    
    
    good_feats<-cbind(mzrt_sub,good_feats)
    
    if(is.na(Xtest)==FALSE){
      good_feats_test<-Xtest[,good_feats_index]
      good_feats_test<-t(good_feats_test)
      colnames(good_feats_test)<-sampnames_test
      good_feats_test<-cbind(mzrt_sub,good_feats_test)
    }else{
      good_feats_test<-NA
      Ytest_mat<-NA
    }
    
  }
  
  print("Number of features selected")
  print(length(good_feats_index))
  
  #  #save(good_feats,Xtrain,good_feats_test,Xtest,Ytest,Y,good_feats_index,stability_matrix_1,file="feat.sel.res.Rda")
  
  
  if(length(good_feats_index)>1){
    
    X<-X[,good_feats_index]
    
    if(is.na(Xtest)==FALSE){
      
      Xtest<-Xtest[,good_feats_index]
    }
    
    #    #save(X,Y,fiveCV10iter,Xtest,Ytest,good_feats_test,Ytest,file="acc.Rda")
    
    return(good_feats_index)
    
    if(tune_classifiers==TRUE)
    {
      
      print("Building classification model using training set without tuning")
      
      if(length(good_feats_index)>=3)
      {
        
        
        set.seed(seedvalue)
        tune_plslda <- suppressWarnings(CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA, grids = list(comp = 1:10),trace=FALSE))
        
        #     ##save(tune_plslda,file="tune_plslda.Rda")
        
        set.seed(seedvalue)
        tune_plsrf <- CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA, grids = list(comp = 1:10),trace=FALSE)
        
        ##save(tune_plsrf,file="tune_plsrf.Rda")
      }
      
      ##saveX,Y,fiveCV10iter,file="scda.Rda")
      set.seed(seedvalue)
      tune_scda <-try(CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA, grids = list( ),trace=FALSE),silent=TRUE)
      
      ##save(tune_scda,file="tune_scda.Rda")
      
      if(is(tune_scda,"try-error")){
        
        #t1<-new("list")
        #t1<-as.list(rep(0.5,nrow(fiveCV10iter@learnmatrix)))
        #  tune_scda<-new("tuningresult",tuneres=t1,method="scDA")
        
        
      }
      
      set.seed(seedvalue)
      tune_svm <- CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, grids = list( ), kernel = "radial",trace=FALSE)
      
      ##save(tune_svm,file="tune_svm.Rda")
      set.seed(seedvalue)
      #  tune_plr <- CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = plrCMA, grids = list( ), trace=FALSE)
      
      
      set.seed(seedvalue)
      
      #if(FALSE)
      {
        if(dim(X)[2]>100){
          tune_nnet <- CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA, trace=FALSE) #grids = list(size=1:5,decay=c(0,0.0001,0.001,0.005, 0.01,0.05, 0.1)), trace=FALSE)
        }else{
          tune_nnet <- CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA, trace=FALSE) # grids = list(size=1:5,decay=c(0,0.0001,0.001,0.005, 0.01,0.05, 0.1)), trace=FALSE)
          
        }
        
        ##save(tune_nnet,file="tune_nnet.Rda")
      }
      
      # ##save(X,Y,fiveCV10iter,nnetCMA,tune_nnet,learnmatrix,file="Debug.rda")
      
      set.seed(seedvalue)
      class_nnet<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE,tuneres=tune_nnet)
      
      
      
      #  set.seed(seedvalue)
      #tune_rf <- CMA::tune(X = X, y = Y, learningsets = fiveCV10iter, classifier = rfCMA, grids = list( ), trace=FALSE)
      
      if(length(good_feats_index)>2){
        set.seed(seedvalue)
        class_plslda <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA, tuneres = tune_plslda,trace=FALSE)
        set.seed(seedvalue)
        class_plsrf <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA, tuneres = tune_plsrf,trace=FALSE)
      }
      
      set.seed(seedvalue)
      
      if(is(tune_scda,"try-error")){
        
        class_scda <- NA
      }else{
        class_scda <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA, tuneres = tune_scda,trace=FALSE)
      }
      
      
      set.seed(seedvalue)
      class_svm <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres = tune_svm,kernel = "radial",trace=FALSE,probability=TRUE)
    }else{
      
      print("Building classification model using training set without tuning")
      if(length(good_feats_index)>2){
        set.seed(seedvalue)
        class_plslda <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA, trace=FALSE)
        set.seed(seedvalue)
        class_plsrf <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA, trace=FALSE)
      }
      
      set.seed(seedvalue)
      class_scda <- try(classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA, trace=FALSE),silent=TRUE)
      
      if(is(class_scda,"try-error")){
        
        class_scda <- NA
        
      }
      
      
      set.seed(seedvalue)
      class_svm <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, kernel = "radial",trace=FALSE,probability=TRUE)
      
      set.seed(seedvalue)
      class_nnet<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE)
    }
    
    
    
    set.seed(seedvalue)
    class_rf <- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = rfCMA,trace=FALSE) #tuneres = tune_rf,
    #size=3,decay=0.1) #
    set.seed(seedvalue)
    class_plslr<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = plrCMA,trace=FALSE) #tuneres=tune_plr,
    if(length(good_feats_index)>2){ 
      ##save(class_plslda,file="class_plslda.Rda")
      
      ##save(class_plsrf,file="class_plsrf.Rda")
    }
    ##save(class_scda,file="class_scda.Rda")
    ##save(class_svm,file="class_svm.Rda")
    ##save(class_rf,file="class_rf.Rda")
    ##save(class_nnet,file="class_nnet.Rda")
    ##save(class_plr,file="class_plr.Rda")
    
    
    
    if(length(class_levels)==2){
      
      
      eval_measure="auc"
      
      
    }else{
      
      eval_measure="misclassification"
    }
    
    
    
    
    if(length(good_feats_index)>=2){
      
      
      
      
      
      if(is.na(class_scda)==FALSE){
        
        
        eval_scda<-try(evaluation(class_scda,measure=eval_measure),silent=TRUE)
        if(is(eval_scda,"try-error")){
          
          eval_scda<-NA
          class_scda<-NA
          
        }
        
      }else{
        eval_scda<-NA
        class_scda<-NA
      }
      
      
      ###save(class_scda,eval_scda,class_svm,class_rf,class_nnet,class_plr,eval_measure,X,Y,fiveCV10iter,file="scda_debug1.Rda")
      
      eval_svm<-try(evaluation(class_svm,measure=eval_measure),silent=TRUE)
      eval_rf<-try(evaluation(class_rf,measure=eval_measure),silent=TRUE)
      eval_nnet<-try(evaluation(class_nnet,measure=eval_measure),silent=TRUE)
      eval_plr<-evaluation(class_plr,measure=eval_measure)
      
      if(is(eval_nnet,"try-error")){
        
        eval_nnet<-new("evaloutput",score=1)
        
        
      }
      
      if(is(eval_rf,"try-error")){
        
        eval_rf<-new("evaloutput",score=1)
        
        
      }
      if(is(eval_svm,"try-error")){
        
        eval_svm<-new("evaloutput",score=1)
        
        
      }
      
      if(is(eval_plr,"try-error")){
        
        eval_plr<-new("evaloutput",score=1)
        
        
      }
      
      
      
      
      if(length(good_feats_index)>2){
        eval_plslda<-evaluation(class_plslda,measure=eval_measure)
        eval_plsrf<-evaluation(class_plsrf,measure=eval_measure)
        
        
      }else{
        eval_plslda<-eval_svm
        eval_plsrf<-eval_svm
        eval_plslda@score<-(1)
        eval_plsrf@score<-(1)
      }
      
      if(eval_measure=="auc")
      {
        eval_plslda@score=1-mean(eval_plslda@score)
        eval_plsrf@score=1-mean(eval_plsrf@score)
        
        if(is.na(class_scda)==FALSE){
          eval_scda@score=1-mean(eval_scda@score)
        }else{
          
          eval_scda=eval_svm
          eval_scda@score=(1)
        }
        eval_svm@score=1-mean(eval_svm@score)
        eval_rf@score=1-mean(eval_rf@score)
        eval_nnet@score=1-mean(eval_nnet@score)
        eval_plr@score=1-mean(eval_plr@score)
        
      }
    }
    
    ####saveeval_svm,file="eval_svm.Rda")
    ####saveclass_svm,file="class_svm.Rda")
    
    
    text2<-paste(dim(v1)[2], " learning sets using training data",sep="")
    
    
  
      
      if(length(good_feats_index)>2){
        eval_mat1<-cbind(100*(1-mean(eval_plslda@score)),100*(1-mean(eval_plsrf@score)),
                         100*(1-mean(eval_scda@score)),100*(1-mean(eval_svm@score)),
                         100*(1-mean(eval_rf@score)),100*(1-mean(eval_nnet@score)),
                         100*(1-mean(eval_plr@score)))
      }else{
        if(is.na(class_scda)==FALSE){
          eval_scda@score=1-mean(eval_scda@score)
        }else{
          
          eval_scda=eval_svm
          eval_scda@score=(1)
        }
        eval_mat1<-cbind(100*(1-1),100*(1-1),100*(1-mean(eval_scda@score)),100*(1-mean(eval_svm@score)),100*(1-mean(eval_rf@score)),100*(1-mean(eval_nnet@score)),100*(1-mean(eval_plr@score)))
        
      }
      
      best_classifier<-which(eval_mat1==max(eval_mat1)[1])
      
      classifier_names<-c("PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR")
      
      best_classifier_name<-classifier_names[best_classifier]
      
      best_innerkfold_acc<-max(eval_mat1)[1]
      
      eval_mat_1<-round(eval_mat1,2)
      eval_mat1<-cbind(text2,eval_mat_1)
      
      colnames(eval_mat1)<-c("Dataset","PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR")
      
    
    
    if(output.device.type!="pdf"){
      
      temp_filename_1<-"Figures/Barplot_classifier_comparison_CVaccuracy.png"
      
      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
    }
    
    
    w <- 0.1 #grconvertX(l$rect$w, to='ndc') - grconvertX(0, to='ndc')
    par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
    barplot(eval_mat_1,beside=TRUE,main="Comparison of CV accuracy using different classifiers\n based on learning sets",
            xlab="Classifier",ylab="kfold classification accuracy(%)",col=barplot.col.opt[1],type="p",ylim=c(0,100),xpd=FALSE,cex.axis=0.7,cex.names=0.7)
    
    
    
    if(output.device.type!="pdf"){
      
      try(dev.off(),silent=TRUE)
    }
    
    if(length(check_name1)>0){
      mzrt_1<-good_feats[,1]
    }else{
      mzrt_1<-paste(round(good_feats[,1],5),round(good_feats[,2],1),sep="_")
      
    }
    rownames(good_feats)<-mzrt_1
    
    
    Y1<-cbind(sampnames,as.character(Y))
    Y1<-as.data.frame(Y1)
    
    if(length(good_feats_index)>=3){
      
      if(output.device.type!="pdf"){
        
        temp_filename_1<-"Figures/HCA_selectedfeats.png"
        
        png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      }
      
      good_feats<-as.data.frame(good_feats)
      
      if(FALSE){
        if(length(check_name1)>0){
          
          cnames1<-colnames(good_feats)
          cnames1[1]<-c("Name")
          colnames(good_feats)<-cnames1
          
          good_feats[,-c(1)]<-apply(good_feats[,-c(1)],2,as.numeric)
          
        }else{
          
          cnames1<-colnames(good_feats)
          cnames1[1]<-c("Name")
          colnames(good_feats)<-cnames1
          good_feats[,-c(1:2)]<-apply(good_feats[,-c(1:2)],2,as.numeric)
        }
        
      }
      
      
      
      
      try(get_hca(parentoutput_dir=outloc,X=good_feats,Y=Y1,heatmap.col.opt=heatmap.col.opt,cor.method="spearman",is.data.znorm=FALSE,analysismode="classification",
                  sample.col.opt="rainbow",plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3, hca_type=hca_type,
                  newdevice=FALSE,
                  labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots),silent=TRUE)
      
      
      
      if(output.device.type!="pdf"){
        
        try(dev.off(),silent=TRUE)
      }
      
      
      if(output.device.type!="pdf"){
        
        temp_filename_1<-"Figures/PCAplots_selectedfeats.pdf"
        
        #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
        #pdf(temp_filename_1)
        
        pdf(temp_filename_1,width=plots.width,height=plots.height)
      }
      
      
    }
    
    
    if(output.device.type!="pdf"){
      
      try(dev.off(),silent=TRUE)
    }
    
    
    if(output.device.type!="pdf"){
      
      temp_filename_1<-"Figures/Boxplots_selectedfeats.pdf"
      
      #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      #pdf(temp_filename_1)
      pdf(temp_filename_1,width=plots.width,height=plots.height)
    }
    
    
    
    
    
    par(mfrow=c(1,1),family="sans",cex=cex.plots)
    get_boxplots(X=good_feats,Y=Y1,parentoutput_dir=outloc,boxplot.col.opt=boxplot.col.opt,
                 sample.col.opt=sample.col.opt,
                 newdevice=FALSE,cex.plots=cex.plots,
                 ylabel=ylabel,add.pvalues=add.pvalues,add.jitter=add.jitter,
                 boxplot.type=boxplot.type,study.design=analysistype,
                 multiple.figures.perpanel=multiple.figures.perpanel,
                 alphacol = alpha.col,ggplot.type1=ggplot.type1,facet.nrow=facet.nrow)
    
    
    
    
    
    if(output.device.type!="pdf"){
      
      try(dev.off(),silent=TRUE)
    }
    
    num_levels<-levels(as.factor(Y))
    
    
    
    
    #if(is.na(Xtest)==FALSE)
    {
      
      
      
      best_kfold_acc<-best_innerkfold_acc
      #outerkfold_acc<-100*(1-mean(testeval_res@score))
      
      permkfold_acc<-{}
      permkfold_acc1<-{}
      
      permkfold_acc2<-{}
      
      permkfold_acc3<-{}
      
      permkfold_acc4<-{}
      
      permkfold_acc5<-{}
      
      permkfold_acc6<-{}
      
      permkfold_acc7<-{}
      Yorig<-Y
      
      text2B<-paste("Permuted ",dim(v1)[2], " learning sets using training data",sep="")
      #if(is.na(Xtest)==FALSE)
      
      nperm<-3
      seedvalue_rand_list<-runif(nperm,1,10000)
      #for(p1 in 1:nperm)
      eval_mat_perm<-lapply(1:nperm,function(p1)
      {
        seedvalue_cur=round(seedvalue_rand_list[p1],0)
        #set.seed(27611)
        set.seed(seedvalue_cur)
        Y<-Yorig[sample(1:length(Yorig),size=length(Yorig))]
        #set.seed(27611)
        set.seed(seedvalue_cur)
        suppressMessages(library(CMA))
        fiveCV10iter<-GenerateLearningsets(y=Y,method=learningsetmethod,fold=kfold,niter=1,strat=TRUE)
        
        classifier_names<-c("PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR") #,"PLSLR","pLRlasso","pLRelasticnet")
        
        
        if(length(good_feats_index)>=3){
          
          set.seed(seedvalue)
          class_plslda <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA,trace=FALSE) #,tuneres=tune_plslda
          testeval_res1<-evaluation(class_plslda,measure=eval_measure)
          
          set.seed(seedvalue)
          class_plsrf <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA,trace=FALSE) #,tuneres=tune_plsrf
          testeval_res2<-evaluation(class_plsrf,measure=eval_measure)
          
        }
        set.seed(seedvalue)
        
        
        if(is.na(class_scda)==FALSE){
          
          class_scda <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA,trace=FALSE) #,tuneres=tune_scda
          testeval_res3<-try(evaluation(class_scda,measure=eval_measure),silent=TRUE)
          
          if(is(testeval_res3,"try-error")){
            
            testeval_res3<-NA
          }
          
        }else{
          testeval_res3<-NA
        }
        
        
        set.seed(seedvalue)
        class_svm <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA,kernel = "radial",trace=FALSE,probability=TRUE) #,tuneres=tune_svm
        testeval_res4<-evaluation(class_svm,measure=eval_measure)
        
        set.seed(seedvalue)
        class_rf <- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = rfCMA,trace=FALSE) #,tuneres=tune_rf
        testeval_res5<-evaluation(class_rf,measure=eval_measure)
        
        set.seed(seedvalue)
        class_nnet<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE)
        #size=3,decay=0.1) #,tuneres=tune_nnet
        
        testeval_res6<-evaluation(class_nnet,measure=eval_measure)
        
        set.seed(seedvalue)
        class_plr<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = plrCMA,trace=FALSE) #,tuneres=tune_plr
        testeval_res7<-evaluation(class_plr,measure=eval_measure)
        
        
        if(eval_measure=="auc")
        {
          eval_plslda@score=1-mean(eval_plslda@score)
          eval_plsrf@score=1-mean(eval_plsrf@score)
          
          if(is.na(class_scda)==FALSE){
            eval_scda@score=1-mean(eval_scda@score)
          }
          eval_svm@score=1-mean(eval_svm@score)
          eval_rf@score=1-mean(eval_rf@score)
          eval_nnet@score=1-mean(eval_nnet@score)
          eval_plr@score=1-mean(eval_plr@score)
          
        }
        
        
        
        if(length(good_feats_index)>=3){
          permkfold_acc1<-c(permkfold_acc1,100*(1-mean(testeval_res1@score)))
          
          permkfold_acc2<-c(permkfold_acc2,100*(1-mean(testeval_res2@score)))
          
        }else{
          permkfold_acc1<-c(permkfold_acc1,0)
          permkfold_acc2<-c(permkfold_acc2,0)
          testeval_res1<-testeval_res4
          testeval_res2<-testeval_res4
          testeval_res1@score<-1
          testeval_res2@score<-1
        }
        
        if(is.na(class_scda)==FALSE){
          
          if(is.na(testeval_res3)==FALSE){
            
            permkfold_acc3<-100*(1-mean(testeval_res3@score))
          }else{
            
            permkfold_acc3<-(0)
          }
          
          
        }else{
          
          permkfold_acc3<-(0)
        }
        
        permkfold_acc4<-c(permkfold_acc4,100*(1-mean(testeval_res4@score)))
        
        permkfold_acc5<-c(permkfold_acc5,100*(1-mean(testeval_res5@score)))
        
        permkfold_acc6<-c(permkfold_acc6,100*(1-mean(testeval_res6@score)))
        
        permkfold_acc7<-c(permkfold_acc7,100*(1-mean(testeval_res7@score)))
        
        temp_res<-c(100*(1-mean(testeval_res1@score)),100*(1-mean(testeval_res2@score)),permkfold_acc3,
                    100*(1-mean(testeval_res4@score)),100*(1-mean(testeval_res5@score)),100*(1-mean(testeval_res6@score)),
                    100*(1-mean(testeval_res7@score)))
        
        return(temp_res)
      })
      
      
      
      eval_mat_perm<-do.call(rbind,eval_mat_perm)
      eval_mat_perm<-apply(eval_mat_perm,2,mean)
      
      
      eval_mat_perm<-t(eval_mat_perm)
      eval_mat_perm<-round(eval_mat_perm,2)
      
      eval_mat_perm_final<-cbind(text2B,eval_mat_perm)
      
      
      colnames(eval_mat_perm_final)<-c("Dataset","PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR")
      
      eval_mat_actual<-as.data.frame(eval_mat_1)
      eval_mat_perm1<-as.data.frame(eval_mat_perm)
      eval_mat_perm1<-round(eval_mat_perm1,2)
      
      
      colnames(eval_mat_perm1)<-colnames(eval_mat_actual)
      emat1<-rbind(eval_mat_actual,eval_mat_perm1)
      
      emat1<-t(emat1)
      classifier_names<-c("PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR")
      
      rownames(emat1)<-classifier_names
      
      
      eval_mat_actual<-((emat1[,1]-emat1[,2])*0.5)+(0.5*(emat1[,1]))
      
      emat1<-cbind(emat1,eval_mat_actual)
      #[((Actual-Permuted)*0.5)+(0.5*Actual)]
      colnames(emat1)<-c("Actual.accuracy","Permuted.accuracy","Score")
      
      
      
      
      
      test_acc<-NA
      test_acc_mat<-{}
      Y<-Yorig
      if(is.na(Xtest)==FALSE){
        
        
        if(num_levels==2){
          if(split.train.test==TRUE){
            
            res<-get_classification.accuracy(kfold=kfold,featuretable=good_feats,classlabels=Y,classifier="logit",testfeaturetable=good_feats_test,testclasslabels=Ytest,errortype="BAR",kernelname=svm_kernel,svm.cost=svm.cost,svm.gamma=svm.gamma)
            
            
          }else{
            #get_roc(dataA=good_feats,classlabels=Y,classifier="svm",kname=svm_kernel,rocfeatlist=seq(2,10,1),rocfeatincrement=TRUE,testset=X,testclasslabels=Y,mainlabel="Using training set based on SVM")
            
            #get_roc(dataA=good_feats,classlabels=Y,classifier="svm",kname=svm_kernel,rocfeatlist=c(dim(good_feats)[2]),rocfeatincrement=FALSE,testset=good_feats_test,testclasslabels=Ytest,mainlabel="Test set")
            
            res<-get_classification.accuracy(kfold=kfold,featuretable=good_feats,classlabels=Y,classifier="logit",testfeaturetable=good_feats_test,testclasslabels=Ytest,errortype="BAR",kernelname=svm_kernel,svm.cost=svm.cost,svm.gamma=svm.gamma)
            
            
          }
        }
        
        test_acc_mat<-{}
        class_levels_vec<-levels(as.factor(Y))
        
        
        learnmatrix <- matrix(seq(1,nrow(X)), nrow = 1)
        fiveCV10iter<-new("learningsets", learnmatrix = learnmatrix, method = "none",ntrain = ncol(learnmatrix), iter = nrow(learnmatrix))
        X<-rbind(X,Xtest)
        Y<-c(Y,Ytest)
        classifier_names<-c("PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR","H2O.deeplearning","PLSLR","pLRlasso","pLRelasticnet")
        
        result_cma_list<-new("list")
        
        ##save(fiveCV10iter,X,Y,learnmatrix,file="debug1.Rda")
        ###savelist=ls(),file="debug3.Rda")
        
        confusion_matrix_list<-new("list")
        
        if(length(good_feats_index)>2)
        {
          
          if(tune_classifiers==TRUE){
            s1<-ldply(tune_plslda@tuneres,rbind)
            
            s2<-apply(s1,2,median)
            
            
            t1<-new("list")
            confusion_matrix_list<-new("list")
            t1[[1]]<-s2
            tune_plslda1<-tune_plslda
            tune_plslda1@tuneres<-t1
            
            set.seed(seedvalue)
            class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA, tuneres = tune_plslda1,trace=FALSE)
            
            b1<-best(tune_plslda1)
            
            
            
            learnmatrix<-as.numeric(learnmatrix)
            
            set.seed(seedvalue)
            class_res2<-pls_ldaCMA(X = X, y = Y, learnind = learnmatrix, comp = median(unlist(b1)))
            
            
          }else{
            
            set.seed(seedvalue)
            class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA, trace=FALSE)
            learnmatrix<-as.numeric(learnmatrix)
            
            set.seed(seedvalue)
            class_res2<-pls_ldaCMA(X = X, y = Y, learnind = learnmatrix)
            
            
          }
          ##saveclass_res2,file="pls_ldaCMA.Rda")
          result_cma_list[[1]]<-class_res2
          
          ###saveconfusion_matrix_1,file="confusion_matrix_plslda.Rda")
          confusion_matrix_list[[1]]<-table(class_res2@y,class_res2@yhat)
          
          #debughere
          if(length(class_levels_vec)==2){
            testeval_res_auc<-evaluation(class_res,measure = "auc")
            ###savetesteval_res_auc,file="testeval_res_auc.Rda")
            
            test_auc<-100*(mean(testeval_res_auc@score))
            test_acc_mat<-c(test_acc_mat,test_auc)
            
          }else{
            
            test_acc<-evaluation(class_res)
            
            test_acc<-100*(1-mean(testeval_res_auc@score))
            test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
            
            
          }
          
          
          
          
          #if(best_classifier_name==classifier_names[2]){
          
          if(tune_classifiers==TRUE){
            s1<-ldply(tune_plsrf@tuneres,rbind)
            s2<-apply(s1,2,median)
            t1<-new("list")
            t1[[1]]<-s2
            
            tune_plsrf1<-tune_plsrf
            tune_plsrf1@tuneres<-t1
            set.seed(seedvalue)
            class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA, tuneres = tune_plsrf1,trace=FALSE)
            
            b1<-best(tune_plsrf1)
            # ###saveb1,file="b1_pls_rfCMA.Rda")
            
            learnmatrix<-as.numeric(learnmatrix)
            
            set.seed(seedvalue)
            class_res2<-pls_rfCMA(X = X, y = Y, learnind = learnmatrix, comp = median(unlist(b1)))
          }else{
            set.seed(seedvalue)
            class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA, trace=FALSE)
            learnmatrix<-as.numeric(learnmatrix)
            
            set.seed(seedvalue)
            class_res2<-pls_rfCMA(X = X, y = Y, learnind = learnmatrix)
            
            
          }
          
          ##saveclass_res2,file="pls_rfCMA.Rda")
          result_cma_list[[2]]<-class_res2
          #confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
          ###saveconfusion_matrix_1,file="confusion_matrix_rfCMA.Rda")
          
          confusion_matrix_list[[2]]<-table(class_res2@y,class_res2@yhat)
          
          if(length(class_levels_vec)==2){
            testeval_res_auc<-evaluation(class_res,measure = "auc")
            ###savetesteval_res_auc,file="testeval_res_auc.Rda")
            
            test_auc<-100*(mean(testeval_res_auc@score))
            test_acc_mat<-c(test_acc_mat,test_auc)
            
          }else{
            
            test_acc<-evaluation(class_res)
            
            test_acc<-100*(1-mean(testeval_res_auc@score))
            test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
            
            
          }
          
          
          
          if(tune_classifiers==TRUE){
            
            s1<-ldply(tune_scda@tuneres,rbind)
            s2<-apply(s1,2,median)
            
            t1<-new("list")
            t1[[1]]<-s2
            
            tune_scda1<-tune_scda
            tune_scda1@tuneres<-t1
            
            #tune_scda<-new("tuningresult",tuneres=t1)
            
            set.seed(seedvalue)
            class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA, tuneres = tune_scda1,trace=FALSE)
            #scdaCMA(X, y, f, learnind, delta = 0.5, models=FALSE,...)
            
            b1<-best(tune_scda1)
            
            
            learnmatrix<-as.numeric(learnmatrix)
            set.seed(seedvalue)
            class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix, delta = median(unlist(b1)))
            
          }else{
            
            if(is.na(class_scda)==FALSE){
              set.seed(seedvalue)
              class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA,trace=FALSE)
              set.seed(seedvalue)
              class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix)
              
            }
          }
          
          if(is.na(class_scda)==FALSE){
            
            ##saveclass_res2,file="scdaCMA.Rda")
            result_cma_list[[3]]<-class_res2
            #confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_scdaCMA.Rda")
            confusion_matrix_list[[3]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ###savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_auc)
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
          }else{
            result_cma_list[[3]]<-NA
            confusion_matrix_list[[3]]<-NA
            test_acc_mat<-c(test_acc_mat,0)
            
          }
          
          
          
          #if(best_classifier_name==classifier_names[4])
          {
            
            if(tune_classifiers==TRUE){
              s1<-ldply(tune_svm@tuneres,rbind)
              
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              tune_svm1<-tune_svm
              tune_svm1@tuneres<-t1
              
              b1<-best(tune_svm1)
              
              set.seed(seedvalue)
              class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres=tune_svm1, kernel ="radial",trace=FALSE,probability=TRUE)
              
              ##save(b1,file="b1.Rda")
              
              
              b2=unlist(unlist(b1))
              
              learnmatrix<-as.numeric(learnmatrix)
              
              set.seed(seedvalue)
              
              
              class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE,cost=median(b2[seq(1,length(b2),2)]),gamma=median(b2[seq(2,length(b2),2)])) #,gamma=gamma_1,cost=cost_1)
              
              
              
            }else{
              
              set.seed(seedvalue)
              class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, kernel ="radial",trace=FALSE,probability=TRUE)
              set.seed(seedvalue)
              class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE)
              
            }
            
            ##saveclass_res2,file="svmCMA.Rda")
            result_cma_list[[4]]<-class_res2
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_svmCMA.Rda")
            confusion_matrix_list[[4]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ###savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_auc)
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
            
          }
          
          #if(best_classifier_name==classifier_names[5])
          {
            
            if(FALSE){
              s1<-ldply(tune_rf@tuneres,rbind)
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              
              tune_rf1<-tune_rf
              tune_rf1@tuneres<-t1
            }
            
            set.seed(seedvalue)
            class_res <- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = rfCMA,trace=FALSE) #,tuneres=tune_rf1
            
            learnmatrix<-as.numeric(learnmatrix)
            
            
            set.seed(seedvalue)
            class_res2 <- rfCMA(X =X, y = Y, learnind=learnmatrix, varimp = FALSE) #mtry=tune_rf1$mtry,nodesize=tune_rf1$nodesize
            
            ##saveclass_res2,file="rfCMA.Rda")
            result_cma_list[[5]]<-class_res2
            
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_rfCMA.Rda")
            confusion_matrix_list[[5]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ###savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_auc)
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
            
          }
          
          #if(best_classifier_name==classifier_names[6])
          {
            
            if(tune_classifiers==TRUE){
              
              
              s1<-ldply(tune_nnet@tuneres,rbind)
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              
              tune_nnet1<-tune_nnet
              tune_nnet1@tuneres<-t1
              
              
              b1<-best(tune_nnet1)
              b2=unlist(unlist(b1))
              
              
              size_val=b1[[1]]$size
              decay_val=b1[[1]]$decay
              
              ##save(b1,file="b1.Rda")
              
              set.seed(seedvalue)
              class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE,tuneres=tune_nnet1) #size=3,decay=0.1) #,
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              
              set.seed(seedvalue)
              #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
              class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix),size=median(b2[seq(1,length(b2),2)]),decay=median(b2[seq(2,length(b2),2)])) #size=size_val,decay=decay_val)
              
            }else{
              
              set.seed(seedvalue)
              class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE) #size=3,decay=0.1) #,
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              
              set.seed(seedvalue)
              #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
              class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix)) #size=3,decay=0.1) #
            }
            
            ##saveclass_res2,file="nnetCMA.Rda")
            result_cma_list[[6]]<-class_res2
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_nnetCMA.Rda")
            confusion_matrix_list[[6]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ###savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_auc)
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
            
          }
          
          #if(best_classifier_name==classifier_names[7])
          {
            
            if(FALSE){
              s1<-ldply(tune_plr@tuneres,rbind)
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              
              tune_plr1<-tune_plr
              tune_plr1@tuneres<-t1
              
              
              b1<-best(tune_plr1)
            }
            
            set.seed(seedvalue)
            class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = plrCMA,trace=FALSE) #,tuneres=tune_plr
            
            set.seed(seedvalue)
            class_res2 <- plrCMA(X =X, y = Y, learnind=learnmatrix)
            
            ##saveclass_res2,file="plrCMA.Rda")
            result_cma_list[[7]]<-class_res2
            
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_plrCMA.Rda")
            confusion_matrix_list[[7]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ###savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_auc)
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(testeval_res_auc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
            
            
            
          }
          ##save(result_cma_list,confusion_matrix_list,test_acc_mat,file="test_acc_mat.Rda")
          
          h2o_res<-NA
          
          #h2o
          if(deeplearning==TRUE){
            #      #save(X,Y,learnmatrix,fiveCV10iter,file="h2o.Rda")
            
            
            #loss="CrossEntropy",
            
            require(h2o)
            try(h2o.removeAll(),silent=TRUE)
            
            localH2O = h2o.init(ip = "localhost", port = 54321, startH2O = TRUE, max_mem_size='2g',nthreads=1)
            
            
            train_hex_split<-new("list")
            if(length(learnmatrix)<1000){
              set.seed(555)
              
              learnmatrixa<-learnmatrix[sample(1:length(learnmatrix),size=1000,replace=TRUE)]
            }else{
              learnmatrixa<-learnmatrix
              
            }
            
            stopping_metric="AUC" #logloss
            # stopping_metric="logloss"
            
            # learnmatrixa<-learnmatrix
            
            print("length of learnmatrix")
            print(length(learnmatrix))
            
            train_hex_split<-new("list")
            
            Class<-Y[learnmatrix]
            train_hex_split[[1]]<-cbind(X[learnmatrix,],Class)
            
            
            train_hex_split[[1]]<-as.data.frame(train_hex_split[[1]])
            train_hex_split[[1]]$Class<-as.factor(train_hex_split[[1]]$Class)
            
            
            if(FALSE)
            {
              learnmatrix_1<-learnmatrixa[1:(length(learnmatrixa)*0.7)]
              learnmatrix_2<-learnmatrixa[(length(learnmatrixa)*0.7+1):(length(learnmatrixa))]
              
              Class<-Y[learnmatrix_1]
              train_hex_split[[1]]<-cbind(X[learnmatrix_1,],Class)
              Class<-Y[learnmatrix_2]
              train_hex_split[[2]]<-cbind(X[learnmatrix_2,],Class)
              
              
              train_hex_split[[1]]<-as.data.frame(train_hex_split[[1]])
              train_hex_split[[1]]$Class<-as.factor(train_hex_split[[1]]$Class)
              train_hex_split[[2]]<-as.data.frame(train_hex_split[[2]])
              train_hex_split[[2]]$Class<-as.factor(train_hex_split[[2]]$Class)
            }
            
            hyper_params <- list(
              activation=c("Rectifier","Tanh","Maxout","RectifierWithDropout","TanhWithDropout","MaxoutWithDropout"),
              hidden=list(c(20,20),c(50,50),c(30,30,30),c(25,25,25,25),c(64,64,64),c(128,128),c(128,128,128),rep(128,5),c(100,100,100),c(16,32,64,128,256)),
              input_dropout_ratio=c(0,0.01,0.05),
              l1=seq(0,1e-2,1e-4),
              l2=seq(0,1e-2,1e-4),
              epochs=c(1,5,10),
              rho=c(0.9,0.95,0.99,0.999),
              epsilon=c(1e-10,1e-8,1e-6,1e-4)
            )
            
            
            ## Stop once the top 5 models are within 1% of each other (i.e., the windowed average varies less than 1%)
            search_criteria = list(strategy = "RandomDiscrete", max_runtime_secs = 360, max_models = 100, seed=1234567, stopping_rounds=2, stopping_tolerance=1e-2)
            
            #   set.seed(999)
            dl_random_grid <- h2o.grid(
              algorithm="deeplearning",
              nfolds=10,
              grid_id = "dl_grid_random",
              training_frame=as.h2o(train_hex_split[[1]]),
              validation_frame=as.h2o(train_hex_split[[1]]),
              x=1:(ncol(train_hex_split[[1]])-1),
              y="Class",
              stopping_metric=stopping_metric,reproducible=T,
              
              score_validation_samples=100, ## downsample validation set for faster scoring
              score_duty_cycle=0.025,         ## don't score more than 2.5% of the wall time
              max_w2=10,                      ## can help improve stability for Rectifier
              hyper_params = hyper_params,
              search_criteria = search_criteria
              
            )
            
            if(stopping_metric=="AUC"){ #
              grid <- h2o.getGrid("dl_grid_random",sort_by="AUC",decreasing=TRUE)
            }else{
              
              if(stopping_metric=="logloss"){
                #grid <- h2o.getGrid("dl_grid_random",sort_by="mean_per_class_error",decreasing=FALSE)
                
                grid <- h2o.getGrid("dl_grid_random",sort_by="logloss",decreasing=FALSE)
              }
            }
            #h2o.removeAll()
            
            #grid@summary_table[1,]
            best_model <- h2o.getModel(grid@model_ids[[1]]) ## model with lowest logloss
            
            
            
            train_hex_split<-new("list")
            
            Class<-Y[learnmatrix]
            train_hex_split[[1]]<-cbind(X[learnmatrix,],Class)
            Class<-Y[-learnmatrix]
            train_hex_split[[2]]<-cbind(X[-learnmatrix,],Class)
            
            
            train_hex_split[[1]]<-as.data.frame(train_hex_split[[1]])
            train_hex_split[[1]]$Class<-as.factor(train_hex_split[[1]]$Class)
            train_hex_split[[2]]<-as.data.frame(train_hex_split[[2]])
            train_hex_split[[2]]$Class<-as.factor(train_hex_split[[2]]$Class)
            
            
            amd.dl <- h2o.deeplearning(x=1:(ncol(train_hex_split[[1]])-1),y = "Class", seed=1234567, training_frame = as.h2o(train_hex_split[[1]]), activation=best_model@parameters$activation, epoch=best_model@parameters$epochs, l1=best_model@parameters$l1,l2=best_model@parameters$l2,rho = best_model@parameters$rho,epsilon = best_model@parameters$epsilon,
                                       nfolds=10,balance_classes=TRUE,hidden = best_model@parameters$hidden,input_dropout_ratio=best_model@parameters$input_dropout_ratio,
                                       stopping_metric=stopping_metric,validation_frame=as.h2o(train_hex_split[[2]][,1:(ncol(train_hex_split[[2]]))]),reproducible=T)
            
            #  amd.dl2 <- h2o.deeplearning(x=1:(ncol(train_hex_split[[1]])-1),y = "Class", seed=1234567, training_frame = as.h2o(train_hex_split[[1]]))
            #   amd.dl3 <- h2o.deeplearning(x=1:(ncol(train_hex_split[[1]])-1),y = "Class", seed=1234567, training_frame = as.h2o(train_hex_split[[1]]))
            
            
            predictions <- h2o.predict(amd.dl, as.h2o(train_hex_split[[2]][,1:(ncol(train_hex_split[[2]])-1)]))
            
            p1<-(predictions$predict)
            #  t1<-table(p1,as.vector(train_hex_split[[2]]$Class))
            
            predfit<-as.numeric(as.character(p1))
            
            if(FALSE){
              pred_acc<-multiclass.roc(testclass,as.numeric(predfit),levels=levels(as.factor(testclass)))
              
              pred_acc<-round(pred_acc$auc[1],2)
              
              test_auc<-100*(pred_acc)
              
              test_acc_mat<-c(test_acc_mat,test_auc)
            }
            
            
            h2o_res<-h2o.auc(amd.dl,train=TRUE,valid=TRUE,xval=TRUE)
            
            
            h2o_results<-list("res"=amd.dl,"pred"=predfit)
            
            ##save(amd.dl,h2o_res,file="h2o_res.Rda")
            
            if(is.na(test_data_check)==TRUE){
              h2o_res<-c(100*h2o_res[3],NA,NA,100*h2o_res[1])
              
            }else{
              h2o_res<-c(100*h2o_res[3],NA,NA,100*h2o_res[2])
            }
            
            # pred1 <- ROCR::prediction(as.vector(predfit), (train_hex_split[[2]]$Class))
            #p1<-performance(pred1,"auc")
            #p1=round(p1@y.values[[1]],2)
            
            ###save(amd.dl,predictions,train_hex_split,file="h2ores.Rda")
            
            try(h2o.shutdown(prompt=F),silent=FALSE)
            
          }
          
          
          
          if(length(class_levels_vec)==2){
            
            
            
            acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
            acc_mat<-rbind(acc_mat,h2o_res)
            
            
            if(is.na(test_data_check)==TRUE){
              
              colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Training accuracy(AUC)")
              
              print("Training set evaluation using selected features and the best classifier based on AUC measure")
            }else{ 
              colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Test accuracy(AUC)")
              
              print("Test set evaluation using selected features and the best classifier based on AUC measure")
            }
            
            
            
            
            #rownames(acc_mat)<-best_classifier_name[1]
            
            write.table(acc_mat,file="Classification_evaluation_results_AUC.txt",sep="\t")
            
            
          }else{
            
            acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
            
            
            if(is.na(test_data_check)==TRUE){
              
              colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Training accuracy (Misclassification)")
              print("Training set evaluation using selected features and the best classifier based on misclassification rate measure")
              
            }else{             	
              colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Test accuracy (Misclassification)")
              print("Test set evaluation using selected features and the best classifier based on misclassification rate measure")
            }
            
            print(acc_mat[,c(1,4)])
            
            #rownames(acc_mat)<-best_classifier_name[1]
            
            write.table(acc_mat,file="Classification_evaluation_results_misclassification.txt",sep="\t")
            
          }
          
          ###save(acc_mat,file="acc_mat.Rda")
          
          
          acc_mat<-acc_mat[,-c(3)]
          
          
          mainlab<-paste("Performance evaluation using classifiers and selected features",sep="")
          
          if(output.device.type!="pdf"){
            
            temp_filename_1<-"Figures/Barplot_classification_accuracy.png"
            
            png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
          }
          
          
          
          acc_mat1<-t(acc_mat)
          #xaxt="n",
          #
          w <- 0.1
          par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
          if(length(class_levels_vec)==2){
            barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
          }else{
            
            barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
            
          }
          if(FALSE){
            if(length(class_levels_vec)==2){
              axis(side=1,at=seq(1,4),labels=c("kfold CV","Permuted kfold CV","Test set","AUC"),cex.axis=cex.plots)
            }else{
              axis(side=1,at=seq(1,3),labels=c("kfold CV","Permuted kfold CV","Test set"),cex.axis=cex.plots)
            }
          }
          
          
          
          if(is.na(test_data_check)==TRUE){
            le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("Training (kfold)","Training (overall)"), pch = rep(19,2), pt.cex = 0.6, title = "",cex=0.7,col=barplot.col.opt))
            
          }else{
            le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("Training (kfold)","Test"), pch = rep(19,2), pt.cex = 0.6, title = "",cex=0.7,col=barplot.col.opt))
          }
          
          if(output.device.type!="pdf"){
            
            try(dev.off(),silent=TRUE)
          }
          
          
          try(dev.off(),silent=TRUE)
          
        }else{
          
          test_acc_mat<-c(0,0)
          
          if(tune_classifiers==TRUE){
            
            s1<-ldply(tune_scda@tuneres,rbind)
            s2<-apply(s1,2,median)
            
            t1<-new("list")
            t1[[1]]<-s2
            
            tune_scda1<-tune_scda
            tune_scda1@tuneres<-t1
            
            #tune_scda<-new("tuningresult",tuneres=t1)
            
            set.seed(seedvalue)
            class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA, tuneres = tune_scda1,trace=FALSE)
            #scdaCMA(X, y, f, learnind, delta = 0.5, models=FALSE,...)
            
            b1<-best(tune_scda)
            
            
            learnmatrix<-as.numeric(learnmatrix)
            set.seed(seedvalue)
            class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix, delta = median(unlist(b1)))
            
          }else{
            
            if(is.na(class_scda)==FALSE){
              set.seed(seedvalue)
              class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA,trace=FALSE)
              set.seed(seedvalue)
              class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix)
              
            }
          }
          
          if(is.na(class_scda)==FALSE){
            
            ##saveclass_res2,file="scdaCMA.Rda")
            result_cma_list[[3]]<-class_res2
            #confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_scdaCMA.Rda")
            confusion_matrix_list[[3]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ###savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              
              test_auc<-100*(mean(testeval_res_auc@score))
              
              test_acc_mat<-c(test_acc_mat,test_auc)
              
              
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(test_acc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
          }else{
            result_cma_list[[3]]<-NA
            confusion_matrix_list[[3]]<-NA
            test_acc_mat<-c(test_acc_mat,0)
            
          }
          
          
          
          #if(best_classifier_name==classifier_names[4])
          {
            
            if(tune_classifiers==TRUE){
              s1<-ldply(tune_svm@tuneres,rbind)
              
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              
              
              tune_svm1<-tune_svm
              tune_svm1@tuneres<-t1
              
              b1<-best(tune_svm1)
              
              
              #class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres=tune_svm1, kernel ="radial",trace=FALSE,probability=TRUE)
              
              
              #                ##save(X,Y,learnmatrix,seedvalue,fiveCV10iter,tune_svm1,b1,svmCMA,file="svmdebug.Rda")
              set.seed(seedvalue)
              class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres=tune_svm1, kernel ="radial",trace=FALSE,probability=TRUE)
              
              
              cost_1=b1[[1]]$cost
              gamma_1=b1[[1]]$gamma
              
              b2=unlist(unlist(b1))
              
              learnmatrix<-as.numeric(learnmatrix)
              
              
              
              
              set.seed(seedvalue)
              #class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix, cost = cost_1,gamma=gamma_1,probability=TRUE)
              class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE,cost=median(b2[seq(1,length(b2),2)]),gamma=median(b2[seq(2,length(b2),2)]))
              
            }else{
              
              set.seed(seedvalue)
              class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, kernel ="radial",trace=FALSE,probability=TRUE)
              set.seed(seedvalue)
              class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE)
              
            }
            
            ##saveclass_res2,file="svmCMA.Rda")
            result_cma_list[[4]]<-class_res2
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_svmCMA.Rda")
            confusion_matrix_list[[4]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ####savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              
              test_acc_mat<-c(test_acc_mat,test_auc)
              
              
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(test_acc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
          }
          
          #if(best_classifier_name==classifier_names[5])
          {
            
            if(FALSE){
              s1<-ldply(tune_rf@tuneres,rbind)
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              
              tune_rf1<-tune_rf
              tune_rf1@tuneres<-t1
            }
            
            set.seed(seedvalue)
            class_res <- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = rfCMA,trace=FALSE) #,tuneres=tune_rf1
            
            learnmatrix<-as.numeric(learnmatrix)
            
            
            set.seed(seedvalue)
            class_res2 <- rfCMA(X =X, y = Y, learnind=learnmatrix, varimp = FALSE) #mtry=tune_rf1$mtry,nodesize=tune_rf1$nodesize
            
            ##saveclass_res2,file="rfCMA.Rda")
            result_cma_list[[5]]<-class_res2
            
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_rfCMA.Rda")
            confusion_matrix_list[[5]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ####savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              
              test_acc_mat<-c(test_acc_mat,test_auc)
              
              
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(test_acc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
          }
          
          #if(best_classifier_name==classifier_names[6])
          {
            
            if(tune_classifiers==TRUE){
              s1<-ldply(tune_nnet@tuneres,rbind)
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              
              tune_nnet1<-tune_nnet
              tune_nnet1@tuneres<-t1
              
              
              b1<-best(tune_nnet1)
              b2=unlist(unlist(b1))
              
              set.seed(seedvalue)
              class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE,tuneres=tune_nnet1) #size=3,decay=0.1) #
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              
              set.seed(seedvalue)
              #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
              class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix),size=median(b2[seq(1,length(b2),2)]),decay=median(b2[seq(2,length(b2),2)])) #size=3,decay=0.1)
              
            }else{
              
              set.seed(seedvalue)
              class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE) #size=3,decay=0.1) #
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              
              set.seed(seedvalue)
              #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
              class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix)) #size=3,decay=0.1)
              
              
            }
            
            ##saveclass_res2,file="nnetCMA.Rda")
            result_cma_list[[6]]<-class_res2
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_nnetCMA.Rda")
            confusion_matrix_list[[6]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ####savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              
              test_acc_mat<-c(test_acc_mat,test_auc)
              
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(test_acc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
          }
          
          #if(best_classifier_name==classifier_names[7])
          {
            
            if(FALSE){
              s1<-ldply(tune_plr@tuneres,rbind)
              s2<-apply(s1,2,median)
              
              t1<-new("list")
              t1[[1]]<-s2
              
              tune_plr1<-tune_plr
              tune_plr1@tuneres<-t1
              
              
              b1<-best(tune_plr1)
            }
            
            set.seed(seedvalue)
            class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = plrCMA,trace=FALSE) #,tuneres=tune_plr
            
            set.seed(seedvalue)
            class_res2 <- plrCMA(X =X, y = Y, learnind=learnmatrix)
            
            ##saveclass_res2,file="plrCMA.Rda")
            result_cma_list[[7]]<-class_res2
            
            confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
            
            ###saveconfusion_matrix_1,file="confusion_matrix_plrCMA.Rda")
            confusion_matrix_list[[7]]<-table(class_res2@y,class_res2@yhat)
            
            if(length(class_levels_vec)==2){
              
              testeval_res_auc<-evaluation(class_res,measure = "auc")
              ####savetesteval_res_auc,file="testeval_res_auc.Rda")
              
              test_auc<-100*(mean(testeval_res_auc@score))
              
              test_acc_mat<-c(test_acc_mat,test_auc)
              
              
              
            }else{
              
              test_acc<-evaluation(class_res)
              
              test_acc<-100*(1-mean(test_acc@score))
              test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
              
              
            }
            
          }
          
          
          if(length(class_levels_vec)==2){
            
            
            
            acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
            
            
            if(is.na(test_data_check)==TRUE){     
              colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Training accuracy(AUC)")
              
              print("Training set evaluation using selected features and the best classifier based on AUC measure")
            }else{
              colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Test accuracy(AUC)")
              
              print("Test set evaluation using selected features and the best classifier based on AUC measure")
              
            }
            
            
            ###save(acc_mat,file="acc_mat.Rda")
            #    print(acc_mat[,c(1,4)])
            
            #rownames(acc_mat)<-best_classifier_name[1]
            
            write.table(acc_mat,file="Classification_evaluation_results_AUC.txt",sep="\t")
            
            
          }else{
            
            acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
            
            if(is.na(test_data_check)==TRUE){ 
              colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Training accuracy (Misclassification)")
              
              print("Training set evaluation using selected features and the best classifier based on misclassification rate measure")
            }else{
              
              colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Test accuracy (Misclassification)")
              
              print("Test set evaluation using selected features and the best classifier based on misclassification rate measure")
              
              
            }
            
            print(acc_mat[,c(1,4)])
            
            #rownames(acc_mat)<-best_classifier_name[1]
            
            write.table(acc_mat,file="Classification_evaluation_results_misclassification.txt",sep="\t")
            
          }
          
          
          
          acc_mat<-acc_mat[,-c(3)]
          
          
          mainlab<-paste("Performance evaluation using classifiers and selected features",sep="")
          
          if(output.device.type!="pdf"){
            
            temp_filename_1<-"Figures/Barplot_classification_accuracy.png"
            
            png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
          }
          
          
          acc_mat1<-t(acc_mat)
          #xaxt="n",
          #
          w <- 0.1
          par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
          if(length(class_levels_vec)==2){
            barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
          }else{
            
            barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
            
          }
          if(FALSE){
            if(length(class_levels_vec)==2){
              axis(side=1,at=seq(1,4),labels=c("kfold CV","Permuted kfold CV","Test set","AUC"),cex.axis=cex.plots)
            }else{
              axis(side=1,at=seq(1,3),labels=c("kfold CV","Permuted kfold CV","Test set"),cex.axis=cex.plots)
            }
          }
          #col = col_vec[1:length(t1)],
          le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("Training (kfold)","Test"), pch = rep(19,2), pt.cex = 0.6, title = "",cex=0.7,col=barplot.col.opt))
          
          
          if(output.device.type!="pdf"){
            
            try(dev.off(),silent=TRUE)
          }
          
          
          try(dev.off(),silent=TRUE)
          print("number of features too small.")
        }
        
      }else{
        
        
        acc_mat<-acc_mat[,-c(3)]
        
        acc_mat1<-t(acc_mat)
        
        colnames(acc_mat)<-c("kfold CV accuracy","Permuted kfold CV accuracy")
        mainlab<-paste("Performance evaluation using ",best_classifier_name," classifier and selected features",sep="")
        
        if(output.device.type!="pdf"){
          
          temp_filename_1<-"Figures/Barplot_classification_accuracy.png"
          
          png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
        }
        
        
        w <- 0.1
        par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
        if(length(class_levels_vec)==2){
          barplot(acc_mat1,main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
        }else{
          
          barplot(acc_mat1,main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
          
        }
        
        # barplot(acc_mat,xaxt="n",main=mainlab,col=barplot.col.opt,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE)
        # axis(side=1,at=seq(1,2),labels=c("Best kfold CV","Permuted kfold CV"),cex.axis=cex.plots)
        
        le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("Training (kfold)","Training (permuted)"), pch = rep(19,2), pt.cex = 0.6, title = "",cex=0.7,col=barplot.col.opt))
        
        
        if(output.device.type!="pdf"){
          
          try(dev.off(),silent=TRUE)
        }
        
        
      }
      
      
      
      
    }
    
    
    try(dev.off(),silent=TRUE)
    
    eval_mat1<-rbind(eval_mat1,eval_mat_perm_final)
    
    
    
    
    #emat1
    write.table(emat1,file="Classifier_accuracy_comparison_training_set.txt",sep="\t",row.names=TRUE)
    
    confounder_eval=NA
    if(is.na(confounder.matrix)==FALSE){
      
      response_mat<-confounder.matrix[,-c(1)]
      confounder_eval<-try(runlmreg(X=good_feats,Y=response_mat,fdrmethod=confounderfdrmethod,fdrthresh=confounderfdrthresh),silent=TRUE)
    }
    
    parentoutput_dir=outloc
    setwd(parentoutput_dir)
    
    if(globalcor==TRUE){
      
      print("##############Level 2: Correlation network analysis selected features###########")
      print(paste("Generating metabolome-wide ",cor.method," correlation network",sep=""))
      data_m_fc_withfeats<-as.data.frame(Xorig)
      
      good_feats<-as.data.frame(good_feats)
      #print(goodfeats[1:4,])
      sigfeats_index<-which(data_m_fc_withfeats$mz%in%good_feats$mz)
      sigfeats<-sigfeats_index
      
      #outloc<-paste(parentoutput_dir,"/Allcornetworksigfeats","log2fcthresh",log2.fold.change.thresh,"/",sep="")
      outloc<-paste(parentoutput_dir,"/MWASresults","/",sep="")
      
      suppressWarnings(dir.create(outloc,showWarnings = FALSE))
      setwd(outloc)
      
      #cor.method="spearman",networktype="complete",abs.cor.thresh=0.4,cor.fdrthresh=0.05,max.cor.num=100,net_node_colors=c("green","red"), net_legend=TRUE
      
      if(networktype=="complete"){
        mwan_fdr<-do_cor(data_m_fc_withfeats,subindex=sigfeats_index,targetindex=NA,outloc,networkscope="global",cor.method,abs.cor.thresh,cor.fdrthresh,max.cor.num,net_node_colors,net_legend,cex.plots=cex.plots)
      }else{
        if(networktype=="GGM"){
          mwan_fdr<-get_partial_cornet(data_m_fc_withfeats, sigfeats.index=sigfeats_index,targeted.index=NA,networkscope="global",cor.method,
                                       abs.cor.thresh,cor.fdrthresh,outloc=outloc,net_node_colors,net_legend)
        }else{
          print("Invalid option. Please use complete or GGM.")
        }
      }
      
      print("##############Level 2: processing complete###########")
    }
    
    if(length(good_feats)>0){
      
      write.csv(good_feats,file="train_selected_data.csv",row.names=FALSE)
      try(write.csv(good_feats_test,file="test_selected_data.csv",row.names=FALSE),silent=TRUE)
      try(write.csv(confounder_eval,file="confounder_eval.csv",row.names=FALSE),silent=TRUE)
      
      write.csv(Ytrain_mat,file="train_classlabels_data.csv",row.names=FALSE)
      try(write.csv(Ytest_mat,file="test_classlabels_data.csv",row.names=FALSE),silent=TRUE)
    }
    
    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF","grey57")
    auc_vec<-{}
    classifier_names<-c("PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR")
    
    
    
    if(length(class_levels)==2){
      png("ROC_classifier_comparison.png",width=8,height=8,res=300,type="cairo",units="in")
      if(length(good_feats_index)>=3){
        start_ind=1
      }else{
        start_ind=3
      }
      for(i in start_ind:length(result_cma_list))
      {
        
        
        object=result_cma_list[[i]]
        
        
        
        roc1<-try(ROCinternal.panda(test = object@prob[,2], object@y,FALSE),silent=TRUE)
        
        if(is(roc1,"try-error")){
          
        }else{
          
          
          auc_vec<-c(auc_vec,round(roc1$auc,2))
          roc1=roc1$plotcoordinates
          
          
          if(i==start_ind){
            plot(roc1$x,roc1$y,col=col_vec[i],type="s",lty=i,lwd=2,xlab="1-specificity",ylab="Sensitivity",main="Receiver Operating Characteristic curve")
            lines(seq(0,1),seq(0,1),lwd=2)
          }else{
            
            lines(roc1$x,roc1$y,col=col_vec[i],type="s",lty=i,lwd=2)
          }
        }
        
        
      }
      
      legend('bottomright', paste(classifier_names,":",auc_vec,sep=""), col=col_vec[1:7], lty=1:7, cex=0.8, bty='n',lwd=rep(2,7))
      
      dev.off()
      
    }
    
    options(warn=0)
    #print(acc_mat)
    #bestcvacc=best_kfold_acc,permcvacc=permkfold_acc,testacc=test_acc,
    return(list(train.selected.data=good_feats,test.selected.data=good_feats_test,classifier.comparison=emat1,feature.selection.matrix=stability_matrix_1,best.performance.measures=acc_mat,train.class=Ytrain_mat,test.class=Ytest_mat,confounder.eval.res=confounder_eval,test.result.classifiers=result_cma_list,h2o_results=h2o_results))
    
  }
  
  
  
}





ROCinternal.panda <- function(test, resp, plot, ...)
{
  dotsCall <- substitute(list(...))
  ll <- eval(dotsCall)
  if(!hasArg(xlab)) ll$xlab <- "Threshold for assignment to class 1"
  if(!hasArg(ylab)) ll$ylab <- "specificity for class 0"
  if(!hasArg(main)) ll$main <- "Receiver Operator Characteristic"
  if(!hasArg(lwd)) ll$lwd <- 2
  m <- as.matrix(table(test, resp))
  fv <- as.numeric(row.names(m))
  nr <- dim(m)[1]
  a <- apply(m, 2, sum)
  m <- addmargins(m, 2)
  m <- apply(m[nr:1, ], 2, cumsum)[nr:1, ]
  sn <- c(m[, 2]/a[2], 0)
  sp <- c((a[1] - m[, 1])/a[1], 1)
  pvp <- c(m[, 2]/m[, 3], 1)
  pvn <- (a[1] - m[, 1])/(sum(a) - m[, 3])
  pvn <- c(pvn, rev(pvn)[1])
  res <- data.frame(cbind(sn, sp, pvp, pvn, c(NA, fv)))
  auc <- sum((res[-1, 1] +res[-nr, 1])/2 * diff(res[, 2]))
  #xl <- range(test)
  #ll$x <- xl
  #ll$y <- 0:1
  #ll$xlim <- xl
  #ll$ylim <- 0:1
  #ll$type <- "n"
  ll$x <- 1-res[,2]
  ll$y <- res[,1]
  ll$xlim <- 0:1
  ll$xlab <- "1-specificity"
  ll$ylim <- 0:1
  ll$ylab <- "Sensitivity"
  ll$type <- "n"
  if(plot){
    do.call("plot", args=ll)
    #plot(xl, 0:1, xlim = xl, xlab = paste(deparse(substitute(test)),
    #    "(grid at deciles)"), ylim = 0:1, ylab = " ",
    #    type = "n")
    
    #plot(1 - res[, 2], res[, 1], xlim = 0:1, xlab = "1-Specificity",
    #       ylim = 0:1, ylab = "Sensitivity", type = "n", ...)
    #   if (grid)
    #       abline(h = 0:10/10, v = 0:10/10, col = gray(0.9))
    #   abline(0, 1, col = gray(0.4))
    box()
    ll$type <- "l"
    do.call("lines", args = ll)
    
    
    #box()
    #ll$xlim <- NULL
    #ll$ylim <- NULL
    #ll$type <- "l"
    #ll$x <- fv
    #ll$y <- res[, 2]
    #ll$left <- TRUE
    #ll$order <- TRUE
    #do.call("steplines", args=ll)
    plot(function(x) x, from=0, to=1, lty="dashed", add=TRUE)
    text(0.8, 0.1, cex=2, label=paste("AUC=", round(auc,3), sep=""))
  }
  names(auc) <- "auc"
  return(list("plotcoordinates"=ll,"auc"=auc))
}

plotEigengeneNetworks_custom<-function (multiME, setLabels, letterSubPlots = FALSE, Letters = NULL,
                                        excludeGrey = TRUE, greyLabel = "grey", plotDendrograms = TRUE,
                                        plotHeatmaps = TRUE, setMargins = TRUE, marDendro = NULL,
                                        marHeatmap = NULL, colorLabels = TRUE, signed = TRUE, heatmapColors = NULL,
                                        plotAdjacency = TRUE, printAdjacency = FALSE, cex.adjacency = 0.8,
                                        coloredBarplot = TRUE, barplotMeans = TRUE, barplotErrors = FALSE,
                                        plotPreservation = "standard", zlimPreservation = c(0, 1),
                                        printPreservation = FALSE, cex.preservation = 0.8)
{
  size = checkSets(multiME, checkStructure = TRUE)
  if (!size$structureOK) {
    multiME = fixDataStructure(multiME)
  }
  if (is.null(Letters))
    Letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
  if (is.null(heatmapColors))
    if (signed) {
     # heatmapColors = greenWhiteRed(50)
    }
  else {
    #heatmapColors = topo.colors(30) #heat.colors(30)
  }
  heatmapColors = topo.colors(30)
  
  heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
  heatmap_cols<-rev(heatmap_cols)
  
  nSets = length(multiME)
  
  cex.before <- par("cex")
  cex = par("cex")
  mar = par("mar")
  nPlotCols = 1 #nSets
  nPlotRows = 1 #as.numeric(plotDendrograms) + nSets * as.numeric(plotHeatmaps)
  if (nPlotRows == 0)
    stop("Nothing to plot: neither dendrograms not heatmaps requested.")
 par(mfrow = c(nPlotRows, nPlotCols))
  par(cex = cex)
  if (excludeGrey)
    for (set in 1:nSets) multiME[[set]]$data = multiME[[set]]$data[,
                                                                   substring(names(multiME[[set]]$data), 3) != greyLabel]
  plotPresTypes = c("standard", "hyperbolic", "both","change","differences")
  ipp = pmatch(plotPreservation, plotPresTypes)
  if (is.na(ipp))
    stop(paste("Invalid 'plotPreservation'. Available choices are",
               paste(plotPresTypes, sep = ", ")))
  letter.ind = 1

#  save(multiME,nSets,setLabels,colorLabels,heatmap_cols,file="debugwgcna.rda")
  if (plotHeatmaps)
    for (i.row in (1:nSets)) for (i.col in (i.row:nSets)) {
      letter.ind = i.row * nSets + i.col
      if (letterSubPlots) {
        letter = paste(substring(Letters, first = letter.ind,
                                 last = letter.ind), ".  ", sep = "")
      }
      else {
        letter = NULL
      }
      par(cex = cex)
      if (setMargins) {
        if (is.null(marHeatmap)) {
          if (colorLabels) {
            par(mar = c(1, 2, 3, 4) + 0.2)
          }
          else {
            par(mar = c(6, 7, 3, 5) + 0.2)
          }
        }
        else {
          par(mar = marHeatmap)
        }
      }
      nModules = dim(multiME[[i.col]]$data)[2]
      textMat = NULL
      
     
      par(cex = 0.7)
      
    
      if (i.row == i.col) {
        corME = WGCNA::cor(multiME[[i.col]]$data, use = "p")
        pME = corPvalueFisher(corME, nrow(multiME[[i.col]]$data))
        if (printAdjacency) {
          textMat = paste(signif(corME, 2), "\n", signif(pME,1))
          dim(textMat) = dim(corME)
        }
        
        corrplot::corrplot(corME,col=heatmap_cols,cl.cex=0.8,tl.cex=0.45,title=setLabels[i.col],cl.offset=2,tl.offset=0.2,mar=c(1, 2, 4, 2) + 0.01)
      }
      else {
        corME1 = WGCNA::cor(multiME[[i.col]]$data, use = "p")
        corME2 = WGCNA::cor(multiME[[i.row]]$data, use = "p")
        cor.dif = (corME1 - corME2)/2
        
        corrplot::corrplot(cor.dif,col=heatmap_cols,cl.cex=0.9,tl.cex=0.45,title=paste("Delta correlation: ",setLabels[i.row], " vs ", setLabels[i.col],sep=""),
                           cl.offset=2,tl.offset=0.2,mar=c(1, 2, 4, 2) + 0.01)
        
     #   save(corME1,corME2,i.row,i.col,multiME,setLabels,file="debugbarplot.Rda")
        
        d = tanh((corME1 - corME2)/(abs(corME1) + abs(corME2))^2)
       
              dp = 1 - abs(cor.dif)
              method = "Preservation"
          
          diag(dp) = 0
          #write.table(dp,file="preservation_matrix.txt",sep="\t")
         
            sum_dp = mean(dp[upper.tri(dp)])
            means = apply(dp, 2, sum)/(ncol(dp) - 1)
            if (barplotErrors) {
              errors = sqrt((apply(dp^2, 2, sum)/(ncol(dp) -1) - means^2)/(ncol(dp) - 2))
            }
            else {
              errors = NULL
            }
            Dmatrix=cbind(names(multiME[[i.col]]$data),means)
            Dmatrix=as.data.frame(Dmatrix)
            colnames(Dmatrix)<-c("Module","meanPreservationScore")
            
            fname<-paste("Tables/mean_preservation_matrix_",i.row,"vs",i.col,".txt",sep="")
            write.table(Dmatrix,file=fname,sep="\t",row.names=FALSE)
            labeledBarplot(means, names(multiME[[i.col]]$data),
                           main = paste(method, " score for ",i.row," vs ", i.col, ":",signif(sum_dp,
                                                                                                      2)), ylim = c(0, 1), 
                           stdErrors = errors,cex.lab=cex.preservation,cex.main=cex.preservation)
            
                           #colorLabels = colorLabels,
               #            colored = coloredBarplot, setStdMargins = FALSE,
                          
          # barplot(as.numeric(as.character(Dmatrix$meanPreservationScore)),Dmatrix$Module,main = paste("Preservation score for ",setLabesl[i.row]," vs ", setLabels[i.col], ":",signif(sum_dp,2),sep=""),cex.main=0.7,ylim = c(0, 1))
       
        }
      
    }
  
  par(cex = cex.before)
}


degree_eval<-function(feature_table_file=NA,class_labels_file=NA,X=NA,Y=NA,sigfeats=NA,sigfeatsind=NA){
  
  
  suppressMessages(library(WGCNA))
  #print("degree eval")
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  }else{
    
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
  }else{
    
    classlabels<-Y
  }
  
  
  classlabels<-as.data.frame(classlabels)
  #print(dim(classlabels))
  # print(length(classlabels))
  
  
  if(dim(classlabels)[2]>2){
    classgroup<-paste(classlabels[,2],":",classlabels[,3],sep="") #classlabels[,2]:classlabels[,3]
  }else{
    
    classgroup<-classlabels[,2]
  }
  classlabels<-as.data.frame(classlabels)
  
  class_labels_levels<-levels(as.factor(classgroup))
  
  rnames<-paste(data_matrix$mz,data_matrix$time,sep="_") #sprintf("%.4f",
  
  data_matrix_orig<-data_matrix
  data_matrix<-data_matrix[,-c(1:2)]
  #data_matrix<-na.omit(data_matrix)
  
  rnamesAB<-gsub(pattern="NA_NA",replacement=NA,x=rnames)
  rnamesAB<-na.omit(rnamesAB)
  
  nSets = length(class_labels_levels);
  multiExpr = vector(mode = "list", length = nSets)
  data_matrix_list<-new("list")
  num_samps_groups<-new("list")
  degree_list<-new("list")
  
  data_matrix_all<-t(data_matrix)
  
  
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(data=data_matrix_all, dataIsExpr=TRUE,powerVector = powers, verbose = 0)
  power_val=sft$powerEstimate
  
  if(is.na(power_val)==TRUE){
    power_val=6
  }
  
  
  degree_overall<-softConnectivity(datExpr=data_matrix_all,power=power_val,minNSamples=10)
  degree_overall<-replace(degree_overall,which(degree_overall<0),0)
  
  
  sig_status<-rep(0,dim(data_matrix_orig)[1])
  
  colors_met<-cbind(data_matrix_orig[,c(1:2)],degree_overall,sig_status)
  
  colors_met<-as.data.frame(colors_met)
  
  colors_met$sig_status[sigfeatsind]=1
  
  colnames(colors_met)<-c("mz","time","degree_overall","sig_status")
  
  colnames_vec<-c("mz","time","degree_overall","sig_status")
  
  # print(sigfeats$mz)
  
  
  colors_met_all<-colors_met
  
  colors_met<-colors_met[order(colors_met$degree_overall,decreasing=TRUE),]
  
  sig_ind<-which(colors_met$sig_status==1)
  
  # print(summary(colors_met$degree_overall))
  
  #pdf("DICE_plots.pdf")
  
  names=paste(round(colors_met$mz,3),round(colors_met$time,0),sep="_")
  
  names=paste(round(colors_met$mz,4),sep="_")
  
  # print(names[sig_ind])
  
  if(FALSE)
  {
    plot(colors_met$degree_overall,cex=0.2,main="Overall degree distribution",ylab="Degree",xlab="Feature Index",col="orange",type="b",lwd=0.5)
    
    #for(i in 1:length(sig_ind)){
    lapply(1:length(sig_ind),function(i){
      points(y=colors_met$degree_overall[sig_ind[i]],x=sig_ind[i],col="darkgreen",cex=0.8,lwd=2)
      if(i%%2>0){
        text(y=colors_met$degree_overall[sig_ind[i]],x=sig_ind[i],names[sig_ind[i]],cex=0.31,adj=c(1,2))
      }else{
        text(y=colors_met$degree_overall[sig_ind[i]],x=sig_ind[i],names[sig_ind[i]],cex=0.31,adj=c(0,-1))
      }
      
    })
  }
  
  
  for(i in 1:length(class_labels_levels)){
    
    data_matrix_list[[i]]<-t(data_matrix[,which(classgroup==class_labels_levels[i])])
    num_samps_groups[[i]]<-dim(data_matrix_list[[i]])[1]
    #print(dim(data_matrix_list[[i]]))
    multiExpr[[i]]<-list(data = as.data.frame(data_matrix_list[[i]]));
    rownames(multiExpr[[i]]$data)=c(paste(rep(class_labels_levels[i],num_samps_groups[[i]]),seq(1,num_samps_groups[[i]]),sep=""))
    
    degree_list[[i]]<-softConnectivity(datExpr=data_matrix_list[[i]],power=power_val,minNSamples=2)
    #
    colnames_vec<-c(colnames_vec,paste("DegreeClass",i,sep=""))
    
    degree_list[[i]]<-replace(degree_list[[i]],which(degree_list[[i]]<0),0)
    
    #degree_list[[i]][which(is.na(degree_list[[i]])==TRUE)]=1
    
    colors_met<-cbind(data_matrix_orig[,c(1:2)],degree_list[[i]],sig_status)
    
    colors_met<-as.data.frame(colors_met)
    
    colors_met_all<-cbind(colors_met_all,degree_list[[i]])
    
    colors_met$sig_status[sigfeatsind]=1
    
    colnames(colors_met)<-c("mz","time","DegreeClass","sig_status")
    
    #colnames_vec<-c("mz","time","DegreeClass","sig_status")
    colors_met<-as.data.frame(colors_met)
    
    colors_met<-colors_met[order(colors_met$DegreeClass,decreasing=TRUE),]
    
    sig_ind<-which(colors_met$sig_status==1)
    
    names=paste(round(colors_met$mz,4),sep="_")
    
    # print(names[sig_ind])
    mainlab=paste("Class ",i," degree distribution",sep="")
    
    if(FALSE)
    {
      plot(colors_met$DegreeClass,cex=0.2,main=mainlab,ylab="Degree",xlab="Feature Index",col="orange",type="b",lwd=0.5)
      #for(i in 1:length(sig_ind))
      lapply(1:length(sig_ind),function(i)
      {
        points(y=colors_met$DegreeClass[sig_ind[i]],x=sig_ind[i],col="darkgreen",cex=0.8,lwd=2)
        
        if(i%%2>0){
          text(y=colors_met$DegreeClass[sig_ind[i]],x=sig_ind[i],names[sig_ind[i]],cex=0.31,adj=c(1,2))
        }else{
          text(y=colors_met$DegreeClass[sig_ind[i]],x=sig_ind[i],names[sig_ind[i]],cex=0.31,adj=c(0,-1))
        }
      })
      
    }
    
  }
  
  # dev.off()
  
  colors_met_all<-as.data.frame(colors_met_all)
  colnames(colors_met_all)<-colnames_vec
  
  
  #print(table(MET[[1]]$validColors))
  #print(table(classAmoduleColors))
  write.table(colors_met_all,file="Tables/Degree_eval_allfeats.txt",sep="\t",row.names=FALSE)
  
  sub_colors_met<-{}
  #if(is.na(sigfeats)==FALSE){
  
  if(typeof(sigfeats)!="logical"){
    sub_colors_met<-colors_met_all[sigfeatsind,]
    write.table(sub_colors_met,file="Tables/Degree_eval_selectfeats.txt",sep="\t",row.names=FALSE)
  }
  
  ####saveMET,file="MET.Rda")
  
  
  
  return(list(all=colors_met_all,sigfeats=sub_colors_met))
}



get_scatter_plots<-function (X = NA, Y = NA, feature_table_file, parentoutput_dir, 
                             class_labels_file, group_by_mat_file = NA, scatterplot.col.opt = "journal", 
                             alphacol = 0.3, newdevice = TRUE, cex.plots = 0.6, replace.by.NA = FALSE, 
                             pairedanalysis = FALSE, filename = "", ylabel = "Response", 
                             alphabetical.order = FALSE, name = NA, add.jitter = TRUE, 
                             add.pvalues = TRUE, xlabel = "Predictor", ellipse = FALSE, 
                             ypos.adj.factor = 0.5, group_by_mat = NA, cor.method = "pearson", multiple.facets=TRUE,
                             conf.int=TRUE,
                             ...) 
{
  suppressMessages(library(ggpubr))
  if (is.na(X[1]) == TRUE) {
    data_matrix <- read.table(feature_table_file, sep = "\t", 
                              header = TRUE)
  }
  else {
    data_matrix <- X
  }
  if (is.na(Y[1]) == TRUE) {
    classlabels <- read.table(class_labels_file, sep = "\t", 
                              header = TRUE)
  }
  else {
    classlabels <- Y
  }
  if (is.na(group_by_mat_file[1]) == FALSE) {
    group_by_mat <- read.table(group_by_mat_file, sep = "\t", 
                               header = TRUE)
  }
  class_labels_levels <- c("A")
  sample.col.opt = scatterplot.col.opt
  if (sample.col.opt == "default") {
    col_vec <- c("#CC0000", "#AAC000", "blue", 
                 "mediumpurple4", "mediumpurple1", "blueviolet", 
                 "cornflowerblue", "cyan4", "skyblue", 
                 "darkgreen", "seagreen1", "green", 
                 "yellow", "orange", "pink", "coral1", 
                 "palevioletred2", "red", "saddlebrown", 
                 "brown", "brown3", "white", "darkgray", 
                 "aliceblue", "aquamarine", "aquamarine3", 
                 "bisque", "burlywood1", "lavender", 
                 "khaki3", "black")
  }
  else {
    if (sample.col.opt == "topo") {
      col_vec <- topo.colors(length(class_labels_levels), 
                             alpha = alphacol)
    }
    else {
      if (sample.col.opt == "heat") {
        col_vec <- heat.colors(length(class_labels_levels), 
                               alpha = alphacol)
      }
      else {
        if (sample.col.opt == "rainbow") {
          col_vec <- rainbow(length(class_labels_levels), 
                             start = 0, end = alphacol)
        }
        else {
          if (sample.col.opt == "terrain") {
            col_vec <- cm.colors(length(class_labels_levels), 
                                 alpha = alphacol)
          }
          else {
            if (sample.col.opt == "colorblind") {
              if (length(class_labels_levels) < 9) {
                col_vec <- c("#0072B2", "#E69F00", 
                             "#009E73", "#56B4E9", "#D55E00", 
                             "#CC79A7", "#E64B35FF", 
                             "grey57")
              }
              else {
                col_vec <- c("#0072B2", "#E69F00", 
                             "#009E73", "#56B4E9", "#D55E00", 
                             "#CC79A7", "#E64B35B2", 
                             "#4DBBD5B2", "#00A087B2", 
                             "#3C5488B2", "#F39B7FB2", 
                             "#8491B4B2", "#91D1C2B2", 
                             "#DC0000B2", "#7E6148B2", 
                             "#374E55B2", "#DF8F44B2", 
                             "#00A1D5B2", "#B24745B2", 
                             "#79AF97B2", "#6A6599B2", 
                             "#80796BB2", "#0073C2B2", 
                             "#EFC000B2", "#868686B2", 
                             "#CD534CB2", "#7AA6DCB2", 
                             "#003C67B2", "grey57")
              }
            }
            else {
              check_brewer <- grep(pattern = "brewer", 
                                   x = sample.col.opt)
              if (length(check_brewer) > 0) {
                sample.col.opt_temp = gsub(x = sample.col.opt, 
                                           pattern = "brewer.", replacement = "")
                col_vec <- colorRampPalette(brewer.pal(10, 
                                                       sample.col.opt_temp))(length(class_labels_levels))
              }
              else {
                if (sample.col.opt == "journal") {
                  col_vec <- c("#0072B2", "#E69F00", 
                               "#009E73", "#56B4E9", 
                               "#D55E00", "#CC79A7", 
                               "#E64B35FF", "#3C5488FF", 
                               "#F39B7FFF", "#8491B4FF", 
                               "#91D1C2FF", "#DC0000FF", 
                               "#B09C85FF", "#5F559BFF", 
                               "#808180FF", "#20854EFF", 
                               "#FFDC91FF", "#B24745FF", 
                               "#374E55FF", "#8F7700FF", 
                               "#5050FFFF", "#6BD76BFF", 
                               "#E64B3519", "#4DBBD519", 
                               "#631879E5", "grey75")
                  if (length(class_labels_levels) < 8) {
                    col_vec <- c("#0072B2", "#E69F00", 
                                 "#009E73", "#56B4E9", 
                                 "#D55E00", "#CC79A7", 
                                 "grey75")
                  }
                  else {
                    if (length(class_labels_levels) <= 
                        28) {
                      col_vec <- c("#0072B2", "#E69F00", 
                                   "#009E73", "#56B4E9", 
                                   "#D55E00", "#CC79A7", 
                                   "#E64B35FF", "#3C5488FF", 
                                   "#F39B7FFF", "#8491B4FF", 
                                   "#91D1C2FF", "#DC0000FF", 
                                   "#B09C85FF", "#5F559BFF", 
                                   "#808180FF", "#20854EFF", 
                                   "#FFDC91FF", "#B24745FF", 
                                   "#374E55FF", "#8F7700FF", 
                                   "#5050FFFF", "#6BD76BFF", 
                                   "#8BD76BFF", "#E64B3519", 
                                   "#9DBBD0FF", "#631879E5", 
                                   "#666666", "grey75")
                    }
                    else {
                      colfunc <- colorRampPalette(c("#0072B2", 
                                                    "#E69F00", "#009E73", 
                                                    "#56B4E9", "#D55E00", 
                                                    "#CC79A7", "grey75"))
                      col_vec <- colfunc(length(class_labels_levels))
                      col_vec <- col_vec[sample(col_vec)]
                    }
                  }
                }
                else {
                #  if (length(sample.col.opt) == 1) {
                 #   col_vec <- rep(sample.col.opt, length(class_labels_levels))
                  #}
                  #else {
                   # colfunc <- colorRampPalette(sample.col.opt)
                  #  col_vec <- colfunc(length(class_labels_levels))
                  #}
                  
                  if(length(sample.col.opt)==1){
                    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  }else{
                    
                    if(length(sample.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-sample.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                      
                      
                    }else{
                      colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    }
                    
                  }
                  
                  
                }
              }
            }
          }
        }
      }
    }
  }

  cnames <- colnames(data_matrix)
  cnames <- tolower(cnames)
  cnames <- tolower(cnames)
  check_names <- grep(cnames, pattern = "^name$")
  if (length(check_names) > 0) {
    if (check_names == 1) {
      check_names1 <- grep(cnames, pattern = "^mz$")
      check_names2 <- grep(cnames, pattern = "^time$")
      if (length(check_names1) < 1 & length(check_names2) < 
          1) {
        mz <- seq(1.00001, nrow(data_matrix) + 1, 1)
        time <- seq(1.01, nrow(data_matrix) + 1, 1)
        check_ind <- gregexpr(cnames, pattern = "^name$")
        check_ind <- which(check_ind > 0)
        X <- as.data.frame(data_matrix)
        Name <- as.character(X[, check_ind])
        X <- cbind(mz, time, X[, -check_ind])
        names_with_mz_time = cbind(Name, mz, time)
        names_with_mz_time <- as.data.frame(names_with_mz_time)
        write.table(names_with_mz_time, file = "Stage1/Name_mz_time_mapping.txt", 
                    sep = "\t", row.names = FALSE)
        X <- as.data.frame(X)
      }
      else {
        if (length(check_names1) > 0 & length(check_names2) > 
            0) {
          check_ind <- gregexpr(cnames, pattern = "^name$")
          check_ind <- which(check_ind > 0)
          Name <- as.character(X[, check_ind])
          X <- X[, -check_ind]
          names_with_mz_time = cbind(Name, X$mz, X$time)
          colnames(names_with_mz_time) <- c("Name", 
                                            "mz", "time")
          names_with_mz_time <- as.data.frame(names_with_mz_time)
          X <- as.data.frame(X)
          write.table(names_with_mz_time, file = "Stage1/Name_mz_time_mapping.txt", 
                      sep = "\t", row.names = FALSE)
        }
      }
    }
  }
  else {
    check_names1 <- grep(cnames[1], pattern = "^mz$")
    check_names2 <- grep(cnames[2], pattern = "^time$")
    if (length(check_names1) < 1 || length(check_names2) < 
        1) {
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  data_matrix <- X
  
  
  data_m <- data_matrix[, -c(1:2)]
  data_m <- as.matrix(data_m)
  mzvec <- data_matrix[, 1]
  timevec <- data_matrix[, 2]
  goodfeats <- data_m
  rm(data_m)
  rm(X)
  rm(Y)
  
  file_ind <- 0
  boxplots_fname <- paste("scatterplots", filename, ".pdf", 
                          sep = "")
  if (newdevice == TRUE) {
    pdf(boxplots_fname)
  }
  par(mfrow = c(1, 1), family = "sans", cex = cex.plots)
  class_vec <- classlabels[, 2]
  lapply(1:dim(goodfeats)[1], function(m) {
    if (m%%9 == 0) {
      file_ind <- file_ind + 1
      boxplots_fname <- paste("scatterplots_file", 
                              file_ind, ".tiff", sep = "")
    }
   # round_mzval <- sprintf("%.4f", mzvec[m])
    #round_timeval <- sprintf("%.1f", timevec[m])
    if (is.na(name) == TRUE) {
      if (length(check_names) > 0) {
        if (check_names == 1) {
          mzname <- as.character(names_with_mz_time[m, 1])
        }
        else {
          mzname <- paste("mz_time: ", round_mzval, 
                          "_", round_timeval, sep = "")
        }
      }
      else {
        mzname <- paste("mz_time: ", round_mzval, 
                        "_", round_timeval, sep = "")
      }
    }
    else {
      mzname = as.character(name[m])
    }
    cur_d <- new("list")
    feat_vec <- {
    }
    temp_dm <- cbind(colnames(goodfeats), class_vec, as.vector(t(goodfeats[m, 
                                                                           ])))
    temp_dm <- as.data.frame(temp_dm)
    colnames(temp_dm) <- c("SID", "Class", "Feature")
    temp_dm$Class <- as.numeric(as.character(temp_dm$Class))
    temp_dm$Feature <- as.numeric(as.character(temp_dm$Feature))
    par(mfrow = c(1, 1), family = "sans", cex = cex.plots)
    w <- 0.1
    par(omd = c(0, 1 - w, 0, 1), cex.main = 0.7)
    if (is.na(group_by_mat[1]) == FALSE) {
      colnames(group_by_mat) <- c("SID", "GroupBy")
      temp_dm <- merge(temp_dm, group_by_mat, by = "SID")
    }
    temp_dm <- as.data.frame(temp_dm)
    s1 = summary(temp_dm$Class)
    
    sadj = (s1[5] - s1[3]) * ypos.adj.factor
    if (is.na(group_by_mat[1]) == TRUE) {
      p <- suppressMessages(ggscatter(temp_dm, x = "Class", y = "Feature", conf.int=conf.int,
                     title = mzname, xlab = xlabel, ylab = ylabel, 
                     palette = col_vec[1], col = col_vec[1], shape = 20, 
                     size = 3, add = "reg.line",
                     add.params = list(color = "black", 
                    fill = "lightgray"))) + theme(plot.title = element_text(hjust = 0.5, size = 10)) + stat_cor(method = cor.method) #label.y = max(temp_dm$Class + (sadj))
    }
    else {
      temp_dm$GroupBy <- as.factor(temp_dm$GroupBy)
      
      if(multiple.facets==TRUE){
        p <- suppressMessages(ggscatter(temp_dm, x = "Class", y = "Feature", conf.int=conf.int,
                       title = mzname, xlab = xlabel, ylab = ylabel,
                       add = "reg.line", color = "GroupBy", facet.by="GroupBy", scales="free",
                       palette = col_vec, fullrange = TRUE, shapez = 20, 
                       size = 3)) + theme(plot.title = element_text(hjust = 0.5, 
                                                                   size = 10)) + stat_cor(method = cor.method, aes(color = GroupBy))
      }else{
        
        #ylim=c(s1[1],s1[6]),
        
        p <- suppressMessages(ggscatter(temp_dm, x = "Class", y = "Feature", conf.int=conf.int,
                       title = mzname, xlab = xlabel, ylab = ylabel, 
                       add = "reg.line", color = "GroupBy", 
                       palette = col_vec, fullrange = TRUE, shape = 20, 
                       size = 3)) + theme(plot.title = element_text(hjust = 0.5, 
                                                                   size = 10)) + stat_cor(method = cor.method, aes(color = GroupBy))
      }
    }
    
    p=ggpar(p, ylim = c(min(temp_dm$Feature,na.rm=TRUE), max(temp_dm$Feature,na.rm=TRUE)))  #c(min(temp_dm$Class,na.rm=TRUE), max(temp_dm$Class,na.rm=TRUE))
    suppressMessages(print(p))
  })
  if (newdevice == TRUE) {
    dev.off()
  }
}







#metab_data: KEGGID, Statistic
get_fcs<-function(target.data,target.data.annot=NA,kegg_species_code="hsa",database="pathway",
                  reference_set=NA,type.statistic=c("pvalue","t-statistic","fold.change","VIP"),fcs.min.hits=2,itrs=100, numnodes=2){
  
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  
  #metab_data: ID, Statistic
  #reference set: SetID, Name
  suppressMessages(library('KEGGREST'))
  
  colnames(target.data)<-c("XID","Statistic")
  
 # print(fcs.min.hits)
  #print(itrs)
 # print(numnodes)
  #print(head(target.data))
  #print(head(reference_set))
  #print(type.statistic)
  
  count.unique.formula.overlapsize=TRUE
  dup.feature.check=TRUE
  
  if(is.na(target.data.annot)==FALSE){
    
    if(target.data.annot=="none"){
      
      target.data.annot=NA
    }
  }
  if(is.na(reference_set)==TRUE){
    
    if(database=="pathway"){
      #homo sapiens: humans
      if(kegg_species_code=="hsa"){
        data(kegg_hsa)
        g1=kegg_hsa
        rm(kegg_hsa)
      }else{
        #Mus musculus: mouse
        if(kegg_species_code=="mmu"){
          data(kegg_mmu)
          g1=kegg_mmu
          rm(kegg_mmu)
        }else{
          
          #Pan troglodytes: Chimpanzee
          if(kegg_species_code=="ptr"){
            data(kegg_ptr)
            g1=kegg_ptr
            rm(kegg_ptr)
          }else{
            
            #Macaca mulatta: Rhesus monkey
            if(kegg_species_code=="mcc"){
              data(kegg_mcc)
              g1=kegg_mcc
              rm(kegg_mcc)
            }else{
              #Bos taurus: cow
              if(kegg_species_code=="bta"){
                data(kegg_bta)
                g1=kegg_bta
                rm(kegg_bta)
              }else{
                #Rattus norvegicus: rat
                if(kegg_species_code=="rno"){
                  data(kegg_rno)
                  g1=kegg_rno
                  rm(kegg_rno)
                }else{
                  
                  #Danio rerio: Zebrafish
                  if(kegg_species_code=="dre"){
                    data(kegg_dre)
                    g1=kegg_dre
                    rm(kegg_dre)
                  }else{
                    
                    #C. elegans: nematode
                    if(kegg_species_code=="cel"){
                      data(kegg_cel)
                      g1=kegg_cel
                      rm(kegg_cel)
                    }else{
                      
                      #Drosophila melanogaster: fruit fly
                      if(kegg_species_code=="dme"){
                        data(kegg_dme)
                        g1=kegg_dme
                        rm(kegg_dme)
                      }
                      
                    }
                    
                  }
                  
                }
                
              }
              
            }
          }
          
        }
        
      }
      
    }else{
      
      if(database=="module"){
        
        data(kegg_modules)
        g1=kegg_modules
        rm(kegg_modules)
      }else{
        if(database=="brite"){
          
          data(kegg_brite)
          g1=kegg_brite
          rm(kegg_brite)
        }else{
          if(database=="lipidmaps_mainclass"){
            
            data(lipidmaps_mainclass)
            g1=lipidmaps_mainclass
            rm(lipidmaps_mainclass)
          }else{
            
            if(database=="lipidmaps_subclass"){
              
              data(lipidmaps_subclass)
              g1=lipidmaps_subclass
              rm(lipidmaps_subclass)
            }else{
              
              if(database=="refmet_superclass"){
                
                data(refmet_superclass)
                g1=refmet_superclass
                rm(refmet_superclass)
              }else{
                if(database=="refmet_mainclass"){
                  
                  data(refmet_mainclass)
                  g1=refmet_mainclass
                  rm(refmet_mainclass)
                }else{
                  
                  if(database=="refmet_subclass"){
                    
                    data(refmet_subclass)
                    g1=refmet_subclass
                    rm(refmet_subclass)
                  }else{
                    if(database=="reactome_compound"){
                      
                      data(reactome_atlas)
                      g1<-reactome_atlas[which(reactome_atlas$IDtype=="compound"),]
                      rm(reactome_atlas)
                    }else{
                      if(database=="reactome_atlas"){
                        
                        data(reactome_atlas)
                        g1<-reactome_atlas
                        rm(reactome_atlas)
                      }else{
                        if(database=="kegg_atlas"){
                          #load("/Users/karanuppal/Documents/Emory/JonesLab/Projects/DifferentialExpression/xmsPaNDA/xmsPANDA_v1.1.65/data/kegg_atlas.rda")
                           data(kegg_atlas)
                          g1<-kegg_atlas
                          rm(kegg_atlas)
                        }
                        
                      }
                      
                    }
                    
                  }
                }
                
              }
            }
          }
          
        }
        
        
      }
      
      
    }
  }else{
    
    
    colnames(reference_set)<-c("XID","SetID","SetName")
    
    g1<-reference_set
    
    if(FALSE){
    if(ncol(g1)<5){
      
      
      exact_mass<-seq(1,nrow(g1))
      chemformula<-paste("A",seq(1,nrow(g1)),sep="")
      
      
      g1<-cbind(g1,exact_mass,chemformula)
      
      
    }
    
  }
    
  }
  g1<-as.data.frame(g1)
  #colnames(hsa_module_comp)<-c("MetabSetID","KEGGID")
  
  
  if(is.na(target.data.annot)==FALSE){
    
    cnames1<-colnames(target.data)
    
    if(grep("mz",cnames1)>0 && grep("time",cnames1)>0){
      
      
      target.data_1<-merge(target.data,target.data.annot,by=c("mz","time"))
      target.data_1<-target.data_1[,-c(1:2)]
      
    }else{
      
      
      if(grep("mz",cnames1)>0){
        
        target.data_1<-merge(target.data,target.data.annot,by=c("mz"))
        target.data_1<-target.data_1[,-c(1)]
        
      }else{
        
        if(grep("Name",cnames1)>0){
          
          target.data_1<-merge(target.data,target.data.annot,by=c("Name"))
          target.data_1<-target.data_1[,-c(1)]
        }else{
          
          warning("Skipping merge with target annotation file as no columns are labeled as mz or Name in the annotation file.")
        }
      }
    }
    metab_data<-target.data_1
    rm(target.data_1)
    rm(target.data)
    
    
    metab_data<-metab_data[,c("XID","Statistic")]
    
  }else{
    
    colnames(target.data)<-c("XID","Statistic")
    metab_data<-target.data
    
    rm(target.data)
    
    
    metab_data<-metab_data[,c("XID","Statistic")]
  }
  
  if(type.statistic=="pvalue" || type.statistic=="p-value" || type.statistic=="p.value"){
    
    
    metab_data$Statistic=(-1)*log10(metab_data$Statistic)
    
  }
  
  
  
  cnames_g1<-colnames(g1)
  
  check_colnames<-length(which(cnames_g1%in%c("XID","SetID","SetName")))
  
  if(check_colnames<3){
    
    check_colnames<-length(which(cnames_g1%in%c("XID","SetID","Name")))
    
    if(check_colnames<3){
    
        stop("The columns in the reference database file should be: XID, SetID, and SetName")
    }
  }
  
  
  cnames_g1[1:3]<-c("XID","SetID","SetName")
  
  
  colnames(g1)<-cnames_g1 #c("XID","SetID","Name","ExactMass","Formula")
  res<-get_fcs_child(metab_data=metab_data,reference_sets=g1,fcs.min.hits=fcs.min.hits,itrs=itrs,numnodes=numnodes)
  
  save(res,g1,metab_data,file="r5.rda")
  
  g2=g1[which(g1$XID%in%metab_data$XID),]
  
  g1agg<-aggregate(g2$XID,by=list(g2$SetID),function(x){paste(x,sep="",collapse=";")})
  colnames(g1agg)<-c("SetID","XID")
  
  if(length(which(duplicated(g1$SetID)==TRUE))>0){
    path_names_ids<-g1[-which(duplicated(g1$SetID)==TRUE),c("SetID","SetName")]
  }else{
    path_names_ids<-g1[,c("SetID","SetName")]
  }
  
  #   print(head(res))
  res[,-c(1)]<-apply(res[,-c(1)],2,function(x){as.numeric(as.character(x))})
  
  
  if(length(res)<1){
    res<-{}
    
    print("Functional class scoring returned no rsults. Please make sure that the features match between the feature table and the annotation files.")
  }else{
    res<-merge(res,path_names_ids,by.x="SetID",by.y="SetID")
    
    cnames1<-colnames(res)
    #print(head(res))
    cnames1[length(cnames1)]<-c("SetName")
    
    colnames(res)<-cnames1
    
    res<-res[order(as.numeric(as.character(res$FDR.meta)),decreasing=FALSE),]
    
    
    if(is.na(fcs.min.hits)==FALSE){
      res<-res[which(res$Num.Hits>=fcs.min.hits),]
      
    }
    
    
    
    if(length(res)>0){
      
      res<-merge(res,g1agg,by="SetID")
      res<-res[order(as.numeric(as.character(res$pval.MaxMean)),decreasing=FALSE),]
      #  #save(res,file="res.Rda")
      #res<-res[,c("SetID","Agg.Statistic","Z.score","MaxMean","Total.Size","Num.Hits","pval.Agg.Statistic","pval.Z.score","pval.MaxMean","FDR.MaxMean","pval.meta","FDR.meta","SetName","XID")]
      # res<-res[,c("SetID","MaxMean","Total.Size.x","Num.Hits","pval.MaxMean","FDR.MaxMean","SetName","XID")]
      
      #   res<-res[which(abs(res$Z.score)>0),]
      
      # res<-res[,c("SetID","Agg.Statistic","Z.score","MaxMean","Total.Size","Num.Hits","pval.Agg.Statistic","pval.Z.score","pval.MaxMean","pval.meta","FDR.meta","SetName")]
      res<-res[,c("SetID","Total.Size","Num.Hits","Agg.Statistic","pval.Z.score","pval.MaxMean","FDR.Z.score","FDR.MaxMean","SetName","XID")]
      
      colnames(res)<-c("SetID","Total.Size","Num.Hits","Agg.Statistic","p.Z.stat","p.MaxMean","FDR.Z.stat","FDR.MaxMean","SetName","XID")
      
      #  res<-res[,c("SetID","MaxMean","MaxMean.Std","Total.Size","Num.Hits","pval.MaxMean","FDR.MaxMean","SetName","XID")]
      
      # colnames(res)<-res[,c("SetID","Agg.MaxMean.Statistic","Total.Size","Num.Hits","pval.Agg.Statistic","pval.Z.score","pval.MaxMean","pval.meta","FDR.meta","SetName","XID")]
      
      
    }else{
      
      res<-{}
    }
  }
  
  #print(head(res))
  ##save(res,file="res.Rda")
  return(res)
  
}


z.test<-function (x, y = NULL, alternative = "two.sided", mu = 0, sigma.x = NULL,
                  sigma.y = NULL, conf.level = 0.95)
{
  choices <- c("two.sided", "greater", "less")
  alt <- pmatch(alternative, choices)
  alternative <- choices[alt]
  if (length(alternative) > 1 || is.na(alternative))
    stop("alternative must be one \"greater\", \"less\", \"two.sided\"")
  if (!missing(mu))
    if (length(mu) != 1 || is.na(mu))
      stop("mu must be a single number")
  if (is.null(sigma.x) && !is.null(x) && is.null(y))
    stop("You must enter the value for sigma.x")
  if (!is.null(y) && is.null(sigma.y) || is.null(sigma.x))
    stop("You must enter values for both sigma.x and sigma.y")
  if (!missing(conf.level))
    if (length(conf.level) != 1 || is.na(conf.level) || conf.level <
        0 || conf.level > 1)
      stop("conf.level must be a number between 0 and 1")
  if (!is.null(y)) {
    dname <- paste(deparse(substitute(x)), "and", paste(deparse(substitute(y))))
  }
  else {
    dname <- deparse(substitute(x))
  }
  nx <- length(x)
  if (nx <= 2)
    stop("not enough x observations")
  mx <- mean(x)
  estimate <- mx
  if (is.null(y)) {
    stderr <- sigma.x/sqrt(nx)
    zobs <- (mx - mu)/stderr
    method <- c("One-sample z-Test")
    names(estimate) <- c("mean of x")
  }
  else {
    ny <- length(y)
    if (ny <= 2)
      stop("not enough y observations")
    my <- mean(y)
    method <- c("Two-sample z-Test")
    estimate <- c(mx, my)
    names(estimate) <- c("mean of x", "mean of y")
    stderr <- sqrt(((sigma.x^2)/nx) + ((sigma.y^2)/ny))
    zobs <- (mx - my - mu)/stderr
  }
  if (alternative == "less") {
    pval <- stats::pnorm(zobs)
    cint <- c(NA, zobs * stderr + qnorm(conf.level) * stderr)
  }
  else if (alternative == "greater") {
    pval <- 1 - stats::pnorm(zobs)
    cint <- c(zobs * stderr - stats::qnorm(conf.level) * stderr,
              NA)
  }
  else {
    pval <- 2 * stats::pnorm(-abs(zobs))
    alpha <- 1 - conf.level
    cint <- c(zobs * stderr - stats::qnorm((1 - alpha/2)) * stderr,
              zobs * stderr + stats::qnorm((1 - alpha/2)) * stderr)
  }
  cint <- cint + mu
  names(zobs) <- "z"
  if (!is.null(y))
    names(mu) <- "difference in means"
  else names(mu) <- "mean"
  attr(cint, "conf.level") <- conf.level
  rval <- list(statistic = zobs, p.value = pval, conf.int = cint,
               estimate = estimate, null.value = mu, alternative = alternative,
               method = method, data.name = dname)
  attr(rval, "class") <- "htest"
  return(rval)
}

#metab_data: KEGGID, Statistic
#reference sets: Pathway/Module ID, KEGGID
get_fcs_childv1.0.8.50<-function(metab_data,reference_sets,itrs=1000,fcs.min.hits=2,numnodes=2){
  
  
  
  # colnames(reference_sets)<-c("SetID","Name","XID")
  count.unique.formula.overlapsize=TRUE
  dup.feature.check=TRUE
  
  
  cnames1<-colnames(metab_data)
  
  cnames1[1:2]<-c("XID","Statistic")
  
  colnames(metab_data)<-cnames1
  
  
  set_size=table(reference_sets$SetID)
  set_size<-cbind(names(set_size),set_size)
  set_size<-as.data.frame(set_size)
  colnames(set_size)<-c("SetID","Total.Size")
  
  
  metab_data_sets<-merge(metab_data,reference_sets,by="XID")
  
  #save(metab_data_sets,metab_data,reference_sets,file="metab_data_sets.Rda")
  
  metab_data_sets<-metab_data_sets[order(metab_data_sets$SetID,metab_data_sets$Statistic,decreasing=TRUE),]
  
  if(count.unique.formula.overlapsize==TRUE){
    
    if(length(grep(colnames(metab_data_sets),pattern="Formula"))>0){
      xid_formula<-paste(metab_data_sets$SetID,"_",metab_data_sets$Formula,sep="")
      
      dup_check<-which(duplicated(xid_formula)==TRUE)
      if(length(dup_check)>0){
        metab_data_sets<-metab_data_sets[-dup_check,]
      }
    }
  }
  #  write.table(metab_data_sets,file="fcs_sets_with_statistic.txt",sep="\t",row.names=FALSE)
  metab_data_sets<-metab_data_sets[,c(1:4)]
  
  if(nrow(metab_data_sets)<1){
    
    metabset_res_mat<-{}
    
  }else{
    sid_list<-metab_data_sets$SetID;
    sid_list<-unique(sid_list)
    
    metab_data_sets$Statistic<-as.numeric(as.character(metab_data_sets$Statistic))
    
    
    set_statistic1=aggregate(metab_data_sets$Statistic,by=list(metab_data_sets$SetID),FUN=function(x){
      x<-as.numeric(as.character(x))
      max_mean<-max(mean(x[which(x>0)],na.rm=TRUE),mean(x[which(x<0)],na.rm=TRUE),na.rm=TRUE)
      
      resv<-c(agg.stat=sum(x,na.rm=TRUE)/length(x),zscore=sqrt(length(x))*sum(x,na.rm=TRUE)/length(x), maxmean=max_mean,numhits=length(x))
      resv<-round(resv,3)
      return(resv)
    })
    set_statistic1<-do.call(data.frame,set_statistic1)
    colnames(set_statistic1)=c("SetID","Agg.Statistic","Z.score","MaxMean","Num.Hits")
    
    set_statistic1$Z.score<-scale(set_statistic1$MaxMean)
    
    
    #metabset_res<-parLapply(cl,1:length(sid_list),function(c,dup.feature.check,fcs.method,fcs.permutation.type){
    z.test1 = function(x=NA,mu=NA,popvar=NA,z.score=NA){
      
      one.tail.p <- NULL
      
      if(is.na(z.score)==TRUE){
        z.score <- round((mean(x)-mu)/(popvar/sqrt(length(x))),3)
      }
      one.tail.p <- round(pnorm(abs(z.score),lower.tail = FALSE),3)
      
      
      return(one.tail.p)
    }
    if(dup.feature.check==TRUE){
      
      if(length(duplicated(paste(metab_data_sets$SetID,"_",metab_data_sets$mz,"_",metab_data_sets$time,sep=""))==TRUE)>0){
        metab_data_sets<-metab_data_sets[-which(duplicated(paste(metab_data_sets$SetID,"_",metab_data_sets$mz,"_",metab_data_sets$time,sep=""))==TRUE),]
      }
    }
    
    metab_data_sets<-merge(metab_data_sets,set_size,by="SetID")
    
    #save(metab_data_sets,file="prerand.Rda")
    
    cl<-makeCluster(max(numnodes,detectCores()*0.5))
    #   a=Sys.time()
    randmetabset_res<-parLapply(cl,1:itrs,function(i,metab_data_sets){
      
      set.seed(i)
      all <- sample(1:nrow(metab_data_sets),nrow(metab_data_sets))
      randmetab_data_sets<-metab_data_sets
      randmetab_data_sets$Statistic<-metab_data_sets$Statistic[all]
      randmetab_data_sets$XID<-metab_data_sets$XID[all]
      
      #randmetab_data_sets[,1]<-randkeggids
      #randmetab_data_sets[,2]<-randstat
      
      randset_statistic1=aggregate(randmetab_data_sets$Statistic,by=list(randmetab_data_sets$SetID),FUN=function(x){
        
        x<-as.numeric(as.character(x))
        
        max_mean<-max(mean(x[which(x>0)],na.rm=TRUE),mean(x[which(x<0)],na.rm=TRUE),na.rm=TRUE)
        
        
        resv<-c(agg.stat=sum(x,na.rm=TRUE)/length(x),zscore=sqrt(length(x))*sum(x,na.rm=TRUE)/length(x), maxmean=max_mean)
        
        resv<-round(resv,3)
        
        # resv<-as.data.frame(resv)
        return(resv)
      })
      
      return(randset_statistic1)
      
    },metab_data_sets=metab_data_sets)
    
    # b=Sys.time()
    #print(b-a)
    stopCluster(cl)
    
    randmetabset_res<-do.call(rbind, randmetabset_res)
    randmetabset_res<-do.call(data.frame, randmetabset_res)
    
    
    
    #checkhere
    
    colnames(randmetabset_res)<-c("SetID","Agg.Statistic","Z.score","MaxMean")
    
    randmetabset_res$Z.score<-randmetabset_res$MaxMean
    
    randset_maxmean=aggregate(randmetabset_res$MaxMean,by=list(randmetabset_res$SetID),FUN=function(x){
      
      x<-as.numeric(as.character(x))
      return(c(meanval=round(mean(x,na.rm=TRUE),3),sdval=round(sd(x,na.rm=TRUE),3)))
    })
    
    randset_maxmean<-do.call(data.frame,randset_maxmean)
    
    colnames(randset_maxmean)<-c("SetID","RandMeanMaxMean","RandSdMaxMean")
    
    
    set_statistic1<-merge(set_statistic1,randset_maxmean,by="SetID")
    
    MaxMean.Std<-round((set_statistic1$MaxMean-set_statistic1$RandMeanMaxMean)/set_statistic1$RandSdMaxMean,3)
    
    
    set_statistic1<-cbind(set_statistic1,MaxMean.Std)
    
    randmetabset_res<-merge(randmetabset_res,randset_maxmean,by="SetID")
    RandMaxMean.Std<-(randmetabset_res$MaxMean-randmetabset_res$RandMeanMaxMean)/randmetabset_res$RandSdMaxMean
    randmetabset_res<-cbind(randmetabset_res,round(RandMaxMean.Std,3))
    #set_statistic1A=merge(set_statistic1,set_size,by="SetID")
    #Norm.Agg.Statistic=set_statistic1A$Agg.Statistic/set_statistic1A$Size
    
    meanp.agg<-function (p)
    {
      keep <- (p >= 0) & (p <= 1)
      invalid <- sum(1L * keep) < 3
      if (invalid) {
        warning("Must have at least four valid p values")
        res <- list(z = NA_real_, p = NA_real_, validp = p[keep])
      }
      else {
        pi <- mean(p[keep])
        k <- length(p[keep])
        z <- (0.5 - pi) * sqrt(12 * k)
        if (k != length(p)) {
          warning("Some studies omitted")
        }
        res <- list(z = z, p = pnorm(z, lower.tail = FALSE),
                    validp = p[keep])
      }
      #class(res) <- c("meanp", "metap")
      res
    }
    
    #save(randmetabset_res,set_statistic1,file="pvaldebug.Rda")
    metabset_res1<-lapply(1:length(sid_list),function(c){
      
      
      cur_sid_rand<-randmetabset_res[which(randmetabset_res$SetID==sid_list[c]),]
      cur_sid_orig<-set_statistic1[which(set_statistic1$SetID==sid_list[c]),]
      if(nrow(cur_sid_orig)>0){
        pval_agg.stat=length(which(as.numeric(as.character(cur_sid_rand[,2]))>as.numeric(as.character(cur_sid_orig[2]))))/itrs
        
        z.score=as.numeric(as.character(cur_sid_orig[3]))
        
        pval_zscore=round(pnorm(abs(z.score),lower.tail = FALSE),3)
        
        #length(which(as.numeric(as.character(cur_sid_rand[,3]))>as.numeric(as.character(cur_sid_orig[3]))))/itrs
        pval_stdmaxmean=length(which(as.numeric(as.character(cur_sid_rand[,4]))>as.numeric(as.character(cur_sid_orig[4]))))/itrs
        
        #z.score=as.numeric(as.character(cur_sid_orig[7]))
        # pval_zscore=round(pnorm(abs(z.score),lower.tail = FALSE),3)
        
        #pval_stdmaxmean=round(pnorm(abs(z.score),lower.tail = FALSE),3)
        
        pval_meta=meanp.agg(c(pval_agg.stat,pval_zscore,pval_stdmaxmean))$p #,na.rm=TRUE)$p
        #zval=(0.5-meanp_val)*sqrt(12*3)
        #pval_meta <- round(pnorm((zval),lower.tail = FALSE),3)
        
        pval_mat<-c(as.character(sid_list[c]),round(pval_agg.stat,3),round(pval_zscore,3),round(pval_stdmaxmean,3),round(pval_meta,3))
        #   return(pval_mat)
      }
    })
    
    metabset_res_pvalmat<-ldply(metabset_res1,rbind)
    
    metabset_res_qvalmat<-apply(metabset_res_pvalmat[,-c(1)],2,function(x){p.adjust(x,method="BH")})
    
    metabset_res_pvalmat<-cbind(metabset_res_pvalmat,round(metabset_res_qvalmat,3))
    
    colnames(metabset_res_pvalmat)<-c("SetID","pval.Agg.Statistic","pval.Z.score","pval.MaxMean","pval.meta","FDR.Agg.Statistic","FDR.Z.score","FDR.MaxMean","FDR.meta")
    
    res<-merge(set_statistic1,metabset_res_pvalmat,by="SetID")
    
    res<-merge(res,set_size,by="SetID")
    
    #res$Z.score<-res$MaxMean.Std
    
    #save(res,file="reschild.Rda")
    
    return(res)
    
  }
}



#metab_data: KEGGID, Statistic
#reference sets: Pathway/Module ID, KEGGID
get_fcs_child<-function(metab_data,reference_sets,itrs=1000,fcs.min.hits=2,numnodes=2){
  
  
  
  # colnames(reference_sets)<-c("SetID","Name","XID")
  count.unique.formula.overlapsize=TRUE
  dup.feature.check=TRUE
  
  
  cnames1<-colnames(metab_data)
  
  cnames1[1:2]<-c("XID","Statistic")
  
  colnames(metab_data)<-cnames1
  
  
  set_size=table(reference_sets$SetID)
  set_size<-cbind(names(set_size),set_size)
  set_size<-as.data.frame(set_size)
  colnames(set_size)<-c("SetID","Total.Size")
  
  
  metab_data_sets<-merge(metab_data,reference_sets,by="XID")
  
  ##save(metab_data_sets,metab_data,reference_sets,file="metab_data_sets.Rda")
  
  metab_data_sets<-metab_data_sets[order(metab_data_sets$SetID,metab_data_sets$Statistic,decreasing=TRUE),]
  
  if(count.unique.formula.overlapsize==TRUE){
    
    if(length(grep(colnames(metab_data_sets),pattern="Formula"))>0){
      xid_formula<-paste(metab_data_sets$SetID,"_",metab_data_sets$Formula,sep="")
      
      dup_check<-which(duplicated(xid_formula)==TRUE)
      if(length(dup_check)>0){
        metab_data_sets<-metab_data_sets[-dup_check,]
      }
    }
  }
  #  write.table(metab_data_sets,file="fcs_sets_with_statistic.txt",sep="\t",row.names=FALSE)
  metab_data_sets<-metab_data_sets[,c(1:4)]
  
  if(nrow(metab_data_sets)<1){
    
    metabset_res_mat<-{}
    
  }else{
    sid_list<-metab_data_sets$SetID;
    sid_list<-unique(sid_list)
    
    metab_data_sets$Statistic<-as.numeric(as.character(metab_data_sets$Statistic))
    
    
    set_statistic1=aggregate(metab_data_sets$Statistic,by=list(metab_data_sets$SetID),FUN=function(x){
      x<-as.numeric(as.character(x))
      # max_mean<-max(abs(mean(x[which(x>0)],na.rm=TRUE)),abs(mean(x[which(x<0)],na.rm=TRUE)),na.rm=TRUE)
      
      #max_mean<-max(c((sum(x[which(x>=0)],na.rm=TRUE)/length(x)),((-1)*sum(x[which(x<0)],na.rm=TRUE)/length(x))),na.rm=TRUE)
      
      max_mean<-max(c((sum(x[which(x>=0)],na.rm=TRUE)/length(x)),((-1)*sum(x[which(x<0)],na.rm=TRUE)/length(x))),na.rm=TRUE)
      
      resv<-c(agg.stat=sum(x,na.rm=TRUE)/length(x),zscore=sqrt(length(x))*sum(x,na.rm=TRUE)/length(x), maxmean=max_mean,numhits=length(x))
      resv<-round(resv,3)
      return(resv)
    })
    set_statistic1<-do.call(data.frame,set_statistic1)
    colnames(set_statistic1)=c("SetID","Agg.Statistic","Z.score","MaxMean","Num.Hits")
    
    
    
    #metabset_res<-parLapply(cl,1:length(sid_list),function(c,dup.feature.check,fcs.method,fcs.permutation.type){
    z.test1 = function(x=NA,mu=NA,popvar=NA,z.score=NA){
      
      one.tail.p <- NULL
      
      if(is.na(z.score)==TRUE){
        z.score <- round((mean(x)-mu)/(popvar/sqrt(length(x))),3)
      }
      one.tail.p <- round(pnorm(abs(z.score),lower.tail = FALSE),3)
      
      
      return(one.tail.p)
    }
    if(dup.feature.check==TRUE){
      
      if(length(duplicated(paste(metab_data_sets$SetID,"_",metab_data_sets$mz,"_",metab_data_sets$time,sep=""))==TRUE)>0){
        metab_data_sets<-metab_data_sets[-which(duplicated(paste(metab_data_sets$SetID,"_",metab_data_sets$mz,"_",metab_data_sets$time,sep=""))==TRUE),]
      }
    }
    
    metab_data_sets<-merge(metab_data_sets,set_size,by="SetID")
    
    
    
    cl<-makeCluster(max(numnodes,detectCores()*0.5))
    #   a=Sys.time()
    randmetabset_res<-parLapply(cl,1:itrs,function(i,metab_data_sets){
      
      set.seed(i*100)
      
      all <- sample(1:nrow(reference_sets),nrow(reference_sets))
      
      rand_reference_sets<-reference_sets
      rand_reference_sets$XID<-rand_reference_sets$XID[all]
      randmetab_data_sets<-merge(metab_data,rand_reference_sets,by="XID")
      
      
      # randmetab_data_sets<-metab_data_sets
      #  randmetab_data_sets$Statistic<-metab_data_sets$Statistic[all]
      # randmetab_data_sets$XID<-metab_data_sets$XID[all]
      
      #randmetab_data_sets[,1]<-randkeggids
      #randmetab_data_sets[,2]<-randstat
      
      randset_statistic1=aggregate(randmetab_data_sets$Statistic,by=list(randmetab_data_sets$SetID),FUN=function(x){
        
        x<-as.numeric(as.character(x))
        
        #  max_mean<-max(abs(mean(x[which(x>0)],na.rm=TRUE)),abs(mean(x[which(x<0)],na.rm=TRUE)),na.rm=TRUE)
        
        
        # max_mean<-max(abs(max(x[which(x>0)],na.rm=TRUE)/length(which(x>0))+1),abs(min(x[which(x<0)],na.rm=TRUE)/length(which(x<0))+1),na.rm=TRUE)
        
        
        #  max_mean<-max(max(x[which(x>0)],na.rm=TRUE)/length(which(x<0)),max(x[which(x<0)],na.rm=TRUE)/length(which(x<0)),na.rm=TRUE)
        
        max_mean<-max(c((sum(x[which(x>=0)],na.rm=TRUE)/length(x)),((-1)*sum(x[which(x<0)],na.rm=TRUE)/length(x))),na.rm=TRUE)
        
        resv<-c(agg.stat=sum(x,na.rm=TRUE)/length(x),zscore=sqrt(length(x))*sum(x,na.rm=TRUE)/length(x), maxmean=max_mean)
        
        resv<-round(resv,3)
        
        # resv<-as.data.frame(resv)
        return(resv)
      })
      
      return(randset_statistic1)
      
    },metab_data_sets=metab_data_sets)
    
    # b=Sys.time()
    #print(b-a)
    stopCluster(cl)
    
    randmetabset_res<-do.call(rbind, randmetabset_res)
    randmetabset_res<-do.call(data.frame, randmetabset_res)
    
    
    
    #checkhere
    
    colnames(randmetabset_res)<-c("SetID","Agg.Statistic","Z.score","MaxMean")
    
    randset_maxmean=aggregate(randmetabset_res$MaxMean,by=list(randmetabset_res$SetID),FUN=function(x){
      
      x<-as.numeric(as.character(x))
      return(c(meanval=round(mean(x,na.rm=TRUE),3),sdval=round(sd(x,na.rm=TRUE),3)))
    })
    
    randset_agg=aggregate(randmetabset_res$Agg.Statistic,by=list(randmetabset_res$SetID),FUN=function(x){
      
      x<-as.numeric(as.character(x))
      return(c(meanval=round(mean(x,na.rm=TRUE),3),sdval=round(sd(x,na.rm=TRUE),3)))
    })
    
    randset_maxmean<-do.call(data.frame,randset_maxmean)
    
    randset_agg<-do.call(data.frame,randset_agg)
    
    
    colnames(randset_maxmean)<-c("SetID","RandMeanMaxMean","RandSdMaxMean")
    
    colnames(randset_agg)<-c("SetID","RandMeanAgg","RandSdAgg")
    
    
    set_statistic1<-merge(set_statistic1,randset_maxmean,by="SetID")
    
    # set_statistic1<-merge(set_statistic1,randset_agg,by="SetID")
    
    set_statistic1$Z.score<-round((set_statistic1$Agg.Statistic-mean(set_statistic1$Agg.Statistic,na.rm=TRUE))/sd(set_statistic1$Agg.Statistic,na.rm=TRUE),3)
    
    MaxMean.Std<-round((set_statistic1$MaxMean-mean(set_statistic1$MaxMean,na.rm=TRUE))/sd(set_statistic1$MaxMean,na.rm=TRUE),3)
    set_statistic1<-cbind(set_statistic1,MaxMean.Std)
    
    randmetabset_res<-merge(randmetabset_res,randset_maxmean,by="SetID")
    randmetabset_res<-merge(randmetabset_res,randset_agg,by="SetID")
    
    RandMaxMean.Std<-(randmetabset_res$MaxMean-mean(randmetabset_res$MaxMean))/sd(randmetabset_res$MaxMean) #randmetabset_res$RandMeanMaxMean)/randmetabset_res$RandSdMaxMean
    randmetabset_res<-cbind(randmetabset_res,round(RandMaxMean.Std,3))
    
    randmetabset_res$Z.score<-(randmetabset_res$Agg.Statistic-randmetabset_res$RandMeanAgg)/randmetabset_res$RandSdAgg
    
    #set_statistic1A=merge(set_statistic1,set_size,by="SetID")
    #Norm.Agg.Statistic=set_statistic1A$Agg.Statistic/set_statistic1A$Size
    
    #   #save(set_statistic1,metab_data_sets,randset_maxmean,randmetabset_res,sid_list,file="set_statistic1.Rda")
    
    # set_statistic1$Agg.Statistic<-as.numeric(as.character(set_statistic1$Agg.Statistic))/as.numeric(as.character(metab_data_sets$Total.Size)) 
    #set_statistic1$Z.score<-as.numeric(as.character(set_statistic1$Z.score))/as.numeric(as.character(metab_data_sets$Total.Size)) 
    #set_statistic1$MaxMean<-as.numeric(as.character(set_statistic1$MaxMean))/as.numeric(as.character(metab_data_sets$Total.Size))  
    
    metabset_res1<-lapply(1:length(sid_list),function(c){
      
      
      cur_sid_rand<-randmetabset_res[which(randmetabset_res$SetID==sid_list[c]),]
      cur_sid_orig<-set_statistic1[which(set_statistic1$SetID==sid_list[c]),]
      if(nrow(cur_sid_orig)>0){
        pval_agg.stat=length(which(as.numeric(as.character(cur_sid_rand[,2]))>as.numeric(as.character(cur_sid_orig[2]))))/itrs
        
        #pval_zscore=2*pt(-abs(as.numeric(as.character(cur_sid_orig[8]))),df=as.numeric(as.character(cur_sid_orig[5]))-1) 
        pval_zscore=round(pnorm(abs(as.numeric(as.character(cur_sid_orig[8]))),lower.tail = FALSE),3)
        #pval_zscore<-length(which(as.numeric(as.character(cur_sid_rand[,9]))>as.numeric(as.character(cur_sid_orig[8]))))/itrs
        
        
        pval_stdmaxmean=length(which(as.numeric(as.character(cur_sid_rand[,4]))>as.numeric(as.character(cur_sid_orig[4]))))/itrs
        
        #meanp_val=mean(c(pval_agg.stat,pval_zscore,pval_stdmaxmean),na.rm=TRUE)
        # zval=(0.5-meanp_val)*sqrt(12*3)
        #log(pval_agg.stat),
        
        #log(pval_agg.stat),
        chisq_stat<-(-2)*sum(c(log(pval_zscore),log(pval_stdmaxmean)))
        pval_meta <-pchisq(chisq_stat,df=4,lower.tail=FALSE) #df: 2 x k #round(pnorm((zval),lower.tail = FALSE),3)
        
        pval_mat<-c(as.character(sid_list[c]),round(pval_agg.stat,3),round(pval_zscore,3),round(pval_stdmaxmean,3),round(pval_meta,3))
        #   return(pval_mat)
      }
    })
    
    metabset_res_pvalmat<-ldply(metabset_res1,rbind)
    
    metabset_res_qvalmat<-apply(metabset_res_pvalmat[,-c(1)],2,function(x){p.adjust(x,method="BH")})
    
    metabset_res_pvalmat<-cbind(metabset_res_pvalmat,round(metabset_res_qvalmat,3))
    
    colnames(metabset_res_pvalmat)<-c("SetID","pval.Agg.Statistic","pval.Z.score","pval.MaxMean","pval.meta","FDR.Agg.Statistic","FDR.Z.score","FDR.MaxMean","FDR.meta")
    
    res<-merge(set_statistic1,metabset_res_pvalmat,by="SetID")
    
    res<-merge(res,set_size,by="SetID")
    #  #save(res,file="reschild.Rda")
    
    
    
    
    
    if(FALSE)
    {
      pdf("QQplot.FCS.pdf")
      par(mfrow=c(2,2))
      my.pvalues=as.numeric(as.character(res$pval.Agg.Statistic))
      exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
      plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-meanStatistic")
      abline(0,1)
      
      my.pvalues=as.numeric(as.character(res$pval.Z.score))
      exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
      plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-Zscore")
      abline(0,1)
      
      my.pvalues=as.numeric(as.character(res$pval.MaxMean))
      exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
      plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-maxmean")
      abline(0,1)
      
      my.pvalues=as.numeric(as.character(res$pval.meta))
      exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
      plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-meta")
      abline(0,1)
      
      dev.off()
    }
    
    return(res)
    
  }
}

#metab_data: KEGGID, Statistic
#reference sets: Pathway/Module ID, KEGGID
#v1.0.8.49
get_fcs_child_v1.0.8.53<-function(metab_data,reference_sets,itrs=1000,fcs.min.hits=2,numnodes=2){
  
  
  
  # colnames(reference_sets)<-c("SetID","Name","XID")
  count.unique.formula.overlapsize=TRUE
  dup.feature.check=TRUE
  
  
  cnames1<-colnames(metab_data)
  
  cnames1[1:2]<-c("XID","Statistic")
  
  colnames(metab_data)<-cnames1
  
  scale_stat<-scale(metab_data$Statistic)
  
  metab_data<-cbind(metab_data,scale_stat)
  colnames(metab_data)<-c(cnames1,"Scaled.Statistic")
  
  
  set_size=table(reference_sets$SetID)
  set_size<-cbind(names(set_size),set_size)
  set_size<-as.data.frame(set_size)
  colnames(set_size)<-c("SetID","Total.Size")
  
  
  metab_data_sets<-merge(metab_data,reference_sets,by="XID")
  
  # #save(metab_data_sets,metab_data,reference_sets,set_size,file="metab_data_sets0.Rda")
  
  metab_data_sets<-metab_data_sets[order(metab_data_sets$SetID,metab_data_sets$Statistic,decreasing=TRUE),]
  
  if(count.unique.formula.overlapsize==TRUE){
    
    if(length(grep(colnames(metab_data_sets),pattern="Formula"))>0){
      xid_formula<-paste(metab_data_sets$SetID,"_",metab_data_sets$Formula,sep="")
      
      dup_check<-which(duplicated(xid_formula)==TRUE)
      if(length(dup_check)>0){
        metab_data_sets<-metab_data_sets[-dup_check,]
      }
    }
  }
  #  write.table(metab_data_sets,file="fcs_sets_with_statistic.txt",sep="\t",row.names=FALSE)
  metab_data_sets<-metab_data_sets[,c(1:5)]
  
  
  
  if(nrow(metab_data_sets)<1){
    
    metabset_res_mat<-{}
    
  }else{
    sid_list<-metab_data_sets$SetID;
    sid_list<-unique(sid_list)
    
    metab_data_sets$Statistic<-as.numeric(as.character(metab_data_sets$Statistic))
    
    metab_data_sets$Scaled.Statistic<-as.numeric(as.character(metab_data_sets$Scaled.Statistic))
    
    metab_data_sets<-merge(metab_data_sets,set_size,by="SetID")
    
    cl<-makeCluster(max(numnodes,detectCores()*0.5))
    
    agg_res<-parLapply(cl,1:length(sid_list),function(c,metab_data_sets,sid_list){
      
      
      x<-metab_data_sets$Statistic[which(metab_data_sets$SetID==sid_list[c])]
      
      x<-as.numeric(as.character(x))
      
      scaledx<-metab_data_sets$Scaled.Statistic[which(metab_data_sets$SetID==sid_list[c])]
      
      scaledx<-abs(as.numeric(as.character(scaledx)))
      
      set_size=as.numeric(as.character(metab_data_sets$Total.Size[which(metab_data_sets$SetID==sid_list[c])]))
      
      agg.stat<-sum((x))/set_size
      
      agg.scaled.stat<-sum(scaledx)/set_size
      
      z.score=sqrt(set_size)*agg.scaled.stat
      
      max_mean<-max(c(mean(x[which(x>0)],na.rm=TRUE),mean(x[which(x<0)],na.rm=TRUE)),na.rm=TRUE)/set_size
      
      resv=cbind(as.character(sid_list[c]),round(agg.stat,3),round(agg.scaled.stat,3),round(z.score,3),round(max_mean,3),length(x),set_size,round(sum(abs(x)),3))
      resv=as.data.frame(resv)
      resv=unique(resv)
      # print(resv)
      return(resv)
      
    },metab_data_sets=metab_data_sets,sid_list=sid_list)
    
    stopCluster(cl)
    
    set_statistic1<-ldply(agg_res,rbind) #do.call(data.frame,agg_res)
    colnames(set_statistic1)=c("SetID","Agg.Statistic","Agg.Scaled.Statistic","Z.score","MaxMean","Num.Hits","Total.Size","Sum.Statistic")
    
    
    set_statistic1$MaxMean<-as.numeric(as.character(set_statistic1$MaxMean))
    set_statistic1$Agg.Statistic<-as.numeric(as.character(set_statistic1$Agg.Statistic))
    set_statistic1$Z.score<-as.numeric(as.character(set_statistic1$Z.score))
    
    set_statistic1$Sum.Statistic<-as.numeric(as.character(set_statistic1$Sum.Statistic))
    
    set_statistic1$Z.score<-scale(set_statistic1$MaxMean)
    
    # #save(metab_data_sets,sid_list,set_size,set_statistic1,file="sid1.rda")
    
    
    #metab_data_sets<-metab_data_sets[,-c(4)]
    #metabset_res<-parLapply(cl,1:length(sid_list),function(c,dup.feature.check,fcs.method,fcs.permutation.type){
    z.test1 = function(x=NA,mu=NA,std=NA,z.score=NA){
      
      one.tail.p <- NULL
      
      if(is.na(z.score)==TRUE){
        z.score <- round((mean(x)-mu)/(std),3)
      }
      one.tail.p <- round(pnorm(abs(z.score),lower.tail = FALSE),3)
      
      
      return(one.tail.p)
    }
    if(dup.feature.check==TRUE){
      
      if(length(grep(colnames(metab_data_sets),"mz")[1])>0){ if(length(duplicated(paste(metab_data_sets$SetID,"_",metab_data_sets$mz,"_",metab_data_sets$time,sep=""))==TRUE)>0){
        metab_data_sets<-metab_data_sets[-which(duplicated(paste(metab_data_sets$SetID,"_",metab_data_sets$mz,"_",metab_data_sets$time,sep=""))==TRUE),]
      }
      }
      
    }
    
    
    metab_data_sets$SetID<-as.character(metab_data_sets$SetID)
    
    #  print("Start here")
    ##save(metab_data_sets,sid_list,itrs,file="sid2.rda")
    cl<-makeCluster(max(numnodes,detectCores()*0.5))
    
    clusterEvalQ(cl,library(plyr))
    #   a=Sys.time()
    #parLapply(cl,
    randmetabset_res<-parLapply(cl,1:itrs,function(i,metab_data_sets,sid_list){
      
      set.seed(i)
      all <- sample(1:nrow(metab_data_sets),nrow(metab_data_sets))
      randmetab_data_sets<-metab_data_sets
      randmetab_data_sets$XID<-metab_data_sets$XID[all]
      
      randmetab_data_sets$Statistic<-metab_data_sets$Statistic[all]
      
      randmetab_data_sets$Scaled.Statistic<-metab_data_sets$Scaled.Statistic[all]
      
      agg_res<-lapply(1:length(sid_list),function(c){
        
        x<-randmetab_data_sets$Statistic[which(metab_data_sets$SetID==sid_list[c])]
        
        x<-as.numeric(as.character(x))
        
        
        set_size=as.numeric(as.character(metab_data_sets$Total.Size[which(metab_data_sets$SetID==sid_list[c])]))
        
        agg.stat<-sum((x))/set_size
        
        agg.scaled.stat<-agg.stat
        
        z.score=sqrt(set_size)*agg.scaled.stat
        
        max_mean<-max(mean(x[which(x>0)],na.rm=TRUE),mean(x[which(x<0)],na.rm=TRUE),na.rm=TRUE)/set_size
        
        resv=cbind(as.character(sid_list[c]),round(agg.stat,3),round(agg.scaled.stat,3),round(z.score,3),round(max_mean,3),length(x),set_size,round(sum(abs(x)),3))
        resv=as.data.frame(resv)
        
        resv=unique(resv)
        
        return(resv)
      })
      
      agg_res<-ldply(agg_res,rbind)
      return(agg_res)
      
    },metab_data_sets=metab_data_sets,sid_list=sid_list)
    
    # b=Sys.time()
    #print(b-a)
    stopCluster(cl)
    
    
    
    #  print("End here")
    
    randmetabset_res<-ldply(randmetabset_res,rbind) #do.call(data.frame,agg_res)
    colnames(randmetabset_res)=c("SetID","Agg.Statistic","Agg.Scaled.Statistic","Z.score","MaxMean","Num.Hits","Total.Size","Sum.Statistic")
    
    # #save(randmetabset_res,file="r1.rda")
    
    randmetabset_res$MaxMean<-as.numeric(as.character(randmetabset_res$MaxMean))
    
    randmetabset_res[,-c(1)]<-apply(randmetabset_res[,-c(1)],2,function(x){as.numeric(as.character(x))})
    
    randmetabset_res_maxmean_avg<-mean(randmetabset_res$MaxMean,na.rm=TRUE)
    randmetabset_res_maxmean_std<-sd(randmetabset_res$MaxMean,na.rm=TRUE)
    
    #checkhere
    
    
    meanp.agg<-function (p)
    {
      keep <- (p >= 0) & (p <= 1)
      invalid <- sum(1L * keep) < 2
      if (invalid) {
        warning("Must have at least four valid p values")
        res <- list(z = NA_real_, p = NA_real_, validp = p[keep])
      }
      else {
        pi <- mean(p[keep])
        k <- length(p[keep])
        z <- (0.5 - pi) * sqrt(12 * k)
        if (k != length(p)) {
          warning("Some studies omitted")
        }
        res <- list(z = z, p = pnorm(z, lower.tail = FALSE),
                    validp = p[keep])
      }
      #class(res) <- c("meanp", "metap")
      res
    }
    
    set_statistic1<-as.data.frame(set_statistic1)
    
    # #save(set_statistic1,randmetabset_res,sid_list,file="r2.rda")
    
    
    metabset_res1<-lapply(1:length(sid_list),function(c){
      
      
      cur_sid_rand<-randmetabset_res[which(as.character(randmetabset_res$SetID)==sid_list[c]),]
      cur_sid_orig<-set_statistic1[which(as.character(set_statistic1$SetID)==sid_list[c]),]
      
      
      if(nrow(cur_sid_orig)>0){
        pval_agg.stat=length(which(as.numeric(as.character(cur_sid_rand[,2]))>as.numeric(as.character(cur_sid_orig[1,2]))))/itrs
        
        
        
        #maxmean z-transformation
        z.score=(as.numeric(as.character(cur_sid_orig[1,5]))-mean(as.numeric(as.character(cur_sid_rand[,5])),na.rm=TRUE))/sd(as.numeric(as.character(cur_sid_rand[,5])),na.rm=TRUE)
        
        #randmetabset_res_maxmean_avg)/randmetabset_res_maxmean_std
        
        pval_zscore=round(pnorm(abs(z.score),lower.tail = FALSE),3) #length(which(as.numeric(as.character(cur_sid_rand[,3]))>as.numeric(as.character(cur_sid_orig[3]))))/itrs
        pval_stdmaxmean=length(which(as.numeric(as.character(cur_sid_rand[,5]))>as.numeric(as.character(cur_sid_orig[1,5]))))/itrs
        
        # meanp_val=mean(c(pval_agg.stat,pval_zscore,pval_stdmaxmean),na.rm=TRUE)
        #zval=(0.5-meanp_val)*sqrt(12*3)
        
        
        # pval_meta <- pval_stdmaxmean
        
        pval_meta <-meanp.agg(c(pval_agg.stat,pval_stdmaxmean))$p
        
        ##save(pval_meta,pval_agg.stat,pval_zscore,pval_stdmaxmean,file="pdebug.Rda")
        #round(pnorm((zval),lower.tail = FALSE),3)
        
        pval_mat<-c(as.character(sid_list[c]),round(pval_agg.stat,3),round(pval_zscore,3),round(pval_stdmaxmean,3),round(pval_meta,3))
        #   return(pval_mat)
      }
    })
    
    metabset_res_pvalmat<-ldply(metabset_res1,rbind)
    # #save(metabset_res_pvalmat,file="metabset_res_pvalmat.Rda")
    metabset_res_qvalmat<-apply(metabset_res_pvalmat[,-c(1)],2,function(x){p.adjust(as.numeric(as.character(x)),method="BH")})
    
    metabset_res_pvalmat<-cbind(metabset_res_pvalmat,round(metabset_res_qvalmat,3))
    
    colnames(metabset_res_pvalmat)<-c("SetID","pval.Agg.Statistic","pval.Z.score","pval.MaxMean","pval.meta","FDR.Agg.Statistic","FDR.Z.score","FDR.MaxMean","FDR.meta")
    
    res<-merge(set_statistic1,metabset_res_pvalmat,by="SetID")
    
    res<-merge(res,set_size,by="SetID")
    
    #save(res,file="reschild2.Rda")
    
    pdf("QQplot.pdf")
    my.pvalues=as.numeric(as.character(res$pval.MaxMean))
    exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
    plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-maxmean")
    abline(0,1)
    dev.off()
    
    if(FALSE){
      par(mfrow=c(2,2))
      my.pvalues=as.numeric(as.character(res$pval.Agg.Statistic))
      exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
      plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-meanStatistic")
      abline(0,1)
      
      my.pvalues=as.numeric(as.character(res$pval.Z.score))
      exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
      plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-Zscore")
      abline(0,1)
      
      
      
      my.pvalues=as.numeric(as.character(res$pval.meta))
      exp.pvalues<-(rank(my.pvalues, ties.method="first")+.5)/(length(my.pvalues)+1)
      plot(-log10(exp.pvalues), -log10(my.pvalues), asp=1,main="QQplot-meta")
      abline(0,1)
      
      dev.off()
    }
    
    return(res)
    
  }
}

get_kegg_compounds_brite <- function(keggid) {
  Sys.sleep(0.5)
  b1 <- keggGet(keggid) #paste("cpd:", keggid, sep = ""))
  
  
  if(length(b1[[1]]$BRITE)>0){
    
    brite_inf<-b1[[1]]$BRITE
    
    
    brite_inf <- brite_inf[grep(brite_inf,pattern="BR:br")]
    
    brite_ids<-str_extract(brite_inf,pattern="BR:br[0-9]*")
    brite_name<-gsub(brite_inf,pattern=" [BR:br[0-9]*]",replacement="")
    
    exact_mass<-b1[[1]]$EXACT_MASS
    cformula<-b1[[1]]$FORMULA
    
    
    #otherdb_inf <- paste(b1[[1]]$DBLINKS, collapse = ";")
    r1 <- cbind(as.character(keggid),as.character(brite_ids), as.character(brite_name), exact_mass,cformula)
    colnames(r1)<-c("XID","SetID","Name","ExactMass","Formula")
    
    return(r1)
  }
  
  
}



#get KEGG IDs for all pathways/modules for a given species id
get_kegg_compounds<-function(kegg_species_code="hsa",database="pathway"){
  
  options(warn=-1)
  
  
  
  if(database=="pathway"){
    path_list<-keggList(kegg_species_code,database=database)
    
    kegg_pathway_ids<-names(path_list)
    kegg_pathway_ids<-gsub(kegg_pathway_ids,pattern="path:",replacement="")
  }else{
    
    if(database=="module"){
      
      path_list<-keggList(database=database)
      
      kegg_pathway_ids<-names(path_list)
      kegg_pathway_ids<-gsub(kegg_pathway_ids,pattern="md:",replacement="")
    }else{
      if(database=="brite"){
        path_list<-keggList(database="cpd")
        kegg_cpd_ids<-names(path_list) #[1:2]
        
        cl<-makeCluster(2)
        clusterExport(cl,"get_kegg_compounds_brite")
        clusterEvalQ(cl,library(KEGGREST))
        clusterEvalQ(cl,library(stringr))
        res<-parLapply(cl,1:length(kegg_cpd_ids),function(x,kegg_cpd_ids){
          
          Sys.sleep(0.5)
          keggid<-kegg_cpd_ids[x]
          restemp<-try(get_kegg_compounds_brite(keggid),silent=TRUE)
          Sys.sleep(0.5)
          if(is(restemp,"try-error")){
            # print(restemp)
            #print(keggid)
            #fname1<-paste("bad",keggid,".Rda",sep="")
            ##save(keggid,file=fname1)
          }else{
            return(restemp)
          }
        },kegg_cpd_ids=kegg_cpd_ids)
        
        res<-do.call(rbind,res)
        res<-as.data.frame(res)
        colnames(res)<-c("XID","SetID","Name","ExactMass","Formula")
        
        kegg_cpd_mat<-cbind(names(path_list),path_list)
        colnames(kegg_cpd_mat)<-c("KEGGID","Name")
        #  #save(kegg_cpd_mat,file="kegg_cpd_mat.Rda")
        stopCluster(cl)
        
        return(res)
        #kegg_pathway_ids<-gsub(kegg_pathway_ids,pattern="br:",replacement="")
      }else{
        
        if(database=="reaction"){
          path_list<-keggList(database=database)
          kegg_pathway_ids<-names(path_list)
          
          kegg_pathway_ids<-gsub(kegg_pathway_ids,pattern="rn:",replacement="")
        }else{
          
          if(database=="disease"){
            path_list<-keggList(database=database)
            kegg_pathway_ids<-names(path_list)
            
            kegg_pathway_ids<-gsub(kegg_pathway_ids,pattern="ds:",replacement="")
          }
        }
      }
      
    }
  }
  
  
  
  kegg_pathway_ids<-kegg_pathway_ids
  kegg_comp_list<-{}
  map_res<-{}
  kegg_module_list<-{}
  
  path_name_id_mapping<-cbind(kegg_pathway_ids,path_list)
  path_name_id_mapping<-as.data.frame(path_name_id_mapping)
  
  
  colnames(path_name_id_mapping)<-c("SetID","Name")
  
  
  
  path_comp_mat<-{}
  cl<-makeCluster(detectCores()*0.25)
  clusterExport(cl,"keggGet",envir = .GlobalEnv)
  clusterEvalQ(cl,library(KEGGREST))
  #
  path_comp_mat<-parLapply(cl,1:length(kegg_pathway_ids),function(p,kegg_pathway_ids)
  {
    kegg_pathway_id=kegg_pathway_ids[p]
    Sys.sleep(0.5)
    k1<-keggGet(dbentries=kegg_pathway_id)
    
    kegg_comp_list<-c(kegg_comp_list,k1[[1]]$COMPOUND)
    
    if(length(kegg_comp_list)<1){
      print("bad")
      print(kegg_pathway_id)
      kegg_module_list<-c(kegg_module_list,k1[[1]]$MODULE)
      
    }else{
      path_comp_mat_temp<-cbind(kegg_pathway_id,names(k1[[1]]$COMPOUND))
      
      if(length(path_comp_mat_temp)>0){
        
        if(ncol(path_comp_mat_temp)==2){
          
          return(path_comp_mat_temp)
        }
      }
    }
    Sys.sleep(0.05)
  },kegg_pathway_ids=kegg_pathway_ids)
  stopCluster(cl)
  path_comp_mat<-do.call(rbind,path_comp_mat)
  
  
  colnames(path_comp_mat)<-c("SetID","KEGGID")
  
  path_comp_mat<-merge(path_name_id_mapping,path_comp_mat,by.x="SetID",by.y="SetID")
  
  ##save(path_comp_mat,file="path_comp_mat.Rda")
  
  t1=table(path_comp_mat$SetID)
  
  
  # load("/Users/karanuppal/Documents/Emory/JonesLab/Projects/DifferentialExpression/xmsPaNDA/xmsPANDA_v1.1.46/data/kegg_rno.rda")
  #path_comp_mat<-kegg_rno
  cl<-makeCluster(max(2,detectCores()*0.1))
  clusterExport(cl,"keggGet",envir = .GlobalEnv)
  clusterEvalQ(cl,library(KEGGREST))
  
  unique_keggIDs<-unique(path_comp_mat$KEGGID)
  
  #length(unique_keggIDs)
  kegg_comp_mat<-parLapply(cl,1:length(unique_keggIDs),function(p,unique_keggIDs)
  {
    Sys.sleep(0.5)
    k1<-keggGet(dbentries=as.character(unique_keggIDs[p]))
    
    res<-c(as.character(unique_keggIDs[p]),k1[[1]]$EXACT_MASS,k1[[1]]$FORMULA)
    Sys.sleep(0.5)
    return(res)
  },unique_keggIDs=unique_keggIDs)
  stopCluster(cl)
  
  
  kegg_comp_mat<-do.call(rbind,kegg_comp_mat)
  # #save(kegg_comp_mat,file="kegg_comp_mat.Rda")
  
  kegg_comp_mat<-as.data.frame(kegg_comp_mat)
  colnames(kegg_comp_mat)<-c("XID","ExactMass","Formula")
  path_comp_mat=merge(path_comp_mat,kegg_comp_mat,by="KEGGID")
  
  colnames(path_comp_mat)<-c("XID","SetID","Name","ExactMass","Formula")
  #kegg_rno<-path_comp_mat
  #    #save(kegg_rno,file="/Users/karanuppal/Documents/Emory/JonesLab/Projects/DifferentialExpression/xmsPaNDA/xmsPANDA_v1.1.46/data/new/kegg_rno.Rda")
  
  #c("KEGGID","SetID","Name","ExactMass","Formula")
  
  
  options(warn=0)
  return(path_comp_mat)
}


#function to calculate diffRank between class 1 vs other classes
diffrank_eval<-function(feature_table_file=NA,class_labels_file=NA,X=NA,Y=NA,sigfeats=NA,
                        sigfeatsind=NA,cor.method="pearson",num_nodes=2,abs.cor.thresh=0.4,pvalue.thresh=0.005,
                        cor.fdrthresh=0.2,fdrmethod="Strimmer",degree.centrality.method="eigenvector",alphabetical.order=FALSE,
                        node_names=NA,plot_graph_bool=FALSE,networktype="complete"){
  
  suppressMessages(library(WGCNA))
  
  #print("degree eval")
  
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  }else{
    
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
  }else{
    
    classlabels<-Y
  }
  
  
  classlabels<-as.data.frame(classlabels)
  #print(dim(classlabels))
  # print(length(classlabels))
  
  
  if(dim(classlabels)[2]>2){
    
    if(alphabetical.order==FALSE){
      
      classlabels[,2]<-factor(classlabels[,2],levels=unique(classlabels[,2]))
      classlabels[,3]<-factor(classlabels[,3],levels=unique(classlabels[,3]))
      
    }
    
    classgroup<-paste(classlabels[,2],":",classlabels[,3],sep="") #classlabels[,2]:classlabels[,3]
  }else{
    
    if(alphabetical.order==FALSE){
      
      classlabels[,2]<-factor(classlabels[,2],levels=unique(classlabels[,2]))
     
    }
    
    classgroup<-classlabels[,2]
  }
  
  classlabels<-as.data.frame(classlabels)
  
  if(alphabetical.order==FALSE){
    
    classgroup<-factor(classgroup,levels=unique(classgroup))
    class_labels_levels<-levels(as.factor(classgroup))
    
  }else{
    class_labels_levels<-levels(as.factor(classgroup))
  }
#  rnames<-paste(sprintf("%.4f",data_matrix$mz),data_matrix$time,sep="_")
  
  rnames<-paste(data_matrix$mz,data_matrix$time,sep="_")
  
  data_matrix_orig<-data_matrix
  
  #addition start
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        name=Name
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          name=Name
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame(data_matrix)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
    
    data_matrix<-data_matrix[,-c(1:2)]
    
    #names_with_mz_time=cbind(paste(data_matrix$mz,"_",data_matrix$time,sep=""),data_matrix$mz,data_matrix$time)
    #colnames(names_with_mz_time)<-c("Name","mz","time")
    #names_with_mz_time<-as.data.frame(names_with_mz_time)
    
  }
  
  
  

  #data_matrix<-na.omit(data_matrix)
  
  rnamesAB<-gsub(pattern="NA_NA",replacement=NA,x=rnames)
  rnamesAB<-na.omit(rnamesAB)
  
  nSets = length(class_labels_levels);
  multiExpr = vector(mode = "list", length = nSets)
  data_matrix_list<-new("list")
  num_samps_groups<-new("list")
  degree_list<-new("list")
  
  data_matrix_all<-t(data_matrix)
  
  
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(data=data_matrix_all, dataIsExpr=TRUE,powerVector = powers, verbose = 0)
  power_val=sft$powerEstimate
  
  if(is.na(power_val)==TRUE){
    power_val=6
  }
  
  
  
  #degree_overall<-softConnectivity(datExpr=data_matrix_all,power=power_val,minNSamples=10)
  #degree_overall<-replace(degree_overall,which(degree_overall<0),0)
  
  
  sig_status<-rep(0,dim(data_matrix_orig)[1])
  
  colors_met<-cbind(data_matrix_orig[,c(1:2)],sig_status)
  
  colors_met<-as.data.frame(colors_met)
  
  colors_met$sig_status[sigfeatsind]=1
  
  colnames(colors_met)<-c("mz","time","sig_status")
  
  colnames_vec<-c("mz","time","sig_status")
  
  sig_ind<-which(colors_met$sig_status==1)
  
  
  names=paste(round(colors_met$mz,4),round(colors_met$time,0),sep="_")
  
  #names=paste(round(colors_met$mz,4),sep="_")
  
 
  
  cl<-makeCluster(max(2,detectCores()*0.5))
  clusterEvalQ(cl,library(WGCNA))
  clusterEvalQ(cl,library(parallel))
  clusterEvalQ(cl,library(corpcor))
  # save(data_matrix,abs.cor.thresh,cor.method,pvalue.thresh,power_val,class_labels_levels,node_names,classgroup,file="diffrankdebug.Rda")
  
  adj_mat_list<-parLapply(cl,1:length(class_labels_levels),function(i,data_matrix,abs.cor.thresh,cor.method,pvalue.thresh,power_val,class_labels_levels,classgroup){
  # adj_mat_list<-lapply(1:length(class_labels_levels),function(i,data_matrix,abs.cor.thresh,cor.method,pvalue.thresh,power_val,class_labels_levels,classgroup){
    
     print(i)
    data_matrix_list<-t(data_matrix[,which(classgroup==class_labels_levels[i])])
    num_samps_groups<-dim(data_matrix_list)[1]
    
    num_nodes=max(2,detectCores()*0.5)
    
    if(networktype=="complete"){
    #cor.method="pearson"
    simmat<-suppressWarnings(WGCNA::cor(data_matrix_list,nThreads=num_nodes,method=cor.method,use = 'p'))
    }else{
      
      simmat<-suppressWarnings(pcor.shrink(data_matrix_list))
      
      simmat<-replace(simmat,which(simmat>1),1)
      simmat<-replace(simmat,which(simmat<(-1)),-1)
      
    }
    if(length(which(is.na(simmat)==TRUE))>0){
      
      simmat<-replace(simmat,which(is.na(simmat)==TRUE),0)
      #ADJdataOne<-NA
      
      cor_vec=seq(0,1,0.01)
      #pvalues_vec<-corPvalueStudent(cor=cor_vec,nSamples=num_samps_groups[i])
     # abs.cor.thresh=max(abs.cor.thresh,min(cor_vec[which(pvalues_vec<pvalue.thresh)],na.rm=TRUE),na.rm=TRUE)
      
      simmat[which(abs(simmat)<abs.cor.thresh)]<-0
      
      rownames(simmat)<-rnamesAB
      colnames(simmat)<-rnamesAB
      
      
      #".corthresh",abs.cor.thresh,
      fname=paste("Tables/cor.matrix.allfeatures.class",class_labels_levels[i],".txt",sep="")
      #write.table(simmat,file=fname,sep="\t")
      
      simmat_sig<-simmat[sigfeatsind,sigfeatsind]
      
      fname=paste("Tables/cor.matrix.selectedfeatures.class",class_labels_levels[i],".txt",sep="")
      write.table(simmat_sig,file=fname,sep="\t")
      
      power_val=1
      #adjacency matrix for all features
      ADJdataOne<-simmat
    }else{
    simmat<-round(simmat,3)
    
    #simmat<-replace(simmat,which(is.na(simmat)==TRUE),0)
    pearson_resvec<-as.vector(simmat)
    
    
    cor_vec=seq(0,1,0.01)
   # pvalues_vec<-corPvalueStudent(cor=cor_vec,nSamples=num_samps_groups[i])
    #abs.cor.thresh=max(abs.cor.thresh,min(cor_vec[which(pvalues_vec<pvalue.thresh)],na.rm=TRUE),na.rm=TRUE)
    
    simmat[which(abs(simmat)<abs.cor.thresh)]<-0
   
    rownames(simmat)<-rnamesAB
    colnames(simmat)<-rnamesAB
    
    
    
    fname=paste("Tables/cor.matrix.allfeatures.class",class_labels_levels[i],".corthresh",abs.cor.thresh,".txt",sep="")
    #write.table(simmat,file=fname,sep="\t")
    
    simmat_sig<-simmat[sigfeatsind,sigfeatsind]
    
    fname=paste("Tables/cor.matrix.selectedfeatures.class",class_labels_levels[i],".corthresh",abs.cor.thresh,".txt",sep="")
    write.table(simmat_sig,file=fname,sep="\t")
    
    power_val=1
    #adjacency matrix for all features
    ADJdataOne<-simmat #adjacency.fromSimilarity(similarity=simmat,power=power_val,type="signed")
    }
   
    return(ADJdataOne)
  },data_matrix=data_matrix,abs.cor.thresh=abs.cor.thresh,cor.method=cor.method,pvalue.thresh=pvalue.thresh,power_val=power_val,
  class_labels_levels=class_labels_levels,classgroup=classgroup)
   
  stopCluster(cl)
  
  
  if(plot_graph_bool==TRUE){
    
    pdf("Figures/DiNa_graphs.pdf")
    
  }
  
  
  count_connections_perclass<-lapply(1:length(class_labels_levels),function(i){
    print(i)
    
    diag(adj_mat_list[[i]])<-0
    
    length(which(abs(adj_mat_list[[i]])>abs.cor.thresh))
                  
  })
  
  count_connections_perclass<-unlist(count_connections_perclass)
  
 # save(count_connections_perclass,adj_mat_list,class_labels_levels,file="debugnames.Rda")
  
  names(count_connections_perclass)<-class_labels_levels #rownames(adj_mat_list[[1]])
  
  if(plot_graph_bool==TRUE){
    
    barplot(count_connections_perclass,main=paste("total # of connections per class\n |r| threshold: ", abs.cor.thresh,sep=""),
            horiz=TRUE,las=2,cex.text=0.7,col="#69b3a2",xlab="Number of connections",cex.lab=0.7,cex.axis=0.7,cex.names=0.5)
    par(mfrow=c(2,2))
  }
  
  if(min(count_connections_perclass,na.rm=TRUE)>0){
    
    ignore.edge.weights=FALSE
  }else{
    
    ignore.edge.weights=TRUE
  }
  
  ignore.edge.weights=FALSE
  
  
  #the first class is used as reference
  diffrank_list<-lapply(2:length(class_labels_levels),function(i){
   # print(i)
   # if(typeof(adj_mat_list[[i]])!="logical"){
    #save(i,adj_mat_list,degree.centrality.method,class_labels_levels,file="m1.Rda")
    
    if(count_connections_perclass[i]>0){
      
      #Returns delta centrality between groups
    res<-diffRank(adj_mat_list[[1]],adj_mat_list[[i]],degree.centrality.method=degree.centrality.method,
                  class_labels=c(class_labels_levels[1],class_labels_levels[i]),node_names=node_names,plot_graph_bool=plot_graph_bool,ignore.edge.weights=ignore.edge.weights)
    
    
    
    return(res)
    }else{
      
      res<-rep(NA,nrow(adj_mat_list[[1]]))
    }
    
  })
  if(plot_graph_bool==TRUE){
    
  dev.off()
    
  }
#  save(diffrank_list,class_labels_levels,file="diffrank_list.Rda")
  
  diffrank_mat<-do.call("cbind",diffrank_list)
  
  
  
  if(length(class_labels_levels)>2){
    
    diffrank_res<-apply(diffrank_mat,1,function(x){max(x,na.rm=TRUE)})
    
    diffrank_res_rank<-rank(-1*diffrank_res)
    colnames_vec<-c("mz","time","sigstatus","Max.Delta.Centrality","DiffRank",paste("DiffRank.",class_labels_levels[1],"vs",class_labels_levels[-1],sep=""))
    colors_met_all<-cbind(colors_met,diffrank_res,diffrank_res_rank,diffrank_mat)
    
    
  }else{
    diffrank_res<-diffrank_mat
    
    diffrank_res_rank<-rank(-1*diffrank_res)
    
    colnames_vec<-c("mz","time","sigstatus","Delta.Centrality","DiffRank")
    colors_met_all<-cbind(colors_met,diffrank_res,diffrank_res_rank)
    
    
  }
  
  
  
  colors_met_all<-as.data.frame(colors_met_all)
  colnames(colors_met_all)<-colnames_vec
  
  
  #write.table(colors_met_all,file="Tables/DiNA_eval_allfeats.txt",sep="\t",row.names=FALSE)
  
  sub_colors_met<-{}
  if(is.na(sigfeats)==FALSE){
    sub_colors_met<-colors_met_all[sigfeatsind,]
    #write.table(sub_colors_met,file="Tables/DiNA_eval_selectfeats.txt",sep="\t",row.names=FALSE)
  }
  
  ####saveMET,file="MET.Rda")
  
  colnames(diffrank_mat)<-paste("DiffRank.",class_labels_levels[1],"vs",class_labels_levels[-1],sep="")
  
  rownames(diffrank_mat)<-rownames(adj_mat_list[[1]])
  write.table(diffrank_mat,file="Tables/DiNA_pairwisedeltacentrality.txt",sep="\t",row.names=TRUE)
  
  if(plot_graph_bool==TRUE){
    pdf("Figures/DiNA_delta_centrality.pdf") 
    
    for(i in 1:ncol(diffrank_mat)){
      
      try(barplot(diffrank_mat[,i],main=paste("", colnames(diffrank_mat)[i],sep=""),
              horiz=TRUE,las=2,cex.text=0.7,col="#69b3a2",xlab=paste("Delta centrality (",degree.centrality.method,")",sep=""),
              cex.lab=0.7,cex.axis=0.7,cex.names=0.5,xlim=c(0,1)),silent=TRUE)
    }
    
    dev.off()
  }
  
  return(list(all=colors_met_all,sigfeats=sub_colors_met))
}



do_cv<-function(v,x,y,kname="radial",errortype="CV",conflevel=95,classifier="SVM",seednum=555){
  
  
  num_samp=dim(x)[1]
  
  if(length(num_samp)<1){
    num_samp<-length(x)
    x<-as.data.frame(x)
  }    
  y<-as.data.frame(y)
  
  num_datasets= floor(num_samp)
  n1<-floor(num_samp/v)
  n2<-num_samp-n1*v
  n3<-v-n2
  
  ind<-rep(c(n1,n1+1),c(n3,n2))
  ind<-diffinv(ind)
  min_err=1
  best_k=1
  
  set.seed(seednum)
  group<-sample(1:num_samp,num_samp, replace=FALSE)
  
  
  itr=0
  #svm_acc <- matrix(0,v)  # we set K=30 before, it can be changed to any number<100.
  svm_acc<-rep(0,v)
  for ( i in 1:v)
  {
    g<-group[(ind[i]+1):ind[i+1]]
    temptest<-x[g,]
    temptrain <-x[-g,]
    tempclass <-y[-g,]
    testclass<-y[g,]
    
    
    if(classifier=="SVM"){
      mod_cv <- svm(x=temptrain,y=tempclass, type="nu-classification",kernel=kname)
      
      
      if(v==num_samp){
        
        predfit<-predict(mod_cv,(temptest))
        
      }else{
        predfit<-predict(mod_cv,(temptest))
      }
      
      
    }else{
      if(classifier=="LR"){
        
        Class<-tempclass
        
        dtemp<-cbind(Class,temptrain)
        mod_cv<-glm(as.factor(Class)~.,data=dtemp,family=binomial(logit))
        
        if(v==num_samp){
          
          #predfit<-predict(mod_cv,t(temptest))
          
          predfit<-predict(mod_cv,t(temptest),type="response")
        }else{
          # predfit<-predict(mod_cv,(temptest))
          
          predfit<-predict(mod_cv,temptest,type="response")
        }
        
        
        #mod_cv<-glm.fit(x=temptrain,y=tempclass,family="binomial")
        #predfit<-predict(mod_cv,temptest,type="response")
        
        #print(predfit)
        
        predfit <- ifelse(predfit > 0.5,1,0)
        
        
      }else{
        
        
        if(classifier=="RF"){
          
          
          Class<-tempclass
          
          d1<-cbind(Class,temptrain)
          mod_cv<-randomForest(as.factor(Class)~.,data=d1)
          #mod_cv<-randomForest(x=temptrain,y=tempclass)
          
          # predfit<-predict(mod_cv,temptest)
          if(v==num_samp){
            
            predfit<-predict(mod_cv,t(temptest))
          }else{
            predfit<-predict(mod_cv,(temptest))
          }
          
          
        }
        
      }
      
    }
    
    
    svm_table<-table(predfit,testclass)
    
    class_names<-rownames(svm_table)
    beracc<-{}
    auc_acc<-{}
    totacc<-length(which(predfit==testclass))/length(testclass)
    for(c in 1:dim(svm_table)[1]){
      testclass_ind<-which(testclass==class_names[c])
      beracc<-c(beracc,length(which(predfit[testclass_ind]==testclass[testclass_ind]))/length(testclass_ind))
      
    }
    if(errortype=="AUC"){
      testclass<-as.vector(testclass)
      y1<-as.vector(y[,1])
      pred_acc<-multiclass.roc(testclass,as.numeric(predfit),levels=levels(as.factor(y1)))
      pred_acc_orig<-pred_acc$auc[1]
      auc_acc<-c(auc_acc,pred_acc_orig)
    }
    
    
    
    beracc<-mean(beracc,na.rm=TRUE)
    
    if(errortype=="CV"){
      svm_acc[i]<-(totacc*100)
    }else{
      if(errortype=="AUC"){
        svm_acc[i]<-(auc_acc*100)
      }else{
        svm_acc[i]<-(beracc*100)
      }
    }
    
  }
  avg_acc <-mean(svm_acc,na.rm=TRUE)
  sd_acc<-sd(svm_acc,na.rm=TRUE)
  
  #limit<-avg_acc-(sd.error*(avg_acc) # 1 sd criterion
  #print(avg_acc)
  #print(sd_acc)
  
  #return(list(error=avg_acc,sderror=sd.error))
  probval<-(1-(conflevel*0.01))/2
  probval<-1-probval
  #print(probval)
  error <- qnorm(probval)*sd_acc/sqrt(length(svm_acc))
  
  leftconfint<-avg_acc-error
  rightconfint<-avg_acc+error
  
  options(warn=0)
  #print("done")
  return(list(avg_acc=avg_acc,sd_acc=sd_acc, acc_each_fold=svm_acc,confint=c(leftconfint,rightconfint)))
  #return(list(num=best_k,error=min_err, avg=avg_acc))
}

get_classification.accuracy.child<-function(temptrain,tempclass,kernelname="radial",errortype="AUC",classifier="svm",num_samp,temptest=NA,testclass=NA,numfolds=1,plotroc=TRUE,rocfeatlist=NA,svm.cost=NA,svm.gamma=NA,opt_comp=NA,svm.type="nu-classification",confint.auc=TRUE)
{
  
  suppressMessages(library(pROC))
  suppressMessages(library(ROCR))
  
  options(warn=-1)
  v=numfolds
  classifier=tolower(classifier)
  
  auc_val=NA
  
  #  ##save(temptrain,tempclass,svm.type,kernelname,file="temp2.Rda")
  
  if(classifier=="SVM" | classifier=="svm"){
    suppressMessages(library(e1071))
    if(is.na(svm.cost)==TRUE & is.na(svm.gamma)==TRUE){
      mod_cv <- svm(x=temptrain,y=tempclass, type=svm.type,kernel=kernelname)
      
    }else{
      
      mod_cv <- svm(x=temptrain,y=tempclass, type=svm.type,kernel=kernelname,gammma=svm.gamma,cost=svm.cost)
    }
    
    
    
    if(v==num_samp){
      
      predfit<-predict(mod_cv,(temptest))
      
    }else{
      predfit<-predict(mod_cv,(temptest))
    }
    
    #  ##save(predfit,file="predfit.Rda")
    
    
  }else{
    if(classifier=="logitreg" | classifier=="LR" | classifier=="lr"){
      
      Class<-as.numeric(tempclass) #-1
      
      
      labels_1<-levels(as.factor(Class))
      
      Class<-replace(Class,which(Class==labels_1[1]),0)
      Class<-replace(Class,which(Class==labels_1[2]),1)
      
      dtemp<-cbind(Class,temptrain)
      dtemp<-as.data.frame(dtemp)
      
      labels_2<-levels(as.factor(testclass))
      
      testclass<-replace(testclass,which(testclass==labels_2[1]),0)
      testclass<-replace(testclass,which(testclass==labels_2[2]),1)
      
      
      
      mod_cv<-glm(as.factor(Class)~.,data=dtemp,family=binomial(logit))
      
      if(v==num_samp){
        
        predfit<-predict(mod_cv,(temptest),type="response")
      }else{
        
        
        predfit<-predict(mod_cv,temptest,type="response")
      }
      
      
      predfit <- ifelse(predfit > 0.5,1,0)
      
      #      ##save(dtemp,predfit,mod_cv,temptest,file="logit.Rda")
      # testclass<-as.numeric(testclass)-1
      # print(predfit)
      #print(testclass)
      
    }else{
      
      
      if(classifier=="RF" | classifier=="randomforest" | classifier=="rf" | classifier=="cforest"){
        
        
        Class<-tempclass
        
        
        if(classifier=="cforest"){
          suppressMessages(library(party))
          tempdata_c<-cbind(tempclass,temptrain)
          cnames_c<-colnames(tempdata_c)
          
          mod_cv <- cforest(tempclass~.,data=tempdata_c,controls=cforest_unbiased(ntree=5000))
          
          predfit <- predict(mod_cv, newdata=temptest, OOB=TRUE, type="response")
          
          predfit <- ifelse(predfit > 0.5,1,0)
          
          
          
        }else{
          suppressMessages(library(randomForest))
          
          mod_cv<-randomForest(x=(temptrain),y=as.factor(tempclass),ntree=5000)
          
          
          if(v==num_samp){
            
            predfit<-predict(mod_cv,(temptest))
          }else{
            predfit<-predict(mod_cv,(temptest))
          }
          
        }
        
        
        predfit<-as.numeric(as.character(predfit))
        
        
      }else{
        
        if(classifier=="NaiveBayes" | classifier=="naivebayes"){
          
          
          Class<-tempclass
          
          mod_cv<-naiveBayes(x=(temptrain),y=as.factor(tempclass))
          
          # predfit<-predict(mod_cv,temptest)
          if(v==num_samp){
            
            predfit<-predict(mod_cv,(temptest))
          }else{
            predfit<-predict(mod_cv,(temptest))
          }
          
          
        }else{
          
          if(classifier=="plsda" | classifier=="pls" | classifier=="pls.lda"){
            #set.seed(seednum)
            if(is.na(opt_comp)==TRUE){
              
              max_ncomp=min(c(dim(temptrain)[2],10))
              
              opt_comp<-pls.lda.cv(Xtrain=temptrain, Ytrain=tempclass,  ncomp=c(1:max_ncomp), nruncv=v, alpha=2/3, priors=NULL)
            }
            
            if(classifier=="pls.lda"){
              mod_cv<-pls.lda(Xtrain=temptrain,Ytrain=tempclass,ncomp=opt_comp,nruncv=v,Xtest=temptest)
              predfit<-mod_cv$predclass
              predfit<-as.numeric(as.character(predfit))
            }else{
              mod_cv<-mixOmics::plsda(X=temptrain,Y=(tempclass),ncomp = opt_comp)
              
              set.seed(2543) # for reproducibility here, only when the `cpus' argument is not used
              
              predfit<-predict(mod_cv,temptest,dist="mahalanobis.dist")
              
              predfit<-as.numeric(as.character(predfit$class$mahalanobis.dist[,1]))
            }
            
          }else{
            if(classifier=="plr" | classifier=="pLR"){
              
              Class<-tempclass
              
              
              param_1<-cv.step.plr(x=(temptrain),y=as.numeric(tempclass),lambda=c(1e-4, 1e-2, 0.1,0.5,1),nfold=v)
              
              mod_cv<-plr(x=(temptrain),y=as.numeric(tempclass)) #,lambda=1e-3)
              
              # predfit<-predict(mod_cv,temptest)
              if(v==num_samp){
                
                predfit<-predict(mod_cv,(temptest),type="class")
              }else{
                predfit<-predict(mod_cv,(temptest),type="class")
              }
              
              
              
              
            } #end
            
          }
          
        }
        
        
      }
      
    }
    
  }
  
  ###savelist=ls(),file="t1.Rda")
  
  
  svm_table<-table(predfit,testclass)
  # print(svm_table)
  # ##save(predfit,file="pred.Rda")
  ###save(testclass,file="testclass.Rda")
  
  conf.auc_acc<-{}
  
  
  class_names<-rownames(svm_table)
  beracc<-{}
  auc_acc<-{}
  totacc<-length(which(predfit==testclass))/length(testclass)
  for(c in 1:dim(svm_table)[1]){
    testclass_ind<-which(testclass==class_names[c])
    beracc<-c(beracc,length(which(predfit[testclass_ind]==testclass[testclass_ind]))/length(testclass_ind))
    
  }
  if(errortype=="AUC"){
    testclass<-as.vector(testclass)
    
    pred_acc<-multiclass.roc(testclass,as.numeric(predfit),levels=levels(as.factor(testclass)))
    pred_acc_orig<-pred_acc$auc[1]
    auc_acc<-c(auc_acc,pred_acc_orig)
    
    if(confint.auc==TRUE){
      set.seed(555)
      conf.auc_acc<-ci.auc(testclass,predfit,method="bootstrap")
    }
  }
  
  
  roc_svm={}
  roc_lr={}
  roc_res<-{}
  
  
  if(dim(svm_table)[1]==2){
    
    if(plotroc==TRUE)
    {
      
      #print(pred)
      
      # ##savelist=ls(),file="t.Rda")
      temptrain<-t(temptrain)
      
      temptest<-t(temptest)
      
      ###save(temptrain,file="temptrain.Rda")
      #    ##save(temptest,file="temptest.Rda")
      ##save(testclass,file="testclass.Rda")
      #   #save(predfit,file="predfit.Rda")
      
      #roc_svm<-get_roc(dataA=temptrain,classlabels=tempclass,classifier="svm",kname="radial",rocfeatlist=seq(1,dim(temptrain)[1]),rocfeatincrement=FALSE,testset=temptest,testclasslabels=testclass,mainlabel="Test set (ROC);\n using SVM",mz_names=rownames(temptrain))
      
      #roc_lr<-get_roc(dataA=temptrain,classlabels=tempclass,classifier="logit",kname="radial",rocfeatlist=seq(1,dim(temptrain)[1]),rocfeatincrement=FALSE,testset=temptest,testclasslabels=testclass,mainlabel="Test set (ROC);\n using LR",mz_names=rownames(temptrain))
      predfit<-as.numeric(factor(predfit)) #as.numeric(as.character(predfit))
      
      
      
      if(length(levels(as.factor(testclass)))==2){
        
        pred1 <- ROCR::prediction(predfit, testclass)
        stats1a <- performance(pred1, 'tpr', 'fpr')
        
        roc_res<-cbind(stats1a@x.values[[1]],stats1a@y.values[[1]])
        colnames(roc_res)<-c(stats1a@x.name,stats1a@y.name)
        fname1=paste("ROC",classifier,".rda",sep="")
        ##saveroc_res,file=fname1)
        x1<-seq(0,1,0.01)
        y1<-x1
        p1<-performance(pred1,"auc")
        
        if(length(conf.auc_acc)>0){
          mod.lab <-c(classifier,paste(' performance, AUC: ',round(p1@y.values[[1]],2),"\n","95% CI:",round(conf.auc_acc[[1]]),"-",round(conf.auc_acc[[2]]),sep=""))
        }else{
          
          mod.lab <-c(classifier,paste(' performance, AUC: ',round(p1@y.values[[1]],2),sep=""))
          
        }
        auc_val=round(p1@y.values[[1]],2)
        
        #if(n==1){
        plot(stats1a@x.values[[1]], stats1a@y.values[[1]], type='s', ylab=stats1a@y.name, xlab=stats1a@x.name, col="black", lty=2, main=mod.lab,cex.main=0.7,lwd=2)
        #}else{
        #lines(stats1a@x.values[[1]], stats1a@y.values[[1]], type='s', col=col_lab[n], lty=2,lwd=2)
        #}
        
        
        
        
        
        
      }
      
    }
  }
  
  
  
  beracc<-mean(beracc,na.rm=TRUE)
  
  if(errortype=="CV" | errortype=="total"){
    svm_acc<-(totacc*100)
  }else{
    if(errortype=="AUC"){
      svm_acc<-(auc_acc*100)
    }else{
      svm_acc<-(beracc*100)
    }
  }
  options(warn=0)
  return(list(classification_acc=svm_acc,classification_model=mod_cv,confusion_matrix=svm_table,roc_res=roc_res,auc_res=auc_val,test.auc.confint=conf.auc_acc))
}


stratify_by_class<-function(yclass,kfold){
  
  y<-yclass
  ytable <- table(y)
  dist_by_class <- ytable/sum(ytable)
  n<-length(y)
  siz <- n - floor(n/kfold)
  classize <- roundvector(dist_by_class * siz, siz)
  if (any(ytable < kfold))
    warning("One or several classes are smaller than the number of folds. \n")
  indlist <- sapply(names(ytable), function(z) which(y ==z), simplify = FALSE)
  
  templist <- vector(mode = "list", length = length(indlist))
  suppressMessages(library(CMA))
  for (i in 1:length(indlist)) {
    outp <- do.call(GenerateLearningsets, args = list(n = ytable[i],
                                                      method = "CV", niter = niter, fold = kfold))@learnmatrix
    templist[[i]] <- t(apply(outp, 1, function(z) ifelse(z ==
                                                           0, 0, indlist[[i]][z])))
  }
  topass <- lapply(templist, function(z) z[1:fold,
                                           , drop = FALSE])
  swaporder <- rowswaps(topass)
  nrep <- 1
  while (nrep < niter) {
    swaporder <- rbind(swaporder, swaporder[1:fold,
                                            , drop = FALSE] + fold * nrep)
    nrep <- nrep + 1
  }
  for (i in 1:length(templist)) templist[[i]] <- templist[[i]][swaporder[,
                                                                         i], ]
  learnmatrix <- templist[[1]]
  for (i in 2:length(indlist)) learnmatrix <- cbind(learnmatrix,
                                                    templist[[i]])
}

##This function calculates k-fold cross-validation classification accuracy on training set and overall classification accuracy for test set using balanced error rate,
##total misclassification rate, and AUC criteria.
get_classification.accuracy<-function(kfold,featuretable,classlabels,kernelname="radial",errortype="AUC",conflevel=95,classifier="svm",seednum=555,testfeaturetable=NA,testclasslabels=NA,match_class_dist=TRUE,plotroc=TRUE,svm.cost=NA,svm.gamma=NA,opt_comp=NA,column.rm.index=c(1),svm.type="nu-classification",num.iter.cv=10){
  
  
  
  v=kfold
  kname=kernelname
  
  options(warn=-1)
  
  featuretable<-as.data.frame(featuretable)
  
  
  mz_time<-rownames(featuretable)
  
  if(length(mz_time)<1){
    
    mz_time<-paste(round(featuretable[,1],5),"_",round(featuretable[,2],2),sep="")
  }
  
  if(is.na(column.rm.index)[1]==FALSE){
    x=t(featuretable[,-c(column.rm.index)])
  }else{
    
    x=t(featuretable)
  }
  if(is.na(testfeaturetable)==FALSE){
    
    if(nrow(featuretable)!=nrow(testfeaturetable)){
      
      stop("Number of features/variables should be same in the train and test sets.")
    }
    
    print("Note: the order of features/variables should be same in the train and test sets.")
    
    if(is.na(column.rm.index)[1]==FALSE){
      testfeaturetable<-t(testfeaturetable[,-c(column.rm.index)])
    }else{
      
      testfeaturetable<-t(testfeaturetable)
    }
    colnames(testfeaturetable)<-mz_time
    if(is.na(testclasslabels)==FALSE){
      
      if(is.vector(testclasslabels)==TRUE){
        testclasslabels=as.data.frame(testclasslabels)
      }else{
        testclasslabels=as.data.frame(testclasslabels)
        
        if(dim(testclasslabels)[2]>1){
          testclasslabels<-testclasslabels[,2]
        }else{
          testclasslabels<-testclasslabels[,1]
        }
      }
      
    }
  }
  
  
  
  colnames(x)<-mz_time
  if(is.vector(classlabels)==TRUE){
    y=as.data.frame(classlabels)
  }else{
    classlabels=as.data.frame(classlabels)
    y=classlabels
    if(dim(y)[2]>1){
      y=classlabels[,2]
    }else{
      y=classlabels[,1]
    }
  }
  y=as.data.frame(y)
  
  
  num_samp=dim(x)[1]
  
  if(length(num_samp)<1){
    num_samp<-length(x)
    x<-as.data.frame(x)
  }
  y<-as.data.frame(y)
  x<-as.data.frame(x)
  
  num_datasets= floor(num_samp)
  n1<-floor(num_samp/v)
  n2<-num_samp-n1*v
  n3<-v-n2
  
  ind<-rep(c(n1,n1+1),c(n3,n2))
  ind<-diffinv(ind)
  min_err=1
  best_k=1
  
  parent_svm_acc<-{}
  
  set.seed(seednum)
  seednum<-sample(1:1000,size=num.iter.cv)
  
  #for(nitr in 1:num.iter.cv)
  {
    suppressMessages(library(CMA))
    if(match_class_dist==TRUE){
      #set.seed(seednum[nitr])
      #group=GenerateLearningsets(y=y[,1],niter=1,fold=v,method="CV",strat=TRUE)
      set.seed(seednum)
      group=GenerateLearningsets(y=y[,1],niter=num.iter.cv,fold=v,method="MCCV",strat=TRUE,ntrain=(num_samp-floor(num_samp/v)))
      #return(y)
      #return(group)
      
    }else{
      suppressMessages(library(CMA))
      set.seed(seednum)
      #group<-sample(1:num_samp,num_samp, replace=FALSE)
      group=GenerateLearningsets(y=y[,1],niter=num.iter.cv,fold=v,method="MCCV",strat=FALSE,ntrain=(num_samp-floor(num_samp/v)))
      
    }
    
    
    itr=0
    
    #print(nrow(group@learnmatrix))
    
    svm_acc<-rep(0,v)
    mod_cv_list<-new("list")
    svm_acc<-lapply(1:nrow(group@learnmatrix),function(i)
    {
      if(match_class_dist==TRUE){
        g<-group@learnmatrix[i,]
        g<-seq(1,length(y[,1]))[-group@learnmatrix[i,]]
      }else{
        g<-group[(ind[i]+1):ind[i+1]]
      }
      
      temptest<-x[g,]
      temptrain <-x[-g,]
      tempclass <-y[-g,]
      testclass<-y[g,]
      
      # ##save(g,temptrain,temptest,tempclass,testclass,v,classifier,num_samp,errortype,kernelname,svm.type,file="temp.Rda")
      cv_res<-get_classification.accuracy.child(temptrain=temptrain,tempclass=tempclass,kernelname=kernelname,errortype=errortype,classifier=classifier,num_samp=num_samp,temptest=temptest,testclass=testclass,numfolds=v,plotroc=FALSE,
                                                rocfeatlist=NA,svm.cost=svm.cost,svm.gamma=svm.gamma,svm.type=svm.type,confint.auc=FALSE)
      
      #svm_acc[i]<-cv_res$classification_acc
      
      return(cv_res$classification_acc)
    })
    
    
    svm_acc<-unlist(svm_acc)
    
    parent_svm_acc<-c(parent_svm_acc,svm_acc)
  }
  
  seednum<-seednum[1]
  
  
  svm_acc<-parent_svm_acc
  
  avg_acc <-mean(svm_acc,na.rm=TRUE)
  sd_acc<-sd(svm_acc,na.rm=TRUE)
  
  ##Get confidence interval
  probval<-(1-(conflevel*0.01))/2
  probval<-1-probval
  
  error <- qnorm(probval)*sd_acc/sqrt(length(svm_acc))
  avg_acc<-round(avg_acc,2)
  leftconfint<-avg_acc-error
  rightconfint<-avg_acc+error
  test_acc<-NA
  test_confusion_matrix<-NA
  
  leftconfint<-round(leftconfint,2)
  rightconfint<-round(rightconfint,2)
  print(paste("Training set ", kfold,"-fold CV (repeated ",num.iter.cv," times) ",errortype," ",classifier," classification accuracy (%):",avg_acc,sep=""))
  print(paste("Training set ", kfold,"-fold CV (repeated ",num.iter.cv," times) ",errortype," ",classifier," classification accuracy ", conflevel,"% confidence interval:(",leftconfint,",",rightconfint,")",sep=""))
  
  
  x<-as.data.frame(x)
  y<-y[,1]
  #save(x,y,kernelname,errortype,classifier,num_samp,svm.cost,svm.gamma,file="debugclass.Rda")
  train_res<-get_classification.accuracy.child(temptrain=x,tempclass=y,kernelname=kernelname,errortype=errortype,classifier=classifier,num_samp=num_samp,temptest=x,testclass=y,svm.cost=svm.cost,svm.gamma=svm.gamma)
  print(paste("Training set ",errortype," ",classifier," classification accuracy (%):",round(train_res$classification_acc,2),sep=""))
  
  mod_cv<-train_res$classification_model
  
  test_res={}
  #evaluate test set accuracy
  if(is.na(testfeaturetable)==FALSE){
    
    if(is.na(testclasslabels)==FALSE){
      
      testfeaturetable<-as.data.frame(testfeaturetable)
      
      # ##save(list=ls(),file="t2.Rda")
      
      
      
      test_res<-get_classification.accuracy.child(temptrain=x,tempclass=y,kernelname=kernelname,errortype=errortype,classifier=classifier,num_samp=num_samp,temptest=testfeaturetable,testclass=testclasslabels,plotroc=TRUE,svm.cost=svm.cost,svm.gamma=svm.gamma)
      
      test_acc<-test_res$classification_acc
      test_acc<-round(test_acc,2)
      test_pred_table<-test_res$confusion_matrix
      
      print(paste("Test set ", errortype," ",classifier," classification accuracy (%):",test_acc,sep=""))
      print(paste("Test set confusion matrix using ",classifier,sep=""))
      print(test_pred_table)
      
      test_confusion_matrix<-test_pred_table
      
    }
  }
  
  options(warn=0)
  
  if(classifier=="logitreg" | classifier=="LR"){
    
    Class<-y
    
    dtemp<-cbind(Class,x)
    dtemp<-as.data.frame(dtemp)
    
    mod_cv_all<-glm(as.factor(Class)~.,data=dtemp,family=binomial(logit))
    s1<-summary(mod_cv_all)
    
    options(warn=0)
    return(list(avg.train.cv.acc=avg_acc,sd.train.cv.acc=sd_acc, train.cv.acc.each.fold=svm_acc,glm_fit=s1$coefficients,train.cv.acc.confint=c(leftconfint,rightconfint),test.acc=test_acc,test.confusion.matrix=test_confusion_matrix,test_res=test_res))
  }else{
    
    options(warn=0)
    return(list(avg.train.cv.acc=avg_acc,sd.train.cv.acc=sd_acc,train.cv.acc.each.fold=svm_acc,train.cv.acc.confint=c(leftconfint,rightconfint),test.acc=test_acc,test.confusion.matrix=test_confusion_matrix,test_res=test_res))
  }
  
  
}

##This function calculates k-fold cross-validation classification accuracy on training set and overall classification accuracy for test set using balanced error rate,
##total misclassification rate, and AUC criteria.
get_classification.accuracy_vold<-function(kfold,featuretable,classlabels,kernelname="radial",errortype="AUC",conflevel=95,classifier="svm",seednum=555,testfeaturetable=NA,testclasslabels=NA,match_class_dist=TRUE,plotroc=TRUE,svm.cost=NA,svm.gamma=NA,opt_comp=NA,column.rm.index=c(1,2),svm.type="nu-classification"){
  
  
  
  v=kfold
  kname=kernelname
  
  options(warn=-1)
  
  featuretable<-as.data.frame(featuretable)
  
  
  mz_time<-rownames(featuretable)
  
  if(length(mz_time)<1){
    
    mz_time<-paste(round(featuretable[,1],5),"_",round(featuretable[,2],2),sep="")
  }
  
  if(is.na(column.rm.index)[1]==FALSE){
    x=t(featuretable[,-c(column.rm.index)])
  }else{
    
    x=t(featuretable)
  }
  if(is.na(testfeaturetable)==FALSE){
    
    if(nrow(featuretable)!=nrow(testfeaturetable)){
      
      stop("Number of features/variables should be same in the train and test sets.")
    }
    
    print("Note: the order of features/variables should be same in the train and test sets.")
    
    if(is.na(column.rm.index)[1]==FALSE){
      testfeaturetable<-t(testfeaturetable[,-c(column.rm.index)])
    }else{
      
      testfeaturetable<-t(testfeaturetable)
    }
    colnames(testfeaturetable)<-mz_time
    if(is.na(testclasslabels)==FALSE){
      
      if(is.vector(testclasslabels)==TRUE){
        testclasslabels=as.data.frame(testclasslabels)
      }else{
        testclasslabels=as.data.frame(testclasslabels)
        
        if(dim(testclasslabels)[2]>1){
          testclasslabels<-testclasslabels[,2]
        }else{
          testclasslabels<-testclasslabels[,1]
        }
      }
      
    }
  }
  
  
  
  colnames(x)<-mz_time
  if(is.vector(classlabels)==TRUE){
    y=as.data.frame(classlabels)
  }else{
    classlabels=as.data.frame(classlabels)
    y=classlabels
    if(dim(y)[2]>1){
      y=classlabels[,2]
    }else{
      y=classlabels[,1]
    }
  }
  y=as.data.frame(y)
  
  
  num_samp=dim(x)[1]
  
  if(length(num_samp)<1){
    num_samp<-length(x)
    x<-as.data.frame(x)
  }
  y<-as.data.frame(y)
  x<-as.data.frame(x)
  
  num_datasets= floor(num_samp)
  n1<-floor(num_samp/v)
  n2<-num_samp-n1*v
  n3<-v-n2
  
  ind<-rep(c(n1,n1+1),c(n3,n2))
  ind<-diffinv(ind)
  min_err=1
  best_k=1
  
  suppressMessages(library(CMA))
  if(match_class_dist==TRUE){
    set.seed(seednum)
    #group=GenerateLearningsets(y=y[,1],niter=1,fold=v,method="CV",strat=TRUE)
    
    group=GenerateLearningsets(y=y[,1],niter=v,fold=v,method="MCCV",strat=TRUE,ntrain=(num_samp-floor(num_samp/v)))
    #return(y)
    #return(group)
    
  }else{
    
    set.seed(seednum)
    group<-sample(1:num_samp,num_samp, replace=FALSE)
    
  }
  
  
  itr=0
  
  # ##savev,x,y,classifier,plotroc,errortype,kernelname,group,file="temp.Rda")
  
  
  
  svm_acc<-rep(0,v)
  mod_cv_list<-new("list")
  svm_acc<-lapply(1:v,function(i)
  {
    if(match_class_dist==TRUE){
      g<-group@learnmatrix[i,]
      g<-seq(1,length(y[,1]))[-group@learnmatrix[i,]]
    }else{
      g<-group[(ind[i]+1):ind[i+1]]
    }
    
    temptest<-x[g,]
    temptrain <-x[-g,]
    tempclass <-y[-g,]
    testclass<-y[g,]
    
    # ##save(g,temptrain,temptest,tempclass,testclass,v,classifier,num_samp,errortype,kernelname,svm.type,file="temp.Rda")
    cv_res<-get_classification.accuracy.child(temptrain=temptrain,tempclass=tempclass,kernelname=kernelname,errortype=errortype,classifier=classifier,num_samp=num_samp,temptest=temptest,testclass=testclass,numfolds=v,plotroc=FALSE,rocfeatlist=NA,svm.cost=svm.cost,svm.gamma=svm.gamma,svm.type=svm.type)
    
    #svm_acc[i]<-cv_res$classification_acc
    
    return(cv_res$classification_acc)
  })
  
  
  svm_acc<-unlist(svm_acc)
  
  
  avg_acc <-mean(svm_acc,na.rm=TRUE)
  sd_acc<-sd(svm_acc,na.rm=TRUE)
  
  ##Get confidence interval
  probval<-(1-(conflevel*0.01))/2
  probval<-1-probval
  
  error <- qnorm(probval)*sd_acc/sqrt(length(svm_acc))
  avg_acc<-round(avg_acc,2)
  leftconfint<-avg_acc-error
  rightconfint<-avg_acc+error
  test_acc<-NA
  test_confusion_matrix<-NA
  
  leftconfint<-round(leftconfint,2)
  rightconfint<-round(rightconfint,2)
  print(paste("Training set ", kfold,"-fold CV ",errortype," ",classifier," classification accuracy (%):",avg_acc,sep=""))
  print(paste("Training set ", kfold,"-fold CV ",errortype," ",classifier," classification accuracy ", conflevel,"% confidence interval:(",leftconfint,",",rightconfint,")",sep=""))
  
  
  x<-as.data.frame(x)
  y<-y[,1]
  ###save(x,y,kernelname,errortype,classifier,num_samp,svm.cost,svm.gamma,file="debugclass.Rda")
  train_res<-get_classification.accuracy.child(temptrain=x,tempclass=y,kernelname=kernelname,errortype=errortype,classifier=classifier,num_samp=num_samp,temptest=x,testclass=y,svm.cost=svm.cost,svm.gamma=svm.gamma)
  print(paste("Training set ",errortype," ",classifier," classification accuracy (%):",round(train_res$classification_acc,2),sep=""))
  
  mod_cv<-train_res$classification_model
  
  test_res={}
  #evaluate test set accuracy
  if(is.na(testfeaturetable)==FALSE){
    
    if(is.na(testclasslabels)==FALSE){
      
      testfeaturetable<-as.data.frame(testfeaturetable)
      
      # ##save(list=ls(),file="t2.Rda")
      
      
      
      test_res<-get_classification.accuracy.child(temptrain=x,tempclass=y,kernelname=kernelname,errortype=errortype,classifier=classifier,num_samp=num_samp,temptest=testfeaturetable,testclass=testclasslabels,plotroc=TRUE,svm.cost=svm.cost,svm.gamma=svm.gamma)
      
      test_acc<-test_res$classification_acc
      test_acc<-round(test_acc,2)
      test_pred_table<-test_res$confusion_matrix
      
      print(paste("Test set ", errortype," ",classifier," classification accuracy (%):",test_acc,sep=""))
      print(paste("Test set confusion matrix using ",classifier,sep=""))
      print(test_pred_table)
      
      test_confusion_matrix<-test_pred_table
      
    }
  }
  
  options(warn=0)
  
  if(classifier=="logitreg" | classifier=="LR"){
    
    Class<-y
    
    dtemp<-cbind(Class,x)
    dtemp<-as.data.frame(dtemp)
    
    mod_cv_all<-glm(as.factor(Class)~.,data=dtemp,family=binomial(logit))
    s1<-summary(mod_cv_all)
    
    options(warn=0)
    return(list(avg.train.cv.acc=avg_acc,sd.train.cv.acc=sd_acc, train.cv.acc.each.fold=svm_acc,glm_fit=s1$coefficients,train.cv.acc.confint=c(leftconfint,rightconfint),test.acc=test_acc,test.confusion.matrix=test_confusion_matrix,test_res=test_res))
  }else{
    
    options(warn=0)
    return(list(avg.train.cv.acc=avg_acc,sd.train.cv.acc=sd_acc,train.cv.acc.each.fold=svm_acc,train.cv.acc.confint=c(leftconfint,rightconfint),test.acc=test_acc,test.confusion.matrix=test_confusion_matrix,test_res=test_res))
  }
  
  
}


do_wgcna<-function(feature_table_file=NA,class_labels_file=NA,X=NA,Y=NA,sigfeats=NA){
  
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  }else{
    
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
  }else{
    
    classlabels<-Y
  }
  
  if(dim(classlabels)[2]>2){
    classgroup<-paste(classlabels[,2],":",classlabels[,3],sep="") #classlabels[,2]:classlabels[,3]
  }else{
    
    classgroup<-classlabels[,2]
  }
  classlabels<-as.data.frame(classlabels)
  
  class_labels_levels<-levels(as.factor(classgroup))
  
  rnames<-paste(data_matrix$mz,data_matrix$time,sep="_") #paste(sprintf("%.4f",data_matrix$mz),data_matrix$time,sep="_")
  
  data_matrix_orig<-data_matrix
  data_matrix<-data_matrix[,-c(1:2)]
  data_matrix<-na.omit(data_matrix)
  
  rnamesAB<-gsub(pattern="NA_NA",replacement=NA,x=rnames)
  rnamesAB<-na.omit(rnamesAB)
  
  nSets = length(class_labels_levels);
  multiExpr = vector(mode = "list", length = nSets)
  data_matrix_list<-new("list")
  num_samps_groups<-new("list")
  for(i in 1:length(class_labels_levels)){
    
    data_matrix_list[[i]]<-t(data_matrix[,which(classgroup==class_labels_levels[i])])
    num_samps_groups[[i]]<-dim(data_matrix_list[[i]])[1]
    #print(dim(data_matrix_list[[i]]))
    multiExpr[[i]]<-list(data = as.data.frame(data_matrix_list[[i]]));
    rownames(multiExpr[[i]]$data)=c(paste(rep(class_labels_levels[i],num_samps_groups[[i]]),seq(1,num_samps_groups[[i]]),sep=""))
  }
  
  data_matrix_all<-t(data_matrix)
  
  
  # We work with two sets:
  # For easier labeling of plots, create a vector holding descriptive names of the two sets.
  setLabels = as.character(class_labels_levels) #c("Slow", "Rapid")
  shortLabels = as.character(class_labels_levels) #c("Slow", "Rapid")
  
  ####saveclass_labels_levels,file="class_labels_levels.Rda")
  ####savemultiExpr,file="multiExpr.Rda")
  
  exprSize = checkSets(multiExpr)
  
  
  sampleTrees = list()
  for (set in 1:nSets)
  {
    sampleTrees[[set]] = hclust(dist(multiExpr[[set]]$data), method = "average")
  }
  
  
  #pdf(file = "SampleClustering.pdf", width = 12, height = 12);
  
  
  for (set in 1:nSets)
  {
    # Find clusters cut by the line
    #labels = cutreeStatic(sampleTrees[[set]], cutHeight = cutHeights[set])
    # Keep the largest one (labeled by the number 1)
    #keep = (labels==1)
    multiExpr[[set]]$data = multiExpr[[set]]$data
  }
  collectGarbage();
  
  
  # Check the size of the leftover data
  exprSize = checkSets(multiExpr)
  exprSize;
  
  traitData<-as.data.frame(classlabels)
  
  dim(traitData)
  names(traitData)
  
  # See how big the traits are and what are the trait and sample names
  # Form a multi-set structure that will hold the clinical traits.
  Traits = vector(mode="list", length = nSets);
  for (set in 1:nSets)
  {
    
    Traits[[set]] = list(data = data_matrix_list[[i]] );
    rownames(Traits[[1]]$data) = rownames(data_matrix_list[[i]]);
    #Traits[[2]] = list(data = dataexprB );
    #rownames(Traits[[2]]$data) = rownames(dataexprB);
  }
  collectGarbage();
  # Define data set dimensions
  nGenes = exprSize$nGenes;
  nSamples = exprSize$nSamples;
  
  ####savemultiExpr, Traits, nGenes, nSamples, file = "Consensus-dataInput.RData");
  
  
  
  
  
  
  powers = c(c(1:10), seq(from = 12, to=20, by=2))
  sft = pickSoftThreshold(data=data_matrix_all, dataIsExpr=TRUE,powerVector = powers, verbose = 0)
  power_val=sft$powerEstimate
  
  if(is.na(power_val)==TRUE){
    power_val=6
  }
  
  netclassA = suppressWarnings(blockwiseConsensusModules(multiExpr, power = power_val, minModuleSize = 10, deepSplit = 2,
                                        pamRespectsDendro = FALSE,
                                        mergeCutHeight = 0.2, numericLabels = TRUE,saveTOMs = FALSE, verbose = 0,saveIndividualTOMs=FALSE,useDiskCache=FALSE))
  
  
  # open a graphics window
  sizeGrWindow(12, 9)
  # Convert labels to colors for plotting
  mergedColors = labels2colors(netclassA$colors)
  if(FALSE){
    # Plot the dendrogram and the module colors underneath
    plotDendroAndColors(netclassA$dendrograms[[1]], mergedColors[netclassA$blockGenes[[1]]],
                        "Module colors",
                        dendroLabels = FALSE, hang = 0.03,
                        addGuide = TRUE, guideHang = 0.05)
  }
  
  classAmoduleLabels = netclassA$colors
  classAmoduleColors = labels2colors(netclassA$colors)
  classAMEs = netclassA$MEs;
  classAgeneTree = netclassA$dendrograms[[1]];
  
  
  
  
  # Recalculate consMEs to give them color names
  consMEsC = multiSetMEs(multiExpr, universalColors = classAmoduleColors);
  
  MET = consensusOrderMEs(consMEsC);
  suppressWarnings(dir.create("Figures",showWarnings = FALSE))
  suppressWarnings(dir.create("Tables",showWarnings = FALSE))
  #setwd("NetworkAnalysis/")
  save(MET,setLabels,file="WGCNA_modules.Rda")
#  save(setLabels,file="setLabels.Rda")
  pdf("Figures/Module_preservation_analysis.pdf",width=10,height=8)
  #tiff("module_preservation.tiff",width=2000,height=2000)
  #sizeGrWindow(8,10);
  #par(cex = 1)
  #plotEigengeneNetworks_custom(MET, setLabels, marDendro = c(0,2,2,1), marHeatmap = c(3,3,2,1),zlimPreservation = c(0.5, 1), plotPreservation = "standard",plotDendrograms=FALSE)
  #dev.off()
  ##save(MET,setLabels,multiExpr,classAmoduleColors,consMEsC,file="wgcnamp.Rda")
  
  #mp = modulePreservation(MET, setLabels,dataIsExpr = TRUE)
  ##save(mp,file="mp.Rda")
  
  #sizeGrWindow(8,10);
  #tiff("module_preservation.tiff",width=2000,height=2000)
  #par(cex = 0.9)
  plotEigengeneNetworks_custom(MET, setLabels, marDendro = c(0,2,2,1), marHeatmap = c(3,3,2,1),zlimPreservation = c(0.5, 1), plotPreservation = "standard",
                               plotDendrograms=FALSE)
  try(dev.off(),silent=TRUE)
  graphics.off()
  graphics.off()
  
  
  colors_met<-cbind(data_matrix_orig[,c(1:2)],MET[[1]]$validColors)
  
  colors_met<-as.data.frame(colors_met)
  
  colnames(colors_met)<-c("mz","time","Module")
  
  #print(table(MET[[1]]$validColors))
  #print(table(classAmoduleColors))
  write.table(colors_met,file="Tables/Allfeature_modules.txt",sep="\t",row.names=FALSE)
  
  if(is.na(sigfeats)==FALSE){
    sub_colors_met<-colors_met[which(data_matrix_orig$mz%in%sigfeats$mz),]
    write.table(sub_colors_met,file="Tables/Sigfeature_modules.txt",sep="\t",row.names=FALSE)
  }
  
  ####saveMET,file="MET.Rda")
  
  
  
  return(list(MET=MET,setLabels=setLabels))
}


get_volcanoplots<-function(xvec,yvec,up_or_down,maintext="",ythresh=0.05,y2thresh=NA,
                           ylab,xlab,colorvec=c("darkblue","red3"),
                           col_seq=c("brown","chocolate3","orange3","coral",
                                     "pink","skyblue","blue","darkblue","purple","violet"),
                           xincrement=1,yincrement=1,xthresh=1,pchvec=c(21,21)
                           ,background.points.col="gray50",bad.feature.index=NA,xlim.arg=NA,ylim.arg=NA){
  
  # ###savelist=ls(),file="volcano.Rda")
  d4<-xvec
  min_val<-round(min(d4,na.rm=TRUE)+0.5)
  max_val<-round(max(d4,na.rm=TRUE)+0.5)
  
  windowsize=xincrement
  
  d4<-as.vector(d4)
  
  logp<-as.vector(yvec)
  
  if(is.na(up_or_down)==TRUE){
    up_or_down<-rep(1,length(yvec))
  }
  
  if(is.na(xlim.arg)==TRUE & is.na(ylim.arg)==TRUE){
  plot(d4,logp,xaxt="n",ylab=ylab,xlab=xlab,xaxt="n",yaxt="n",cex=0.4,cex.main=0.7,main=maintext)
    axis(1, at=seq(min_val , max_val, by=xincrement) , las=2)
    axis(2, at=seq(0 , (max(logp)+2), by=yincrement) , las=2)
    
    
   }else{
    plot(d4,logp,xaxt="n",ylab=ylab,xlab=xlab,xaxt="n",yaxt="n",cex=0.4,cex.main=0.7,main=maintext,xlim=xlim.arg,ylim=ylim.arg)
     axis(1, at=seq(xlim.arg[1] , xlim.arg[2], by=xincrement) , las=2)
     axis(2, at=seq(ylim.arg[1],ylim.arg[2], by=yincrement) , las=2)
     
  }
 
  
  points(d4,logp,col=background.points.col,cex=0.4,bg=background.points.col,pch=21)
  points(d4,logp,col=background.points.col,cex=0.4,bg=background.points.col,pch=21)
  
  
 # goodip<-which(yvec>y2thresh & abs(xvec)>xthresh)
  
  if(is.na(y2thresh)==TRUE){
    
    goodip<-which(yvec>ythresh & abs(xvec)>xthresh)
  }else{
    
    goodip<-which(yvec>y2thresh & abs(xvec)>xthresh)
    
  }
  
  
  if(length(bad.feature.index)>0){
    
    if(is.na(bad.feature.index)==FALSE){
      if(length(goodip)>0){
        
        
        check_bad_feat_index<-which(goodip%in%bad.feature.index)
        
        if(length(check_bad_feat_index)>0){
          goodip<-goodip[-check_bad_feat_index]
        }
        #goodip<-goodip[-which(goodip%in%bad.feature.index)] #goodip[-bad.feature.index]
      }
    }
  }
  
  for(i in goodip){
    if(up_or_down[i]>0){
      points(d4[i],logp[i],col=colorvec[1],cex=0.8,pch=pchvec[1],bg=colorvec[1]); points(d4[i],logp[i],col=colorvec[1],cex=0.4,bg=colorvec[1])
    }else{
      
      points(d4[i],logp[i],col=colorvec[2],cex=0.8,pch=pchvec[2],bg=colorvec[2]); points(d4[i],logp[i],col=colorvec[2],cex=0.4,bg=colorvec[2])
    }
  }
  if(length(bad.feature.index)>0){
    
    if(is.na(bad.feature.index)==FALSE){
      for(i in bad.feature.index){
        points(d4[i],logp[i],col=background.points.col,cex=0.4,bg=background.points.col,pch=21)
        
      }
    }
  }
  
  if(length(goodip)>0){
    
    
    abline(v=(-1)*xthresh,col="gray8",lty=2,lwd=0.8)
    abline(v=xthresh,col="gray8",lty=2,lwd=0.8)
    
    abline(h=ythresh,col="gray8",lty=2,lwd=0.8)
    
    if(is.na(y2thresh)==FALSE){
      abline(h=y2thresh,col="gray8",lty=2,lwd=0.8)
      
    }
    
  }
  
  
}


get_manhattanplots<-function(xvec,yvec,up_or_down,maintext="",ythresh=0.05,y2thresh=NA,ylab,xlab,colorvec=c("darkblue","red3"),
                             col_seq=c("brown","chocolate3","orange3","coral","pink","skyblue","blue","darkblue","purple","violet"),xincrement=100,yincrement=1,
                             pchvec=c(21,21),background.points.col="black",bad.feature.index=NA){
  
  d4<-xvec
  min_val<-min(c(0,d4),na.rm=TRUE)[1]
  max_val<-max(d4,na.rm=TRUE)[1]
  
  windowsize=xincrement
  
  d4<-as.vector(d4)
  pvalues<-as.vector(yvec)
  
  logp<-as.vector(yvec)
  
  if(is.na(up_or_down)==TRUE){
    up_or_down<-rep(1,length(yvec))
  }
  
  max_yval<-max(yvec,na.rm=TRUE)[1]+1.96*(sd(yvec,na.rm=TRUE)/(sqrt(length(yvec))))
  
  
  plot(d4,logp,xaxt="n",ylab=ylab,xlab=xlab,xaxt="n",yaxt="n",cex=0.4,cex.main=0.7,main=maintext,ylim=range(pretty(c(0,max(logp)))))
  
  axis(1, at=seq(min_val , max_val, by=xincrement) , las=2)
  axis(2, at=seq(0 , (max(logp)+2), by=yincrement) , las=2)
  
  if(length(col_seq)>1){
    
    s1<-seq(windowsize,max_val,windowsize)
    points(d4[which(d4>=0 & d4<=windowsize)],logp[which(d4>=0 & d4<=windowsize)],col=col_seq[1],cex=0.4,pch=21,bg=background.points.col)
    for(i in 1:(length(s1)-1))
    {
      points(d4[which(d4>s1[i] & d4<=s1[i+1])],logp[which(d4>s1[i] & d4<=s1[i+1])],col=col_seq[i+1],cex=0.4,pch=21,bg=background.points.col)
    }
  }else{
    
    #points(d4[which(d4>=0 & d4<=windowsize)],logp[which(d4>=0 & d4<=windowsize)],col="black",bg=background.points.col,cex=0.4,pch=21)
    
    points(d4,logp,col=background.points.col,bg=background.points.col,cex=0.4,pch=21)
  }
  
  if(is.na(y2thresh)==TRUE){
    
    goodip<-which(yvec>ythresh)
  }else{
    
    goodip<-which(yvec>y2thresh)
    
  }
  
  if(length(bad.feature.index)>0){
    if(is.na(bad.feature.index)==FALSE){
      if(length(goodip)>0){
        
        
        
        check_bad_feat_index<-which(goodip%in%bad.feature.index)
        
        if(length(check_bad_feat_index)>0){
          goodip<-goodip[-check_bad_feat_index]
        }
        
      }
    }
  }
  
  for(i in goodip){
    if(up_or_down[i]>0){
      points(d4[i],logp[i],col=colorvec[1],cex=0.8,pch=pchvec[1],bg=colorvec[1]); points(d4[i],logp[i],col=colorvec[1],cex=0.2,bg=colorvec[1])
    }else{
      
      points(d4[i],logp[i],col=colorvec[2],cex=0.8,pch=pchvec[2],bg=colorvec[2]); points(d4[i],logp[i],col=colorvec[2],cex=0.2,bg=colorvec[2])
    }
  }
  
  if(length(bad.feature.index)>0){
    if(is.na(bad.feature.index)==FALSE){
      for(i in bad.feature.index){
        
        points(d4[i],logp[i],col=background.points.col,cex=0.4,pch=pchvec[1],bg=background.points.col); #points(d4[i],logp[i],col=colorvec[1],cex=0.2,bg=)
      }
    }
  }
  
  if(length(goodip)>0){
    #hfdrfdrthresh<-logp[which(logp==min(logp[which(yvec>ythresh)],na.rm=TRUE))]
    #abline(h=hfdrfdrthresh,col="gray8",lty=2,lwd=2)
    
    abline(h=ythresh,col="gray8",lty=2,lwd=0.8)
    if(is.na(y2thresh)==FALSE){
      abline(h=y2thresh,col="gray8",lty=2,lwd=0.8)
    }
  }
  
}


#function to generate ROC curves using SVM or logistic regression classifiers
get_roc<-function(dataA,classlabels,classifier="svm",kname="radial",rocfeatlist=c(1,2,3,4,5),rocfeatincrement=TRUE,
                  testset=NA,testclasslabels=NA,mainlabel=NA,
                  col_lab=c("black"),legend=TRUE,newdevice=FALSE,mz_names=NA,svm.type="C-classification"){
  
  options(warn=-1)
  
  d1<-dataA
  rm(dataA)
  
  
  if(newdevice==TRUE){
    
    if(dir.exists("Figures")){
    
        pdf("Figures/ROC.pdf")
    }else{
      
      pdf("ROC.pdf")
    }
  }
  cnames<-colnames(d1)
  
  
  classlabels<-as.data.frame(classlabels)
  testclasslabels<-as.data.frame(testclasslabels)
  class_inf<-classlabels
  
 # save(classlabels,file="classlabels.Rda")
  #save(d1,mz_names,file="d1.Rda")
  
  if(is.na(rocfeatlist)==TRUE){
    num_select<-dim(d1)[1]
    rocfeatlist=1:num_select
  }else{
    
    num_select<-length(rocfeatlist)
  }
  
  
  if(is.na(mz_names)==TRUE){
    cnames[1]<-"mz"
    cnames[2]<-"time"
    colnames(d1)<-cnames
    d1<-as.data.frame(d1)
    
    #d1<-unique(d1)
    
    d2<-t(d1[,-c(1:2)])
    
    cnames<-colnames(d1)
    
    if(is.na(testset)==TRUE){
      testset<-d1
      testclasslabels<-classlabels
    }
    
    if(is.na(rocfeatlist)==TRUE){
      
      rocfeatlist<-seq(1,dim(d2)[2])
    }
    
    if(max(rocfeatlist,na.rm=TRUE)>ncol(d2))
    {
      rocfeatlist<-rocfeatlist[-which(rocfeatlist>ncol(d2))]
    }
    
    
    
    
    testset<-t(testset[,-c(1:2)])
    testset<-testset[,rocfeatlist]
    
    d2<-d2[,rocfeatlist]
    d1<-d1[rocfeatlist,]
    mz_names<-paste(d1$mz,d1$time,sep="_")
    
    
  }else{
    
    d1<-as.data.frame(d1)
    #d1<-unique(d1)
    
    d2<-t(d1)
    
    cnames<-colnames(d1)
    
    mz_names<-unique(mz_names)
    
    if(is.na(testset)==TRUE){
      testset<-d1
      testclasslabels<-classlabels
      
      #print(classlabels)
    }
    
    if(is.na(rocfeatlist)==TRUE){
      
      rocfeatlist<-seq(1,dim(d2)[2])
    }
    
    if(max(rocfeatlist,na.rm=TRUE)>ncol(d2))
    {
      rocfeatlist<-rocfeatlist[-which(rocfeatlist>ncol(d2))]
    }
    
    # testset<-unique(testset)
    testset<-t(testset)
    testset<-testset[,rocfeatlist]
    d2<-d2[,rocfeatlist]
    d1<-d1[rocfeatlist,]
    mz_names<-mz_names[rocfeatlist]
    
    
    
  }
  
  
  featlist<-rocfeatlist
  featincrement<-rocfeatincrement
  
  
  
  class_vec<-as.character(class_inf[,1])
  
  class_levels<-levels(as.factor(class_vec))
  
  if(length(class_levels)>2){
    
    #stop("More than two classes detected. Please restrict the analysis to only two classes.")
  }
  
	
  #class_vec<-replace(class_vec,which(class_vec==class_levels[2]),1)
  
  if(classifier=="logitreg" || classifier=="logit"){
  class_vec<-as.numeric(as.factor(class_vec))-1
  
  testclasslabels<-as.numeric(as.factor(testclasslabels[,1]))
  }
  
  d3<-cbind(class_vec,d2)
  d3<-as.data.frame(d3)
  
  #featlist<-featlist+1
  
  colnames(d2)<-as.character(mz_names)
  colnames(testset)<-as.character(mz_names)
  mz_names<-c("Class",mz_names)
  
  
  
  colnames(d3)<-as.character(mz_names)
  
  
  
  
  d3<-as.data.frame(d3)
  
 # save(d3,file="d3.Rda")
  
  #featlist<-unique(featlist)
  
  mod.lab<-{}
  
  
  if(is.na(col_lab)==TRUE){
    if(length(featlist)>1){
      col_lab<-palette(rainbow(length(featlist)))
    }else{
      col_lab<-c("blue")
    }
  }
  
  extra_index<-which(featlist>(dim(d1)[1]+1))
  
  if(length(extra_index)>0){
    featlist<-featlist[-extra_index]
  }
  featlist<-unique(featlist)
  
  if(is.na(mainlabel)==TRUE){
    
    
    if(classifier=="logitreg" || classifier=="logit"){
      mainlab<-"ROC curves using logistic regression"
    }else{
      
      mainlab<-"ROC curves using SVM"
    }
    
  }else{
    
    mainlab=mainlabel
  }
  

  roc_res_list<-new("list")
  
  if(featincrement==TRUE){
    
    
    featlist<-featlist+1
    
    alltestset<-testset
    
    for(n in 1:length(featlist)){
    
     # roc_res_list<-lapply(1:length(featlist),function(n){  
      testset<-alltestset
      num_select<-featlist[n]
      
      
      d4<-as.data.frame(d3[,c(1:num_select)])
      
      cnames1<-colnames(d4)
      
      #  ##save(d4,file="d4.Rda")
      testset<-as.data.frame(testset)
      
      ###save(testset,file="testset.Rda")
      
      testset<-testset[,which(colnames(testset)%in%colnames(d4))]
      testset<-as.data.frame(testset)
      
      #testset<-setnames(testset, cnames1[-c(1)])
      colnames(testset)<-cnames1[-c(1)]
      
      
      match_names_check<-match(colnames(testset),cnames1[-c(1)])
      
      if(length(which(is.na(match_names_check))==TRUE)>0){
        
        stop("Column names don't match between training and test sets.")
      }
      
      if(max(abs(diff(match_names_check)))>1){
        
        stop("Column order doesn't match between training and test sets.")
      }
      
      
      if(classifier=="logitreg" || classifier=="logit"){
        
                if(ncol(d4)>2){
                     d4[,-c(1)]<-apply(d4[,-c(1)],2,function(x){as.numeric(as.character(x))})
                }else{
                  
                  d4[,c(2)]<-as.numeric(as.character(d4[,c(2)]))
                }
                model1 <- glm(d4$Class~., data=d4, family="binomial")
                
                
                pred<-predict(model1,testset,type="response")
               # pred<-ifelse(pred>,)
                #save(d4,model1,testset,testclasslabels,pred,file="logit.Rda")
                pred1 <- ROCR::prediction(pred, testclasslabels)
        
                 #pred1<-multiclass.roc(testclasslabels,as.numeric(pred)) #,levels=levels(as.factor(y1)))
        
      }else{
        
                #Use SVM
                #save(d4,d3,testset,testclasslabels,svm.type,featlist,d1,d2,kname,num_select,n,file="d4.Rda")
                #model1 <- svm(as.factor(d4$Class)~., data=d4, type=svm.type,probability=TRUE,kernel=kname)
                
                #d4[,-c(1)]<-apply(d4[,-c(1)],2,function(x){as.numeric(as.character(x))})
                
                if(ncol(d4)>2){
                  d4[,-c(1)]<-apply(d4[,-c(1)],2,function(x){as.numeric(as.character(x))})
                }else{
                  
                  d4[,c(2)]<-as.numeric(as.character(d4[,c(2)]))
                }
                
                model1 <- svm(as.factor(d4$Class)~., data=d4, type="C",probability=TRUE,kernel=kname)
                
                
                
                
                
                if(length(levels(as.factor(d4$Class)))>2){
                  pred<-predict(model1,testset,probability=FALSE,decision.values=FALSE,type="prob")
                  
                  #pred<-as.numeric(as.character(pred))
                  
                  #  testclasslabels<-as.numeric(as.character(testclasslabels))
                  
                  data_1<-cbind(testclasslabels,pred)
                  colnames(data_1)<-c("response","predictor")
                  
                  # ##save(data_1,file="data_1.Rda")
                  
                  pred1<-multiclass.roc(testclasslabels,pred,levels=levels(as.factor(d4$Class)),data=data_1)
                  #   ##save(pred1,file="pred1.Rda")
                  
                }else{
                  
                  pred<-predict(model1,testset,probability=TRUE,decision.values=TRUE,type="prob")
                  
                  pred1 <- ROCR::prediction(attributes(pred)$probabilities[,2], testclasslabels)
                  #pred1<-multiclass.roc(factor(testclasslabels),attributes(pred)$probabilities[,2],levels=levels(as.factor(d4$Class)))
                }
                
        
      }
      
      
      if(length(levels(as.factor(d4$Class)))==2){
        
        stats1a <- performance(pred1, 'tpr', 'fpr')
        
        roc_res<-cbind(stats1a@x.values[[1]],stats1a@y.values[[1]])
        colnames(roc_res)<-c(stats1a@x.name,stats1a@y.name)
        fname1=paste("ROC",classifier,".rda",sep="")
        ##saveroc_res,file=fname1)
        x1<-seq(0,1,0.01)
        y1<-x1
        p1<-performance(pred1,"auc")
        mod.lab <-c(mod.lab,paste('using top ',(num_select-1),' m/z features: AUC ',round(p1@y.values[[1]],2),sep=""))
        if(n==1){
          plot(stats1a@x.values[[1]], stats1a@y.values[[1]], type='s', ylab=stats1a@y.name, xlab=stats1a@x.name, col=col_lab[n], lty=2, main=mainlab,cex.main=0.7,lwd=2)
        }else{
          lines(stats1a@x.values[[1]], stats1a@y.values[[1]], type='s', col=col_lab[n], lty=2,lwd=2)
        }
        
      }
      
      roc_res_list[[n]]<-roc_res
     # return(roc_res)
    } #)
    
    if(length(levels(as.factor(d4$Class)))==2){
      lines(x1, y1, col="black", type="l",lwd=2)
      if(legend==TRUE){
        
        legend('bottomright', c(mod.lab), col=col_lab, lwd=c(2,1), lty=1:3, cex=0.8, bty='n')
      }
    }
  }else{
    
    
    
    
    
    d4<-as.data.frame(d3)
    testset<-as.data.frame(testset)
    
    #  ##saved4,testset,testclasslabels,file="d4.Rda")
    
    testset<-testset[,which(colnames(testset)%in%colnames(d4))]
    
    match_names_check<-match(colnames(testset),colnames(d4))
    
    
    if(length(which(is.na(match_names_check))==TRUE)>0){
      
      stop("Column names don't match between training and test sets.")
    }
    
    if(max(abs(diff(match_names_check)))>1){
      
      stop("Column order doesn't match between training and test sets.")
    }
    
    
    if(classifier=="logit" || classifier=="logitreg"){
      
      
      
      testset<-as.data.frame(testset)
      
      if(ncol(d4)>2){
        d4[,-c(1)]<-apply(d4[,-c(1)],2,function(x){as.numeric(as.character(x))})
      }else{
        
        d4[,c(2)]<-as.numeric(as.character(d4[,c(2)]))
      }
      
      model1 <- glm(d4$Class~., data=d4, family=binomial)
      
      #pred1 <- prediction(fitted(model1), d3$Class)
      
      pred<-predict(model1,testset)
      
      # pred1 <- ROCR::prediction(pred, testclasslabels)
      
      pred1<-multiclass.roc(testclasslabels,as.numeric(pred))
      
    }else{
      
      if(ncol(d4)>2){
        d4[,-c(1)]<-apply(d4[,-c(1)],2,function(x){as.numeric(as.character(x))})
      }else{
        
        d4[,c(2)]<-as.numeric(as.character(d4[,c(2)]))
      }
      
      
      model1 <- svm(as.factor(d4$Class)~., data=d4, type=svm.type,probability=TRUE,kernel=kname)
      
      
      
      if(length(levels(as.factor(d4$Class)))>2){
        pred<-predict(model1,testset,probability=FALSE,decision.values=FALSE,type="prob")
        
        pred<-as.numeric(as.character(pred))
        
        #  testclasslabels<-as.numeric(as.character(testclasslabels))
        
        data_1<-cbind(testclasslabels,pred)
        colnames(data_1)<-c("response","predictor")
        
        # ##save(data_1,file="data_1.Rda")
        
        pred1<-multiclass.roc(testclasslabels,pred,levels=levels(as.factor(d4$Class)),data=data_1)
        # ##save(pred1,file="pred1.Rda")
        
      }else{
        
        
        pred<-predict(model1,testset,probability=TRUE,decision.values=TRUE,type="prob")
        pred1 <- ROCR::prediction(attributes(pred)$probabilities[,2], testclasslabels)
        
        # pred1<-multiclass.roc(testclasslabels,attributes(pred)$probabilities[,2])
        
        
      }
      
      
    }
    
    n=1
    
    if(length(levels(as.factor(d4$Class)))==2){
      
      stats1a <- performance(pred1, 'tpr', 'fpr')
      roc_res<-cbind(stats1a@x.values[[1]],stats1a@y.values[[1]])
      
      
      colnames(roc_res)<-c(stats1a@x.name,stats1a@y.name)
      
      fname1=paste("ROC",classifier,".rda",sep="")
      ##saveroc_res,file=fname1)
      x1<-seq(0,1,0.01)
      y1<-x1
      p1<-performance(pred1,"auc")
      mod.lab <-c(mod.lab,paste('using selected ',(num_select),' m/z features: AUC ',round(p1@y.values[[1]],2),sep=""))
      if(n==1){
        plot(stats1a@x.values[[1]], stats1a@y.values[[1]], type='s', ylab=stats1a@y.name, xlab=stats1a@x.name, col=col_lab[n], lty=2, 
             main=mainlab,cex.main=0.7,lwd=2)
      }else{
        lines(stats1a@x.values[[1]], stats1a@y.values[[1]], type='s', col=col_lab[n], lty=2,lwd=2)
      }
      
      roc_res_list[[1]]<-roc_res
    }
    
  }
  
#if(FALSE){
  if(length(levels(as.factor(d4$Class)))==2){
    lines(x1, y1, col="black", type="l",lwd=2)
    if(legend==TRUE){
      legend('bottomright', c(mod.lab), col=col_lab, lwd=c(2,1), lty=1:3, cex=0.8, bty='n')
      
    }
    
    auc_res<-p1@y.values[[1]]
  }
  #else{
    
   # auc_res<-pred1$auc
    
    #roc_res<-pred1
    
  #}

  if(newdevice==TRUE){
    try(dev.off(),silent=TRUE)
  }else{
    
    
  }
  options(warn=0)
  return(list("roc"=roc_res)) #prediction"=pred1, #"auc"=auc_res,
}




svm_cv<-function(v,x,y,kname="radial",errortype="CV",conflevel=95,seednum=555,match_class_dist=TRUE,svm.type="C-classification"){
  
  num_samp=dim(x)[1]
  
  num_datasets= floor(num_samp)
  n1<-floor(num_samp/v)
  n2<-num_samp-n1*v
  n3<-v-n2
  
  ind<-rep(c(n1,n1+1),c(n3,n2))
  ind<-diffinv(ind)
  min_err=1
  best_k=1
  y[,1]<-factor(y[,1])
  
  #set.seed(seednum)
  #group<-sample(1:num_samp,num_samp, replace=FALSE)
  
  suppressMessages(library(CMA))
  if(match_class_dist==TRUE){
    set.seed(seednum)
    #group=GenerateLearningsets(y=y[,1],niter=1,fold=v,method="CV",strat=TRUE)
    group=GenerateLearningsets(y=y[,1],niter=v,fold=v,method="MCCV",strat=TRUE,ntrain=(num_samp-floor(num_samp/v)))
    #return(y)
    # return(group)
    
  }else{
    
    set.seed(seednum)
    group<-sample(1:num_samp,num_samp, replace=FALSE)
    # return(group)
  }
  
  
  ###savegroup,x,y,file="temp2.Rda")
  itr=0
  #svm_acc <- matrix(0,v)  # we set K=30 before, it can be changed to any number<100.
  svm_acc<-rep(0,v)
  #for ( i in 1:v)
  
  #cl<-makeCluster(detectCores()*0.4)
  
  svm_acc<-lapply(1:v,function(i)
  {
    
    if(match_class_dist==TRUE){
      g<-group@learnmatrix[i,]
      g<-seq(1,length(y[,1]))[-group@learnmatrix[i,]]
      
    }else{
      g<-group[(ind[i]+1):ind[i+1]]
    }
    
    
    temptest<-x[g,]
    temptrain <-x[-g,]
    tempclass <-y[-g,]
    testclass<-y[g,]
    
    
    mod_cv <- svm(x=temptrain,y=tempclass, type=svm.type,kernel=kname)
    
    if(v==num_samp){
      
      predfit<-predict(mod_cv,t(temptest))
    }else{
      predfit<-predict(mod_cv,(temptest))
    }
    
    svm_table<-table(predfit,testclass)
    
    class_names<-rownames(svm_table)
    beracc<-{}
    auc_acc<-{}
    totacc<-length(which(predfit==testclass))/length(testclass)
    for(c in 1:dim(svm_table)[1]){
      testclass_ind<-which(testclass==class_names[c])
      beracc<-c(beracc,length(which(predfit[testclass_ind]==testclass[testclass_ind]))/length(testclass_ind))
      
    }
    if(errortype=="AUC"){
      testclass<-as.vector(testclass)
      y1<-as.vector(y[,1])
      pred_acc<-multiclass.roc(testclass,as.numeric(predfit),levels=levels(as.factor(y1)))
      pred_acc_orig<-pred_acc$auc[1]
      auc_acc<-c(auc_acc,pred_acc_orig)
    }
    
    
    
    beracc<-mean(beracc,na.rm=TRUE)
    
    if(errortype=="CV"){
      svm_acc<-(totacc*100)
    }else{
      if(errortype=="AUC"){
        svm_acc<-(auc_acc*100)
      }else{
        svm_acc<-(beracc*100)
      }
    }
    return(svm_acc)
  })
  
  svm_acc<-unlist(svm_acc)
  avg_acc <-mean(svm_acc,na.rm=TRUE)
  sd_acc<-sd(svm_acc,na.rm=TRUE)
  
  #limit<-avg_acc-(sd.error*(avg_acc) # 1 sd criterion
  #print(avg_acc)
  #print(sd_acc)
  
  #return(list(error=avg_acc,sderror=sd.error))
  probval<-(1-(conflevel*0.01))/2
  probval<-1-probval
  #print(probval)
  error <- qnorm(probval)*sd_acc/sqrt(length(svm_acc))
  
  leftconfint<-avg_acc-error
  rightconfint<-avg_acc+error
  
  #print("done")
  return(list(avg_acc=avg_acc,sd_acc=sd_acc, acc_each_fold=svm_acc,confint=c(leftconfint,rightconfint)))
  #return(list(num=best_k,error=min_err, avg=avg_acc))
}

plsda_cv<-function(v,x,y,ncomp,errortype="total",conflevel=99){
  
  num_samp=dim(x)[1]
  
  num_datasets= floor(num_samp)
  n1<-floor(num_samp/v)
  n2<-num_samp-n1*v
  n3<-v-n2
  
  ind<-rep(c(n1,n1+1),c(n3,n2))
  ind<-diffinv(ind)
  min_err=1
  best_k=1
  
  set.seed(555)
  group<-sample(1:num_samp,num_samp, replace=FALSE)
  
  
  itr=0
  #plsda_error <- matrix(0,v)  # we set K=30 before, it can be changed to any number<100.
  plsda_error<-rep(0,v)
  for ( i in 1:v)
  {
    g<-group[(ind[i]+1):ind[i+1]]
    temptest<-x[g,]
    temptrain <-x[-g,]
    tempclass <-y[-g]
    testclass<-y[g]
    
    #temptest<-as.data.frame(temptest)
    #temptrain<-as.matrix(temptrain)
    
    
    
    #print(dim(temptrain))
    #print(dim(temptest))
    
    #plsda_cv <- plsda(x=temptrain,y=tempclass, type="nu-classification",kernel=kname) 
    
    #opt_comp<-pls.lda.cv(Xtrain=temptrain, Ytrain=tempclass,  ncomp=c(1:10), nruncv=10, alpha=2/3, priors=NULL)
    predfit<-pls.lda(Xtrain=temptrain,Ytrain=tempclass,ncomp=ncomp,nruncv=v,Xtest=temptest)
    #predfit<-predict(plsda_pred,temptest)
    
    #print(length(which(plsda_pred$predclass==testclass)))
    svm_table<-table(predfit$predclass,testclass)
    
    class_names<-rownames(svm_table)
    #print(testclass)
    #print(predfit$predclass)
    predfit<-predfit$predclass
    totacc<-length(which(predfit==testclass))/length(testclass)
    
    beracc<-{}
    auc_acc<-{}
    for(c in 1:dim(svm_table)[1]){
      testclass_ind<-which(testclass==class_names[c])
      beracc<-c(beracc,length(which(predfit[testclass_ind]==testclass[testclass_ind]))/length(testclass_ind))
      
      
      if(errortype=="AUC"){
        pred_acc<-multiclass.roc(testclass,as.numeric(predfit),levels=levels(as.factor(y)))
        pred_acc_orig<-pred_acc$auc[1]
        auc_acc<-c(auc_acc,pred_acc_orig)
      }
      
    }
    
    beracc<-mean(beracc,na.rm=TRUE)
    
    if(errortype=="CV"){
      plsda_error[i]<-(totacc*100)	
    }else{
      if(errortype=="AUC"){
        plsda_error[i]<-(auc_acc*100)
      }else{
        plsda_error[i]<-(beracc*100)
      }
    }
    
    
    
  }
  avgacc <-mean(plsda_error)
  sdacc<-sd(plsda_error)
  
  probval<-(1-(conflevel*0.01))/2
  probval<-1-probval
  
  error <- qnorm(probval)*sdacc/sqrt(length(y))
  
  leftconfint<-avgacc-error
  rightconfint<-avgacc+error
  
  
  
  return(list(mean_acc=avgacc,sd_acc=sdacc, acc_each_fold=plsda_error,confint=c(leftconfint,rightconfint)))
  
  
}




do_pamr<-function(X,Y,fdrthresh=0.1,nperms=100,pamr.threshold.select.max=FALSE,kfold=10){
  
  
  library(pamr)
  
  #d1<-list(x=X,y=Y)
  
  d1 <- list(x=as.matrix(X),y=factor(Y[,1]), geneid=as.character(1:nrow(X)),
             genenames=paste("g",as.character(1:nrow(X)),sep=""))
  
  ###save(d1,file="d1.Rda")
  p1<-pamr.train(d1)
  
  set.seed(999)
  p2<-pamr.cv(data=d1,fit=p1,nfold=kfold)
  
  threshold_CVerror_matrix<-cbind(p2$threshold,p2$error)
  threshold_CVerror_matrix<-as.data.frame(threshold_CVerror_matrix)
  colnames(threshold_CVerror_matrix)<-c("Threshold","error")
  
  threshold_value<-max(threshold_CVerror_matrix[which(threshold_CVerror_matrix[,2]==min(threshold_CVerror_matrix[,2])),1])[1]
  
  
  
  set.seed(999)
  p3<-pamr.fdr(data=d1,p1,nperms=nperms)
  
  selected_feature_index<-{}
  
  max.discore<-{}
  
  #use median FDR
  if(length(which(p3$results[,4]<fdrthresh))>0){
    pamr_fdr_filt<-p3$results[which(p3$results[,4]<fdrthresh),]
    
    if(length((pamr_fdr_filt))>0){
      threshold_CVerror_fdrmatrix<-merge(threshold_CVerror_matrix,pamr_fdr_filt,by="Threshold")
      
      if(pamr.threshold.select.max==TRUE){
        threshold_value<-max(threshold_CVerror_fdrmatrix[which(threshold_CVerror_fdrmatrix[,2]==min(threshold_CVerror_fdrmatrix[,2])),1])[1]
      }else{
        threshold_value<-min(threshold_CVerror_fdrmatrix[which(threshold_CVerror_fdrmatrix[,2]==min(threshold_CVerror_fdrmatrix[,2])),1])[1]
        
        
      }
      
    }
  }else{
    
    print("pamr: no features meet the fdr criteria")
  }
  
  p4<-pamr.listgenes(fit=p1,data=d1,threshold=threshold_value)
  p4<-as.data.frame(p4)
  
  selected_feature_index<-p4$id
  selected_feature_index<-as.numeric(as.character(selected_feature_index))
  
  discore_matrix<-p4[,-c(1)]
  if(nrow(discore_matrix)>1){
    discore_matrix<-apply(discore_matrix,2,as.numeric)
    abs.discore_matrix<-abs(discore_matrix)
    max.discore<-apply(abs.discore_matrix,1,max)
    
  }else{
    discore_matrix_1<-unlist(discore_matrix)
    discore_matrix<-as.numeric(as.character(discore_matrix_1))
    abs.discore_matrix<-abs(discore_matrix)
    max.discore<-max(abs.discore_matrix)
    
  }
  
  
  
  
  pall<-pamr.listgenes(fit=p1,data=d1,threshold=0)
  
  ##savepall,file="pall.Rda")
  
  pall<-as.data.frame(pall)
  
  
  
  discore_matrix_all<-pall #[,-c(1)]
  discore_matrix_all<-apply(discore_matrix_all,2,as.numeric)
  discore_matrix_all<-as.data.frame(discore_matrix_all)
  discore_matrix_all<-discore_matrix_all[order(discore_matrix_all$id),]
  
  
  discore_matrix_all<-discore_matrix_all[,-c(1)]
  if(nrow(discore_matrix_all)>1){
    discore_matrix_all<-apply(discore_matrix_all,2,as.numeric)
    abs.discore_matrix_all<-abs(discore_matrix_all)
    max.discore.all<-apply(abs.discore_matrix_all,1,max)
    
    max.discore.all.thresh<-min(max.discore.all[selected_feature_index],na.rm=TRUE)
    
    
  }else{
    discore_matrix_all_1<-unlist(discore_matrix_all)
    discore_matrix_all<-as.numeric(as.character(discore_matrix_all_1))
    abs.discore_matrix_all<-abs(discore_matrix_all)
    max.discore.all<-max(abs.discore_matrix_all)
    
    max.discore.all.thresh<-min(max.discore.all[selected_feature_index],na.rm=TRUE)
    
  }
  
  
  # ###savelist=ls(),file="debug.Rda")
  return(list("feature.list"=selected_feature_index,"max.discore.sigfeats"=max.discore,"pam_train_model"=p1,"pam_toplist"=p4,"max.discore.allfeats"=max.discore.all,"threshold_value"=threshold_value,"max.discore.all.thresh"=max.discore.all.thresh))
}

do_plsda<-function(X,Y,oscmode="pls",numcomp=3,kfold=10,evalmethod="CV",keepX=15,sparseselect=FALSE,analysismode="classification",
                   vip.thresh=1,sample.col.opt="default",sample.col.vec=c("red","green","blue","purple"),
                   scoreplot_legend=TRUE,feat_names=NA,pairedanalysis=FALSE,optselect=FALSE,class_labels_levels_main=NA,
                   legendlocation="bottomleft",plotindiv=TRUE,pls.vip.selection="max",output.device.type="pdf",
                   plots.res=600,plots.width=8,plots.height=8,plots.type="cairo",pls.ellipse=TRUE,alphabetical.order=FALSE)
{
  repeatmeasures=pairedanalysis
  
  #print("Starting here")
  if(output.device.type!="pdf"){
    
    temp_filename_1<-"Figures/PLS_performance_plots.pdf"
    #pdf(temp_filename_1)
    
   # pdf(temp_filename_1,width=plots.width,height=plots.height)
  }
  
  
  
  num_var<-dim(X)[1]
  
  if(keepX>num_var){
    keepX=num_var
  }
  
  
  
  X<-t(X)
  
  
  Y<-as.data.frame(Y)
  
  classlabels<-Y    
  
  
# save(X,Y,pairedanalysis,classlabels,file="plspaireddebug.Rda")
  
  #only one column for classlabels if mode=classificaion unpaired
  if(pairedanalysis==FALSE){
    Yclass<-Y[,1]
    
    if(analysismode=="regression"){
      Y<-as.numeric(Y[,1])
    }else{
      
      if(alphabetical.order==FALSE){
        
        Y[,1]<-factor(Y[,1],levels=unique(Y[,1]))
        Yclass<-Y[,1]
      }
      Y<-as.numeric(as.factor(Y[,1]))
    }
    #Y<-as.factor(Y[,1])
    #Yclass<-as.factor(Y[,1])
  }else{
     
    #repeat measures
    if(dim(Y)[2]>2){
      if(analysismode=="classification"){
        
        if(alphabetical.order==FALSE){
          
          Y[,2]<-factor(Y[,2],levels=unique(Y[,2]))
          Y[,3]<-factor(Y[,3],levels=unique(Y[,3])) 
        }
        
        Yclass<-as.factor(Y[,2]):as.factor(Y[,3])
        
        Y<-as.numeric(as.factor(Yclass))
      }else{
        Yclass<-Y[,3] #:Y[,3]
        
        Y<-as.numeric(Yclass)
      }
      
      
    }else{
      if(analysismode=="classification"){
        
        if(alphabetical.order==FALSE){
          
          Y[,2]<-factor(Y[,2],levels=unique(Y[,2]))
          
        }
      }
      
      Yclass<-Y[,2]
      Y<-as.numeric(Y[,2])
      # Y<-as.factor(Y[,2])
    }
    
  }
  
  class_labels_levels<-levels(as.factor(Yclass))
  alphacol=0.3
  if(sample.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{
    if(sample.col.opt=="topo"){
      
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(sample.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(sample.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=sample.col.opt)
              
              if(length(check_brewer)>0){
                sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                
              }else{
                
                if(sample.col.opt=="journal"){
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                }else{
                  #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                #  if(length(sample.col.opt)==1){
                 #   col_vec <-rep(sample.col.opt,length(class_labels_levels))
                #  }else{
                    
                 #   colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    
                #  }
                  
                  if(length(sample.col.opt)==1){
                    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  }else{
                    
                    if(length(sample.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-sample.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                      
                      
                    }else{
                      colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    }
                    
                  }
                }
                
              }
              
            }
          }
          
          
        }
        
      }
      
    }
  }
  
  
  
  
  #print("starting")
  if(dim(X)[2]>1){
    if(optselect==TRUE){
      if(analysismode=="classification")
      {
        set.seed(123)
        opt_comp<-plsgenomics::pls.lda.cv(Xtrain=X, Ytrain=Yclass,  ncomp=c(1:numcomp), nruncv=kfold, alpha=2/3, priors=NULL)
        
        
      }else{
        if(analysismode=="regression")
        {
          
          set.seed(123)
          opt_comp<-plsgenomics::pls.regression.cv(Xtrain=X, Ytrain=Y,  ncomp=c(1:numcomp), nruncv=kfold, alpha=2/3)
          
          
        }
        
      }
    }else{
      
      opt_comp<-numcomp
      keep_x_vec<-rep(keepX,opt_comp)
    }
    
  }
  
  suppressWarnings(dir.create("Tables",showWarnings = FALSE))
  if(opt_comp<2){
    opt_comp<-2
  } 
  if(oscmode=="o1pls"){
    leukemia.pls <- plsr(Y ~ X, ncomp = opt_comp, validation = "LOO")
    ww <- leukemia.pls$loading.weights[,1]
    pp <- leukemia.pls$loadings[,1]
    w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
    t.ortho <- X %*% w.ortho
    
    p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
    Xcorr <- X - tcrossprod(t.ortho, p.ortho)
    
    if(analysismode=="classification")
    {
      cv_res<-plsda_cv(v=kfold,x=Xcorr,y=Yclass,ncomp=opt_comp,errortype=evalmethod)
      #print(paste(kfold," CV evaluation using o1plsda",sep=""))
      #print(cv_res)
    }
    
    X<-Xcorr
  }
  
  if(oscmode=="o2pls"){
    leukemia.pls <- plsr(Y ~ X, ncomp = opt_comp, validation = "LOO")
    ww <- leukemia.pls$loading.weights[,1]
    pp <- leukemia.pls$loadings[,1]
    w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
    t.ortho <- X %*% w.ortho
    
    p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
    Xcorr <- X - tcrossprod(t.ortho, p.ortho)
    
    
    if(analysismode=="classification")
    {
      cv_res<-plsda_cv(v=kfold,x=Xcorr,y=Yclass,ncomp=opt_comp,errortype=evalmethod)
      
      
      #print(paste(kfold," CV evaluation using o2plsda",sep=""))
      #print(cv_res)
    }
    
    X<-Xcorr
  }
  
  
  
  bad_variables<-{}
  
  if(sparseselect==TRUE)
  {
    
    if(analysismode=="classification")
    {
      if(optselect==TRUE){
        keepx_seq<-seq(5,keepX,5)
        best_cv_res<-c(0)
        best_kvec<-c(5)
        for(kvec in keepx_seq){
          keep_x_vec<-rep(kvec,opt_comp)
          
          if(repeatmeasures==TRUE){
            
            
            
            linn.pls <- try(multilevel(X=X, design=classlabels,ncomp = opt_comp,
                                       keepX = keep_x_vec, method = 'splsda'),silent=TRUE)
            
            if(is(linn.pls,"try-error")){
              
              
              
              
              linn.pls <- mixOmics::splsda(X=X,Y=classlabels[,-c(1)],ncomp=opt_comp,keepX=keep_x_vec,multilevel=classlabels[,1])
              
            }
            
          }else{
            
            linn.pls <- mixOmics::splsda(X, Yclass,ncomp=opt_comp,keepX=keep_x_vec)
          }
          
          
          
          linn.vip<-linn.pls$loadings$X
          
          
          bad_variables<-linn.pls$nzv$Position
          
          good_feats<-{}
          for(c1 in 1:opt_comp){
            good_feats<-c(good_feats,which(linn.vip[,c1]!=0))
          }
          
          good_feats<-unique(good_feats)
          
          
          
          if(length(good_feats)>1){
            
            cv_res<-try(plsda_cv(v=kfold,x=X[,good_feats],y=Yclass,ncomp=opt_comp,errortype=evalmethod),silent=TRUE)
            
            
           # print(paste(kfold," CV evaluation using spls top ",kvec," features per component",sep=""))
          #  print(cv_res$mean_acc)
            if(cv_res$mean_acc>=best_cv_res){
              
              best_cv_res<-cv_res$mean_acc
              best_kvec<-kvec
              
              #best_ncomp<-cv_res$ncomp
            }
          }else{
            print("Too few variables to perfrom CV.")
          }
        }
        
        keep_x_vec<-rep(best_kvec,opt_comp)
      }else{
        
        keep_x_vec<-rep(keepX,opt_comp)
      }
    }
    else{
      
      keep_x_vec<-rep(keepX,opt_comp)
      
    }
    
    
    if(analysismode=="regression"){
      
      #   #save(X,Y,opt_comp,classlabels,file="splsreg.Rda")
      if(repeatmeasures==TRUE){
        
        #  ###savelist=ls(),file="debugspls.Rda")
        
        
        
        
        linn.pls <- try(multilevel(X=X, design=classlabels[,2],ncomp = opt_comp,
                                   keepX = keep_x_vec, method = 'spls'),silent=TRUE)
        
        
        if(is(linn.pls,"try-error")){
          
          
          
          
          linn.pls <- mixOmics::spls(X=X,Y=Y,ncomp=opt_comp,keepX=keep_x_vec,multilevel=classlabels[,2])
          
        }
        
        
        
        
      }else{
        linn.pls <- mixOmics::spls(X, Y,ncomp=opt_comp,keepX=keep_x_vec,mode="regression")
      }
    }else{
      #analysismode classification
      if(repeatmeasures==TRUE){
        
        
        linn.pls <- try(multilevel(X=X, design=classlabels,ncomp = opt_comp,
                                   keepX = keep_x_vec, method = 'splsda'),silent=TRUE)
        
        if(is(linn.pls,"try-error")){
          
          
          linn.pls <- mixOmics::splsda(X=X,Y=classlabels[,-c(1)],ncomp=opt_comp,keepX=keep_x_vec,multilevel=classlabels[,1])
          
        }
        
        #  ###savelinn.pls,file="linnpls.Rda")
        
        
        
      }else{
        linn.pls <- mixOmics::splsda(X, Y,ncomp=opt_comp,keepX=keep_x_vec)
      }
    }
    
    linn.vip<-linn.pls$loadings$X
    
    
    bad_variables<-linn.pls$nzv$Position
    
    #VIP based feature selection
    good_feats<-{}
    for(c1 in 1:opt_comp){
      good_feats<-c(good_feats,which(linn.vip[,c1]!=0))
    }
    
    good_feats<-unique(good_feats)
    
    
    
  }else{
    #PLS
    if(analysismode=="regression"){
      
      
      if(repeatmeasures==TRUE){
        
        ##save(X,Y,opt_comp,classlabels,file="plsreg.Rda")
        linn.pls <- mixOmics::pls(X=X,Y=Y,ncomp=opt_comp,multilevel=classlabels[,1])
        
        #  print("done here")
        
      }else{
        
        linn.pls <- mixOmics::pls(X, Y,ncomp=opt_comp)
      }
      
      
    }else{
      
      if(analysismode=="classification"){
        if(repeatmeasures==TRUE){
          
          # print("multilevel PLS classlabels")
          #print(head(classlabels))
          
          linn.pls <- mixOmics::plsda(X, Yclass,ncomp=opt_comp,multilevel=classlabels[,1])
        }else{
          linn.pls <- mixOmics::plsda(X, Yclass,ncomp=opt_comp)
        }
        
      }
    }
    
    
    linn.vip<-mixOmics::vip(linn.pls)
    
    
    bad_variables<-linn.pls$nzv$Position
    
    
    
    good_feats<-{}
    c1<-1
    
    
    good_feats<-{}
    
    if(pls.vip.selection=="max"){
      if(opt_comp>1){
        for(c1 in 1:opt_comp){
          good_feats<-c(good_feats,which(linn.vip[,c1]>vip.thresh))
        }
        
      }else{
        good_feats<-which(linn.vip>vip.thresh)
        
      }
      
    }else{
      
      if(opt_comp>1){
        linn.vip.mean<-apply(linn.vip,1,mean)
        
        good_feats<-which(linn.vip.mean>vip.thresh)
      }else{
        good_feats<-which(linn.vip>vip.thresh)
        
      }
      
    }
    good_feats<-unique(good_feats)
    
  }
  
  
  v1<-{}
  cv_res<-{}
  if(length(good_feats)>1)
  {
    
    #print(paste(oscmode," PLS evaluation using selected variables",sep=""))
    
    
    if(analysismode=="classification"){
      
      if(FALSE){
        if(length(Y)>10){ 
          cv_res<-try(plsda_cv(v=kfold,x=X,y=Y,ncomp=opt_comp,errortype=evalmethod),silent=TRUE)
          
          print(paste(kfold," CV ", evalmethod, " using all features: ",cv_res,sep=""))
          
          
          cv_res<-try(plsda_cv(v=kfold,x=X[,good_feats],y=Y,ncomp=opt_comp,errortype=evalmethod),silent=TRUE)
          
          print(paste(kfold," CV ", evalmethod, " using top features: ",cv_res,sep=""))
        }
        
        if(length(Y)>30){
        set.seed(2543) # for reproducibility here, only when the `cpus' argument is not used
        perf.plsda <- perf(linn.pls, validation = "Mfold", folds = 5, 
                           progressBar = FALSE, auc = TRUE, nrepeat = 10) 
        }else{
          set.seed(2543) # for reproducibility here, only when the `cpus' argument is not used
          perf.plsda <- perf(linn.pls, validation = "loo", 
                             progressBar = FALSE, auc = TRUE) 
          
        }
        # perf.plsda.srbct$error.rate  # error rates
        plot(perf.plsda, col = color.mixo(1:3), sd = TRUE, legend.position = "horizontal")
        
        
      }
    }else{
      
      
      print(paste(oscmode," PLS evaluation using all variables",sep=""))
      
      temp_d<-cbind(Y,X[,good_feats])
      temp_d<-as.data.frame(temp_d)
      
     # linn.pls3 <- mixOmics::pls(X[,good_feats], Y)
      
      linn.pls2 <- mixOmics::pls(X, Y,ncomp=opt_comp)
      r2_q2_valid_res<-{}
      
      if(length(Y)>30){
        
        if(opt_comp>1){
          
          #linn.pls2 <- pls(X, Y,ncomp=opt_comp) #pls(X, Y,ncomp=opt_comp)
          #v1<-try(perf(linn.pls2,validation="loo"),silent=TRUE)
          
          v1<-try(mixOmics::perf(linn.pls2,validation="Mfold",folds=kfold),silent=TRUE)
          
          
          
          if(is(v1,"try-error")){
            
          }else{
            
            r2_q2_valid_res<-rbind(v1$R2,v1$Q2,v1$MSEP)
            
            if(nrow(r2_q2_valid_res)>0){
              rownames(r2_q2_valid_res)<-c("R2","Q2","MSEP")
            }
            
            cnames_vres<-paste("PLScomp",seq(1,opt_comp),sep="")
            colnames(r2_q2_valid_res)<-cnames_vres
            
            
            
            write.table(r2_q2_valid_res,file="Tables/pls_r2_q2_res_usingallfeatures.txt",sep="\t",row.names=TRUE)
            if(plotindiv==TRUE){
              w <- 0.1 #grconvertX(l$rect$w, to='ndc') - grconvertX(0, to='ndc')
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              barplot(r2_q2_valid_res[1:2,],beside=TRUE,main="PLS leave-one-out validation diagnostics using all features",ylab="Variation",col=c("darkgrey","lightgrey"))
              #legend("topright",c("R2","Q2"),col=c("darkgrey","lightgrey"),pch=c(20))
              
              le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("R2","Q2"), col=c("darkgrey","lightgrey"),pch = c(19), pt.cex = 0.6, title = "",cex=0.8))
              
            }
            
            #linn.pls2 <- pls(X, Y,ncomp=opt_comp) #pls(X, Y,ncomp=opt_comp)
            
          }
          
        }
        
      }else{
        r2_q2_valid_res<-{}
        if(opt_comp>1){
          print("PLS loo validation diagnostics using all features")
          
          v1<-try(mixOmics::perf(linn.pls2,validation="loo"),silent=TRUE)
          
          if(is(v1,"try-error")){
            
          }else{
            
            r2_q2_valid_res<-rbind(v1$R2,v1$Q2,v1$MSEP)
            
            if(nrow(r2_q2_valid_res)>0){
              rownames(r2_q2_valid_res)<-c("R2","Q2","MSEP")
            }
            
            cnames_vres<-paste("PLScomp",seq(1,opt_comp),sep="")
            colnames(r2_q2_valid_res)<-cnames_vres
            
            if(plotindiv==TRUE){
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              barplot(r2_q2_valid_res[1:2,],beside=TRUE,main="PLS loo validation diagnostics \n using all features",ylab="Variation",col=c("darkgrey","lightgrey"))
              
              le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("R2","Q2"), col=c("darkgrey","lightgrey"),pch = c(19), pt.cex = 0.6, title = "",cex=0.8))
              
            }
          }
          v1<-try(perf(linn.pls3,validation="loo"),silent=TRUE)
          if(is(v1,"try-error")){
          }else{
            
            print("PLS loo validation diagnostics using selected features")
            
            
            r2_q2_valid_res<-rbind(v1$R2,v1$Q2,v1$MSEP)
            
            if(nrow(r2_q2_valid_res)>0){
              rownames(r2_q2_valid_res)<-c("R2","Q2","MSEP")
            }
            
            cnames_vres<-paste("PLScomp",seq(1,dim(r2_q2_valid_res)[2]),sep="")
            colnames(r2_q2_valid_res)<-cnames_vres
            
            write.table(r2_q2_valid_res,file="Tables/pls_r2_q2_res_usingselectfeats.txt",sep="\t",row.names=TRUE)
            
            if(plotindiv==TRUE){
              w <- 0.1 #grconvertX(l$rect$w, to='ndc') - grconvertX(0, to='ndc')
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              barplot(r2_q2_valid_res[1:2,],beside=TRUE,main="PLS loo validation diagnostics \n using selected features",ylab="Variation",col=c("darkgrey","lightgrey"))
              # legend("topright",c("R2","Q2"),col=c("darkgrey","lightgrey"),pch=c(20))
              
              le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("R2","Q2"), col=c("darkgrey","lightgrey"),pch = c(19), pt.cex = 0.6, title = "",cex=0.8))
            }
            
          }
          
        }
        
      }
      
    }
    
    
  }else{
    print("No variables selected.")
  }
  
  
  # print("Done with plsda")
  
  #linn.pls2 <- pls(X, Y,ncomp=opt_comp)
  
  SS<-get_plscompvar(linn.pls,nvar=dim(X)[2],opt_comp)
  
  # SS<-c(linn.pls$loadings$X)^2*colSums(linn.pls$variates$X^2)
  
  pls_var<-100*SS/(sum(SS))
  
  pls_var<-round(pls_var,2)
  
  
  
  if(output.device.type!="pdf"){
    try(dev.off(),silent=TRUE)
    
  }
  
  
  
  #barplot(pls_var,main="PLS %variation per component",cex.main=0.7)
  
  if(analysismode=="classification")
  {
    # color for plotIndiv
    col.stimu = as.numeric(Y)
    
    #print("plotting PLS")
    #print(opt_comp)
    class_labels_levels<-levels(as.factor(Yclass))
    color_vec<-col_vec #sample.col.vec #rainbow(length(class_labels_levels), start = 0, end = 0.1) #c("green","purple")
    col.stimu<-color_vec[col.stimu]
    
    class_labels_levels2<-class_labels_levels
    # pch for plots
    pch.time = rep(15, length(class_labels_levels))
    #pch.time[time == 't2'] = 4
    
    pch_vec<-seq(1,50) #c(3,5,7,9,12,13,2,17,21)
    
    Yclass2=Yclass
    
    
    samplelabels<-as.data.frame(Yclass)
    samplelabels<-as.factor(samplelabels[,1])
    l2<-levels(as.factor(samplelabels))
    col_all=topo.colors(256)
    
    t1<-table(samplelabels)
    if(is.na(class_labels_levels)[1]==TRUE){
      
      l1<-levels(as.factor(samplelabels))
    }else{
      l1<-class_labels_levels
      
      
    }
    
    class_labels_levels<-l1
    
    col <- rep(col_vec[1:length(t1)], t1)
    #col<-rep(col_all[1:length(l1)],t1)
    ## Choose different size of points
    cex <- rep(2, length(Yclass))
    
    pch_vec<-seq(1,50) #c(3,5,7,9,12,13,2,17,21) #seq(1,50) #
    pch <- rep(15,length(Yclass))
    cex <- rep(2, length(Yclass))
    for(p1 in 1:length(l2)){
      
      pch[which(samplelabels==l2[p1])]=pch_vec[p1]
    }
    
    
    if(pairedanalysis==TRUE){
      
      if(ncol(classlabels)>2){
        
        class_labels_levels2<-levels(as.factor(classlabels[,2]):as.factor(classlabels[,3]))
        Yclass2<-as.factor(classlabels[,2]):as.factor(classlabels[,3])
      }else{
        class_labels_levels2<-levels(as.factor(classlabels[,2]))
        Yclass2=classlabels[,2]
      }
    }
    
    #  col.stimu = as.numeric(Yclass2)
    #color_vec<-col_vec #sample.col.vec #rainbow(length(class_labels_levels), start = 0, end = 0.1) #c("green","purple")
    col.stimu<-col #color_vec[col.stimu]
    
    #pch_vec<-seq(1,length(Yclass2))
    
    for(p1 in 1:length(class_labels_levels2)){
      
      pch.time[which(Yclass2==class_labels_levels2[p1])]=pch_vec[p1]
    }
    pch.time=pch
    
    # ###savelist=ls(),file="debug.Rda")
    if(plotindiv==TRUE){
      
      
      if(output.device.type!="pdf"){
        
        temp_filename_1<-"Figures/PLS_pairwise_component_plots.pdf"
        
        #pdf(temp_filename_1)
        pdf(temp_filename_1,width=plots.width,height=plots.height)
        #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      }
      
   #  save(X,linn.pls,pls_var,Yclass,opt_comp,col.stimu,sample.col.opt,class_labels_levels,pls.ellipse,file="plsplots.Rda")
     
    # print(Sys.time())
      get_plsplots(X,plsres=linn.pls,plsvar=pls_var,samplelabels=Yclass,filename=NA,ncomp=opt_comp,center=TRUE,scale=TRUE,legendcex=0.5,outloc=getwd(),col_vec=col.stimu,
                   sample.col.opt=sample.col.opt,alphacol=0.3,legendlocation="topright",class_levels=class_labels_levels,pls.ellipse=pls.ellipse,alphabetical.order=alphabetical.order)
      #,silent=TRUE)
     # print(Sys.time())
      if(output.device.type!="pdf"){
        
        try(dev.off(),silent=TRUE)
      }
      
      
      
    }
    #legend = c(class_labels_levels), cex = 0.55)
  }
  
 # print("Done with PLSDA")
  write.table(linn.pls$variates$X,file="Tables/pls_scores.txt",sep="\t")
  write.table(linn.pls$loadings$X,file="Tables/pls_loadings.txt",sep="\t")
  ####savelinn.pls,file="pls_res.Rda")
  return(list("model"=linn.pls,"vip_res"=linn.vip,"valid_res"=v1,"cv_res"=cv_res,"opt_comp"=opt_comp,"selected_variables"=good_feats,"bad_variables"=bad_variables))
  
}


do_plsda_rand<-function(X,Y,oscmode="pls",numcomp=3,kfold=10,evalmethod="CV",keepX=15,sparseselect=FALSE,analysismode="classification",
                        vip.thresh=1,sample.col.opt="default",sample.col.vec=c("red","green","blue","purple"),scoreplot_legend=TRUE,
                        feat_names=NA,pairedanalysis=FALSE,optselect=FALSE,class_labels_levels_main=NA,
                        legendlocation="bottomleft",plotindiv=TRUE,alphabetical.order=FALSE)
{
  repeatmeasures=pairedanalysis
  
  
  num_var<-dim(X)[1]
  
  if(keepX>num_var){
    keepX=num_var
  }
  
  X<-t(X)
  Y<-as.data.frame(Y)
  
  classlabels<-Y
  
  if(sample.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{
    if(sample.col.opt=="topo"){
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(sample.col.opt=="heat"){
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="rainbow"){
          
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          
        }else{
          
          if(sample.col.opt=="terrain"){
            
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }
          
          
        }
        
      }
      
    }
  }

  if(FALSE){  
  if(pairedanalysis==FALSE){
    Yclass<-Y[,1]
    Y<-as.numeric(Y[,1])
  }else{
    
    if(dim(Y)[2]>2){
      if(analysismode=="classification"){
        
        Yclass<-as.factor(Y[,2]):as.factor(Y[,3])
      }else{
        Yclass<-Y[,3] #:Y[,3]
      }
      Y<-as.numeric(Yclass)
    }else{
      Yclass<-Y[,2]
      Y<-as.numeric(Y[,2])
    }
    
    
    
  }
  }
  
  
  if(pairedanalysis==FALSE){
    Yclass<-Y[,1]
    
    if(analysismode=="regression"){
      Y<-as.numeric(Y[,1])
    }else{
      
      if(alphabetical.order==FALSE){
        
        Y[,1]<-factor(Y[,1],levels=unique(Y[,1]))
        Yclass<-Y[,1]
      }
      Y<-as.numeric(as.factor(Y[,1]))
    }
    #Y<-as.factor(Y[,1])
    #Yclass<-as.factor(Y[,1])
  }else{
    
    #repeat measures
    if(dim(Y)[2]>2){
      if(analysismode=="classification"){
        
        if(alphabetical.order==FALSE){
          
          Y[,2]<-factor(Y[,2],levels=unique(Y[,2]))
          Y[,3]<-factor(Y[,3],levels=unique(Y[,3])) 
        }
        
        Yclass<-as.factor(Y[,2]):as.factor(Y[,3])
        
        Y<-as.numeric(as.factor(Yclass))
      }else{
        Yclass<-Y[,3] #:Y[,3]
        
        Y<-as.numeric(Yclass)
      }
      
      
    }else{
      if(analysismode=="classification"){
        
        if(alphabetical.order==FALSE){
          
          Y[,2]<-factor(Y[,2],levels=unique(Y[,2]))
          
        }
      }
      
      Yclass<-Y[,2]
      Y<-as.numeric(Y[,2])
      # Y<-as.factor(Y[,2])
    }
    
  }
  
  
  
  #Y<-as.numeric(as.factor(Y[,1]))
  #Y<-as.vector(Y)
  
  #  print(dim(X))
  #print(dim(Y))
  
  #print("starting")
  if(dim(X)[2]>1){
    if(optselect==TRUE){
      if(analysismode=="classification")
      {
        set.seed(123)
        opt_comp<-pls.lda.cv(Xtrain=X, Ytrain=Yclass,  ncomp=c(1:numcomp), nruncv=kfold, alpha=2/3, priors=NULL)
        
        #cv_res<-plsda_cv(v=kfold,x=X,y=Y,ncomp=opt_comp,errortype=evalmethod)
        
        #print(paste(kfold," CV evaluation using plsda",sep=""))
        #print(cv_res)
      }else{
        if(analysismode=="regression")
        {
          
          set.seed(123)
          opt_comp<-pls.regression.cv(Xtrain=X, Ytrain=Y,  ncomp=c(1:numcomp), nruncv=kfold, alpha=2/3)
          
          
        }
        
      }
    }else{
      
      opt_comp<-numcomp
      keep_x_vec<-rep(keepX,opt_comp)
    }
    
  }
  
  if(opt_comp<2){
    opt_comp<-2
  }
  if(oscmode=="o1pls"){
    leukemia.pls <- plsr(Y ~ X, ncomp = opt_comp, validation = "LOO")
    ww <- leukemia.pls$loading.weights[,1]
    pp <- leukemia.pls$loadings[,1]
    w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
    t.ortho <- X %*% w.ortho
    
    p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
    Xcorr <- X - tcrossprod(t.ortho, p.ortho)
    
    if(analysismode=="classification")
    {
      cv_res<-plsda_cv(v=kfold,x=Xcorr,y=Yclass,ncomp=opt_comp,errortype=evalmethod)
      #print(paste(kfold," CV evaluation using o1plsda",sep=""))
      #print(cv_res)
    }
    
    X<-Xcorr
  }
  
  if(oscmode=="o2pls"){
    leukemia.pls <- plsr(Y ~ X, ncomp = opt_comp, validation = "LOO")
    ww <- leukemia.pls$loading.weights[,1]
    pp <- leukemia.pls$loadings[,1]
    w.ortho <- pp - crossprod(ww, pp)/crossprod(ww) * ww
    t.ortho <- X %*% w.ortho
    
    p.ortho <- crossprod(X, t.ortho) / c(crossprod(t.ortho))
    Xcorr <- X - tcrossprod(t.ortho, p.ortho)
    
    
    if(analysismode=="classification")
    {
      cv_res<-plsda_cv(v=kfold,x=Xcorr,y=Yclass,ncomp=opt_comp,errortype=evalmethod)
      
      
     # print(paste(kfold," CV evaluation using o2plsda",sep=""))
      #print(cv_res)
    }
    
    X<-Xcorr
  }
  
  
  
  bad_variables<-{}
  
  if(sparseselect==TRUE)
  {
    
    if(analysismode=="classification")
    {
      if(optselect==TRUE){
        keepx_seq<-seq(5,keepX,5)
        best_cv_res<-c(0)
        best_kvec<-c(5)
        for(kvec in keepx_seq){
          keep_x_vec<-rep(kvec,opt_comp)
          
          if(repeatmeasures==TRUE){
            
            #print("spls classlabels")
            #   print(classlabels)
            #print(dim(X))
            
            #linn.pls <- multilevel(X=X, design=classlabels,ncomp = opt_comp,
            #keepX = keep_x_vec, method = 'splsda')
            
            linn.pls <- try(mixOmics::multilevel(X=X, design=classlabels,ncomp = opt_comp,
                                                 keepX = keep_x_vec, method = 'splsda'),silent=TRUE)
            
            if(is(linn.pls,"try-error")){
              
              
              
              
              linn.pls <- mixOmics::splsda(X=X,Y=classlabels[,-c(1)],ncomp=opt_comp,keepX=keep_x_vec,multilevel=classlabels[,1])
              
            }
            
            #print(linn.pls)
            
          }else{
            
            linn.pls <- mixOmics::splsda(X, Yclass,ncomp=opt_comp,keepX=keep_x_vec)
          }
          
          
          
          #linn.vip<-vip(linn.pls)
          linn.vip<-linn.pls$loadings$X
          #linn.vip<-linn.vip[,1]
          
          bad_variables<-linn.pls$nzv$Position
          
          good_feats<-{}
          for(c1 in 1:opt_comp){
            good_feats<-c(good_feats,which(linn.vip[,c1]!=0))
          }
          
          good_feats<-unique(good_feats)
          
          
          
          if(length(good_feats)>1){
            
            cv_res<-plsda_cv(v=kfold,x=X[,good_feats],y=Yclass,ncomp=opt_comp,errortype=evalmethod)
            
            #cv_res<-pls.lda.cv(Xtrain=X, Ytrain=Y,  ncomp=c(1:numcomp), nruncv=kfold, alpha=2/3, priors=NULL)
            
            #cv_res<-cv_res$cv
        #    print(paste(kfold," CV evaluation using spls top ",kvec," features per component",sep=""))
         #   print(cv_res$mean_acc)
            if(cv_res$mean_acc>best_cv_res){
              
              best_cv_res<-cv_res$mean_acc
              best_kvec<-kvec
              
              #best_ncomp<-cv_res$ncomp
            }
          }else{
            print("Too few variables to perfrom CV.")
          }
        }
        
        keep_x_vec<-rep(best_kvec,opt_comp)
      }else{
        
        keep_x_vec<-rep(keepX,opt_comp)
      }
    }
    else{
      #keep_x_vec<-rep(dim(X)[2],opt_comp)
      keep_x_vec<-rep(keepX,opt_comp)
      
    }
    if(analysismode=="regression"){
      
      if(repeatmeasures==TRUE){
        
        #print("spls classlabels")
        #print(classlabels)
        #print(dim(X))
        #print(keep_x_vec)
        
        
        # linn.pls <- multilevel(X=X, design=classlabels,ncomp = opt_comp,
        #keepX = keep_x_vec, method = 'spls')
        
        linn.pls <- try(mixOmics::multilevel(X=X,Y=Y,design=classlabels[,2],ncomp = opt_comp,
                                             keepX = keep_x_vec, method = 'spls'),silent=TRUE)
        
        if(is(linn.pls,"try-error")){
          
          
          
          
          linn.pls <- mixOmics::spls(X=X,Y=Y,ncomp=opt_comp,keepX=keep_x_vec,multilevel=classlabels[,2])
          
        }
        
        
        
        
      }else{
        linn.pls <- mixOmics::spls(X, Y,ncomp=opt_comp,keepX=keep_x_vec,mode="regression")
      }
    }else{
      
      if(repeatmeasures==TRUE){
        #print("spls classlabels")
        #print(classlabels)
        #print(dim(X))
        
        
        #linn.pls <- multilevel(X=X, design=classlabels,ncomp = opt_comp,
        #keepX = keep_x_vec, method = 'splsda')
        
        linn.pls <- try(multilevel(X=X, design=classlabels,ncomp = opt_comp,
                                   keepX = keep_x_vec, method = 'splsda'),silent=TRUE)
        
        if(is(linn.pls,"try-error")){
          
          
          
          
          linn.pls <- mixOmics::splsda(X=X,Y=classlabels[,-c(1)],ncomp=opt_comp,keepX=keep_x_vec,multilevel=classlabels[,1])
          
        }
        
        if(FALSE){
          stimu.time<-data.frame(cbind(as.character(classlabels[,2]),
                                       as.character(classlabels[,3])))
          repeat.stimu2<-classlabels[,1]
          
          res.2level <- multilevel(X, cond = stimu.time,
                                   sample = repeat.stimu2, ncomp = 3,
                                   keepX = keep_x_vec, tab.prob.gene = NULL, method = 'splsda')
        }
        
      }else{
        linn.pls <- mixOmics::splsda(X, Y,ncomp=opt_comp,keepX=keep_x_vec)
      }
    }
    
    linn.vip<-linn.pls$loadings$X
    
    
    
    
    
  }else{
    
    # print("opt comp")
    #print(opt_comp)
    if(analysismode=="regression"){
      
      if(repeatmeasures==TRUE){
        linn.pls <- mixOmics::pls(X, Y,ncomp=opt_comp,multilevel=classlabels[,1])
      }else{
        linn.pls <- mixOmics::pls(X, Y,ncomp=opt_comp)
      }
      
    }else{
      
      if(repeatmeasures==TRUE){
        linn.pls <- mixOmics::plsda(X, Yclass,ncomp=opt_comp,multilevel=classlabels[,1])
      }else{
        linn.pls <- mixOmics::plsda(X, Yclass,ncomp=opt_comp)
      }
    }
    
    linn.vip<-mixOmics::vip(linn.pls)
    
    
    
    
    
  }
  
  
  v1<-{}
  cv_res<-{}
  
  
  
  
  
  return(list("model"=linn.pls,"vip_res"=linn.vip))
  
}

get_plscompvar<- function(p2,nvar,h) {
  
  
  b<-c(p2$loadings$Y)[1:h]
  T<-p2$variates$X[,1:h]
  SS<-b^2 * colSums(T^2)
  
  
  return(SS)
}



get_VIPmulticomp<- function(loadings.X,loadings.Y,scores.X,nvar,h) {
  
  
  b<-c(loadings.Y)[1:h] #c(p2$loadings$Y)[1:h]
  T<-scores.X[,1:h] #p2$variates$X[,1:h]
  SS<-b^2 * colSums(T^2)
  
  W<-loadings.X[,1:h]
  # print(dim(W))
  W<-as.data.frame(W)
  nvar=nrow(W)
  h=ncol(W)
  
  Wnorm2 <- colSums(W^2)
  pls_vec<-lapply(1:nvar,function(j){
    # return(sqrt(nrow(W) * sum(SS * W[j,]^2 / Wnorm2) / sum(SS)))
    
    return(sqrt(nrow(W) * sum( (W[j,]^2 / Wnorm2) * (SS/ sum(SS)))))
  })
  pls_vec<-unlist(pls_vec)
  return(pls_vec)
}


#Function:find.Overlapping.mzs
#Description: This function matches features between two or more datasets using the
#following user defined criteria:
#1) Maximum m/z difference (+/-) ppm
#2) Maximum retention time difference in seconds
#Input:
#data_a->apLCMS output for dataset A,
#data_b->apLCMS output for dataset B,
#max.mz.diff->Maximum m/z difference (+/-) ppm
#max.rt.diff->Maximum retention time difference in seconds
#
#Output:
#Data frame that includes mz and retention time of common features
#
#Usage:
#common_features<-matchFeaturesmulti(data_a, data_b, max.mz.diff=10, max.rt.diff=300)
############################################
find.Overlapping.mzs<-function(dataA, dataB, mz.thresh=10, time.thresh=NA, alignment.tool=NA,use.best.match=FALSE)
{
  
  data_a<-as.data.frame(dataA)
  data_b<-as.data.frame(dataB)
  #data_a<-unique(data_a)
  rm(dataA)
  rm(dataB)
  
  #   data_b<-unique(data_b)
  
  com_mz_num=1
  unique_mz={}
  ppm_v={}
  rt_v={}
  
  commat={}
  
  col.names.dataA=colnames(data_a)
  col.names.dataB=colnames(data_b)
  
  if(is.na(alignment.tool)==FALSE){
    if(alignment.tool=="apLCMS")
    {
      sample.col.start=5
    }
    else
    {
      if(alignment.tool=="XCMS")
      {
        sample.col.start=9
        col.names.dataA[1]="mz"
        col.names.dataA[2]="time"
        col.names.dataB[1]="mz"
        col.names.dataB[2]="time"
        colnames(data_a)=col.names.dataA
        colnames(data_b)=col.names.dataB
      }
      
    }}else{
      #stop(paste("Invalid value for alignment.tool. Please use either \"apLCMS\" or \"XCMS\"", sep=""))
      
      col.names.dataA[1]="mz"
      
      col.names.dataB[1]="mz"
      if(is.na(time.thresh)==FALSE){
        col.names.dataA[2]="time"
        col.names.dataB[2]="time"
        print("Using the 1st column as \"mz\" and 2nd column as \"retention time\"")
      }else{
        print("Using the 1st column as \"mz\"")
      }
      colnames(data_a)=col.names.dataA
      colnames(data_b)=col.names.dataB
    }
  
  #data_a<-data_a[order(data_a$mz),]
  #data_b<-data_b[order(data_b$mz),]
  data_a<-as.data.frame(data_a)
  data_b<-as.data.frame(data_b)
  colnames(data_a)=col.names.dataA
  colnames(data_b)=col.names.dataB
  #create header for the matrix with common features
  if(is.na(time.thresh)==FALSE){
    mznames=c("index.A","mz.data.A", "time.data.A", "index.B","mz.data.B","time.data.B", "time.difference") 
  }else{
    mznames=c("index.A","mz.data.A", "index.B","mz.data.B") 
  }
  
  #Step 1 Group features by m/zdim(data_a)[1]
  mz_groups<-lapply(1:dim(data_a)[1],function(j){
    
    commat={}
    commzA=new("list")
    commzB=new("list")
    ppmb=(mz.thresh)*(data_a$mz[j]/1000000)
    
    getbind_same<-which(abs(data_b$mz-data_a$mz[j])<=ppmb)
    
    if(is.na(time.thresh)==FALSE){
      if(length(getbind_same)>0)
      {
        nearest_time_diff=10000
        bestmatch={}
        rnames={}
        temp={}
        commat={}
        for (comindex in 1:length(getbind_same))
        {
          tempA=cbind(j,data_a[j,c(1,2)])
          tempB=cbind(getbind_same[comindex],data_b[getbind_same[comindex],c(1,2)])
          temp=cbind(tempA,tempB)
          
          timediff=abs(data_a[j,2]-data_b[getbind_same[comindex],2])
          
          temp<-cbind(temp,timediff)
          
          if(timediff<time.thresh && timediff<=nearest_time_diff)
          {
            bestmatch=as.data.frame(temp)
            nearest_time_diff=timediff
          }
          
          
          if(timediff<time.thresh)
          {
            temp<-as.data.frame(temp)
            commat<-rbind(commat,temp)
            rnamestemp<-paste("mz",j,"_",comindex,sep="")
            rnames<-c(rnames,rnamestemp)
          }
          
        }
        
        # if(use.best.match==TRUE){
        
        #print("HERE")
        
        #       commat=as.data.frame(bestmatch)
        #}
        
        if(length(commat)>=4){
          rownames(commat)=rnames
        }
        
        
      }
    }
    else
    {
      if(length(getbind_same)>0)
      {
        temp1<-{}
        for (comindex in 1:length(getbind_same))
        {
          tempA=cbind(j,data_a[j,c(1)])
          tempB=cbind(getbind_same[comindex],data_b[getbind_same[comindex],c(1)])
          temp=cbind(tempA,tempB)
          #temp=cbind(data_a[j,c(1)],data_b[getbind_same[comindex],c(1)])
          temp1<-rbind(temp1,temp)
        }
        commat=as.data.frame(temp1)
        rnames<-paste("mz",j,"_",seq(1,length(getbind_same)),sep="")
        rownames(commat)=rnames
        
      }
    }
    return(as.data.frame(commat))
    
    
  })
  
  #Step 2 Sub-group features from Step 1 by Retention time
  #find the features with RT values within the defined range as compared to the query feature
  
  uniqueinA={}
  uniqueinB={}
  commat=data.frame()
  
  
  if(length(mz_groups)>0){
    for(j in 1:length(mz_groups))
    {
      temp_diff={}
      
      if(is.list(mz_groups)==TRUE)
      {
        tempdata=mz_groups[[j]]
      }
      else
      {
        tempdata=mz_groups[j]
      }
      
      if(length(tempdata)>1)
      {
        
        colnames(tempdata)=mznames
        tempdata=as.data.frame(t(tempdata))
        
        temp=tempdata
        
        temp=as.data.frame(temp)
        
        if(is.null(commat)==TRUE)
        {
          commat=t(temp)
          
        }
        else
        {
          
          commat=rbind(commat,t(temp))
          
        }
        
        
      }
      
      
    }
    
    if(is.null(dim(commat))==FALSE)
    {
      commat=as.data.frame(commat)
      
      if(use.best.match==TRUE){
        
        dup_index_A<-which(duplicated(commat$index.A)==TRUE)
        
        if(length(dup_index_A)>0){
          commat<-commat[-dup_index_A,]
        }
        
        dup_index_B<-which(duplicated(commat$index.B)==TRUE)
        
        if(length(dup_index_B)>0){
          commat<-commat[-dup_index_B,]
        }
        
        
      }
    }
  }
  
  
  return(commat)
}



find.Unique.mzs<-function(dataA, dataB, mz.thresh=10, time.thresh=NA, alignment.tool=NA)
{
  
  
  data_a<-as.data.frame(dataA)
  data_b<-as.data.frame(dataB)
  data_a<-unique(data_a)
  rm(dataA)
  rm(dataB)
  
  data_b<-unique(data_b)
  
  com_mz_num=1
  unique_mz={}
  ppm_v={}
  rt_v={}
  
  commat={}
  
  col.names.dataA=colnames(data_a)
  col.names.dataB=colnames(data_b)
  
  if(is.na(alignment.tool)==FALSE){
    if(alignment.tool=="apLCMS")
    {
      sample.col.start=5
    }
    else
    {
      if(alignment.tool=="XCMS")
      {
        sample.col.start=9
        col.names.dataA[1]="mz"
        col.names.dataA[2]="time"
        col.names.dataB[1]="mz"
        col.names.dataB[2]="time"
        colnames(data_a)=col.names.dataA
        colnames(data_b)=col.names.dataB
      }
      
    }}else{
      #stop(paste("Invalid value for alignment.tool. Please use either \"apLCMS\" or \"XCMS\"", sep=""))
      
      col.names.dataA[1]="mz"
      
      col.names.dataB[1]="mz"
      if(is.na(time.thresh)==FALSE){
        col.names.dataA[2]="time"
        col.names.dataB[2]="time"
        print("Using the 1st column as \"mz\" and 2nd column as \"retention time\"")
      }else{
        print("Using the 1st column as \"mz\"")
      }
      colnames(data_a)=col.names.dataA
      colnames(data_b)=col.names.dataB
    }
  
  #data_a<-data_a[order(data_a$mz),]
  #data_b<-data_b[order(data_b$mz),]
  data_a<-as.data.frame(data_a)
  data_b<-as.data.frame(data_b)
  colnames(data_a)=col.names.dataA
  colnames(data_b)=col.names.dataB
  
  #create header for the matrix with common features
  if(is.na(time.thresh)==FALSE){
    mznames=c("index.A","mz.data.A", "time.data.A", "index.B","mz.data.B","time.data.B", "time.difference") 
  }else{
    mznames=c("index.A","mz.data.A", "index.B","mz.data.B") 
  }
  
  overlap_res<-find.Overlapping.mzs(dataA=data_a, dataB=data_b, mz.thresh, time.thresh, alignment.tool)
  
  
  
  if(length(overlap_res$index.A)>0){
    uniqueA<-data_a[-c(overlap_res$index.A),]
  }else{
    uniqueA<-data_a
  }
  
  if(length(overlap_res$index.B)>0){
    uniqueB<-data_b[-c(overlap_res$index.B),]
  }else{
    uniqueB<-data_b
  }
  return(list("uniqueA"=uniqueA,"uniqueB"=uniqueB))
}




#########################################################
#
#
#
#
#########################################################
getVenn<-function(dataA,name_a, dataB,name_b,mz.thresh=10,time.thresh=30,alignment.tool=NA, xMSanalyzer.outloc,use.unique.mz=FALSE,plotvenn=TRUE,use.best.match=FALSE)
{
  dir.create(xMSanalyzer.outloc,showWarnings=FALSE)
  
  data_a<-as.data.frame(dataA)
  data_b<-as.data.frame(dataB)
  rm(dataA)
  rm(dataB)
  
  ############################################
  
  if(use.unique.mz==TRUE){
    data_a<-find.Unique.mzs.sameset(dataA=data_a,dataB=data_a,mz.thresh=mz.thresh,time.thresh=time.thresh,alignment.tool=alignment.tool)
    data_a<-data_a$uniqueA
    
    #print(dim(data_a))
    
    data_b<-find.Unique.mzs.sameset(dataA=data_b,dataB=data_b,mz.thresh=mz.thresh,time.thresh=time.thresh,alignment.tool=alignment.tool)
    data_b<-data_b$uniqueA
  }
  common<-find.Overlapping.mzs(data_a,data_b,mz.thresh,time.thresh=time.thresh,alignment.tool=alignment.tool,use.best.match=use.best.match)
  
  if(length(common)>0){
    commonA<-data_a[c(common$index.A),]
    commonA<-unique(commonA)
    
    commonB<-data_b[c(common$index.B),]
    commonB<-unique(commonB)
    
    data_a<-data_a[-c(common$index.A),]
    data_b<-data_b[-c(common$index.B),]
    
    
    
    rm_index<-which(data_a$mz%in%common$mz.data.A)
    
    if(length(rm_index)>0){
      uniqueA<-data_a[-rm_index,]
    }else{
      uniqueA<-data_a
    }
    
    rm_index<-which(data_b$mz%in%common$mz.data.B)
    
    if(length(rm_index)>0){
      uniqueB<-data_b[-rm_index,]
    }else{
      uniqueB<-data_b
    }
    
    #uniqueA<-data_a[-c(common$index.A),]
    #uniqueB<-data_b[-c(common$index.B),]
    num_commonA<-length(unique(common$index.A))
    num_commonB<-length(unique(common$index.B))
    
    num_common<-min(num_commonA,num_commonB)[1]
  }else{
    uniqueA<-data_a
    uniqueB<-data_b
    num_common<-0
    commonA<-{}
    commonB<-{}
  }
  num_commonA<-num_common
  num_commonB<-num_common
  num_uniqueA<-dim(uniqueA)[1]
  num_uniqueB<-dim(uniqueB)[1]
  
  #print(num_commonA)
  #print(num_uniqueA)
  g1 <-c(seq(1,(num_commonA+num_uniqueA)))
  g2<-c(seq(1,(num_commonB+num_uniqueB)))
  
  g1[1:num_commonA]=paste("x_",g1[1:num_commonA],sep="")
  g2[1:num_commonB]=paste("x_",g2[1:num_commonB],sep="")
  
  if(num_uniqueA>0){
    g1[(num_commonA+1):(num_commonA+num_uniqueA)]=paste("y_",g1[(num_commonA+1):(num_commonA+num_uniqueA)],sep="")
  }
  if(num_uniqueA>0){
    g2[(num_commonB+1):(num_commonB+num_uniqueB)]=paste("z_",g2[(num_commonB+1):(num_commonB+num_uniqueB)],sep="")
  }
  set1=as.character(g1)
  set2=as.character(g2)
  universe <- sort(unique(c(set1,set2)))
  
  Counts <- matrix(0, nrow=length(universe), ncol=2)
  colnames(Counts) <- c(name_a, name_b)
  for (i in 1:length(universe))
  {
    Counts[i,1] <- universe[i] %in% set1
    Counts[i,2] <- universe[i] %in% set2
  }
  fname<-paste(xMSanalyzer.outloc,"/Venn", name_a,"_",name_b,"_",mz.thresh,"ppm",time.thresh,"s.pdf",sep="")
  venn_counts<-vennCounts(Counts)
  if(plotvenn==TRUE){
    
    pdf(fname)
    vennDiagram(venn_counts)
    try(dev.off(),silent=TRUE)
  }
  
  return(list("common"=common,"commonA"=commonA,"uniqueA"=uniqueA,"commonB"=commonB,"uniqueB"=uniqueB,"vennCounts"=venn_counts))
  
}

do_minmax<-function(data_m, newmin, newmax)
{
  data_m=apply(data_m,2,function(x){
    minx=min(x,na.rm=TRUE)
    maxx=max(x,na.rm=TRUE)
    if(minx!=maxx)
    {
      (((x-min(x,na.rm=TRUE))/(max(x,na.rm=TRUE)-min(x,na.rm=TRUE)))*(newmax-newmin))+newmin
    }else
    {
      (x-min(x,na.rm=TRUE))/(max(x,na.rm=TRUE)-min(x,na.rm=TRUE)+1)
    }
  })
  return(data_m)
  
}



do_mean<-function(x){
  
  mean_val<-mean(x,na.rm=TRUE)
  return(mean_val)
}

do_rsd<-function(x){
  
  sd_val<-sd(x,na.rm=TRUE)
  mean_val<-mean(x,na.rm=TRUE)
  cv_val<-100*(sd_val/(mean_val))
  
  return(cv_val)
}


check_model<-function(model.fit,dependent.var){
  
  
  residuals <- resid(model.fit)
  plot(fitted(model.fit), residuals)
  abline(0,0)
  
  plot(fitted(model.fit), dependent.var)
  
  qqnorm(residuals)
  qqline(residuals)
}

getCorchild<-function(cur_mzdata,data_mt,cor.method){
  
  pearson_res<-lapply(1:dim(data_mt)[2],function(j){
    return(WGCNA::cor(as.numeric(cur_mzdata),data_mt[,j],method=cor.method,use="pairwise.complete.obs"))
    
    
  })
  
  pvalues_list<-{}
  pearson_resmat<-{}
  pearson_list<-{}
  
  for(i in 1:length(pearson_res))
  {
    pearson_list<-c(pearson_list,pearson_res[[i]][1])
    nval<-length(which(is.na(data_mt[,i])==FALSE))
    
    pvalues_list<-c(pvalues_list,docortest(nval,pearson_res[[i]][[1]]))
  }
  
  
  return(list(cormat=pearson_list,complete_pearsonpvalue_mat=pvalues_list)) #,complete_pearsonqvalue_mat=qvalues_list))
}


plotTukeyHSD1 <- function(tukey.res,
                                          x.axis.label = "Comparison",
                                          y.axis.label = "Effect Size",
                                          plot.cex.axis=0.7,var.name=NA){
  

  res1<-lapply(1:length(tukey.res),function(j)
  {
  tukey.out <- as.data.frame(tukey.res[[j]])
  means <- tukey.out$diff
  categories <- row.names(tukey.out)
 # categories<-factor(categories,levels=unique(categories))
  groups <- length(categories)
  ci.low <- tukey.out$lwr
  ci.up  <- tukey.out$upr  
  padj<-tukey.out$`p adj`
  padjbool<-rep(0,length(padj))
  padjbool<-replace(padjbool,which(padj<0.05),1)
  
  tmp1<-cbind(categories,means,ci.low,ci.up,padj,padjbool)
  tmp1<-as.data.frame(tmp1)
  tmp1[,-c(1)]<-apply(tmp1[,-c(1)],2,function(x){as.numeric(as.character(x))})
  cex.plots=plot.cex.axis
  tmp1$categories<-factor(tmp1$categories,levels=unique(tmp1$categories))
 
  p1=ggplot(tmp1,aes(y=means,x=categories,colour=factor(padjbool),show.legend = FALSE)) + geom_point() + 
    geom_errorbar(aes(ymin=ci.low,ymax=ci.up),width=0.1) + coord_flip()+ #scale_y_continuous(breaks = scales::pretty_breaks(n = 10))+
    geom_hline(yintercept = 0,lty=2,col="blue") + theme_bw()+ ylab(as.character(y.axis.label[j])) + xlab("Comparison")
 
  if(is.na(var.name)==FALSE){
   
      title.sub<-paste(" (",var.name,")",sep="") 
  }else{
    
      title.sub=""
  }
       if(j==1){
        
        p1=p1+ggtitle(paste("TukeyHSD: Factor 1",title.sub,sep=""))
      }else{
        if(j==2){
          
          p1=p1+ggtitle(paste("TukeyHSD: Factor 2",title.sub,sep=""))
        }else{
          
          if(j==3){
            
            p1=p1+ggtitle(paste("TukeyHSD: Factor 1x2",title.sub,sep=""))
          }
        }
        
      }
  
  p1=p1 + labs(fill="p<0.05") + font("legend.text", size = 10*cex.plots, color = "black") + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                        panel.grid.minor = element_blank(),
                                                                                                        panel.spacing=unit(1,"lines"),
                                                                                                        axis.line = element_line(colour = "black",size=1),
                                                                                                        axis.text= element_text(size=9*cex.plots), axis.title=element_text(size=11*cex.plots,face="bold"),
                                                                                                        plot.title = element_text(hjust = 0.5,size=12*cex.plots),
                                                                                                        axis.ticks.length = unit(-0.05, "in"),
                                                                                                        axis.text.y = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
                                                                                                        axis.text.x = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
                                                                                                        axis.ticks.x = element_blank(),
                                                                                                        aspect.ratio = 1,
                                                                                                        legend.background = element_rect(color = "black", fill = "white"),
                                                                                                        strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                        strip.text = element_text(face="bold")) + scale_color_manual(values=c("blue","red"),labels=c("padj>=0.05","padj<0.05")) 

 #p1=p1+aes(show.lege)
   p1=p1+theme(legend.position="none")
  #}   
  
  return(p1) # + xlab(x.axis.label)
  })
  
  res2<-lapply(1:1,function(j)
  {
    tukey.out <- as.data.frame(tukey.res[[j]])
    means <- tukey.out$diff
    categories <- row.names(tukey.out)
    # categories<-factor(categories,levels=unique(categories))
    groups <- length(categories)
    ci.low <- tukey.out$lwr
    ci.up  <- tukey.out$upr  
    padj<-tukey.out$`p adj`
    padjbool<-rep(0,length(padj))
    padjbool<-replace(padjbool,which(padj<0.05),1)
    
    tmp1<-cbind(categories,means,ci.low,ci.up,padj,padjbool)
    tmp1<-as.data.frame(tmp1)
    tmp1[,-c(1)]<-apply(tmp1[,-c(1)],2,function(x){as.numeric(as.character(x))})
    cex.plots=plot.cex.axis
    tmp1$categories<-factor(tmp1$categories,levels=unique(tmp1$categories))
    
    p1=ggplot(tmp1,aes(y=means,x=categories,colour=factor(padjbool),show.legend = FALSE)) + geom_point() + 
      geom_errorbar(aes(ymin=ci.low,ymax=ci.up),width=0.1) + coord_flip()+ #scale_y_continuous(breaks = scales::pretty_breaks(n = 10))+
      geom_hline(yintercept = 0,lty=2,col="blue") + theme_bw()+ ylab(as.character(y.axis.label[j])) 
    
    
    
    p1=p1 + labs(fill="p<0.05") + font("legend.text", size = 8*cex.plots, color = "black") + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                   panel.grid.minor = element_blank(),
                                                                                                   panel.spacing=unit(1,"lines"),
                                                                                                   axis.line = element_line(colour = "black",size=1),
                                                                                                   axis.text= element_text(size=9*cex.plots), axis.title=element_text(size=11*cex.plots,face="bold"),
                                                                                                   plot.title = element_text(hjust = 0.5,size=12*cex.plots),
                                                                                                   axis.ticks.length = unit(-0.05, "in"),
                                                                                                   axis.text.y = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
                                                                                                   axis.text.x = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
                                                                                                   axis.ticks.x = element_blank(),
                                                                                                   aspect.ratio = 1,
                                                                                                   legend.background = element_rect(color = "black", fill = "white"),
                                                                                                   strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                   strip.text = element_text(face="bold")) + scale_color_manual(values=c("blue","red"),labels=c("padj>=0.05","padj<0.05")) 
    
    #p1=p1+aes(show.lege)
    p1=p1+theme(legend.title=element_blank())
    #}   
    
    return(p1) # + xlab(x.axis.label)
  })
  
  #save(res1,file="res1.Rda")
  g1=ggarrange(res1[[1]],res1[[2]],res1[[3]],ggpubr::get_legend(res2[[1]]),nrow=2,ncol=2)
  return(g1)
}

#Function to perform 2-way ANOVA analysis and post-hoc comparisons using Tukey HSD method
diffexplmtwowayanova<-function(dataA,covar.matrix=NA,plot.tukeyhsd=FALSE,var.name=NA){
  dataA<-as.data.frame(dataA)
  
  dataA$Factor1<-as.factor(dataA$Factor1)
  dataA$Factor2<-as.factor(dataA$Factor2)
  
  ref_group<-dataA$Factor1:dataA$Factor2
  
  ref_group<-ref_group[1]
  
  #Fit a 2-way ANOVA model
  res<-aov(as.numeric(Response) ~ (Factor1) + (Factor2) + (Factor1) * (Factor2),data=dataA)
  
  #get ANOVA results with p-values
  anova_res<-anova(res)
  
  #Perform post-hoc comparisons using the Tukey Honestly Significant Differences (HSD) test
  posthoc <- TukeyHSD(x=res, conf.level=0.95,test=univariate())
  
  p1<-posthoc
  p2=p1$`Factor1`[grep(rownames(p1$`Factor1`),pattern=paste("-",levels(dataA$Factor1)[1],"$",sep="")),]
  p1$`Factor1`<-p2
  p2=p1$`Factor2`[grep(rownames(p1$`Factor2`),pattern=paste("-",levels(dataA$Factor2)[1],"$",sep="")),]
  p1$`Factor2`<-p2
  p2=p1$`Factor1:Factor2`[grep(rownames(p1$`Factor1:Factor2`),pattern=paste("-",ref_group,"$",sep="")),]
  
  #rownames(p2)<-gsub(rownames(p2),pattern=paste("-",ref_group,"$",sep=""),replacement="")
  
  p1$`Factor1:Factor2`<-p2
  
  ref_groups<-paste("Differences in mean levels \ncompared to the reference group: ",c(levels(dataA$Factor1)[1],levels(dataA$Factor2)[1],levels(dataA$Factor1:dataA$Factor2)[1]),sep="")
  
  #plot(p1,cex.axis=0.5,las=2)
  
  plot_res<-try(plotTukeyHSD1(tukey.res=p1,x.axis.label = "",y.axis.label=ref_groups,var.name=var.name),silent=TRUE)
  
 # print(plot_res)
  num_rows<-dim(anova_res)[1]
  
  pvalues_factors<-data.frame(t(anova_res["Pr(>F)"][-c(num_rows),]))
  
  names(pvalues_factors)<-rownames(anova_res)[-c(num_rows)]
  
  interact_res<-t(c(posthoc$Factor1[,4],posthoc$Factor2[,4],posthoc$'Factor1:Factor2'[,4]))
  
  colnames(interact_res)<-c(rownames(posthoc$Factor1),rownames(posthoc$Factor2),rownames(posthoc$'Factor1:Factor2'))
  
  #return resutls
  return(list("mainpvalues"=pvalues_factors,"posthoc"=interact_res,"plot.tukeyhsd"=plot_res))
  
  
}


#Function to perform two-way ANOVA repeated measures analysis and post-hoc comparisons using Tukey HSD method
diffexplmtwowayanovarepeat<-function(dataA,subject_inf,modeltype="lme.RIRS",covar.matrix=NA){
  
  dataA<-as.data.frame(dataA)
  
  dataA$Factor1<-as.factor(dataA$Factor1)
  dataA$Factor2<-as.factor(dataA$Factor2)
  
  subject_inf<-as.vector(subject_inf)
  
  Subject<-subject_inf
  dataA<-cbind(dataA,subject_inf)
  
  ##save(dataA,file="dataA.Rda")
  
  if(modeltype=="lme.RI"){
    
    
    #call the lme function from the nlme package; random intercept only model
    res <- lme(as.numeric(Response) ~ Factor1 + Factor2 + Factor1 * Factor2, random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf))
  }else{
    if(modeltype=="lme.RIRS"){
      
      #call the lme function from the nlme package;random intercept and random slope model
      res <- lme(as.numeric(Response) ~ Factor1 + Factor2 + Factor1 * Factor2, random=~ 1 + Factor2 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #corAR1())
      
    }else{
      if(modeltype=="nlme.RIRS"){
        
        #call the lme function from the nlme package;random intercept and random slope model
        res <- nlme(as.numeric(Response) ~ Factor1 + Factor2 + Factor1 * Factor2, random=~ 1 + Factor2 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #corAR1())
        
      }else{
        if(modeltype=="nlme.RI"){
          
          #call the lme function from the nlme package; random intercept only model
          res <- nlme(as.numeric(Response) ~ Factor1 + Factor2 + Factor1 * Factor2, random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf))
          
        }
        
      }
      
    }
    
  }
  
  if(is(res,"try-error")){
    
    return(list("mainpvalues"=NA,"posthoc"=NA))
  }else{
    
    anova_res<-anova(res)
    
    
    
    #using lsmeans package for post-hoc comparisons since version v1.0.7.6
    means.factors=lsmeans(res,specs=c("Factor1","Factor2"))
    posthoc_res=pairs(means.factors,adjust="tukey")
    posthoc_res<-data.frame(posthoc_res)
    posthoc_pvalues<-posthoc_res$p.value
    names(posthoc_pvalues)<-as.character(posthoc_res$contrast)
    
    num_rows<-dim(anova_res)
    pvalues_factors<-data.frame(t(anova_res["p-value"][-c(1),]))
    
    names(pvalues_factors)<-rownames(anova_res)[-c(1)]
    
    return(list("mainpvalues"=pvalues_factors,"posthoc"=posthoc_pvalues))
  }
  
}


#Function to perform one-way ANOVA repeated measures analysis and post-hoc comparisons using Tukey HSD method
diffexplmonewayanovarepeat<-function(dataA,subject_inf,analysismode="classification",modeltype="RIRS",covar.matrix=NA){
  
  dataA<-as.data.frame(dataA)
  
  if(analysismode=="classification"){
    dataA$Factor1<-as.factor(dataA$Factor1)
  }
  Subject<-subject_inf
  dataA<-cbind(dataA,subject_inf)
  
  ##savedataA,file="dataA.Rda")
if(FALSE){ 
  if(modeltype=="RI"){
    
    res <- lme(as.numeric(Response) ~ Factor1, random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #,silent=TRUE)
  }else{
    if(modeltype=="RIRS"){
      res <- try(lme(as.numeric(Response) ~ Factor1, random = ~ 1 + Factor1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)),silent=TRUE)
    }
  }
}  
  if(modeltype=="lme.RI"){
    
    res <- lme(as.numeric(Response) ~ Factor1, random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #,silent=TRUE)
  }else{
    if(modeltype=="lme.RIRS"){
      res <- try(lme(as.numeric(Response) ~ Factor1, random = ~ 1 + Factor1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)),silent=TRUE)
    }else{
      if(modeltype=="nlme.RIRS"){
        res <- try(nlme(as.numeric(Response) ~ Factor1, random = ~ 1 + Factor1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)),silent=TRUE)
      }else{
        if(modeltype=="nlme.RI"){
          res <- nlme(as.numeric(Response) ~ Factor1, random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #,silent=TRUE)
        }
      }
    }
    
    
  }
  
  if(is(res,"try-error")){
    return(list("mainpvalues"=NA,"posthoc"=NA))
  }else{
    anova_res<-anova(res)
    num_rows<-dim(anova_res)
    pvalues_factors<-data.frame(t(anova_res["p-value"][-c(1),]))
    
    if(analysismode=="classification"){
      
      
      
      #using lsmeans package for post-hoc comparisons since version v1.0.7.6
      means.factors=lsmeans(res,specs=c("Factor1"))
      posthoc_res=pairs(means.factors,adjust="tukey")
      posthoc_res<-data.frame(posthoc_res)
      posthoc_pvalues<-posthoc_res$p.value
      names(posthoc_pvalues)<-as.character(posthoc_res$contrast)
      
      return(list("mainpvalues"=pvalues_factors,"posthoc"=posthoc_pvalues))
    }else{
      return(list("mainpvalues"=pvalues_factors))
    }
  }
  
}



#Function to perform one-way ANOVA repeated measures analysis and post-hoc comparisons using Tukey HSD method
diffexplmregrepeat<-function(dataA,subject_inf,modeltype="lme.RIRS",covar.matrix=NA){
  
  dataA<-as.data.frame(dataA)
  
  Subject<-subject_inf
  dataA<-cbind(dataA,subject_inf)
  save(dataA,covar.matrix,file="dataA.Rda")
  
  dataA$Response<-as.numeric(dataA$Response)
  dataA$Factor1<-as.numeric(dataA$Factor1)
  
  y <- "Response"
  x <- names(dataA)[!names(dataA) %in% c(y,"subject_inf")]
  mymodel <- as.formula(paste(y, paste(x, collapse="+"), sep="~"))
  
  save(dataA,covar.matrix,file="dataA.Rda")
  
  
  if(is.na(covar.matrix)==FALSE){
          if(modeltype=="lme.RI"){
            
            res <- lme(mymodel, random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #,silent=TRUE)
          }else{
            if(modeltype=="lme.RIRS"){
              res <- try(lme(mymodel, random = ~ 1 + Factor1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)),silent=TRUE)
            }else{
              if(modeltype=="nlme.RIRS"){
                res <- try(nlme(mymodel, random = ~ 1 + Factor1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)),silent=TRUE)
              }else{
                if(modeltype=="nlme.RI"){
                  res <- nlme(mymodel, random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #,silent=TRUE)
                }
              }
            }
            
            
          }
  }else{
    
    if(modeltype=="lme.RI"){
      
      res <- lme(as.numeric(Response) ~ as.numeric(Factor1), random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #,silent=TRUE)
    }else{
      if(modeltype=="lme.RIRS"){
        res <- try(lme(as.numeric(Response) ~ as.numeric(Factor1), random = ~ 1 + Factor1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)),silent=TRUE)
      }else{
        if(modeltype=="nlme.RIRS"){
          res <- try(nlme(as.numeric(Response) ~ as.numeric(Factor1), random = ~ 1 + Factor1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)),silent=TRUE)
        }else{
          if(modeltype=="nlme.RI"){
            res <- nlme(as.numeric(Response) ~ as.numeric(Factor1), random = ~ 1 | subject_inf, data=dataA,control=lmeControl(opt="optim"),correlation=corCompSymm(form=~1|subject_inf)) #,silent=TRUE)
          }
        }
      }
      
      
    }
    
    
  }
  if(is(res,"try-error")){
    
    return(NA)
  }else{
    s1<-summary(res)
    
    s2=s1$tTable[2,c("p-value","Value","Std.Error","t-value")]
    return(s2)
  }
  
}


#one-way ANOVA: nointeraction
diffexponewayanova<-function(dataA,covar.matrix=NA){
  
  dataA<-as.data.frame(dataA)
  
  ###savedataA,file="dataA.Rda")
  
  a1 <- aov(dataA$Response ~ .,data=dataA) # + chocolate$Factor1*chocolate$Factor2)
  
  posthoc <- TukeyHSD(x=a1, conf.level=0.95,test=univariate())
  anova_res<-anova(a1)
  
  num_rows<-dim(anova_res)
  pvalues_factors<-data.frame(t(anova_res["Pr(>F)"][-c(num_rows),]))
  
  return(list("mainpvalues"=pvalues_factors,"posthocfactor1"=posthoc$Factor1[,4]))
  
}


diffexpsvmrfe<-function(x,y,svmkernel="radial"){
  
  #Checking for the variables
  stopifnot(!is.null(x) == TRUE, !is.null(y) == TRUE)
  
  n = ncol(x)
  survivingFeaturesIndexes = seq_len(n)
  featureRankedList = vector(length=n)
  rankedFeatureIndex = n
  
  while(length(survivingFeaturesIndexes)>0){
    #train the support vector machine
    svmModel = svm(x[, survivingFeaturesIndexes], y, type="nu-classification", kernel=svmkernel)
    
    #compute the weight vector
    w = t(svmModel$coefs)%*%svmModel$SV
    
    #compute ranking criteria
    rankingCriteria = w * w
    
    #rank the features
    ranking = sort(rankingCriteria, index.return = TRUE)$ix
    
    #update feature ranked list
    featureRankedList[rankedFeatureIndex] = survivingFeaturesIndexes[ranking[1]]
    rankedFeatureIndex = rankedFeatureIndex - 1
    
    if(length(survivingFeaturesIndexes)==n){
      
      featureWeights=rankingCriteria
      
    }
    
    #eliminate the feature with smallest ranking criterion
    (survivingFeaturesIndexes = survivingFeaturesIndexes[-ranking[1]])
    
    
  }
  
  return (list(featureRankedList=featureRankedList,featureWeights=featureWeights))
}


diffexpsvmrfemulticlass  = function(x,y,svmkernel="radial"){
  n = ncol(x)
  survivingFeaturesIndexes = seq(n)
  featureRankedList = vector(length=n)
  rankedFeatureIndex = n
  while(length(survivingFeaturesIndexes)>0){
    #train the support vector machine
    svmModel = svm(x[, survivingFeaturesIndexes],
                   y,
                   scale= FALSE,
                   type="nu-classification", kernel=svmkernel)
    #compute the weight vector
    multiclassWeights = svm.getweights(svmModel)
    #compute ranking criteria
    multiclassWeights = multiclassWeights * multiclassWeights
    rankingCriteria = 0
    for(i in 1:ncol(multiclassWeights))rankingCriteria[i] = mean(multiclassWeights[,i])
    #rank the features
    (ranking = sort(rankingCriteria, index.return = TRUE)$ix)
    
    if(length(survivingFeaturesIndexes)==n){
      
      featureWeights=rankingCriteria
      
    }
    
    ## New update feature ranked list
    #featureRankedList[rev((s-r+1):s)] <-survivingFeaturesIndexes[ranking[1:r]]
    featureRankedList[rankedFeatureIndex] = survivingFeaturesIndexes[ranking[1]]
    rankedFeatureIndex = rankedFeatureIndex - 1
    ## New to remove perc.rem
    #  rankedFeatureIndex <- rankedFeatureIndex - r
    
    #eliminate the feature with smallest ranking criterion
    #survivingFeaturesIndexes <-
    #   survivingFeaturesIndexes[-ranking[1:r]]
    
    (survivingFeaturesIndexes = survivingFeaturesIndexes[-ranking[1]])
  }
  #return(featureRankedList)
  return (list(featureRankedList=featureRankedList,featureWeights=featureWeights))
}


svm.getweights<-function(model){
  w=0
  if(model$nclasses==2){
    w=t(model$coefs)%*%model$SV
  }else{
    
    #when we deal with OVO svm classification
    ## compute start-index
    start <- c(1, cumsum(model$nSV)+1)
    start <- start[-length(start)]
    calcw <- function (i,j) {
      ## ranges for class i and j:
      ri <- start[i] : (start[i] + model$nSV[i] -1)
      rj <- start[j] : (start[j] + model$nSV[j] -1)
      ## coefs for (i,j):
      coef1 <- model$coefs[ri, j-1]
      coef2 <- model$coefs[rj, i]
      ## return w values:
      w=t(coef1)%*%model$SV[ri,]+t(coef2)%*%model$SV[rj,]
      return(w)
    }
    W=NULL
    for (i in 1 : (model$nclasses - 1)){
      for (j in (i + 1) : model$nclasses){
        wi=calcw(i,j) 
        W=rbind(W,wi) 
      } 
    } 
    w=W 
  } 
  return(w) 
}

#Nointeraction
diffexplmreg<-function(dataA,logistic_reg=FALSE,poisson_reg=FALSE,robust.estimate=FALSE,vcovHC.type="HC3"){
  
  dataA<-as.data.frame(dataA)
  
  ###savedataA,file="lmreg_func.Rda")
  if(logistic_reg==TRUE){
    cnames1<-colnames(dataA)
    cnames1[2]<-"Class"
    colnames(dataA)<-cnames1
    
    labels_1<-levels(as.factor(dataA$Class))
    
    dataA$Class<-replace(dataA$Class,which(dataA$Class==labels_1[1]),0)
    dataA$Class<-replace(dataA$Class,which(dataA$Class==labels_1[2]),1)
    
    
    a1 <- glm(dataA$Class ~ .,family=binomial(logit),data=dataA)
  }else{
    
    if(poisson_reg==TRUE){
      
      cnames1<-colnames(dataA)
      cnames1[2]<-"Class"
      colnames(dataA)<-cnames1
      
      ####savedataA,file="temp1.Rda")
      labels_1<-levels(as.factor(dataA$Class))
      dataA$Class<-as.numeric(dataA$Class)
      
      a1 <- glm(dataA$Class ~ .,family=poisson(log),data=dataA)
      
    }else{
      
      cnames1<-colnames(dataA)
      cnames1[2]<-"Class"
      colnames(dataA)<-cnames1
      dataA$Class<-as.numeric(dataA$Class)
      a1 <- lm(dataA$Response ~ .,data=dataA) # aov(dataA$Response ~ .,data=dataA) # + chocolate$Factor1*chocolate$Factor2)
      
    }
  }
  s1<-summary(a1)
  
  
  if(logistic_reg==FALSE){
    
    r2<-s1$adj.r.squared
  }else{
    r2<-NA
  }
  
  if(robust.estimate==FALSE){
    
    
    s1<-s1$coefficients
  }else{
    cov.a1 <- vcovHC(a1,vcovHC.type) #using default: HC3 #, type="HC0")
    std.err <- sqrt(diag(cov.a1))
    s1 <- cbind(Estimate= coef(a1), "Robust SE" = std.err, "z value"=coef(a1)/std.err,
                "Pr(>|z|)" = 2 * pnorm(abs(coef(a1)/std.err), lower.tail=FALSE),
                LL = coef(a1) - 1.96 * std.err,
                UL = coef(a1) + 1.96 * std.err)
    
    
  }
  
  #save(s1,file="s1.Rda")
  
  if(nrow(s1)>1){
    
    s1<-s1[-c(1),]
    
    if(dim(dataA)[2]<3){ # && dim(dataA)[1]<3){
      #s1<-as.data.frame(s1)
      s1<-t(s1)
      
    }
    
    
    confint_lower<-s1[,1]-(1.96*s1[,2])
    confint_upper<-s1[,1]+(1.96*s1[,2])
    
    
    return(list("mainpvalues"=s1[,4],"estimates"=s1[,1],"statistic"=s1[,3],"stderr"=s1[,2],"r2"=r2,"confint"=c(confint_lower,confint_upper)))
  }else{
    
    return(list("mainpvalues"=NA,"estimates"=NA,"statistic"=NA,"stderr"=NA,"r2"=r2,"confint"=c(NA,NA)))
  }
  
}

#Nointeraction
diffexpcoxph<-function(dataA,logistic_reg=FALSE,poisson_reg=FALSE,vcovHC.type="HC3"){
  
  dataA<-as.data.frame(dataA)
  
  # ###savedataA,file="lmreg_func.Rda")
  
  
  if(logistic_reg==TRUE){
    cnames1<-colnames(dataA)
    cnames1[2]<-"Class"
    colnames(dataA)<-cnames1
    
    labels_1<-levels(as.factor(dataA$Class))
    
    dataA$Class<-replace(dataA$Class,which(dataA$Class==labels_1[1]),0)
    dataA$Class<-replace(dataA$Class,which(dataA$Class==labels_1[2]),1)
    
    
    a1 <- glm(dataA$Class ~ .,family=binomial(logit),data=dataA)
  }else{
    
    if(poisson_reg==TRUE){
      
      cnames1<-colnames(dataA)
      cnames1[2]<-"Class"
      colnames(dataA)<-cnames1
      
      ####savedataA,file="temp1.Rda")
      labels_1<-levels(as.factor(dataA$Class))
      dataA$Class<-as.numeric(dataA$Class)
      
      a1 <- glm(dataA$Class ~ .,family=poisson(log),data=dataA)
      
    }else{
      
      a1 <- lm(dataA$Response ~ .,data=dataA) # aov(dataA$Response ~ .,data=dataA) # + chocolate$Factor1*chocolate$Factor2)
    }
  }
  s1<-summary(a1)
  
  
  if(logistic_reg==FALSE){
    
    r2<-s1$adj.r.squared
  }else{
    r2<-NA
  }
  if(poisson_reg==FALSE){
    s1<-s1$coefficients
  }else{
    cov.a1 <- vcovHC(a1,vcovHC.type) #, type="HC0")
    std.err <- sqrt(diag(cov.a1))
    s1 <- cbind(Estimate= coef(a1), "Robust SE" = std.err, "z value"=coef(a1)/std.err,
                "Pr(>|z|)" = 2 * pnorm(abs(coef(a1)/std.err), lower.tail=FALSE),
                LL = coef(a1) - 1.96 * std.err,
                UL = coef(a1) + 1.96 * std.err)
    
    
  }
  
  s1<-s1[-c(1),]
  
  if(dim(dataA)[2]<3){ # && dim(dataA)[1]<3){
    #s1<-as.data.frame(s1)
    s1<-t(s1)
    
  }
  
  
  confint_lower<-s1[,1]-(1.96*s1[,2])
  confint_upper<-s1[,1]+(1.96*s1[,2])
  
  
  return(list("mainpvalues"=s1[,4],"estimates"=s1[,1],"statistic"=s1[,3],"stderr"=s1[,2],"r2"=r2,"confint"=c(confint_lower,confint_upper)))
  
  
}
do_mars_lmreg<-function(dataA){
  
  
  dataA<-as.data.frame(dataA)
  
  
  #print(dim(dataA))
  mars_res<-new("list")
  
  
  mars_res[[1]]<-try(earth(dataA$Response~.,data=as.data.frame(dataA),degree=1,ncross=10,nfold=10),silent=TRUE)
  mars_res[[2]]<-try(earth(dataA$Response~.,data=as.data.frame(dataA),degree=2,ncross=10,nfold=10),silent=TRUE)
  mars_res[[3]]<-try(earth(dataA$Response~.,data=as.data.frame(dataA),degree=3,ncross=10,nfold=10),silent=TRUE)
  
  gcv_list<-c(mars_res[[1]]$gcv,mars_res[[2]]$gcv,mars_res[[3]]$gcv)
  
  min_gcv<-which(gcv_list==min(gcv_list,na.rm=TRUE))
  
  marsfitdeg<-earth(formula=factor(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=min_gcv[1],ncross=kfold,nfold=10)
  
  print(summary(marsfitdeg))
  #marsfitdeg<-earth(mz~Strain+Treatment+Batch,data=as.data.frame(curdata),degree=3,ncross=10,nfold=10)
  #marsfitdeg<-try(earth(dataA$Response~.,data=as.data.frame(dataA),degree=1,ncross=10,nfold=10),silent=TRUE)
  
  if (is(marsfitdeg, "try-error")){
    lmtest_pval<-NA
  }else{
    #print(summary(marsfitdeg))
    #evdeg1 <- evimp(marsfitdeg)
    #plot(evdeg1)
    qqnorm(marsfitdeg$residuals)
    qqline(marsfitdeg$residuals)
    shapiro.test(marsfitdeg$residuals)
    bx1 <- model.matrix(marsfitdeg)
    #deg.lm <- glm(as.vector(curdata[,1]) ~ bx1[,-1]) # -1 to drop intercept
    deg.lm <- try(glm(as.numeric(dataA$Response) ~ bx1[,-1]),silent=TRUE)
    if (is(deg.lm, "try-error")){
      lmtest_pval<-1
    }else{
      slm<-summary(deg.lm)
      lmtest_pval=slm$coefficients[,4]
      #print(slm$coefficients)
      
    }
    
    #slm<-summary(deg.lm) # yields same coeffs as above summary
    #aicdeg1[i]<-s1$aic
    #plot(effect('Dept:Gender', berk.mod2), multiline=TRUE)
  }
  return(list("marsummary"=summary(marsfitdeg), "pvalues"=lmtest_pval))
  
}


diffexplogitreg<-function(dataA){
  
  dataA<-as.data.frame(dataA)
  
  labels_1<-labels(as.factor(dataA$Factor1))
  
  #print(labels_1)
  dataA$Factor1<-replace(dataA$Factor1,which(dataA$Factor1==labels_1[1]),0)
  dataA$Factor1<-replace(dataA$Factor1,which(dataA$Factor1==labels_1[2]),1)
  
  a1 <- glm(dataA$Factor1 ~ .,family=binomial(logit),data=dataA) # aov(dataA$Response ~ .,data=dataA) # + chocolate$Factor1*chocolate$Factor2) 
  
  c1<-confint(a1,level=0.95)
  s1<-summary(a1)
  #print(summary(a1))
  
  anova_res<-anova(a1)
  num_rows<-dim(anova_res)
  #pvalues_factors<-data.frame(t(anova_res["Pr(>F)"][-c(num_rows),]))
  
  s1<-s1$coefficients
  s1<-s1[-c(1),]
  
  confint_lower<-s1[,1]-(1.96*s1[,2])
  confint_upper<-s1[,1]+(1.96*s1[,2])
  
  #print(anova_res)
  #
  return(list("mainpvalues"=s1[,4],"estimates"=s1[,1],"zstat"=s1[,3],"stderr"=s1[,2],"confint"=c(confint_lower,confint_upper)))
  
  
}


# extract dataset if not provided
.get_data <- function(fit, data = NULL, complain = FALSE) {
  if(is.null(data)){
    if (complain)
      warning ("The `data` argument is not provided. Data will be extracted from model fit.")
    data <- eval(fit$call$data)
  }
  data
}

ggadjustedcurves.single <- function(data, fit) {
  time <- surv <- variable <- NULL
  
  pred <- survexp(~1, data = data, ratetable = fit)
  
  curve <- data.frame(time = c(0,pred$time),
                      variable = "total",
                      surv = c(1, pred$surv))
  
}

ggadjustedcurves.average <- function(data, fit, variable) {
  time <- surv <- NULL
  
  lev <- sort(unique(data[,variable]))
  pred <- survexp(as.formula(paste("~", variable)), data = data,
                  ratetable = fit)
  
  curve <- data.frame(time = rep(c(0,pred$time), length(lev)),
                      variable = factor(rep(lev, each=1+length(pred$time))),
                      surv = c(rbind(1, pred$surv)))
  
}

ggadjustedcurves.conditional <- function(data, fit, variable, reference) {
  time <- surv <- NULL
  
  lev <- sort(unique(data[,variable]))
  reference[,variable] = "_reference_"
  df0 <- reference
  form <- paste(variable, "~", gsub(as.character(formula(fit))[3], pattern="\\+ *strata.*[^\\)].", replacement=""))
  
  allRes <- list()
  rwt <- numeric(nrow(data))
  for (level in lev) {
    indexes <- which(data[,variable] == level)
    if (length(indexes) > 0) {
      df1 <- data[indexes, ]
      ndf <- rbind(df0, df1)
      ndf[,variable] <- factor(ndf[,variable])
      model <- glm(as.formula(form), ndf, family="binomial")
      allRes[[level]] <- predict(model, newdata = data, type = "response")
      rwt[indexes] <- 1/allRes[[level]][indexes]
    }
  }
  
  nform <- paste(as.character(formula(fit))[2], "~", variable)
  nfit <- coxph(as.formula(nform), data = data, weights = rwt)
  
  pred <- survexp(as.formula(paste("~", variable)), data = data, ratetable = nfit)
  
  # remove leading zeros
  # while survexp returns non monotonic results
  if (length(dim(pred$surv))==2) {
    for (i in 1:ncol(pred$surv))
      for (j in nrow(pred$surv):2)
        if (pred$surv[j,i] > pred$surv[j - 1,i])
          pred$surv[j - 1,i] <- 1
  }
  
  curve <- data.frame(time = rep(c(0,pred$time), length(lev)),
                      variable = factor(rep(lev, each=1+length(pred$time))),
                      surv = c(rbind(1, pred$surv)))
  
}

ggadjustedcurves.marginal <- function(data, fit, variable) {
  time <- surv <- NULL
  
  lev <- sort(unique(data[,variable]))
  ndata <- data[rep(1:nrow(data), each=length(lev)),
                setdiff(colnames(data), variable)]
  ndata[,variable] = rep(lev, nrow(data))
  
  pred <- survexp(as.formula(paste("~", variable)), data = ndata,
                  ratetable = fit)
  # remove leading zeros
  # while survexp returns non monotonic results
  if (length(dim(pred$surv)) == 2) {
    for (i in 1:ncol(pred$surv))
      for (j in nrow(pred$surv):2)
        if (pred$surv[j,i] > pred$surv[j - 1,i])
          pred$surv[j - 1,i] <- 1
  }
  
  curve <- data.frame(time = rep(c(0,pred$time), length(lev)),
                      variable = factor(rep(lev, each=1+length(pred$time))),
                      surv = c(rbind(1, pred$surv)))
}

get_survplot_adjustedcurve <- function(fit,
                                       variable = NULL,
                                       data = NULL,
                                       reference = NULL,
                                       method = "conditional",
                                       plottitle = "",
                                       xlab = "Time", ylab = "Survival probability",
                                       size = 1, xincrement="auto", yincrement=0.25,
                                       concordance=TRUE, rsquare=FALSE, L_ratio_test=FALSE, waldtest=TRUE, logrank=FALSE,
                                       linecolor="auto", add.risk.table=TRUE, add.cumulative.events=FALSE
) {
  stopifnot(method %in% c("marginal", "average", "conditional", "single"))
  indata <- .get_data(fit, data)
  
  # deal with default arguments
  # reference = NULL
  if (is.null(reference))
    reference <- indata
  
  # variable = NULL
  if (is.null(variable)) {
    # is there a 'strata' component?
    term.labels <- attr(terms(fit$formula), "term.labels")
    strata.term.labels <- grep(term.labels, pattern = "strata(", fixed = TRUE, value = TRUE)
    if (length(strata.term.labels) > 0) {
      variable <- gsub(
        gsub(
          strata.term.labels,
          pattern = "strata(", replacement = "", fixed = TRUE)[1],
        pattern = "[\\) ]", replacement = "")
      cat("The variable argument is missing. Using", variable, "as extracted from strata\n")
    } else {
      # if not then leave variable = NULL
      method = "single"
    }
  }
  
  if(method=="single"){
    
    add.risk.table=FALSE; add.cumulative.events=FALSE
  }
  
  
  curve <- switch(method,
                  single = ggadjustedcurves.single(indata, fit),
                  average =  ggadjustedcurves.average(indata, fit, variable),
                  conditional = suppressWarnings(ggadjustedcurves.conditional(indata, fit, variable, reference)),
                  marginal = ggadjustedcurves.marginal(indata, fit, variable))
  
  timepoints <- unique(curve$time)
  
  mintime <- 0
  maxtime <- ceiling(max(timepoints)/100)*100
  if(xincrement=="auto"){
    xincrement <- maxtime/5
  }else{
    xincrement <- xincrement
  }
  
  sfit <- summary(fit)
  ydecrease <- 0
  if(concordance==TRUE){
    label_concordance <- str_pad(paste("Concordance = ",format(round(sfit$concordance[1],3),nsmall=3), sep=""),46,side="right",pad=" ")
    annotation_concordance <- annotate("text", label = label_concordance, x = (maxtime - 120), y = (1-ydecrease))
    ydecrease <- ydecrease +0.04
  }else{
    annotation_concordance = NULL
  }
  if(rsquare==TRUE){
    label_rsquare <- str_pad(paste("R-square = ",format(round(sfit$rsq[1],3),nsmall=3), sep=""),49,side="right",pad=" ")
    annotation_rsquare <- annotate("text", label = label_rsquare, x = (maxtime - 120), y = (1-ydecrease))
    ydecrease <- ydecrease +0.04
  }else{
    annotation_rsquare = NULL
  }
  if(L_ratio_test==TRUE){
    label_LRT <- str_pad(paste("Likelihood ratio test p-value = ",format(round(sfit$logtest[3],3),nsmall=3),sep=""),39,side="right",pad=" ")
    annotation_LRT <- annotate("text", label = label_LRT, x = (maxtime - 120), y = (1-ydecrease))
    ydecrease <- ydecrease +0.04
  }else{
    annotation_LRT = NULL
  }
  if(waldtest==TRUE){
    label_waldtest <- str_pad(paste("Wald test p-value = ",format(round(sfit$waldtest[3],3),nsmall=3),sep=""),43,side="right",pad=" ")
    annotation_waldtest <- annotate("text", label = label_waldtest, x = (maxtime - 120), y = (1-ydecrease))
    ydecrease <- ydecrease +0.04
  }else{
    annotation_waldtest = NULL
  }
  if(logrank==TRUE){
    label_logrank <- str_pad(paste("Log-rank test p-value = ",format(round(sfit$sctest[3],3),nsmall=3),sep=""),41,side="right",pad=" ")
    annotation_logrank <- annotate("text", label = label_logrank, x = (maxtime - 120), y = (1-ydecrease))
    ydecrease <- ydecrease +0.04
  }else{
    annotation_logrank = NULL
  }
  
  if( length(linecolor)==1 & linecolor[1]=="auto"){
    scale_color_value <- NULL
    table_group_color <- NULL
  }else {
    group <- levels(factor(curve$variable))
    names(linecolor) <- group
    scale_color_value <- scale_colour_manual(values =linecolor)
    table_group_color <- linecolor
  }
  
  plot <- list(); i<-0
  
  p1 <- ggplot(curve, aes(x = time, y = surv)) +
    geom_step(aes(color=factor(variable)), size=size) +
    labs(color=variable) +
    xlab(xlab) +
    ylab(ylab) +
    ggtitle(plottitle) +
    scale_color_value +
    annotation_concordance + annotation_rsquare + annotation_LRT + annotation_waldtest + annotation_logrank +
    scale_x_continuous(breaks = seq(mintime, maxtime, by = xincrement), lim=c(0,maxtime)) +
    scale_y_continuous(breaks = seq(0, 1, by = yincrement)) +
    theme(axis.title=element_text(size=12),
          axis.text =element_text(size=12),
          axis.line = element_line(size=1, colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          legend.key=element_blank(),
          legend.title=element_text(size=13),
          legend.position="bottom",
          plot.title = element_text(size=18, hjust = 0),
          axis.text.x=element_text(colour="black", size = 11,angle=0),
          axis.text.y=element_text(colour="black", size = 11))
  
  if(method=="single"){
    
    p1 <- p1 + theme(legend.position = "none")
  }
  i <- i+1; plot[[i]]  <- p1
  
  if(add.risk.table==TRUE){
    
    p2 <- ggsurvtable(survfit(as.formula(paste(as.character(fit$call$formula)[2],"~",variable,sep=" ")),data=indata),
                      data=indata, survtable=c("risk.table"),
                      break.time.by = xincrement, xlim=c(0,maxtime),ylab="",xlsab="",
                      legend.labs=levels(factor(indata$variable)), color = "strata", palette = table_group_color)
    p2 <- p2 + theme(legend.position="none",
                     plot.margin = unit(c(5.5,5.5,5.5,28), "pt"),
                     axis.line = element_blank())
    i <- i+1; plot[[i]]  <- p2
    
  }
  
  if(add.cumulative.events==TRUE){
    
    p3 <- ggsurvtable(survfit(as.formula(paste(as.character(fit$call$formula)[2],"~",variable,sep=" ")),data=indata),
                      data=indata, survtable=c("cumevents"),
                      break.time.by = xincrement, xlim=c(0,maxtime),ylab="",xlsab="",
                      legend.labs=levels(factor(indata$variable)), color = "strata", palette = table_group_color)
    p3 <- p3 + theme(legend.position="none",
                     plot.margin = unit(c(5.5,5.5,5.5,28), "pt"),
                     axis.line = element_blank())
    i <- i+1; plot[[i]]  <- p3
    
  }
  
  if(length(plot)==1){
    
    #p <- grid.arrange(plot[[1]])
    p <- cowplot::plot_grid(plotlist = plot, nrow=1)
  } else if (length(plot)==2) {
    
    height1 <- 0.85 - (length(levels(curve$variable))-2)*0.3 ; height2 <- 0.15 + (length(levels(curve$variable))-2)*0.3
    p <- cowplot::plot_grid(plotlist = plot, nrow=2, rel_heights=c(height1, height2))
    #p <- grid.arrange(plot[[1]], plot[[2]], nrow = 2, heights = c(height1, height2))
  } else if (length(plot)==3) {
    
    height1 <- 0.7 - (length(levels(curve$variable))-2)*0.6
    height2 <- 0.15 + (length(levels(curve$variable))-2)*0.3
    height3 <- 0.15 + (length(levels(curve$variable))-2)*0.3
    p <- cowplot::plot_grid(plotlist = plot, nrow=3, rel_heights=c(height1, height2, height3))
    #p <- grid.arrange(plot[[1]], plot[[2]], plot[[3]], nrow = 3, heights = c(height1, height2, height3))
    
  
  }
  #print(plot)
  return(p)
}


get_forestplot <- function(fit,data,xlab="",ylab="Hazard Ratio (95% CI)",sigcolor="red"){
  
  indata <- .get_data(fit, data)
  #save(fit,data,file="fit.Rda")
  fit_summary <- summary(fit)
  coef_table <- fit_summary$coefficients
  plotdata <- data.frame(predictor=as.character(rownames(coef_table)),
                         hazard_ratio=as.numeric(round(coef_table[,2],3)),
                         upper=as.numeric(coef_table[,2])+1.96*as.numeric(coef_table[,3]),
                         lower=as.numeric(coef_table[,2])-1.96*as.numeric(coef_table[,3]),
                         pvalue=as.numeric(round(coef_table[,5],3)),
                         stringsAsFactors=FALSE
  )
  plotdata$predictor <- factor(plotdata$predictor,levels=plotdata$predictor)
  plotdata[,"sig"]<-ifelse(plotdata$pvalue<0.05,"Yes","No")
  plotdata[plotdata$pvalue<0.05,"annotation"] <- paste(round(plotdata[plotdata$pvalue<0.05,"hazard_ratio"],3)," (p value ",round(plotdata[plotdata$pvalue<0.05,"pvalue"],3),"*)",sep="")
  plotdata[plotdata$pvalue<0.01,"annotation"] <- paste(round(plotdata[plotdata$pvalue<0.01,"hazard_ratio"],3)," (p value ",round(plotdata[plotdata$pvalue<0.01,"pvalue"],3),"**)",sep="")
  plotdata[plotdata$pvalue<0.001,"annotation"] <- paste(round(plotdata[plotdata$pvalue<0.001,"hazard_ratio"],3)," (p value ",round(plotdata[plotdata$pvalue<0.001,"pvalue"],3),"***)",sep="")
  plotdata[is.na(plotdata$annotation),"annotation"] <- paste(round(plotdata[is.na(plotdata$annotation),"hazard_ratio"],3)," (p value ",round(plotdata[is.na(plotdata$annotation),"pvalue"],3),")",sep="")
  
  p <- ggplot(data=plotdata, aes(x=predictor, y=hazard_ratio, ymin=lower, ymax=upper, color=sig)) +
    geom_errorbar(width=0.2) +
    geom_point() +
    geom_text(aes(label=plotdata$annotation),vjust=-1, hjust=0.5) +
    geom_hline(yintercept=1, lty=2) +
    coord_flip() +
    xlab(xlab) + ylab(ylab) +
    scale_x_discrete(limits = rev(plotdata$predictor)) +
    scale_colour_manual(name ='Significant', values =c('No'='black','Yes'=sigcolor), labels = c('No','Yes')) +
    theme(axis.title=element_text(size=10),
          axis.text =element_text(size=15),
          axis.line = element_line(size=1, colour = "black"),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          panel.background = element_blank(),
          legend.key=element_blank(),
          legend.title=element_text(size=13),
          legend.position="none",
          plot.title = element_text(size=18, hjust = 0),
          axis.text.x=element_text(colour="black", size = 12,angle=0),
          axis.text.y=element_text(colour="black", size = 12))
  return(p)
}

confusion_matrix2 <- function(
  prediction,
  target,
  positive = NULL,
  prevalence = NULL,
  return_table = FALSE,
  dnn = c('Predicted', 'Target'),
  longer = FALSE,
  ...
) {
  
  
  init <- data.frame(prediction, target) %>%
    dplyr::mutate_if(is.logical, as.numeric) %>%
    dplyr::mutate_all(as.factor)
  
  
  
  if (any(levels(init$target) != levels(init$prediction))) {
    warning(
      "Levels are not the same for target and prediction.
    \nRefactoring prediction to match. Some statistics may not be available."
    )
    
    init <- init %>%
      dplyr::mutate(prediction = factor(prediction, levels = levels(target)))
  }
  
  prediction <- init$prediction
  target   <- init$target
  
  # changed focus to be on target levels; prediction can have a single class
  # without failure.
  classLevels <- levels(target)
  numLevels   <- length(classLevels)
  
  
  if(numLevels == 2 & is.null(positive))  positive <- levels(target)[1]
  
  # create confusion matrix
  
  conf_mat <- table(prediction, target, dnn = dnn)
  
  return(conf_mat)
}

calc_stats <- function(tabble, prevalence = NULL, positive, ...) {
  # checks
  # using original all.equal checks will fail
  if (!identical(nrow(tabble), ncol(tabble)))
    stop("the table must have nrow = ncol")
  
  # this doesn't really check order
  if (!identical(rownames(tabble), colnames(tabble)))
    stop("the table must the same groups in the same order")
  
  tabble_init <- tabble
  
  print(tabble)
  
  # Calculate Sensitivity ---------------------------------------------------
  
  if (nrow(tabble_init) > 2) {
    tmp <- tabble_init
    tabble <- matrix(NA, 2, 2)
    
    colnames(tabble) <- rownames(tabble) <- c("pos", "neg")
    posCol <- which(colnames(tmp) %in% positive)
    negCol <- which(!(colnames(tmp) %in% positive))
    
    tabble[1, 1] <- sum(tmp[posCol, posCol])
    tabble[1, 2] <- sum(tmp[posCol, negCol])
    tabble[2, 1] <- sum(tmp[negCol, posCol])
    tabble[2, 2] <- sum(tmp[negCol, negCol])
    tabble <- as.table(tabble)
    
    
    pos <- "pos"
    neg <- "neg"
    
    rm(tmp)
  } else {
    pos <- positive
    neg <- rownames(tabble_init)[rownames(tabble_init) != positive]
  }
  
  numer <- sum(tabble[pos, pos])
  denom <- sum(tabble[, pos])
  sens  <- ifelse(denom > 0, numer/denom, NA)
  
  detection_rate <- sum(tabble[pos, pos])/sum(tabble)
  detection_prevalence <- sum(tabble[pos, ])/sum(tabble)
  
  
  # Calculate Specificity ---------------------------------------------------
  
  numer <- sum(tabble[neg, neg])
  denom <- sum(tabble[, neg])
  spec  <- ifelse(denom > 0, numer/denom, NA)
  
  
  # Calculate Prevalence ----------------------------------------------------
  
  if (is.null(prevalence))
    prevalence <- sum(tabble_init[, positive]) / sum(tabble_init)
  
  
  # Calculate PPV/NPV -------------------------------------------------------
  
  ppv <-
    (sens * prevalence) /
    ((sens * prevalence) + ((1 - spec) *(1 - prevalence)))
  
  npv <-
    (spec * (1 - prevalence)) /
    (((1 - sens) * prevalence) + ((spec) * (1 - prevalence)))
  
  
  # Calculate F1 ------------------------------------------------------------
  
  f1 <- 2/(1/sens + 1/ppv)
  
  
  # Calculate d-prime/AUC ---------------------------------------------------
  
  # check for inability to calculate
  if (any(rowSums(tabble) == 0)) {
    d_prime <- NA
    auc <- NA
  }
  else {
    d_prime <- qnorm(sens) - qnorm(1-spec)  # primary calculation
    
    # check if sens/spec 1/0 and fudge with warning
    if (is.infinite(d_prime)) {
      warning('Encountered infinite values for d_prime,
    fudge factor introduced to correct.')
      sens_   <- abs(sens - .000001)
      spec_   <- abs(spec - .000001)
      d_prime <- qnorm(sens_) - qnorm(1 - spec_)
      
      xmax <- max(4, d_prime + 3)
      x <- seq(-3, xmax, 0.05)
      
      vpx <- stats::pnorm(x + stats::qnorm(sens_))
      fpx <- stats::pnorm(x - stats::qnorm(spec_))
    }
    else {
      xmax <- max(4, d_prime + 3)
      x <- seq(-3, xmax, 0.05)
      
      vpx <- stats::pnorm(x + stats::qnorm(sens))
      fpx <- stats::pnorm(x - stats::qnorm(spec))
    }
    
    fpx.diff <- diff(fpx)
    lower.sum <- sum(fpx.diff * vpx[-1])
    upper.sum <- sum(fpx.diff * vpx[-length(vpx)])
    auc <- (lower.sum + upper.sum)/2
    auc <- ifelse(auc < .5, 1 - auc, auc)
    # shortcut auc = pnorm(tab$`D Prime`/sqrt(2))
  }
  
  
  # Return result -----------------------------------------------------------
  
  dplyr::tibble(
    `Sensitivity/Recall/TPR` = sens,
    `Specificity/TNR` = spec,
    `PPV/Precision` = ppv,
    `NPV` = npv,
    `F1/Dice` = f1,
    `Prevalence` = prevalence,
    `Detection Rate` = detection_rate,
    `Detection Prevalence` = detection_prevalence,
    `Balanced Accuracy` = (sens + spec)/2,
    `FDR` = 1 - ppv,
    `FOR`  = 1 - npv,
    `FPR/Fallout`  = 1 - spec,
    `FNR`  = 1 - sens,
    `D Prime` = d_prime,
    `AUC` = auc
  )
}

get_diagnosis <- function(fit,data,covariate=NULL,type="pha",maintitle=""){
  
  
  
  indata <- .get_data(fit, data)
  custom_theme <- theme(axis.title=element_text(size=15),
                        axis.text =element_text(size=12),
                        axis.line = element_line(size=1, colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_blank(),
                        legend.key=element_blank(),
                        legend.title=element_text(size=13),
                        legend.position="none",
                        plot.title = element_text(size=18, hjust = 0),
                        strip.background =element_blank(),
                        strip.text = element_text(size=12),
                        axis.text.x=element_text(colour="black", size = 12,angle=0),
                        axis.text.y=element_text(colour="black", size = 12))
  
  if(type=="pha"){
    ## check the proportional hazards assumption for the Cox model
    ptmp <- ggcoxzph(cox.zph(fit), ggtheme = custom_theme)
    p <- cowplot::plot_grid(plotlist = ptmp, ncol=2)
    p <- cowplot::add_sub(p,"Notice: The proportional hazard assumption is supported by the non-significant p-value", y = 0.5, vjust = 0, colour = "red")
    p <- cowplot::ggdraw(p)
    title <- cowplot::ggdraw() + cowplot::draw_label(maintitle, fontface='bold', size=16)
    p <- cowplot::plot_grid(title,p,nrow =2,rel_heights=c(0.1, 1))
    
  } else if (type=="io"){
    ## check influential observations
    p <- ggcoxdiagnosis(fit, type = "dfbeta", linear.predictions = FALSE, ggtheme = custom_theme, ylab="Residuals",title = maintitle)
  } else if (type=="nl" & !is.null(covariate)){
    ## check non linearity in relationship between the log hazard and the covariates
    newfunction <- coxph(as.formula(paste(as.character(fit$call$formula)[2],"~",covariate,"+log(",covariate,")+sqrt(",covariate,")",sep="")),data=indata)
    p <- ggcoxfunctional(newfunction,data=indata)
    p <- cowplot::plot_grid(plotlist = p, ncol=2)
    title <- cowplot::ggdraw() + cowplot::draw_label(maintitle, fontface='bold', size=16)
    p <- cowplot::plot_grid(title,p,nrow =2,rel_heights=c(0.1, 1))
  } else {
    stop("This function only supports three types: 'pha', 'io' and 'nl'. If chossing 'nl', please make sure the covariate is continuous.")
  }
  
}

get_survivalanalysis<-function(Xmat,Ymat,GroupBy.variable="sex",cox.glmnet=FALSE,newdevice=TRUE,plot.width=8,plot.height=8,KMplot=TRUE)
{
  
  
  Xmat1<-cbind(colnames(Xmat[,-c(1)]),t(Xmat[,-c(1)]))
  Xmat1<-as.data.frame(Xmat1)
  cnames<-colnames(Xmat1)
  cnames[1]<-"SID"
  colnames(Xmat1)<-cnames
  
  cnames<-colnames(Ymat)
  cnames[1]<-"SID"
  cnames[2]<-"time"
  cnames[3]<-"status"
  colnames(Ymat)<-cnames
  
  
  sdata1<-merge(Ymat,Xmat1,by="SID")
  
  
  if(cox.glmnet==TRUE){
    cox.cv.glmnet<-cv.glmnet(x=data.matrix(sdata1[,-c(1:3)]),y=Surv(sdata1$time, sdata1$status),family="cox",alpha=1)
    
    cox.glmnet.res<-glmnet(x=data.matrix(sdata1[,-c(1:3)]),y=Surv(sdata1$time, sdata1$status),family="cox",lambda=cox.cv.glmnet$lambda.min)
    
    select_feats<-which(abs(cox.glmnet.res$beta)>0)
    
    
    if(length(select_feats)<0){
      stop("No features selected.")
    }
    #sdata<-sdata[,c(1,2,(select_feats+2))]
    #fit<-cox.glmnet.res	
    Xmat2<-Xmat1[,c(1,select_feats+1)]
    sdata1<-merge(Ymat,Xmat2,by="SID")
  }
  
  
  
  
 
  plist = list()
  
  if(newdevice==TRUE){
    
    pdf("CPH_results.pdf",width=plot.width,height=plot.height)
  }
  if(KMplot==TRUE){
    
    
    if(length(grep(colnames(sdata1),pattern=GroupBy.variable))>0){
      
      fit <- coxph(Surv(time, status) ~ ., data=sdata1[,-c(1)])
      p<- get_survplot_adjustedcurve(fit,data=sdata1,variable=GroupBy.variable,L_ratio_test=FALSE,waldtest=FALSE,
                                   logrank=TRUE,concordance = FALSE,add.risk.table=TRUE, add.cumulative.events=FALSE)
    
    }else{
      
      fit <- coxph(Surv(time, status) ~ ., data=sdata1[,-c(1)])
      p<- get_survplot_adjustedcurve(fit,data=sdata1,method = "single",L_ratio_test=FALSE,waldtest=FALSE,
                                     logrank=FALSE,concordance = FALSE,add.risk.table=FALSE, add.cumulative.events=FALSE)
      
    }
    
   # plist[[length(plist)+1]] <- cowplot::ggdraw(p)
    
    text_val <-"Kaplan-Meier survival curve"
    
    # Create a text grob
    tgrob <- text_grob(text_val,size = 16)
    # Draw the text
    plot_0 <- as_ggplot(tgrob) + theme(plot.margin = margin(0,1,0,0, "cm"))
    
    print(ggarrange(plot_0,p,ncol = 1,nrow = 2,heights = c(0.75,5)))
    
  }
  
  
  
  #run univariate analysis
  res<-lapply((ncol(Ymat)+1):ncol(sdata1),function(j){
                
                intensity<-as.numeric(as.character(sdata1[,c(j)]))
                
                if(length(which(is.na(intensity)==FALSE))<1){
                  intensity<-as.factor(sdata1[,c(j)])
                  
                }
                sdata_temp<-cbind(Ymat[,-c(1)],intensity)
                
                sdata_temp<-as.data.frame(sdata_temp)
                
              
                
                cnames_all<-colnames(sdata_temp)
                
                
                cnames_other<-cnames_all[-which(cnames_all%in%c("time","status","intensity"))]
                
                
                if(length(cnames_other)>0){
                sdata_temp<-sdata_temp[,c("time","status","intensity",cnames_other)]
                }else{
                  sdata_temp<-sdata_temp[,c("time","status","intensity")]
                  
                }
                
                cnames_1<-colnames(sdata_temp)
                
                cnames_1[which(cnames_1=="intensity")]<-colnames(sdata1)[j]
                colnames(sdata_temp)<-cnames_1
                
                if(length(grep(colnames(Ymat),pattern=GroupBy.variable))>0){
                  
                  KM.method="conditional"
                 
                  
                  res<-get_survivalanalysis_univariate(sdata=sdata_temp,KMplot=TRUE,forestplot=TRUE,diagnosis=TRUE, maintitle="",
                                                       KM.variable = GroupBy.variable,
                                                       KM.reference = NULL,
                                                       KM.method = KM.method,
                                                       KM.plottitle = "",
                                                       KM.xlab = "Time", KM.ylab = "Survival probability",
                                                       KM.size = 1, KM.xincrement="auto", KM.yincrement=0.25,
                                                       KM.concordance=TRUE, KM.rsquare=TRUE, KM.L_ratio_test=FALSE, KM.waldtest=FALSE, KM.logrank=TRUE,
                                                       KM.linecolor="auto", KM.add.risk.table=TRUE, KM.add.cumulative.events=TRUE,
                                                       forest.xlab="",forest.ylab="Hazard Ratio (95% CI)",forest.sigcolor="red",
                                                       diagnosis.covariate=NULL,diagnosis.type="pha",cox.glmnet=FALSE,cv.glm.alpha=1)
                  
                  
                  text_val <- paste("Forest plot for variable: ",colnames(sdata1)[j],sep="")
                  
                  # Create a text grob
                  tgrob <- text_grob(text_val,size = 16)
                  # Draw the text
                  plot_0 <- as_ggplot(tgrob) + theme(plot.margin = margin(0,3,0,0, "cm"))
                  
                  print(ggarrange(plot_0,res$plots[[2]],
                            ncol = 1,nrow = 2,heights = c(1,5)))
                  
                  
                }else{
                  
                  KM.method="single"
                  
                 # print(head(sdata_temp))
                  
                  res<-get_survivalanalysis_univariate(sdata=sdata_temp,KMplot=TRUE,forestplot=TRUE,diagnosis=TRUE, maintitle="",
                                                       KM.variable = GroupBy.variable,
                                                       KM.reference = NULL,
                                                       KM.method = KM.method,
                                                       KM.plottitle = "",
                                                       KM.xlab = "Time", KM.ylab = "Survival probability",
                                                       KM.size = 1, KM.xincrement="auto", KM.yincrement=0.25,
                                                       KM.concordance=TRUE, KM.rsquare=TRUE, KM.L_ratio_test=FALSE, KM.waldtest=FALSE, KM.logrank=TRUE,
                                                       KM.linecolor="auto", KM.add.risk.table=TRUE, KM.add.cumulative.events=TRUE,
                                                       forest.xlab="",forest.ylab="Hazard Ratio (95% CI)",forest.sigcolor="red",
                                                       diagnosis.covariate=NULL,diagnosis.type="pha",cox.glmnet=FALSE,cv.glm.alpha=1)
                  
                  
                  text_val <- paste("Forest plot for CPH model for variable: ",colnames(sdata1)[j],sep="")
                  
                  # Create a text grob
                  tgrob <- text_grob(text_val,size = 16)
                  # Draw the text
                  plot_0 <- as_ggplot(tgrob) + theme(plot.margin = margin(0,3,0,0, "cm"))
                  
                  print(ggarrange(plot_0,res$plots[[2]],
                            ncol = 1,nrow = 2,heights = c(1,5)))
                }
               
                s1=summary(res$stats[[1]])
                
                resvec<-c(s1[[7]],s1[[7]][2]-1.96*s1[[7]][3],s1[[7]][2]+1.96*s1[[7]][3])
                
                return(resvec)
    })
  #save(res,file="res1.Rda")
  res<-ldply(res,rbind)
  rownames(res)<-colnames(sdata1)[c((ncol(Ymat)+1):ncol(sdata1))]
  try(dev.off(),silent=TRUE)
  colnames(res)<-c("coef","exp(coef)","se(coef)","z","pvalue","lower.confint.95pct","upper.confint.95pct")
  return(res)
}

### specify a variable for group information ##
#data(kidney)
#out <- get_survivalanalysis(kidney[,-1], KM.variable="sex", maintitle="analysis for kidney data")

#library(stringr)
#library(survminer)
#Xmat: Name, S1,S2,S3
#Ymat: SID,time,status, covariates
get_survivalanalysis_univariate <- function(sdata,KMplot=TRUE,forestplot=TRUE,diagnosis=TRUE, maintitle="",
                                 KM.variable = NULL,
                                 KM.reference = NULL,
                                 KM.method = "conditional",
                                 KM.plottitle = "",
                                 KM.xlab = "Time", KM.ylab = "Survival probability",
                                 KM.size = 1, KM.xincrement="auto", KM.yincrement=0.25,
                                 KM.concordance=TRUE, KM.rsquare=TRUE, KM.L_ratio_test=TRUE, KM.waldtest=TRUE, KM.logrank=TRUE,
                                 KM.linecolor="auto", KM.add.risk.table=TRUE, KM.add.cumulative.events=TRUE,
                                 forest.xlab="",forest.ylab="Hazard Ratio (95% CI)",forest.sigcolor="red",
                                 diagnosis.covariate=NULL,diagnosis.type="pha",cox.glmnet=FALSE,cv.glm.alpha=1){
  
  suppressMessages(library(glmnet))
  suppressMessages(library(cowplot))
  
  
#  print("Survival analysis is running.")
  #print("Using the first three columns as follow-up time, status, intensity.")
  outlist = list()
  
  #subject_id=as.vector(data[,-1])

  
  if(class(sdata[,1])=="numeric" & class(sdata[,2])=="numeric"){ # & class(sdata[,3])=="numeric"){
    
    #colnames(sdata)[1:3]=c("time","status","intensity")
    
    #fit <- coxph(Surv(time, status) ~ ., data=sdata)
    
   
    
    #colnames(sdata)[1:3]=c("time","status","intensity")
    fit <- coxph(Surv(time, status) ~ ., data=sdata)
    
    outlist[[length(outlist)+1]] <- fit
    names(outlist)[length(outlist)] <- "fitted_model"
  
      
    
    #print(summary(fit))
    
    plist = list()
    
    if(KMplot==TRUE){
      
      p<- get_survplot_adjustedcurve(fit,data=sdata,variable=KM.variable,reference=KM.reference,method=KM.method,
                                     plottitle=KM.plottitle,xlab=KM.xlab,ylab=KM.ylab,size=KM.size,
                                     xincrement=KM.xincrement,yincrement=KM.yincrement,concordance=KM.concordance,
                                     rsquare=KM.rsquare,L_ratio_test=KM.L_ratio_test,waldtest=KM.waldtest,
                                     logrank=KM.logrank,linecolor=KM.linecolor,add.risk.table=KM.add.risk.table,add.cumulative.events=KM.add.cumulative.events)
      
      plist[[length(plist)+1]] <- cowplot::ggdraw(p)
    }
    
    
    if(forestplot==TRUE){
      
      p <- get_forestplot(fit,data=sdata,xlab=forest.xlab,ylab=forest.ylab,sigcolor=forest.sigcolor)
      
      plist[[length(plist)+1]] <- cowplot::ggdraw(p)
      
    }
    
    
    if(length(plist)!=0){
      
      pcombine <- cowplot::plot_grid(plotlist = plist ,ncol =2)
      title <- cowplot::ggdraw() + cowplot::draw_label(maintitle, fontface='bold', size=16)
      pcombine <- cowplot::plot_grid(title,pcombine,nrow =2,rel_heights=c(0.1, 1))
      
      outlist[[length(outlist)+1]] <- pcombine
      names(outlist)[length(outlist)] <- "analysisplots"
    }
    
    if(diagnosis==TRUE){
      
      pdiagnosis <- get_diagnosis(fit,data=sdata,covariate=diagnosis.covariate,type=diagnosis.type,maintitle=maintitle)
      
      outlist[[length(outlist)+1]] <- pdiagnosis
      names(outlist)[length(outlist)] <- "diagnosis"
      
    }
    
    names(outlist)
   # print(plist)
    return(list("stats"=outlist,"plots"=plist))
    
  }else{
    
    print("Error occured: There are something wrong in the first three columns. Please double check your input data and make sure there is no missing value and all numeric values.")
    
  }
  
  
}





do_cor<-function(data_m_fc_withfeats,subindex=NA,targetindex=NA,outloc,networkscope,cor.method,abs.cor.thresh,cor.fdrthresh,
                 max.cor.num,net_node_colors,net_legend,netrandseed=555,num_nodes=6, plots.width=2000,plots.height=2000,plots.res=300,cex.plots=0.8,newdevice=FALSE){
  
  
  suppressWarnings(dir.create(outloc,showWarnings = FALSE))
  setwd(outloc)
  allsig_pcornetwork<-{}
  cormat<-{}
  
  suppressWarnings(dir.create("Figures",showWarnings = FALSE))
  suppressWarnings(dir.create("Tables",showWarnings = FALSE))
  suppressMessages(library(fdrtool))
  suppressMessages(library(igraph))
  
  allsig_pcornetwork_fdr0.05<-{}
  
  suppressMessages(library(qvalue))
  suppressMessages(library(fdrtool))
  
  allsig_pcornetwork_fdr0.05<-{}
  
  if(dim(data_m_fc_withfeats)[1]>1)
  {
    if(is.na(subindex[1])==FALSE){
      goodfeats<-data_m_fc_withfeats[subindex,]
      
    }else{
      goodfeats<-data_m_fc_withfeats
      
    }
    
    if(is.na(targetindex[1])==FALSE){
      data_m_fc_withfeats<-data_m_fc_withfeats[targetindex,]
      
    }else{
      data_m_fc_withfeats<-data_m_fc_withfeats
      
    }
    
    if(is.na(subindex[1])==FALSE){
      if(length(subindex)>=(nrow(data_m_fc_withfeats)-2)){
        
        data_m_fc_withfeats<-data_m_fc_withfeats
        
      }else{
        data_m_fc_withfeats<-data_m_fc_withfeats[-subindex,]
      }
    }
    m1<-apply(data_m_fc_withfeats[,-c(1:2)],2,as.numeric)
    
    
    rnames<-paste("mzid_",seq(1,dim(data_m_fc_withfeats)[1]),sep="")
    
    
    rownames(m1)=rnames
    
    data_mt<-t(m1)
  }else{
    m1<-as.numeric(data_m_fc_withfeats[,-c(1:2)])
    
    data_mt<-(m1)
    
    data_mt<-as.matrix(data_mt)
    
  }
  
  goodfeats_inf<-as.data.frame(goodfeats[,c(1:2)])
  
  goodfeats<-as.data.frame(goodfeats)
  
  complete_pearsonpvalue_mat<-{}
  complete_pearsonqvalue_mat<-{}
  l1<-list.files(".")
  
  
  cat(paste("Computing ",cor.method," matrix for correlation analysis between selected and all other features",sep=""),sep="\n")
  #system.time(pearson_res<-parRapply(cl,goodfeats[,-c(1:2)],getCorchild,data_mt,cor.method))
  
  temp_mat<-rbind(goodfeats[,-c(1:2)],t(data_mt))
  
  pearson_res<-WGCNA::cor(t(temp_mat),nThreads=num_nodes,method=cor.method)
  
  pearson_res<-pearson_res[c(1:dim(goodfeats[,-c(1:2)])[1]),-c(1:dim(goodfeats[,-c(1:2)])[1])]
  
  num_samp<-dim(data_mt)[1]
  
  
  num_samp<-dim(goodfeats[,-c(1:2)])[2]
  
  pearson_resmat<-{}
  
  pearson_resvec<-as.vector(pearson_res)
  
  pearson_pvalue<-lapply(1:length(pearson_resvec),function(x){
    
    return(WGCNA::corPvalueStudent(pearson_resvec[x],num_samp))
    
    
  })
  
  complete_pearsonpvalue_mat<-unlist(pearson_pvalue)
  dim(complete_pearsonpvalue_mat)<-dim(pearson_res)
  
  cormat<-pearson_res
  
  pearson_Res_all<-{}
  
  cormat<-as.data.frame(cormat)
  cormat<-as.matrix(cormat)
  
  
  pearson_Res_all<-{}
  
  
  complete_pearsonpvalue_mat<-as.data.frame(complete_pearsonpvalue_mat)
  complete_pearsonpvalue_mat<-as.matrix(complete_pearsonpvalue_mat)
  
  
  complete_pearsonpvalue_mat<-t(complete_pearsonpvalue_mat)
  cormat<-t(cormat)
  
  
  pearson_Res_all<-{}
  
  
  complete_pearsonqvalue_mat<-apply(cormat,2,function(x){
    
    
    x<-as.numeric(x)
    pdf("fdrtoolB.pdf")
    
    fdr_adjust_pvalue<-try(suppressWarnings(fdrtool(x,statistic="correlation",verbose=FALSE)),silent=TRUE)
    
    if(is(fdr_adjust_pvalue,"try-error")){
      fdr_adjust_pvalue<-NA
    }else{
      fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
    }
    try(dev.off(),silent=TRUE)
    return(fdr_adjust_pvalue)
  }
  
  )
  
  
  complete_pearsonqvalue_mat<-as.data.frame(complete_pearsonqvalue_mat)
  complete_pearsonqvalue_mat<-as.matrix(complete_pearsonqvalue_mat)
  
  setwd(outloc)
  
  
  goodfeats<-as.data.frame(goodfeats)
  
  colnames(cormat)<-as.character(goodfeats$mz)
  
  
  data_m_fc_withfeats<-as.data.frame(data_m_fc_withfeats)
  
  
  rownames(cormat)<-as.character(data_m_fc_withfeats$mz)
  
  cormat<-round(cormat,2)
  
  
  fname<-paste("Tables/cor.matrix_selectedvsallfeatures.txt",sep="")
  #write.table(cormat,file=fname,sep="\t",row.names=TRUE)
  
  fname<-paste("Tables/cor.matrix.pvalues_selectedvsallfeatures.txt",sep="")
  
  complete_pearsonpvalue_mat<-round(complete_pearsonpvalue_mat,2)
  
  #  write.table(complete_pearsonpvalue_mat,file=fname,sep="\t",row.names=TRUE)
  
  fname<-paste("Tables/cor.matrix.qvalues_selectedvsallfeatures.txt",sep="")
  
  complete_pearsonqvalue_mat<-round(complete_pearsonqvalue_mat,2)
  
  #   write.table(complete_pearsonqvalue_mat,file=fname,sep="\t",row.names=TRUE)
  
  
  
  
  #nonsig_vs_fdr0.05_pearson_mat<-
  nonsig_vs_fdr0.05_pearson_mat_bool<-cormat
  
  nonsig_vs_fdr0.05_pearson_mat_bool[complete_pearsonqvalue_mat>cor.fdrthresh]<-0
  
  cormat_abs<-abs(cormat)
  
  nonsig_vs_fdr0.05_pearson_mat_bool[cormat_abs<abs.cor.thresh]<-0
  
  rm(cormat_abs)
  
  sum_mat<-apply(nonsig_vs_fdr0.05_pearson_mat_bool,1,sum)
  
  bad_index<-which(sum_mat==0)
  
  
  
  nonsig_vs_fdr0.05_pearson_mat_bool_filt<-nonsig_vs_fdr0.05_pearson_mat_bool
  
  mz_index<-which(data_m_fc_withfeats$mz%in%goodfeats$mz)
  
  if(length(bad_index)>0){
    nonsig_vs_fdr0.05_pearson_mat_bool_filt<-nonsig_vs_fdr0.05_pearson_mat_bool[-bad_index,]
  }
  
  
  if(length(mz_index)==length(data_m_fc_withfeats$mz))
  {
    nonsig_vs_fdr0.05_pearson_mat_bool_filt[lower.tri(nonsig_vs_fdr0.05_pearson_mat_bool_filt)==TRUE]<-0
    diag(nonsig_vs_fdr0.05_pearson_mat_bool_filt)<-0
  }else{
    
    mz_index<-which(data_m_fc_withfeats$mz%in%goodfeats$mz)
    
    if(length(mz_index)>0){
      nonsig_vs_fdr0.05_pearson_mat_bool_filt<-nonsig_vs_fdr0.05_pearson_mat_bool_filt[-mz_index,]
    }
    
  }
  
  nonsig_vs_fdr0.05_pearson_mat_bool_filt<-unique(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
  
  if(length(nonsig_vs_fdr0.05_pearson_mat_bool_filt)>0){
    
    
    nonsig_vs_fdr0.05_pearson_mat_bool_filt_1<-as.data.frame(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
    
    if(length(nonsig_vs_fdr0.05_pearson_mat_bool_filt)>dim(nonsig_vs_fdr0.05_pearson_mat_bool_filt_1)[1] && (length(nonsig_vs_fdr0.05_pearson_mat_bool_filt)>1))
      #if((length(nonsig_vs_fdr0.05_pearson_mat_bool_filt)>1))
    {
      
      
      
      check_cor<-apply(abs(nonsig_vs_fdr0.05_pearson_mat_bool_filt),1,function(x){max(x,na.rm=TRUE)})
      
      nonsig_vs_fdr0.05_pearson_mat_bool_filt<-nonsig_vs_fdr0.05_pearson_mat_bool_filt[order(check_cor,decreasing=TRUE),]
      
      #print(head(nonsig_vs_fdr0.05_pearson_mat_bool_filt))
      
      nonsig_vs_fdr0.05_pearson_mat_bool_filt<-na.omit(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      fname<-paste("Tables/cor.matrix_selectedvsallfeaturescorthresh",abs.cor.thresh,networkscope,"_mzlabels.txt",sep="")
      
      #nonsig_vs_fdr0.05_pearson_mat_bool_filt<-round(nonsig_vs_fdr0.05_pearson_mat_bool_filt,2)
      
      write.table(nonsig_vs_fdr0.05_pearson_mat_bool_filt,file=fname,sep="\t",row.names=TRUE)
      
      
      #	fname<-paste("Tables/significant_correlations_",networkscope,"CIRCOSformat_mzlabels.txt",sep="")
      
      
      mz_rnames<-rownames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      mz_cnames<-colnames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      
      
      circos_format<-abs(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      
      circos_format<-cbind(mz_rnames,circos_format)
      
      #
      
      #	write.table(circos_format,file=fname,sep="\t",row.names=FALSE)
      
      
      rnames<-mz_rnames
      cnames<-mz_cnames
      
      cnames<-seq(1,length(cnames))
      rnames<-seq(1,length(rnames))
      
      id_mapping_mat<-cbind(rnames,mz_rnames)
      
      
      if(length(nonsig_vs_fdr0.05_pearson_mat_bool_filt)>0)
      {
        
        if(nrow(nonsig_vs_fdr0.05_pearson_mat_bool_filt)>0){
          
          
          colnames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)<-paste("Y",cnames,sep="")
          rownames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)<-paste("X",rnames,sep="")
          
          fname<-paste("Tables/cor.matrix_selectedvsallfeaturescorthresh",abs.cor.thresh,networkscope,"_rowcolnumlabels.txt",sep="")
          
          #nonsig_vs_fdr0.05_pearson_mat_bool_filt<-round(nonsig_vs_fdr0.05_pearson_mat_bool_filt,2)
          
          write.table(nonsig_vs_fdr0.05_pearson_mat_bool_filt,file=fname,sep="\t",row.names=TRUE)
        }else{
          stop("No correlations found.")
        }
      }else{
        
        stop("No correlations found.")
      }
      circos_format<-abs(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      
      
      circos_format<-cbind(rnames,circos_format)
      
      fname<-paste("Tables/significant_correlations_",networkscope,"CIRCOSformat_rowcolnumlabels.txt",sep="")
      
      
      # write.table(circos_format,file=fname,sep="\t",row.names=FALSE)
      
      
      if(length(which(check_cor>=abs.cor.thresh))>0){
        
        
        if(is.na(max.cor.num)==FALSE){
          
          if(max.cor.num>dim(nonsig_vs_fdr0.05_pearson_mat_bool_filt)[1]){
            max.cor.num<-dim(nonsig_vs_fdr0.05_pearson_mat_bool_filt)[1]
          }
          nonsig_vs_fdr0.05_pearson_mat_bool_filt<-nonsig_vs_fdr0.05_pearson_mat_bool_filt[1:max.cor.num,]
          
          mz_rnames<-mz_rnames[1:max.cor.num]
          rnames<-rnames[1:max.cor.num]
        }
        
        
        if(newdevice==TRUE){
        pdfname<-paste("Figures/Level2_networkplot_selectedvsall",networkscope,"corthresh",abs.cor.thresh,".pdf",sep="")
        pdf(pdfname) #,width=8,height=10)
        }
        
        dup_ind<-which(duplicated(rnames)==TRUE)
        if(length(dup_ind)>0){
          nonsig_vs_fdr0.05_pearson_mat_bool_filt_1<-nonsig_vs_fdr0.05_pearson_mat_bool_filt[-which(duplicated(rnames)==TRUE),]
          rnames<-rnames[-which(duplicated(rnames)==TRUE)]
          mz_rnames<-mz_rnames[-which(duplicated(rnames)==TRUE)]
          
        }else{
          nonsig_vs_fdr0.05_pearson_mat_bool_filt_1<-nonsig_vs_fdr0.05_pearson_mat_bool_filt
        }
        
        dup_indB<-which(duplicated(cnames)==TRUE)
        if(length(dup_indB)>0){
          nonsig_vs_fdr0.05_pearson_mat_bool_filt_1<-nonsig_vs_fdr0.05_pearson_mat_bool_filt_1[,-which(duplicated(cnames)==TRUE)]
          cnames<-cnames[-which(duplicated(cnames)==TRUE)]
          mz_cnames<-mz_cnames[-which(duplicated(cnames)==TRUE)]
          
        }
        
        set.seed(netrandseed)
        
      # save(nonsig_vs_fdr0.05_pearson_mat_bool_filt_1,file="nonsig_vs_fdr0.05_pearson_mat_bool_filt_1.Rda")
        
        net_result<-network(mat=as.matrix(nonsig_vs_fdr0.05_pearson_mat_bool_filt_1), cutoff=abs.cor.thresh,color.node = net_node_colors,
                            shape.node = c("rectangle", "circle"),
                            color.edge = c("red", "blue"), lwd.edge = 1,
                            show.edge.labels = FALSE, interactive = FALSE,cex.node.name=0.3) #,silent=TRUE)
        
        
        if(is(net_result,"try-error")){
          
          set.seed(netrandseed)
          
          if(FALSE){
            net_result<-try(network(mat=as.matrix(nonsig_vs_fdr0.05_pearson_mat_bool_filt_1), threshold=abs.cor.thresh,color.node = net_node_colors,
                                    shape.node = c("rectangle", "circle"),
                                    color.edge = c("red", "blue"), lwd.edge = 1,
                                    show.edge.labels = FALSE, interactive = FALSE,cex.node.name=0.6),silent=TRUE)
          }
          
        }
        
        
        cytoscape_fname<-paste("Figures/Networkplot_selectedvsallfeatures",networkscope,"corthresh",abs.cor.thresh,".gml",sep="")
        write.graph(net_result$gR, file =cytoscape_fname, format = "gml")
        
        if(net_legend==TRUE){
          (legend("bottomright",c("Selected features","Other features"),pch=c(22,19),col=net_node_colors, cex=cex.plots,title="Legend:"))
        }
        
        
        
        
      if(newdevice==TRUE){  
          try(dev.off(),silent=TRUE)
        }
        
      }else{
        if(networkscope=="all"){
          print(paste("Metabolome-wide correlation network can not be generated as the correlation threshold criteria is not met.",sep=""))
        }else{
          print(paste("Targeted correlation network can not be generated as the correlation threshold criteria is not met.",sep=""))
        }
        
      }
      
    }
    
  }else{
    if(length(nonsig_vs_fdr0.05_pearson_mat_bool_filt)==dim(goodfeats)[1]){
      
      #print("here")
      
      rnames<-rownames(nonsig_vs_fdr0.05_pearson_mat_bool)
      rnames1<-rnames[-bad_index]
      nonsig_vs_fdr0.05_pearson_mat_bool_filt<-as.matrix(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      nonsig_vs_fdr0.05_pearson_mat_bool_filt<-t(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      rownames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)<-as.character(rnames1)
      check_cor<-max(abs(nonsig_vs_fdr0.05_pearson_mat_bool_filt))
      
      fname<-paste("Tables/cor.matrix_selectedvsallfeaturescorthresh",abs.cor.thresh,networktype,"_mzlabels.txt",sep="")
      
      #nonsig_vs_fdr0.05_pearson_mat_bool_filt<-round(nonsig_vs_fdr0.05_pearson_mat_bool_filt,2)
      
      write.table(nonsig_vs_fdr0.05_pearson_mat_bool_filt,file=fname,sep="\t",row.names=TRUE)
      
      fname<-paste("Tables/significant_correlations_",networktype,"CIRCOSformat_mzlabels.txt",sep="")
      
      mz_rnames<-rownames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      mz_cnames<-colnames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      #rnames<-c("Data",rnames)
      
      circos_format<-abs(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      
      
      circos_format<-cbind(rnames,circos_format)
      
      
      
      #write.table(circos_format,file=fname,sep="\t",row.names=FALSE)
      
      
      #	print("here")
      rnames<-mz_rnames
      cnames<-mz_cnames
      
      #cnames<-round(as.numeric(cnames),5)
      #rnames<-round(as.numeric(rnames),5)
      
      cnames<-seq(1,length(cnames))
      rnames<-seq(1,length(rnames))
      
      id_mapping_mat<-cbind(rnames,mz_rnames)
      
      #id_mapping_mat<-rbind(id_mapping_mat,cbind(cnames,mz_cnames))
      # colnames(id_mapping_mat)<-c("ID","Name")
      #write.csv(id_mapping_mat,file="node_id_mapping.csv",row.names=FALSE)
      
      colnames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)<-paste("Y",cnames,sep="")
      rownames(nonsig_vs_fdr0.05_pearson_mat_bool_filt)<-paste("X",rnames,sep="")
      
      fname<-paste("Tables/significant_correlations_",networktype,"CIRCOS_format_rowcolnumlabels.txt",sep="")
      
      circos_format<-abs(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
      #circos_format<-round(circos_format,2)
      
      #circos_format<-rbind(cnames,circos_format)
      circos_format<-cbind(rnames,circos_format)
      
      
      
      #write.table(circos_format,file=fname,sep="\t",row.names=FALSE)
      
      fname<-paste("Tables/cor.matrix_selectedvsallfeaturescorthresh",abs.cor.thresh,networktype,"rowcolnumlabels.txt",sep="")
      
      #  nonsig_vs_fdr0.05_pearson_mat_bool_filt<-round(nonsig_vs_fdr0.05_pearson_mat_bool_filt,2)
      
      write.table(nonsig_vs_fdr0.05_pearson_mat_bool_filt,file=fname,sep="\t",row.names=TRUE)
    
      if(FALSE){ 
      if(check_cor>=abs.cor.thresh){
        
        
        #pdf("network_plot.pdf",width=9,height=11)	
        
        pdfname<-paste("Figures/Networkplot_selectedvsallfeatures",networkscope,"corthresh",abs.cor.thresh,".pdf",sep="")
        pdf(pdfname,width=8,height=10)
        
        nonsig_vs_fdr0.05_pearson_mat_bool_filt_1<-nonsig_vs_fdr0.05_pearson_mat_bool_filt[-which(duplicated(rnames)==TRUE),]
        set.seed(netrandseed)
        net_result<-try(network(mat=as.matrix(nonsig_vs_fdr0.05_pearson_mat_bool_filt_1), cutoff=abs.cor.thresh,color.node = net_node_colors,
                                shape.node = c("rectangle", "circle"),
                                color.edge = c("red", "blue"), lwd.edge = 1,
                                show.edge.labels = FALSE, interactive = FALSE,cex.node.name=0.6),silent=TRUE)
        
        if(is(net_result,"try-error")){
          
          if(FALSE){
            set.seed(netrandseed)
            net_result<-try(network(mat=as.matrix(nonsig_vs_fdr0.05_pearson_mat_bool_filt_1), threshold=abs.cor.thresh,color.node = net_node_colors,shape.node = c("rectangle", "circle"),
                                    color.edge = c("red", "blue"), lwd.edge = 1,show.edge.labels = FALSE, interactive = FALSE,cex.node.name=0.6),silent=TRUE)
          }
        }
        
        print(net_result)
        
        if(net_legend==TRUE){
          (legend("bottomright",c("Row #","Colum #"),pch=c(22,19),col=net_node_colors, cex=cex.plots,title="Network matrix values:"))
        }
        #write.graph(net_result$gR, file = "network_cytoscape_format.gml", format = "gml")
        
        cytoscape_fname<-paste("Figures/Networkplot_selectedvsallfeatures",networkscope,"corthresh",abs.cor.thresh,"_rowcolnumlabels.gml",sep="")
        write.graph(net_result$gR, file =cytoscape_fname, format = "gml")
        #dev.off()
        
        
        try(dev.off(),silent=TRUE)
        
      }
      }
      
    }else{
      cat("No significant correlations found.",sep="\n")
    }
  }
  
  # ###savenet_result,file="metabnet.Rda")
  
  return(nonsig_vs_fdr0.05_pearson_mat_bool_filt)
  
  
}



docortest<-function(n,r){
  #n<-length(x)
  t<-r*sqrt((n-2)/(1-r^2))
  pvalue<-2*pt(-abs(t),df=n-2)
  
  return(pvalue)
  
}




get_full_cormat<-function(data_m_fc_withfeats,targeted.index=NA,cor.method="spearman",write.files=TRUE){
  Sys.sleep(0.2)
  
  allsig_pcornetwork<-{}
  cormat<-{}
  
  allsig_pcornetwork_fdr0.05<-{}
  
  metab_names<-paste(data_m_fc_withfeats$mz,data_m_fc_withfeats$time,sep="_")
  rnames<-paste("mzid_",seq(1,dim(data_m_fc_withfeats)[1]),sep="")
  
  if(dim(data_m_fc_withfeats)[1]>1)
  {
    m1<-apply(data_m_fc_withfeats[,-c(1:2)],2,as.numeric)
    
    
    rownames(m1)=rnames
    
    data_mt<-t(m1)
  }else{
    
    m1<-as.numeric(data_m_fc_withfeats[,-c(1:2)])
    
    
    data_mt<-(m1)
  }
  data_mt<-as.matrix((data_mt))
  
  print(paste("Computing ",cor.method," correlation matrix",sep="")) 
  cormat<-WGCNA::cor(data_mt,use="pairwise.complete.obs",method=cor.method)
  colnames(cormat)<-as.character(metab_names)
  rownames(cormat)<-as.character(metab_names)
  
  num_samp<-dim(data_m_fc_withfeats[,-c(1:2)])[2]
  pearson_resvec<-as.vector(cormat)
  
  cl<-makeCluster(3)
  
  pearson_pvalue<-parLapply(cl,1:length(pearson_resvec),function(x){
    
    return(WGCNA::corPvalueStudent(pearson_resvec[x],num_samp))
    
    
  })
  
  stopCluster(cl)
  
  complete_pearsonpvalue_mat<-unlist(pearson_pvalue)
  dim(complete_pearsonpvalue_mat)<-dim(cormat)
  
  
  cormat<-as.data.frame(cormat)
  cormat<-as.matrix(cormat)
  pearson_Res_all<-{}
  
  cormat<-round(cormat,2)
  
  complete_pearsonpvalue_mat<-as.data.frame(complete_pearsonpvalue_mat)
  
  complete_pearsonpvalue_mat<-round(complete_pearsonpvalue_mat,2)
  
  if(write.files==TRUE)
  {
    write.table(cormat,file="correlationmatrix.txt",sep="\t",row.names=TRUE)
    
    write.table(complete_pearsonpvalue_mat,file="pvalue_matrix.txt",sep="\t",row.names=TRUE)
    
    ####savecormat,file="full_correlation.Rda")
    
    if(is.na(targeted.index)==FALSE){
      
      cormat<-cormat[targeted.index,]
      complete_pearsonpvalue_mat<-complete_pearsonpvalue_mat[targeted.index,]
      
      write.table(cormat,file="targetcorrelationmatrix.txt",sep="\t",row.names=TRUE)
      write.table(complete_pearsonpvalue_mat,file="targetpvalue_matrix.txt",sep="\t",row.names=TRUE)
      
    }
  }
  
  return(cormat)
}

get_partial_cornet<-function(data_m_fc_withfeats, sigfeats.index=NA,targeted.index=NA,networkscope="global",cor.method="spearman",abs.cor.thresh=0.4,
                             cor.fdrthresh=0.2,outloc,net_node_colors,net_legend=FALSE,netrandseed=555,pcor.method="pcor.shrink",newdevice=FALSE){
  
  suppressMessages(library(GeneNet))
  suppressMessages(library(igraph))
  
  setwd(outloc)
  l1<-list.files(".")
  
  data_m_fc_withfeats<-as.data.frame(data_m_fc_withfeats)
  
  metab_names<-paste(data_m_fc_withfeats$mz,data_m_fc_withfeats$time,sep="_")
  
  
  
  if(pcor.method=="cor2pcor"){
    
    cormat<-get_full_cormat(data_m_fc_withfeats,cor.method=cor.method)
    
    
    
    fname<-paste("complete_correlation_matrix.txt",sep="")
    
    cormat<-round(cormat,2)
    
    #write.table(cormat,file=fname,sep="\t",row.names=TRUE)
    
    
    
    p1<-cor2pcor(cormat)
  }else{
    
    p1<-suppressWarnings(pcor.shrink(data_mt))
    
    p1<-replace(p1,which(p1>1),1)
    p1<-replace(p1,which(p1<(-1)),-1)
  }
  colnames(p1)<-as.character(metab_names)
  rownames(p1)<-as.character(metab_names)
  
  suppressWarnings(dir.create("Tables",showWarnings = FALSE))
  p1<-round(p1,2)
  ####savep1,file="partial_cor.Rda")
  write.table(p1,file="Tables/partial_cor.txt",sep="\t",row.names=TRUE)
  
  
  
  colnames(p1)<-as.character(metab_names)
  rownames(p1)<-as.character(metab_names)
  
  
  if(is.na(targeted.index[1])==FALSE){
    
    networkscope="targeted"
  }
  
  
  
  
  #only raw p-values
  if(is.na(cor.fdrthresh)==TRUE){
    
    #p1sig<-cor0.test(p1, kappa=16)
    
    fname<-paste("net3_corpval",cor.fdrthresh,".Rda",sep="")
    
    edge.list<-network.test.edges(p1,fdr=FALSE,verbose=FALSE,plot=FALSE)
    
    
    net<-extract.network(edge.list,cutoff.ggm=0.80,verbose=FALSE)
    
    net2<-net[order(net$node1),]
    
    net3<-net2[,c(2,3,1,4)]
    
    
    ####savenet3,file=fname)
    
    
    
    
    
    
    
    netcormat<-matrix(data=0,nrow=dim(p1)[2],ncol=dim(p1)[2])
    colnames(netcormat)<-colnames(p1)
    rownames(netcormat)<-rownames(p1)
    
    for(i in 1:(dim(net3)[1])){
      
      r<-net3$node1[i]
      c<-net3$node2[i]
      p<-net3$pcor[i]
      
      netcormat[r,c]<-p
      netcormat[c,r]<-p
    }
    diag(netcormat)<-1
    #print(dim(netcormat))
    if(is.na(targeted.index[1])==TRUE){
      
      targeted.index=seq(1,dim(netcormat)[2])
    }
    
    if(is.na(sigfeats.index[1])==FALSE){
      netcormat<-netcormat[c(sigfeats.index),c(targeted.index)]
      
    }else{
      netcormat<-netcormat[,c(targeted.index)]
    }
    
  }else{
    
    
    if(cor.fdrthresh!=(-1) | (is.na(cor.fdrthresh)==TRUE)){
      
      #p1sig<-cor0.test(p1, kappa=16)
      fname<-paste("net3_corpval",cor.fdrthresh,".Rda",sep="")
      
      edge.list<-network.test.edges(p1,fdr=TRUE,verbose=FALSE,plot=FALSE)
      
      
      net<-extract.network(edge.list,method.ggm="qval",cutoff.ggm=(1-cor.fdrthresh),verbose=FALSE)
      
      net2<-net[order(net$node1),]
      
      net3<-net2[,c(2,3,1,4,5)]
      
      
      ####savenet3,file=fname)
      
      
      
      netcormat<-matrix(data=0,nrow=dim(p1)[2],ncol=dim(p1)[2])
      colnames(netcormat)<-colnames(p1)
      rownames(netcormat)<-rownames(p1)
      
      for(i in 1:(dim(net3)[1])){
        netcormat[net3$node1[i],net3$node2[i]]=net3$pcor[i]
        netcormat[net3$node2[i],net3$node1[i]]=net3$pcor[i]
      }
      diag(netcormat)<-1
      if(is.na(targeted.index)==TRUE){
        
        targeted.index=seq(1,dim(netcormat)[2])
      }
      if(is.na(sigfeats.index)==FALSE){
        netcormat<-netcormat[c(sigfeats.index),c(targeted.index)]
        
      }else{
        netcormat<-netcormat[,c(targeted.index)]
      }
    }else{
      if(is.na(sigfeats.index)==FALSE){
        netcormat<-p1[c(sigfeats.index),c(targeted.index)]
        
      }else{
        netcormat<-p1[,c(targeted.index)]
      }
    }
    
    
    
    
  }
  
  if(length(sigfeats.index)<dim(data_m_fc_withfeats)[1]){
    fname<-paste("Tables/significant_correlations_for_network.txt",sep="")
    
    # netcormat<-round(netcormat,2)
    
    write.table(netcormat,file=fname,sep="\t",row.names=TRUE)
    
    net_fname<-paste("Figures/partial_corsig",cor.fdrthresh,"network.tiff",sep="")
    
    max_cor_check<-max(abs(netcormat),na.rm=TRUE,warnings=FALSE)
    
    #if(max_cor_check>0)
    
    if(max_cor_check>=abs.cor.thresh){
      
      netcormat<-t(netcormat)
      colnames(netcormat)<-paste("Y",seq(1,dim(netcormat)[2]),sep="")
      rownames(netcormat)<-paste("X",seq(1,dim(netcormat)[1]),sep="")
      #tiff(net_fname, width=plots.width,height=plots.height,res=plots.res, compression="lzw")
      
      if(newdevice==TRUE){
      pdf(net_fname,width=8,height=10)
      }
      par_rows=1
      par(mfrow=c(par_rows,1))
      set.seed(netrandseed)
      net_result<-try(network(mat=as.matrix(nonsig_vs_fdr0.05_pearson_mat_bool_filt_1), cutoff=abs.cor.thresh,color.node = net_node_colors,
                              shape.node = c("rectangle", "circle"),
                              color.edge = c("red", "blue"), lwd.edge = 1,
                              show.edge.labels = FALSE, interactive = FALSE,cex.node.name=0.6),silent=TRUE)
      
      if(is(net_result,"try-error")){
        
        if(FALSE){
          set.seed(netrandseed)
          net_result<-try(network(mat=as.matrix(netcormat), threshold=abs.cor.thresh,color.node = net_node_colors,shape.node = c("rectangle", "circle"),
                                  color.edge = c("red", "blue"), lwd.edge = 1,show.edge.labels = FALSE, interactive = FALSE,cex.node.name=0.6),silent=TRUE)
        }
      }
      
      #legend("bottomright",c("Row #","Colum #"),pch=c(22,19),col=net_node_colors, cex=0.8)
      print(net_result)
      
      if(net_legend==TRUE){
        (legend("bottomright",c("Row #","Colum #"),pch=c(22,19),col=net_node_colors, cex=cex.plots,title="Network matrix values:"))
      }
      
      
      # ###savenet_result,"metabnet.Rda")
      
      
      write.graph(net_result$gR, file = "Figures/network_cytoscape_format.gml", format = "gml")
      
      if(newdevice==TRUE){
        
      try(dev.off(),silent=TRUE)
      }
    }else{
      print("No significant correlations found.")
    }
  }else{
    
    print("Network plot can not be generated. Rows and columns need to be exclusive.")
  }
  net4<-netcormat
  

  
  return(net4)
}

#alpha=1; lasso
#alpha=0; ridge
#alpha=0.5;elasticnet
do_ridge_lasso_elasticnet<-function(X,classlabels,alpha.val=1){ #,lambda=10^seq(10, -2, length = 100)){
  
  #temp1<-cbind(classlabels,t(X))
  #temp1<-as.data.frame(temp1)
  
  x<-t(X)
  x<-as.matrix(x)
  classlabels=as.numeric(as.factor(classlabels))
  cvfit<-cv.glmnet(x,classlabels, alpha = alpha.val) #, lambda = lambda)	
  
  plot(cvfit)
  res<-coef(cvfit, s = "lambda.min")	
  
  res<-res[-c(1),]
  
  #res_sum<-summary(res)
  
  return(res) #_sum)
}

#uses the Boruta algorithm for feature selection
do_rf_boruta<-function(X,classlabels,maxRuns=1000){
  
  temp1<-cbind(classlabels,t(X))
  temp1<-as.data.frame(temp1)
  set.seed(290875)
  Boruta(classlabels~.,data=temp1,maxRuns=maxRuns)->Bor.test
  mean_imphistory<-apply(Bor.test$ImpHistory,2,mean)
  varimp_res2<-mean_imphistory[1:(length(mean_imphistory)-3)] #rep(0,length(Bor.test$finalDecision))
  temp_decision_vec<-as.character(Bor.test$finalDecision)
  if(length(which(temp_decision_vec=="Rejected"))>0){
    temp_decision_vec<-replace(temp_decision_vec,which(temp_decision_vec=="Rejected"),0)
  }
  if(length(which(temp_decision_vec=="Tentative"))>0){
    temp_decision_vec<-replace(temp_decision_vec,which(temp_decision_vec=="Tentative"),1)
  }
  if(length(which(temp_decision_vec=="Confirmed"))>0){
    temp_decision_vec<-replace(temp_decision_vec,which(temp_decision_vec=="Confirmed"),2)
  }
  temp_decision_vec<-as.numeric(as.character(temp_decision_vec))
  
  if(length(which(temp_decision_vec<2))>0){
    varimp_res2[which(temp_decision_vec<2)]<-0
  }
  return(varimp_res2)
}

do_rf<-function(X,classlabels, ntrees=1000, analysismode="classification"){
  dataA<-t(X)
  dataA<-as.data.frame(dataA)
  classlabels<-as.data.frame(classlabels)
  dataA<-cbind(classlabels,dataA)
  dataA<-as.data.frame(dataA)
  
  colnames(dataA)<-c("Targetvar",paste("mz",seq(1,dim(X)[1]),sep=""))
  dataA<-as.data.frame(dataA)
  
  attach(dataA,warn.conflicts=FALSE)
  
  #	return(dataA)	
  
  set.seed(290875)
  if(analysismode=="classfication"){
    set.seed(290875)
    rf2 <- randomForest(as.factor(Targetvar) ~ .,data=dataA, importance=TRUE,proximity=FALSE,ntree=ntrees,keep.forest=FALSE)
  }else{
    set.seed(290875)
    rf2 <- randomForest(Targetvar ~ .,data=dataA, importance=TRUE,proximity=FALSE,ntree=ntrees,keep.forest=FALSE)
  }
  
  #based on permutation importance;
  varimp_res<-randomForest::importance(rf2,type=1,scale=FALSE)
  varimp_res_scaled<-randomForest::importance(rf2,type=1,scale=TRUE)
  rm(dataA)
  
  #return(varimp_res)
  return(list("rf_model"=rf2,"rf_varimp"=varimp_res,"rf_varimp_scaled"=varimp_res_scaled))
}

do_rf_conditional<-function(X,classlabels, ntrees=1000, analysismode="classification"){
  
  #classlabels<-c(rep("A",6),rep("B",6))
  
  dataA<-t(X)
  dataA<-as.data.frame(dataA)
  dataA<-cbind(classlabels,dataA)
  dataA<-as.data.frame(dataA)
  
  colnames(dataA)<-c("Targetvar",paste("mz",seq(1,dim(X)[1]),sep=""))
  
  dataA<-as.data.frame(dataA)
  
  attach(dataA,warn.conflicts=FALSE)
  
  mtry_num<-if (!is.null(classlabels) && !is.factor(classlabels))
    max(floor(ncol(X)/3), 1) else floor(sqrt(ncol(X)))
  
  #return(dataA)
  set.seed(290875)
  
  nvar=dim(X)[1] 
  if(analysismode=="classfication"){
    set.seed(290875)
    rf1<-cforest(factor(Targetvar)~.,data=dataA,control=cforest_control(teststat = "quad", testtype = "Univ",mincriterion = 0,savesplitstats = FALSE,ntree = ntrees, mtry = ceiling(sqrt(nvar)), replace = TRUE,fraction = 0.632, trace = FALSE))
    
  }else{
    set.seed(290875)
    #rf1<-cforest(Targetvar~.,data=dataA,control=cforest_control(teststat = "max",testtype = "Teststatistic",mincriterion = qnorm(0.9),savesplitstats = FALSE,ntree = ntrees, mtry = NULL, replace = TRUE,fraction = 0.632, trace = FALSE))
    
    #rf1<-cforest(Targetvar~.,data=dataA,control=cforest_unbiased(mtry = ceiling(sqrt(nvar)), ntree =ntrees))
    #  ntree = ntrees, mtry = NULL, replace = TRUE,
    #fraction = 0.632, trace = FALSE))
    
    rf1<-cforest(factor(Targetvar)~.,data=dataA,control=cforest_control(teststat = "quad", testtype = "Univ",mincriterion = 0,savesplitstats = FALSE,ntree = ntrees, mtry = ceiling(sqrt(nvar)), replace = TRUE,fraction = 0.632, trace = FALSE))
    
  }
  
  if(analysismode=="classfication"){
    set.seed(290875)
    varimp_res<-varimp(rf1,conditional=TRUE) #varimpAUC(rf1,conditional=TRUE)
  }else{
    varimp_res<-varimp(rf1,conditional=TRUE)
  }
  print(varimp_res)
  rm(dataA) 
  
  #return(varimp_res)
  return(list("rf_model"=rf1,"rf_varimp"=varimp_res))
  
}

varimp_parallel<-function (object, mincriterion = 0, conditional = FALSE, threshold = 0.2,
                           nperm = 1, OOB = TRUE, pre1.0_0 = conditional)
{
  response <- object@responses
  if (length(response@variables) == 1 && inherits(response@variables[[1]],
                                                  "Surv"))
    return(varimpsurv(object, mincriterion, conditional,
                      threshold, nperm, OOB, pre1.0_0))
  input <- object@data@get("input")
  xnames <- colnames(input)
  inp <- initVariableFrame(input, trafo = NULL)
  y <- object@responses@variables[[1]]
  if (length(response@variables) != 1)
    stop("cannot compute variable importance measure for multivariate response")
  if (conditional || pre1.0_0) {
    if (!all(complete.cases(inp@variables)))
      stop("cannot compute variable importance measure with missing values")
  }
  CLASS <- all(response@is_nominal)
  ORDERED <- all(response@is_ordinal)
  if (CLASS) {
    error <- function(x, oob) mean((levels(y)[sapply(x, which.max)] !=
                                      y)[oob])
  }
  else {
    if (ORDERED) {
      error <- function(x, oob) mean((sapply(x, which.max) !=
                                        y)[oob])
    }
    else {
      error <- function(x, oob) mean((unlist(x) - y)[oob]^2)
    }
  }
  w <- object@initweights
  if (max(abs(w - 1)) > sqrt(.Machine$double.eps))
    warning(sQuote("varimp"), " with non-unity weights might give misleading results")
  perror <- matrix(0, nrow = nperm * length(object@ensemble),
                   ncol = length(xnames))
  colnames(perror) <- xnames
  
  l1<-lapply(1:length(object@ensemble),function(b){
    # for (b in 1:length(object@ensemble)) {
    tree <- object@ensemble[[b]]
    if (OOB) {
      oob <- object@weights[[b]] == 0
    }
    else {
      oob <- rep(TRUE, length(y))
    }
    p <- predict(tree, inp, mincriterion, -1L)
    eoob <- error(p, oob)
    #for (j in unique(varIDs(tree))) {
    l2<-lapply(unique(varIDs(tree)),function(j){
      for (per in 1:nperm) {
        if (conditional || pre1.0_0) {
          tmp <- inp
          ccl <- create_cond_list(conditional, threshold,
                                  xnames[j], input)
          if (length(ccl) < 1) {
            perm <- sample(which(oob))
          }
          else {
            perm <- conditional_perm(ccl, xnames, input,
                                     tree, oob)
          }
          tmp@variables[[j]][which(oob)] <- tmp@variables[[j]][perm]
          p <- predict(tree, tmp, mincriterion, -1L)
        }
        else {
          p <- predict(tree, inp, mincriterion, as.integer(j))
        }
        #perror[(per + (b - 1) * nperm), j] <- (error(p,oob) - eoob)
        perror[(per), j] <- (error(p,oob) - eoob)
      }
      return(perror)
    })
    perror<-ldply(l2,rbind)
    return(perror)
  })
  perror<-ldply(l1,rbind)
  perror <- as.data.frame(perror)
  return(MeanDecreaseAccuracy = colMeans(perror))
}



do_mars<-function(X,classlabels, analysismode="classification",kfold=10){
  
  dataA<-t(X)
  dataA<-as.data.frame(dataA)
  rnames1<-rownames(X)
  
  if(analysismode=="classification"){
    
    dataA<-cbind(classlabels,dataA)
    dataA<-as.data.frame(dataA)
    
    cnames<-c("Targetvar",paste("mz",seq(1,dim(X)[1]),sep=""))
    
    colnames(dataA)<-as.character(cnames)
    
    if(dim(dataA)[1]<20){kfold=1}
    
    dataA<-as.data.frame(dataA)
    
    attach(dataA,warn.conflicts=FALSE)
    
    #print(dim(dataA))
    
    
    mars_res<-new("list")
    
    
    mars_res[[1]]<-earth(formula=factor(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=1,ncross=kfold,nfold=kfold)
    mars_res[[2]]<-earth(formula=factor(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=2,ncross=kfold,nfold=kfold)
    mars_res[[3]]<-earth(formula=factor(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=3,ncross=kfold,nfold=kfold)
    
    gcv_list<-c(mars_res[[1]]$gcv,mars_res[[2]]$gcv,mars_res[[3]]$gcv)
    
    max_gcv<-which(gcv_list==max(gcv_list,na.rm=TRUE))
    
    mars_res<-earth(formula=factor(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=max_gcv[1],ncross=kfold,nfold=kfold)
    
  }else{
    if(analysismode=="regression"){
      
      mars_res<-new("list")
      
      classlabels<-as.data.frame(classlabels)
      #print(dim(classlabels))
      
      if(dim(classlabels)[2]>1){
        classlabels<-apply(classlabels,2,as.numeric)
        classlabels<-as.numeric(classlabels[,1])
      }else{
        classlabels<-as.numeric(classlabels[,1])
        #classlabels<-apply(classlabels,2,as.numeric)
        
      }
      
      
      dataA<-cbind(classlabels,dataA)
      #dataA<-as.data.frame(dataA)
      
      cnames<-c("Targetvar",paste("mz",seq(1,dim(X)[1]),sep=""))
      
      #cnames<-c(paste("mz",seq(1,dim(X)[1]),sep=""))
      
      colnames(dataA)<-as.character(cnames)
      
      if(dim(dataA)[1]<20){kfold=1}
      
      dataA<-as.data.frame(dataA)
      
      attach(dataA,warn.conflicts=FALSE)
      
     # save(dataA,kfold,file="dataA.rda")
      #mars_res[[1]]<-earth(y=(classlabels),x=dataA,Use.beta.cache=FALSE,degree=1,ncross=kfold,nfold=kfold)
      #		mars_res[[2]]<-earth(y=(classlabels),x=dataA,Use.beta.cache=FALSE,degree=2,ncross=kfold,nfold=kfold)
      #		mars_res[[3]]<-earth(y=(classlabels),x=dataA,Use.beta.cache=FALSE,degree=3,ncross=kfold,nfold=kfold)
      
      mars_res[[1]]<-earth(formula=as.numeric(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=1,ncross=kfold,nfold=kfold)
      mars_res[[2]]<-earth(formula=as.numeric(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=2,ncross=kfold,nfold=kfold)
      mars_res[[3]]<-earth(formula=as.numeric(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=3,ncross=kfold,nfold=kfold)
      gcv_list<-c(mars_res[[1]]$gcv,mars_res[[2]]$gcv,mars_res[[3]]$gcv)
      max_gcv<-which(gcv_list==max(gcv_list,na.rm=TRUE))
      
      mars_res<-earth(formula=as.numeric(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=max_gcv[1],ncross=kfold,nfold=kfold)
      #mars_res<-earth(formula=(Targetvar) ~ .,data=dataA,Use.beta.cache=FALSE,degree=3,ncross=kfold,nfold=kfold)
      #mars_res<-earth(y=(classlabels),x=dataA,Use.beta.cache=FALSE,degree=min_gcv[1],ncross=kfold,nfold=kfold)
      
      
    }else{
      stop("Invalid analysismode entered. Please use classification or regression.")
    }
  }
  dataA<-NULL
  detach(dataA)
  rm(dataA)
  
  ###savemars_res,file="mars_res.Rda")
  #varimp_res <- evimp(mars_res)
  
  #if(FALSE)
  {
    varimp_res <- evimp(mars_res,trim=FALSE)

    #save(varimp_res,file="varimp_res.Rda")    
    #varimp_res<-as.data.frame(varimp_res)
    varimp_res<-varimp_res[order(varimp_res[,1]),]
    rownames(varimp_res)<-rnames1
    
    #print(varimp_res[1:10,])
    varimp_marsres1<-varimp_res #[order(varimp_res[,2],decreasing=TRUE),]
    
    mars_mznames<-rownames(varimp_marsres1)
    
    
    g1<-grep(pattern="NA",x=mars_mznames)
    if(length(g1)>0){
      varimp_marsres1<-varimp_marsres1[-g1,]
    }
  }
  
  
  return(list("mars_model"=mars_res,"mars_varimp"=varimp_marsres1))
  
}

getSumreplicates<-function(curdata,alignment.tool,numreplicates,numcluster,rep.max.missing.thresh,summary.method="mean",
                           summary.na.replacement="zeros",missing.val=0,col_end=NA)
{
  mean_replicate_difference<-{}
  sd_range_duplicate_pairs<-{}
  #print(alignment.tool)
  if(is.na(alignment.tool)==FALSE){
  if(alignment.tool=="apLCMS")
  {
    col_end=2
  }
  else
  {
    if(alignment.tool=="XCMS")
    {
      col_end=2
    }
    else
    {
      #stop(paste("Invalid value for alignment.tool. Please use either \"apLCMS\" or \"XCMS\"", sep=""))
    }
  }
  }
  
  if(is.na(col_end)==FALSE){
  curdata_mz_rt_info=curdata[,c(1:col_end)]
  curdata=curdata[,-c(1:col_end)]
  }else{
    curdata_mz_rt_info=curdata
    
  }
  
  
  cl<-parallel::makeCluster(numcluster)
  numfeats=dim(curdata)[1]
  numsamp=dim(curdata)[2]	
  
  if(numsamp%%numreplicates>0){
    
    stop("Not all samples have replicates or the numreplicates value is not correct.")
  }
  
  clusterEvalQ(cl, "getSumreplicateschild")
  sub_samp_list<-list()
  
  sampcount=1
  for(samp in seq(1,(numsamp),numreplicates))
  {
    i=samp
    j=i+numreplicates-1
    if(dim(curdata[,c(i:j)])[1]>0){
      sub_samp_list[[sampcount]]=curdata[,c(i:j)]
    }
    sampcount=sampcount+1
  }
  
  avg.res<-parSapply(cl,sub_samp_list,getSumreplicateschild,alignment.tool=alignment.tool,numreplicates=numreplicates,rep.max.missing.thresh=rep.max.missing.thresh,method=summary.method,missing.val=missing.val)
  #avg.res<-getAvgreplicateschild(sub_samp_list[[1]],alignment.tool,numreplicates)
  #print("done")
  
  
  stopCluster(cl)
  
  
  
  final_set<-as.data.frame(avg.res)
  colnames_data<-colnames(curdata)
  colnames_data<-colnames_data[seq(1,(numsamp),numreplicates)]
  colnames(final_set)<-colnames_data
  rownames(final_set)=NULL
  #final_set<-cbind(curdata_mz_rt_info,final_set)
  
  final_set<-apply(final_set,2,as.numeric)
  #	write.table(final_set,file="final_Set.txt",sep="\t",row.names=FALSE)
  
  if(summary.na.replacement=="zeros"){
    
    final_set<-replace(final_set,which(is.na(final_set)==TRUE),0)
  }else{
    if(summary.na.replacement=="halfsamplemin"){
      
      
      final_set<-apply(final_set,2,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-min(x,na.rm=TRUE)/2}; return(x)})
    }else{
      
      if(summary.na.replacement=="halfdatamin"){
        
        
        min_val<-min(final_set,na.rm=TRUE)*0.5
        final_set<-replace(final_set,which(is.na(final_set)==TRUE),min_val)
        
        #data_m<-apply(data_m,1,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-min(x,na.rm=TRUE)/2}; return(x)})
      }else{
        if(summary.na.replacement=="halffeaturemin"){
          
          
          final_set<-apply(final_set,1,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-min(x,na.rm=TRUE)/2}; return(x)})
          final_set<-t(final_set)
        }else{
          
          if(summary.na.replacement=="knn"){
            
            #	##save(final_set,file="final_set1.Rda")
            # print("imputing")
            suppressMessages(library(impute))
            final_set<-impute.knn(final_set,k = 10, rowmax = 0.5, colmax = 0.8, maxp = 1500, rng.seed=362436069)
            
            final_set<-final_set$data
            final_set<-as.data.frame(final_set)
            
          }else{
            
            if(summary.na.replacement=="randomforest"){
              
              final_set<-RFimpute(t(data_m))
              final_set<-t(final_set$ximp)
              final_set<-as.data.frame(final_set)
              
            }else{
              
              if(summary.na.replacement=="QRILC"){
                
                
                library(tmvtnorm)
                final_set<-QRILCimpute(data_m) #rows: features; cols: samples
                ##save(final_set,file="final_set.Rda")
                final_set<-ldply(final_set,rbind) 
                final_set<-t(final_set)               
                final_set<-as.data.frame(final_set)
                
                if(length(which(final_set<0))>0){
                  final_set<-replace(as.matrix(final_set),which(final_set<0),0)
                }
                
              }
              
              
            }
            
          }
          # ##save(final_set,file="final_set.Rda")
          
        }
      }
    }
    
    
  }
  final_set<-as.data.frame(final_set)
  return(final_set)
}


getSumreplicateschild<-function(curdata,alignment.tool,numreplicates,rep.max.missing.thresh,method="mean",missing.val)
{
  #curdata<-t(curdata)
  #write.table(curdata,file="test.txt",sep="\t",row.names=FALSE)
  numfeats=dim(curdata)[1]
  numsamp=dim(curdata)[2]
  # if(FALSE){
  resvec_1<-lapply(1:numfeats,function(r)
  {
    newrow={}
    finalmat={}
    #for(samp in seq(1,(numsamp),numreplicates))
    {
      # i=samp
      #j=i+numreplicates-1
      
      curdata_int=curdata[r,]
      
      #if(is.na(missing.val)==FALSE){
      #           check_zeros=which(curdata_int==missing.val)
      #           }else{
      check_zeros=which(is.na(curdata_int)==TRUE)
      #           	}
      na_thresh=round(rep.max.missing.thresh*numreplicates)
      
      
      if(length(check_zeros)>na_thresh)
      {
        meanval<-missing.val
      }
      else
      {
        #temporarily replace the missing intensities, set to 0 in apLCMS,
        #with mean intensity value of the corresponding replicates (with non-zero values)
        #curdata_int[check_zeros]=mean(t(curdata_int[-c(check_zeros)]))
        if(length(check_zeros)>0)
        {
          if(method=="mean"){
            meanval<-mean(t(curdata_int[-check_zeros]),na.rm=TRUE)
          }else{
            meanval<-median(t(curdata_int[-check_zeros]),na.rm=TRUE)
          }
        }
        else
        {
          if(method=="mean"){
            meanval<-mean(t(curdata_int),na.rm=TRUE)
          }else{
            meanval<-median(t(curdata_int),na.rm=TRUE)
          }
        }
        
      }
      newrow<-cbind(newrow,meanval)
    }
    
    
    finalmat<-rbind(finalmat, newrow)
    return(finalmat)
  })
  
  #colnames(final_set)<-colnames_data
  #rownames(final_set)=NULL
  return(resvec_1)
  
  
  
}



normalize.qspline<-function (x, target = NULL, samples = NULL, fit.iters = 5, min.offset = 5, 
                             spline.method = "natural", smooth = TRUE, spar = 0, p.min = 0, 
                             p.max = 1, incl.ends = TRUE, converge = FALSE, verbose = TRUE, 
                             na.rm = FALSE) 
{
  if (is.null(target)) 
    target <- exp(apply(log(x), 1, mean))
  x.n <- dim(x)[1]
  m <- dim(x)[2]
  if (is.null(samples)) 
    samples <- max(round(x.n/1000), 100)
  else if (samples < 1) 
    samples <- round(samples * x.n)
  p <- (1:samples)/samples
  p <- p[which(p <= p.max) & which(p >= p.min)]
  samples <- length(p)
  k <- fit.iters
  if (na.rm == TRUE) 
    y.n <- sum(!is.na(target))
  else y.n <- length(target)
  py.inds <- as.integer(p * y.n)
  y.offset <- round(py.inds[1]/fit.iters)
  if (y.offset <= min.offset) {
    y.offset <- min.offset
    k <- round(py.inds[1]/min.offset)
  }
  if (k <= 1) {
    warning("'k' found is non-sense. using default 'fit.iter'")
    k <- fit.iters
  }
  y.offset <- c(0, array(y.offset, (k - 1)))
  y.order <- order(target)
  fx <- matrix(0, x.n, m)
  if (verbose == TRUE) 
    print(paste("samples=", samples, "k=", k, "first=", py.inds[1]))
  for (i in 1:m) {
    if (na.rm == TRUE) 
      x.valid <- which(!is.na(x[, i]))
    else x.valid <- 1:x.n
    x.n <- length(x.valid)
    px.inds <- as.integer(p * x.n)
    x.offset <- round(px.inds[1]/fit.iters)
    if (x.offset <= min.offset) {
      x.offset <- min.offset
      k <- min(round(px.inds[1]/min.offset), k)
    }
    x.offset <- c(0, array(x.offset, (k - 1)))
    x.order <- order(x[, i])
    y.inds <- py.inds
    x.inds <- px.inds
    for (j in 1:k) {
      y.inds <- y.inds - y.offset[j]
      x.inds <- x.inds - x.offset[j]
      ty.inds <- y.inds
      tx.inds <- x.inds
      if (verbose == TRUE) 
        print(paste("sampling(array=", i, "iter=", j, 
                    "off=", x.inds[1], -x.offset[j], y.inds[1], 
                    -y.offset[j], ")"))
      if (converge == TRUE) {
        ty.inds <- as.integer(c(1, y.inds))
        tx.inds <- as.integer(c(1, x.inds))
        if (j > 1) {
          ty.inds <- c(ty.inds, y.n)
          tx.inds <- c(tx.inds, x.n)
        }
      }
      qy <- target[y.order[ty.inds]]
      qx <- x[x.order[tx.inds], i]
      if (smooth == TRUE) {
        sspl <- smooth.spline(qx, qy, spar = spar)
        qx <- sspl$x
        qy <- sspl$y
      }
      fcn <- splinefun(qx, qy, method = spline.method)
      fx[x.valid, i] <- fx[x.valid, i] + fcn(x[x.valid, 
                                               i])/k
    }
    if (na.rm == TRUE) {
      invalid <- which(is.na(x[, i]))
      fx[invalid, i] <- NA
    }
  }
  return(fx)
}



metabnet<-function(feature_table_file,target.metab.file,sig.metab.file,class_labels_file=NA,parentoutput_dir,num_replicates=1,cor.method="spearman",abs.cor.thresh=0.4,cor.fdrthresh=0.05,
                   target.mzmatch.diff=10,target.rtmatch.diff=NA,max.cor.num=100,feat.filt.thresh=NA,summarize.replicates=TRUE,summary.method="mean",all.missing.thresh=0.5, group.missing.thresh=0.7,
                   missing.val=0, networktype="complete", samplermindex=NA,
                   rep.max.missing.thresh=0.3,summary.na.replacement="zeros",net_node_colors=c("pink","skyblue"),net_legend=FALSE,netrandseed=555,normalization.method=c("none"),
                   input.intensity.scale="raw",log2.transform.constant=1,...){
  
  options(warn=-1)
  
  
  
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  data_matrix<-data_preprocess(Xmat=NA,Ymat=NA,feature_table_file=feature_table_file,parentoutput_dir=parentoutput_dir,class_labels_file=NA,num_replicates=num_replicates,feat.filt.thresh=NA,
                               summarize.replicates=summarize.replicates,summary.method=summary.method,
                               all.missing.thresh=all.missing.thresh,group.missing.thresh=group.missing.thresh,
                               missing.val=missing.val,samplermindex=samplermindex, rep.max.missing.thresh=rep.max.missing.thresh,summary.na.replacement=summary.na.replacement,featselmethod=featselmethod,
                               normalization.method=normalization.method,input.intensity.scale=input.intensity.scale,log2.transform.constant=log2.transform.constant)
  
  data_matrix<-data_matrix$data_matrix_afternorm_scaling
  
  
  
  
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  data_m<-data_matrix[,-c(1:2)]
  
  #print(data_matrix[1:3,1:10])
  
  
  
  if(is.na(sig.metab.file)==FALSE){
    goodfeats<-read.table(sig.metab.file,sep="\t",header=TRUE)
  }else{
    goodfeats<-data_matrix
  }
  
  
  if(is.na(target.metab.file)==FALSE){
    dataA<-read.table(target.metab.file,sep="\t",header=TRUE)
    
    dataA<-as.data.frame(dataA)
    outloc<-paste(parentoutput_dir,"/metabnet","/",sep="")
    dir.create(outloc,showWarnings = FALSE)
    print(paste("Searching for metabolites matching target list",sep=""))
    
    g1<-getVenn(dataA=dataA,name_a="TargetSet",name_b="ExperimentalSet",dataB=data_matrix[,c(1:2)],mz.thresh=target.mzmatch.diff,time.thresh=target.rtmatch.diff,
                xMSanalyzer.outloc=outloc,alignment.tool=NA)
    #names(g1)
    
    
    
    if(length(g1$common)>1){
      
      if(is.na(sig.metab.file)==FALSE){
        com_mzs<-find.Overlapping.mzs(dataA=data_matrix,dataB=goodfeats,mz.thresh=1,time.thresh=1,alignment.tool=NA)
        
        sigfeats.index<-com_mzs$index.A #which(data_matrix$mz%in%goodfeats$mz)
        print(paste(length(unique(sigfeats.index))," selected features",sep=""))
        
        
      }else{
        sigfeats.index<-NA #seq(1,dim(data_matrix)[1])
        #sigfeats.index<-seq(1,50)
        
      }
      
      print(paste(length(unique(g1$common$index.B))," metabolites matched the target list",sep=""))
      
      print(paste("Generating targeted network",sep=""))
      
      
      if(networktype=="complete"){
        targetedan_fdr<-do_cor(data_matrix,subindex=sigfeats.index,targetindex=g1$common$index.B,outloc,networkscope="targeted",cor.method,
                               abs.cor.thresh,cor.fdrthresh,max.cor.num,net_node_colors,net_legend,netrandseed)
        
        #  pdf("Cornetworkplot.pdf")
        #load("metabnet.Rda")
        #print(plot(net_result))
        #dev.off()
        
      }else{
        if(networktype=="GGM"){
          targetedan_fdr<-get_partial_cornet(data_matrix, sigfeats.index,targeted.index=g1$common$index.B,networkscope="targeted",cor.method,abs.cor.thresh,
                                             cor.fdrthresh,outloc=outloc,net_node_colors,net_legend,netrandseed)
          
          
          
        }else{
          print("Invalid option. Please use complete or GGM.")
        }
      }
    }else{
      print(paste("Targeted metabolites were not found.",sep=""))
    }
  }else{
    outloc<-paste(parentoutput_dir,"/metabnet","/",sep="")
    #outloc<-paste(outloc,"/MWASresults","/",sep="")
    dir.create(outloc,showWarnings = FALSE)
    setwd(outloc)
    
    if(is.na(sig.metab.file)==FALSE){
      com_mzs<-find.Overlapping.mzs(dataA=data_matrix,dataB=goodfeats,mz.thresh=1,time.thresh=1,alignment.tool=NA)
      
      sigfeats.index<-com_mzs$index.A #which(data_matrix$mz%in%goodfeats$mz)
    }else{
      sigfeats.index<-NA #seq(1,dim(data_matrix)[1])
    }
    
    if(networktype=="complete"){
      
      
      #targetedan_fdr<-do_cor(data_matrix,sigfeats.index,outloc,networkscope="global",cor.method,abs.cor.thresh,cor.fdrthresh,max.cor.num)
      targetedan_fdr<-do_cor(data_matrix,subindex=sigfeats.index,targetindex=NA,outloc,networkscope="global",cor.method,abs.cor.thresh,cor.fdrthresh,
                             max.cor.num,net_node_colors,net_legend,netrandseed)
      
      if(FALSE){
        pdf("Cornetworkplot.pdf")
        load("metabnet.Rda")
        print(plot(net_result))
        dev.off()
      }
      
    }else{
      if(networktype=="GGM"){
        targetedan_fdr<-get_partial_cornet(data_matrix, sigfeats.index,targeted.index=NA,networkscope="global",cor.method,abs.cor.thresh,
                                           cor.fdrthresh,outloc=outloc,net_node_colors,net_legend,netrandseed)
        
        if(FALSE){
          pdf("GGMnetworkplot.pdf")
          load("metabnet.Rda")
          print(plot(net_result))
          dev.off()
        }
        
      }else{
        print("Invalid option")
      }
    }
    
  }
  
  
  print("Processing complete.")
  return(targetedan_fdr)
}


get_boxplot_colors<-function(boxplot.col.opt,class_labels_levels){
  
  alphacol=0.4
  
  if(is.na(boxplot.col.opt)==TRUE){
    
    col_vec<-rep(c("white"),length(class_labels_levels))
    boxplot.col.opt<-col_vec
  }
  
  if(boxplot.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{
    if(boxplot.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels))
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(boxplot.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(boxplot.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(boxplot.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(boxplot.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #   col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=boxplot.col.opt)
              
              if(length(check_brewer)>0){
                
                boxplot.col.opt=gsub(x=boxplot.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, boxplot.col.opt))(length(class_labels_levels))
                
              }else{
                
                if(boxplot.col.opt=="journal"){
                  
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                  
                  
                }else{
                  col_vec <-boxplot.col.opt
                }
                
              }
              
            }
          }
          
          
        }
        
      }
      
    }
  }
  
  return(col_vec)
  
}

theme_Publication <- function(base_size=14, base_family="arial") {
  library(grid)
  library(ggthemes)
  
  (theme_foundation(base_size=base_size,base_family=base_family)
    + theme(plot.title = element_text(face = "bold",
                                      size = rel(1.2), hjust = 0.5),
            text = element_text(),
            panel.background = element_rect(colour = NA),
            plot.background = element_rect(colour = NA),
            panel.border = element_rect(colour = NA),
            axis.title = element_text(face = "bold",size = rel(1)),
            axis.title.y = element_text(angle=90,vjust =2),
            axis.title.x = element_text(vjust = -0.2),
            axis.text = element_text(), 
            axis.line = element_line(colour="black"),
            axis.ticks = element_line(),
            panel.grid.major = element_line(colour="#f0f0f0"),
            panel.grid.minor = element_blank(),
            legend.key = element_rect(colour = NA),
            legend.position = "bottom",
            legend.direction = "horizontal",
            legend.key.size= unit(0.2, "cm"),
            legend.margin = unit(0, "cm"),
            legend.title = element_text(face="italic"),
            plot.margin=unit(c(10,5,5,5),"mm"),
            strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
            strip.text = element_text(face="bold")
    ))
  
}

scale_fill_Publication <- function(...){
  suppressMessages(library(scales))
  discrete_scale("fill","Publication",manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)
  
}

scale_colour_Publication <- function(...){
  suppressMessages(library(scales))
  discrete_scale("colour","Publication",manual_pal(values = c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")), ...)
  
}

set_panel_size<-function (p = NULL, g = ggplot2::ggplotGrob(p), file = NULL, 
          margin = unit(1, "mm"), width = unit(4, "cm"), 
          height = unit(4, "cm")) 
{
  panels <- grep("panel", g$layout$name)
  panel_index_w <- unique(g$layout$l[panels])
  panel_index_h <- unique(g$layout$t[panels])
  nw <- length(panel_index_w)
  nh <- length(panel_index_h)
  g$widths[panel_index_w] <- rep(width, nw)
  g$heights[panel_index_h] <- rep(height, nh)
  if (!is.null(file)) {
    ggplot2::ggsave(file, g, width = grid::convertWidth(sum(g$widths) + 
                                                          margin, unitTo = "in", valueOnly = TRUE), height = grid::convertHeight(sum(g$heights) + 
                                                                                                                                   margin, unitTo = "in", valueOnly = TRUE))
  }
  g
}

get_boxplots<-function(X=NA,Y=NA,feature_table_file,parentoutput_dir,class_labels_file,
                       boxplot.col.opt=c("journal", "npg", "nejm", "jco", "lancet", "custom1", "brewer.RdYlBu", "brewer.RdBu", "brewer.PuOr", 
                                         "brewer.PRGn", "brewer.PiYG", "brewer.BrBG", "brewer.Set2", "brewer.Paired", "brewer.Dark2", "brewer.YlGnBu", "brewer.YlGn",
                                         "brewer.YlOrRd", "brewer.YlOrBr", "brewer.PuBuGn", "brewer.PuRd", "brewer.PuBu", "brewer.OrRd", "brewer.GnBu", "brewer.BuPu",
                                         "brewer.BuGn", "brewer.blues", "black", "grey65", "terrain", "rainbow", "heat", "topo"),
                       alphacol=1,newdevice=TRUE,cex.plots=0.4,replace.by.NA=FALSE,pairedanalysis=FALSE,
                       filename="",ylabel="Intensity",xlabel=NA,alphabetical.order=FALSE,name=NA,
                       add.jitter=FALSE,add.pvalues=FALSE,class.levels=NA,fill.plots=TRUE,
                       connectpairedsamples=FALSE,boxplot.type="ggplot",
                       study.design=c("multiclass","onewayanova","twowayanova","onewayanovarepeat",
                                      "twowayanovarepeat"),
                       multiple.figures.perpanel=FALSE,ggplot.type1=TRUE,replace.outliers=FALSE,
                       plot.height=8,plot.width=8,
                       extra_text=NA,group_by_mat=NA,position_dodge_width=0.75,
                       numnodes=2,hightlight.points=FALSE,ref.group.val=FALSE,facet.nrow=1,facet.ncol=NULL,
                       ylim.val=NA,remove.xaxis.labels=FALSE,boxplot.lwd=1,axis.ticks.size=1.5,axis.line.size=2,jitter.size=3,boxplot.strip.position ="top",legend.all.pages=TRUE,
                       pval.reporting.method="none",replace.by.median=FALSE,pval.table.report=FALSE,subset.factor1=NA,subset.factor2=NA,
                       asterisk.size=6,posthoc.multcomp.test="bonferroni",...)
{
  
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  match_col.opt=match(boxplot.col.opt,c("journal","npg","nejm","jco","lancet","custom1","brewer.RdYlBu","brewer.RdBu","brewer.PuOr","brewer.PRGn","brewer.PiYG","brewer.BrBG",
                                       "brewer.Set2","brewer.Paired","brewer.Dark2","brewer.YlGnBu","brewer.YlGn","brewer.YlOrRd","brewer.YlOrBr","brewer.PuBuGn",
                                       "brewer.PuRd","brewer.PuBu",
                                       "brewer.OrRd","brewer.GnBu","brewer.BuPu","brewer.BuGn","brewer.blues","black","grey65","terrain","rainbow","heat","topo"))
  
  match_col.opt=length(which(is.na(match_col.opt)==TRUE))
  
  if(pval.reporting.method=="none"){
    pval.table.report=FALSE
  }
  
  if(length(match_col.opt)<1){
    
    boxplot.col.opt=boxplot.col.opt[1]
  }else{
    
    if(length(grep(boxplot.col.opt,pattern="brewer."))>1){
      
      boxplot.col.opt=boxplot.col.opt[1]
    }
  }
  
  #color.palette=get_hexcolors_for_palettes(color.palette=color.palette,alpha.col=alpha.col[1])
  
  if(length(boxplot.col.opt)==1){
    boxplot.col.opt=tolower(boxplot.col.opt)
    boxplot.col.opt=get_hexcolors_for_palettes(color.palette=boxplot.col.opt[1],alpha.col=alphacol[1])
  }
#suppressWarnings(suppressMessages(
  res<-get_boxplots_child(X=X,Y=Y,feature_table_file=feature_table_file,parentoutput_dir=parentoutput_dir,class_labels_file=class_labels_file,boxplot.col.opt,
                          alphacol=alphacol,newdevice=newdevice,cex.plots=cex.plots,
                     replace.by.NA=replace.by.NA,pairedanalysis=pairedanalysis,filename=filename,ylabel=ylabel,xlabel=xlabel,
                     alphabetical.order=alphabetical.order,name=name,add.jitter=add.jitter,add.pvalues=add.pvalues,class.levels=class.levels,fill.plots=fill.plots,
                     connectpairedsamples=connectpairedsamples,boxplot.type=boxplot.type,study.design=study.design,
                     multiple.figures.perpanel=multiple.figures.perpanel,ggplot.type1=ggplot.type1,
                     replace.outliers=replace.outliers,plot.height=plot.height,
                     plot.width=plot.width,extra_text=extra_text,group_by_mat=group_by_mat,
                     position_dodge_width=position_dodge_width,numnodes=numnodes,
                     hightlight.points=hightlight.points,ref.group.val=ref.group.val,facet.nrow=facet.nrow,facet.ncol=facet.ncol,ylim.val=ylim.val,
                     remove.xaxis.labels=remove.xaxis.labels,boxplot.lwd=boxplot.lwd,axis.ticks.size=axis.ticks.size,
                     axis.line.size=axis.line.size,jitter.size=jitter.size, boxplot.strip.position = boxplot.strip.position,
                     legend.all.pages=legend.all.pages,pval.reporting.method=pval.reporting.method,replace.by.median=replace.by.median,pval.table.report=pval.table.report,
                     subset.factor1=subset.factor1,subset.factor2=subset.factor2,asterisk.size=asterisk.size,posthoc.multcomp.test=posthoc.multcomp.test,...)
                     #))
  
  if(newdevice==TRUE){
    
    try(dev.off(),silent=TRUE)
  }
  
  try(unlink("Rplots.pdf"),silent=TRUE)
  return(res)
}


get_pval_boxplots<-function(df,pval.reporting.method="wilcox.test",p.adjust.method="bonferroni",ref.group="Buffer",pool.sd.bool=TRUE,var.equal.bool=TRUE){
  
  stat_table1=compare_means(Feature~Factor1,data=df,ref.group=ref.group,group.by = "Factor2",method="wilcox.test")
  stat_table1A<-stat_table1[,c("Factor2","group1","group2","p.format")]
  colnames(stat_table1A)<-c("TimePoint","Group1","Group2","p.value")
  
  #summary(stat_table1)
  
  stat_table1B<-{}
  j=1
  comparison_list<-{}
 
  for(j in 1:nrow(stat_table1A))
  {
    
    group1_mat <- subset(df,Factor1==stat_table1A$Group1[1] & Factor2==stat_table1A$TimePoint[1])
    group2_mat <- subset(df,Factor1==stat_table1A$Group2[j] & Factor2==stat_table1A$TimePoint[j])
    if(FALSE){
      sum_group1<-round(summary(as.numeric(as.character(group1_mat$Feature))),3)
      sum_group2<-round(summary(as.numeric(as.character(group2_mat$Feature))),3)
      sum_group1_text<-paste(sum_group1[3]," (",sum_group1[2],"-",sum_group1[5],")",sep="")
      sum_group2_text<-paste(sum_group2[3]," (",sum_group2[2],"-",sum_group2[5],")",sep="")
      
      sum_group1_text<-paste(mean(as.numeric(as.character(group1_mat$Feature)),na.rm=TRUE), " (",sd(as.numeric(as.character(group1_mat$Feature)),na.rm=TRUE),")",sep="")
      sum_group2_text<-paste(mean(as.numeric(as.character(group2_mat$Feature)),na.rm=TRUE), " (",sd(as.numeric(as.character(group2_mat$Feature)),na.rm=TRUE),")",sep="")
      
      x=c(as.numeric(as.character(group1_mat$Feature)))
      y=c(as.numeric(as.character(group2_mat$Feature)))
      #print(t.test(x,y))
      stat_table1B<-rbind(stat_table1B,cbind(stat_table1A[j,],sum_group1_text,sum_group2_text))
    }
    comparison_list<-c(comparison_list,paste(group2_mat$Factor1,":",group2_mat$Factor2,"-",group1_mat$Factor1,":",group1_mat$Factor2,sep=""))
  }
  
   for(j in 1:nrow(stat_table1A))
  {
        
           group1_mat <- subset(df,Factor1==stat_table1A$Group1[1] & Factor2==stat_table1A$TimePoint[j])
          group2_mat <- subset(df,Factor1==stat_table1A$Group2[j] & Factor2==stat_table1A$TimePoint[j])
          if(FALSE){
          sum_group1<-round(summary(as.numeric(as.character(group1_mat$Feature))),3)
          sum_group2<-round(summary(as.numeric(as.character(group2_mat$Feature))),3)
          sum_group1_text<-paste(sum_group1[3]," (",sum_group1[2],"-",sum_group1[5],")",sep="")
          sum_group2_text<-paste(sum_group2[3]," (",sum_group2[2],"-",sum_group2[5],")",sep="")
          
          sum_group1_text<-paste(mean(as.numeric(as.character(group1_mat$Feature)),na.rm=TRUE), " (",sd(as.numeric(as.character(group1_mat$Feature)),na.rm=TRUE),")",sep="")
          sum_group2_text<-paste(mean(as.numeric(as.character(group2_mat$Feature)),na.rm=TRUE), " (",sd(as.numeric(as.character(group2_mat$Feature)),na.rm=TRUE),")",sep="")
          
          x=c(as.numeric(as.character(group1_mat$Feature)))
          y=c(as.numeric(as.character(group2_mat$Feature)))
          #print(t.test(x,y))
          stat_table1B<-rbind(stat_table1B,cbind(stat_table1A[j,],sum_group1_text,sum_group2_text))
        }
    comparison_list<-c(comparison_list,paste(group2_mat$Factor1,":",group2_mat$Factor2,"-",group1_mat$Factor1,":",group1_mat$Factor2,sep=""))
  }
  
 
  
  for(j in 2:nrow(stat_table1A))
  {
    
    group1_mat <- subset(df,Factor1==stat_table1A$Group1[1] & Factor2==stat_table1A$TimePoint[1])
    group2_mat <- subset(df,Factor1==stat_table1A$Group1[j] & Factor2==stat_table1A$TimePoint[j])
    if(FALSE){
      sum_group1<-round(summary(as.numeric(as.character(group1_mat$Feature))),3)
      sum_group2<-round(summary(as.numeric(as.character(group2_mat$Feature))),3)
      sum_group1_text<-paste(sum_group1[3]," (",sum_group1[2],"-",sum_group1[5],")",sep="")
      sum_group2_text<-paste(sum_group2[3]," (",sum_group2[2],"-",sum_group2[5],")",sep="")
      
      sum_group1_text<-paste(mean(as.numeric(as.character(group1_mat$Feature)),na.rm=TRUE), " (",sd(as.numeric(as.character(group1_mat$Feature)),na.rm=TRUE),")",sep="")
      sum_group2_text<-paste(mean(as.numeric(as.character(group2_mat$Feature)),na.rm=TRUE), " (",sd(as.numeric(as.character(group2_mat$Feature)),na.rm=TRUE),")",sep="")
      
      x=c(as.numeric(as.character(group1_mat$Feature)))
      y=c(as.numeric(as.character(group2_mat$Feature)))
      #print(t.test(x,y))
      stat_table1B<-rbind(stat_table1B,cbind(stat_table1A[j,],sum_group1_text,sum_group2_text))
    }
    comparison_list<-c(comparison_list,paste(group2_mat$Factor1,":",group2_mat$Factor2,"-",group1_mat$Factor1,":",group1_mat$Factor2,sep=""))
  }
  
  temp_df<-df[,c("Feature","Factor1","Factor2")]
  cnames1<-colnames(temp_df)
  cnames1[1]<-"Response"
  colnames(temp_df)<-cnames1
  
 # save(temp_df,file="temp_df.Rda")
  
  if(pval.reporting.method=="twowayanova"){
  res1<-diffexplmtwowayanova(temp_df)
  }else{
    if(pval.reporting.method=="kruskal.test"){
     
      factor2_levels1<-levels(factor(temp_df$Factor2,levels=unique(temp_df$Factor2)))
      
      res1<-lapply(1:length(factor2_levels1),function(i){
        
        temp_df1<-temp_df[which(temp_df$Factor2==factor2_levels1[i]),]
        
        main_res<-kruskal.test(temp_df1$Response~temp_df1$Factor1)
        resdunn<-dunn_test(data=temp_df1,formula=Response~Factor1,p.adjust.method = p.adjust.method) #dunnTest(temp_df1$Response~temp_df1$Factor1,method="none")
        
        temp_res<-c(main_res$p.value,resdunn$p.adj)
        
        main_res<-as.data.frame(temp_res)
        
        rnames_vec<-c("Across all groups",paste(resdunn$group1," - ",resdunn$group2,sep=""))
        
        
        rownames(main_res)<-paste("(Day ",factor2_levels1[i],") ",rnames_vec,sep="")
        
        
        return(main_res)
      })
      
      res1<-bind_rows(res1)
      res1<-na.omit(res1)
      if(p.adjust.method=="none"){
      colnames(res1)<-"p.value"
      }else{
        
        colnames(res1)<-paste("p.adjusted (",p.adjust.method,")",sep="")
      }
      
    }else{
      
      if(pval.reporting.method=="wilcox.test"){
        
        factor1_levels1<-levels(factor(temp_df$Factor1,levels=unique(temp_df$Factor1)))
        factor2_levels1<-levels(factor(temp_df$Factor2,levels=unique(temp_df$Factor2)))
        
        #within day comparisons
        res1<-lapply(1:length(factor2_levels1),function(i){
          
          temp_df1<-temp_df[which(temp_df$Factor2==factor2_levels1[i]),]
          
          main_res<-pairwise.wilcox.test(x=temp_df1$Response,g=temp_df1$Factor1,p.adjust.method = p.adjust.method)
          
          #pw_res<-dunnTest(temp_df1$Response~temp_df1$Factor1,method="bh")
          
          rnames_vec<-{}
          
          for(j in 1:ncol(main_res$p.value)){
            
            rnames_vec<-c(rnames_vec,paste(colnames(main_res$p.value)[j]," - ",rownames(main_res$p.value),sep=""))
          }
          main_res<-as.vector(round(main_res$p.value,4))
          names(main_res)<-paste("(Day ",factor2_levels1[i],") ",rnames_vec,sep="")
          main_res<-as.data.frame(main_res)
          rownames(main_res)<-paste("(Day ",factor2_levels1[i],") ",rnames_vec,sep="")
          #return(list("mainpvalues"=main_res,"posthoc"={}))
          return(main_res)
        })
        
        res1A<-bind_rows(res1)
        res1A<-na.omit(res1A)
        
        ref_group=temp_df[which(temp_df$Factor2==factor2_levels1[1] & temp_df$Factor1==factor1_levels1[1]),]
        ref_group$Factor1<-paste(ref_group$Factor2,":",ref_group$Factor1,sep="")
        #day1 comparisons
        res1<-lapply(1:length(factor2_levels1),function(i){
          
          temp_df1<-temp_df[which(temp_df$Factor2==factor2_levels1[i]),]
          
          temp_df1<-rbind(ref_group,temp_df1)
         # temp_df1$Factor1<-levels(factor(temp_df1$Factor1,levels=unique(temp_df1$Factor1)))
          
          main_res<-pairwise.wilcox.test(x=temp_df1$Response,g=temp_df1$Factor1,p.adjust.method = p.adjust.method)
          
          #pw_res<-dunnTest(temp_df1$Response~temp_df1$Factor1,method="bh")
          
          rnames_vec<-{}

          #for(j in 1:ncol(main_res$p.value)){
            
            rnames_vec<-paste("(Day ", colnames(main_res$p.value)[1],") - (Day ",factor2_levels1[i],") ",rownames(main_res$p.value),sep="")
          #}
          main_res<-as.vector(round(main_res$p.value[,1],4))
                #names(main_res)<-paste("(Day ",factor2_levels[i],") ",rnames_vec,sep="")
                main_res<-as.data.frame(main_res)
                rownames(main_res)<- rnames_vec #paste("(Day ",factor2_levels[i],") ",rnames_vec,sep="")
         # return(list("mainpvalues"=main_res,"posthoc"={}))
          return(main_res)
        })
        
        res1B<-bind_rows(res1)
        res1B<-na.omit(res1B)
        
        res1<-rbind(res1A,res1B)
        
        if(p.adjust.method=="none"){
          colnames(res1)<-"p.value"
        }else{
          
          colnames(res1)<-paste("p.adjusted (",p.adjust.method,")",sep="")
        }
      }else{
        
        
        if(pval.reporting.method=="t.test"){
          
          factor1_levels1<-levels(factor(temp_df$Factor1,levels=unique(temp_df$Factor1)))
          factor2_levels1<-levels(factor(temp_df$Factor2,levels=unique(temp_df$Factor2)))
          
          #within day comparisons
          #pool.sd.bool
          res1<-lapply(1:length(factor2_levels1),function(i){
            
            temp_df1<-temp_df[which(temp_df$Factor2==factor2_levels1[i]),]
            temp_df1$Response<-as.numeric(as.character(temp_df1$Response))
            main_res<-pairwise.t.test(x=temp_df1$Response,g=temp_df1$Factor1,p.adjust.method = p.adjust.method,pool.sd=pool.sd.bool,var.equal = var.equal.bool)
            
         
            
            rnames_vec<-{}
            
            for(j in 1:ncol(main_res$p.value)){
              
              rnames_vec<-c(rnames_vec,paste(colnames(main_res$p.value)[j]," - ",rownames(main_res$p.value),sep=""))
            }
            main_res<-as.vector(round(main_res$p.value,4))
            names(main_res)<-paste("(Day ",factor2_levels1[i],") ",rnames_vec,sep="")
            main_res<-as.data.frame(main_res)
            rownames(main_res)<-paste("(Day ",factor2_levels1[i],") ",rnames_vec,sep="")
            #return(list("mainpvalues"=main_res,"posthoc"={}))
            return(main_res)
          })
          
          res1A<-bind_rows(res1)
          res1A<-na.omit(res1A)
          
          ref_group=temp_df[which(temp_df$Factor2==factor2_levels1[1] & temp_df$Factor1==factor1_levels1[1]),]
          ref_group$Factor1<-paste(ref_group$Factor2,":",ref_group$Factor1,sep="")
          #reference group comparisons
          res1<-lapply(1:length(factor2_levels1),function(i){
            
            temp_df1<-temp_df[which(temp_df$Factor2==factor2_levels1[i]),]
            
            temp_df1<-rbind(ref_group,temp_df1)
            # temp_df1$Factor1<-levels(factor(temp_df1$Factor1,levels=unique(temp_df1$Factor1)))
            
            main_res<-pairwise.t.test(x=temp_df1$Response,g=temp_df1$Factor1,p.adjust.method = p.adjust.method,pool.sd=pool.sd.bool,var.equal = var.equal.bool)
            
            #pw_res<-dunnTest(temp_df1$Response~temp_df1$Factor1,method="bh")
            
            rnames_vec<-{}
            
            #for(j in 1:ncol(main_res$p.value)){
            
            rnames_vec<-paste("(Day ", colnames(main_res$p.value)[1],") - (Day ",factor2_levels1[i],") ",rownames(main_res$p.value),sep="")
            #}
            main_res<-as.vector(round(main_res$p.value[,1],4))
            #names(main_res)<-paste("(Day ",factor2_levels[i],") ",rnames_vec,sep="")
            main_res<-as.data.frame(main_res)
            rownames(main_res)<- rnames_vec #paste("(Day ",factor2_levels[i],") ",rnames_vec,sep="")
            # return(list("mainpvalues"=main_res,"posthoc"={}))
            return(main_res)
          })
          
          res1B<-bind_rows(res1)
          res1B<-na.omit(res1B)
          
          res1<-rbind(res1A,res1B)
          
          if(p.adjust.method=="none"){
            colnames(res1)<-"p.value"
          }else{
            
            colnames(res1)<-paste("p.adjusted (",p.adjust.method,")",sep="")
          }
        }else{
          
          
          if(pval.reporting.method=="onewayanova"){
            res1<-diffexponewayanova(temp_df)
            
            
            posthoc_comp<-t(res1$posthoc)
            
            print(comparison_list)
            
            posthoc_comp<-posthoc_comp[which(rownames(posthoc_comp)%in%unique(comparison_list)),]
        
            
            final_res<-c(t(res1$mainpvalues),posthoc_comp)
          }
        }
      }
    }
    
  }
  
  if(pval.reporting.method=="twowayanova"){
  posthoc_comp<-t(res1$posthoc)
  
  print(comparison_list)
  
  posthoc_comp<-posthoc_comp[which(rownames(posthoc_comp)%in%unique(comparison_list)),]
  #View(unique(comparison_list))
  
  #View(posthoc_comp)
  
  save(temp_df,file="temp_df.Rda")
  
  final_res<-c(t(res1$mainpvalues),posthoc_comp)
  }else{
    final_res<-res1 #t(res1$mainpvalues)
  }
  final_res<-as.data.frame(t(final_res))
  final_res<-t(final_res)
  rnames1<-rownames(final_res)
  
  if(pval.reporting.method=="twowayanova"){
    rnames1[1:3]<-names(res1$mainpvalues)
  }
  
  rownames(final_res)<-rnames1
  colnames(final_res)<-"p.value"
  #rownames(final_res)<-c(names(res1$mainpvalues),rownames(posthoc_comp))
  return(final_res)
 # stat_table1B<-as.data.frame(stat_table1B)
  
  
}

get_boxplots_child<-function(X,Y,feature_table_file,parentoutput_dir,class_labels_file,
                             boxplot.col.opt="journal",alphacol=0.3,newdevice=TRUE,cex.plots=0.4,replace.by.NA=FALSE,
                             pairedanalysis=FALSE,filename="",ylabel="Intensity",xlabel=NA,
                             alphabetical.order=FALSE,name=NA,add.jitter=TRUE,add.pvalues=TRUE,
                             class.levels=NA,fill.plots=FALSE,connectpairedsamples=FALSE,
                             boxplot.type="ggplot",
                             study.design=c("multiclass","onewayanova","twowayanova","onewayanovarepeat",
                                                                  "twowayanovarepeat"),
                             multiple.figures.perpanel=TRUE,
                             ggplot.type1=TRUE,replace.outliers=FALSE,plot.height=8,plot.width=8,
                             extra_text=NA,group_by_mat=NA,position_dodge_width=0.75,
                             numnodes=2,hightlight.points=FALSE,ref.group.val=FALSE,facet.nrow=NULL,facet.ncol=NULL,
                             ylim.val=NA,remove.xaxis.labels=FALSE,boxplot.lwd=1,axis.ticks.size=1.5,
                             axis.line.size=2,jitter.size=2,boxplot.strip.position = "top",legend.all.pages=TRUE,
                             pval.reporting.method="anova",
                             replace.by.median=FALSE,pval.table.report=FALSE,
                             subset.factor1=NA,subset.factor2=NA,asterisk.size=6,posthoc.multcomp.test="bonferroni",...)
{
  options(warn=-1)
  analysistype=study.design[1]
  
  paireddesign=NA
  
  if(boxplot.type=="ggplot"){
    suppressMessages(library(ggplot2))
  }else{
    suppressMessages(library(ggpubr))
  }
  
 # multiple.figures.perpanel=TRUE
  
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }else{
    X<-as.data.frame(X)
    
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
  }else{
    Y<-as.data.frame((Y))
    classlabels<-Y
  }
  rm(X)
  rm(Y)
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  names_with_mz_time<-{}
  
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
 
  if(length(check_names)>0){
    
    #Name is present
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame(data_matrix)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }else{
      
      names_with_mz_time<-cbind(paste(data_matrix$mz,data_matrix$time,sep="_"),data_matrix$mz,data_matrix$time)
    }
  }
  
  
  

  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  mzvec<-data_matrix[,1]
  timevec<-data_matrix[,2]
  goodfeats<-data_m			
  rm(data_m)
  
  #library(extrafont)
  #loadfonts()
  
  multiple.groups=FALSE
  
  #c("multiclass","onewayanova","twowayanova","onewayanovarepeat","twowayanovarepeat")
  
  if(study.design=="onewayanovarepeat" | study.design=="twowayanovarepeat" | study.design=="twowayrepeat" | study.design=="onewayrepeat"){
    
    pairedanalysis=TRUE
  }
  
 # print(head(classlabels))
  
  if(pairedanalysis==TRUE){
    
    print("Using column 2 as subject identifiers")
    paireddesign=classlabels[,c(1,2)]
    
    classlabels<-classlabels[,-c(2)]
  }
  
  pairedanalysis=FALSE
  paireddesign=NA
  
  
  if(dim(classlabels)[2]>2){
    
    
    if(study.design=="twowayanova" | study.design=="twowayanovarepeat" | study.design=="twoway" | study.design=="twowayrepeat"){
      # print("More than two columns found in the class labels file. ")
      
      
      if(alphabetical.order==FALSE){
        classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
        
        classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
      }
      
      Class<-paste(classlabels[,2],":",classlabels[,3],sep="") #classlabels[,2]:classlabels[,3]
      
      multiple.groups=TRUE
      
    }else{
      
      if(study.design=="onewayanova" | study.design=="onewayanovarepeat" | study.design=="oneway"){
        #     print("More than two columns found in the class labels file. ")
        
        if(alphabetical.order==FALSE){
          classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
          
          
        }
        
        Class<-classlabels[,2] #classlabels[,2]:classlabels[,3]
        
        
      }else{
        
        if(alphabetical.order==FALSE){
          classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
          
          
        }
        Class<-classlabels[,2]
        
      }
      
    }
    
  }else{
    if(alphabetical.order==FALSE){
      classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
      
    }
    Class<-classlabels[,2]
  }
  
  
 # par(mfrow=c(2,2),family="sans",cex=cex.plots)
  
  if(alphabetical.order==FALSE){
    Class <- factor(Class, levels=unique(Class))
  }
#  save(Class,classlabels,file="Class.Rda")
  
  class_levels<-levels(as.factor(Class))
  
  class_labels_levels<-levels(as.factor(Class))
  ordered_labels<-Class
  
  class_label_alphabets<-paste("C",1:length(class_labels_levels),sep="") #c("A","B","C","D","E","F","G","H","I","J","K","L","M")
  
  if(is.na(boxplot.col.opt)==TRUE){
    
    col_vec<-rep(c("white"),length(class_labels_levels))
    boxplot.col.opt<-col_vec
  }
  
  #save(boxplot.col.opt,class_labels_levels,file="coldebug.Rda")
  
  if(boxplot.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{ 
    if(boxplot.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels)) 
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(boxplot.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(boxplot.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(boxplot.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(boxplot.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #   col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=boxplot.col.opt[1])
              
              if(length(check_brewer)>0){
                
                boxplot.col.opt=gsub(x=boxplot.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, boxplot.col.opt))(length(class_labels_levels))
                
              }else{
                
                if(boxplot.col.opt=="journal"){
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                  
                  
                }else{
                  #col_vec <-boxplot.col.opt
                  #col_vec <- rep(col_vec,length(class_labels_levels))
                  
                 
                  
                  if(length(boxplot.col.opt)==1){
                    
                    col_vec <-rep(boxplot.col.opt,length(class_labels_levels))
                    
                  }else{
                    
                    #length(boxplot.col.opt)>=length(class_labels_levels)
                    
                    #if(length(boxplot.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-boxplot.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                      
                      
                    #}else{
                     # colfunc <-colorRampPalette(boxplot.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    #}
                    
                  }
                  
                }
                
              }
              
            }
          }
          
          
        }
        
      }
      
    }	
  }
  
  
  
  ordered_labels={}
  num_samps_group<-new("list")
  num_samps_group[[1]]<-0
  groupwiseindex<-new("list")
  groupwiseindex[[1]]<-0
  
  
  for(c in 1:length(class_labels_levels))
  {
    
    classlabels_index<-which(Class==class_labels_levels[c])
    #ordered_labels<-c(ordered_labels,as.character(classlabels[classlabels_index,2]))
    num_samps_group[[c]]<-length(classlabels_index)
    groupwiseindex[[c]]<-classlabels_index
  }
  
  sampleclass<-{}
  patientcolors<-{}
  
  if(length(mzvec)>4){
    max_per_row<-3
    
    
    par_rows<-ceiling(9/max_per_row)
    
  }else{
    max_per_row<-length(mzvec)
    par_rows<-1
  }
  
  
  #name=goodfeats_name,
  #class_labels_levels<-paste("x",seq(1,length(class_labels_levels)),sep="")
  
  file_ind<-0
  boxplots_fname<-paste(filename,".pdf",sep="")
  #tiff(boxplots_fname, width=plots.width,height=plots.height,res=plots.res, compression="lzw")
  
  #tiff(boxplots_fname, width=2000,height=3000,res=plots.res, compression="lzw")
  
  if(newdevice==TRUE){ # & boxplot.type=="simple"){
    pdf(boxplots_fname) #,width=plot.width,height=plot.height)
  }
  #par(mfrow=c(par_rows,max_per_row))
  ###save(goodfeats,class_labels_levels,file="debug1.Rda")
  
  
  #plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
  
  
  # text(5,9,"Description:",font=2,col="blue")
  
  #text(5, 8, "This PDF includes boxplots of individual variables for each group.\n The box represents the interquartile range,
   #    the whiskers represent the 1.5 +/- IQR range,\n and the bold horizontal line represents the median.
    #   \n\n\n Note: The panels are grouped by factor 1 (e.g. group)\n or factor 2 (e.g. timepoint).",cex=1.5,font=2)
  
    # text(5, 7, "The figures include: ")
  if(is.na(extra_text)==FALSE){
    
    #plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
    
    
    # text(5,9,"Description:",font=2,col="blue")
    
    #text(5, 8, extra_text,cex=1.5,font=2)
    #text(extra_text)
  }
  
  temp_dm<-cbind(as.character(Class),(t(goodfeats)))
  temp_dm<-as.data.frame(temp_dm)
  colnames(temp_dm)<-c("Class",rownames(goodfeats))
  
  #keeps the class order same as in the input file; avoids arrangement by alphabetical order
  if(alphabetical.order==FALSE){
    temp_dm$Class <- factor(temp_dm$Class, levels=unique(temp_dm$Class))
    class_levels<-levels(as.factor(temp_dm$Class))
  }else{
    
    class_levels<-levels(as.factor(temp_dm$Class))
  }
  
  if(is.na(class.levels)==FALSE){
    
    match_test<-match(class.levels,levels(as.factor(temp_dm$Class)))
    if(length(which(is.na(match_test)==TRUE))<1){
      
      if(alphabetical.order==FALSE){
        temp_dm$Class <- factor(temp_dm$Class, levels=unique(class.levels))
      }
    }else{
      stop(paste("User defined class.levels ", paste(class.levels,sep=" ",collapse=""), " do not match the levels in the class labels matrix, ",paste(class_levels,sep=" ",collapse=""),sep=""))    
    }
  }
  
  #par(mfrow=c(1,1),family="sans",cex=cex.plots)
  theme_set(theme_gray(base_size = 25, base_family = 'sans' ))
  
  if(boxplot.type=="simple"){
    
    #lapply(1:dim(goodfeats)[1],function(m)
    for(m in 1:dim(goodfeats)[1])
    {
      
      if(m%%9==0){
        
        file_ind<-file_ind+1
        boxplots_fname<-paste("boxplots_file",file_ind,".tiff",sep="")
        
      }
      
      round_mzval<-mzvec[m] #sprintf("%.4f",mzvec[m])
      
      round_timeval<-timevec[m] #sprintf("%.1f",timevec[m])
      
      if(is.na(name[1])==TRUE){
        
        if(length(check_names)>0){
          if(check_names==1){
            
            mzname<-as.character(names_with_mz_time[m,1])
          }else{
            
            mzname<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
          }
          
        }else{
          
          mzname<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
        }
      }else{
        
        mzname=as.character(name[m])
      }
      
      t1<-table(sampleclass)
      cur_d<-new("list")
      feat_vec<-{}
      class_vec<-{}
      
      for(c in 1:length(class_labels_levels))
      {
        num_samps_group[[1]]<-t1[1]
        cvec<-as.vector(t(goodfeats[m,c(groupwiseindex[[c]])]))
        
        if(replace.outliers==TRUE){
           cvec<-replace_outliers(cvec,replace.by.NA,replace.by.median=replace.by.median)
        }
        cur_d[[c]]<-cvec
        feat_vec<-c(feat_vec,cvec)
        class_vec<-c(class_vec,rep(class_labels_levels[c],length(which(Class==class_labels_levels[c]))))
        
      }
      
      #w <- 0.1
      #        par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
      
      #save(cur_d,class_labels_levels,goodfeats,groupwiseindex,file="cur_d.Rda")
      
      boxplot(cur_d,ylab=ylabel,main=mzname,xaxt="n",cex.main=0.7,col="white") #,ylim=range(pretty(c(0,max_yval))))
      
      for(i in 1:length(class_labels_levels)){
        axis(side=1,at=c(i),labels=class_labels_levels[i], col=col_vec[i],cex.axis=cex.plots,srt=90)
        
        
      }
      
      # (legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec[1:length(class_labels_levels)],pch = rep(19,length(col_vec[1:length(class_labels_levels)])), pt.cex = 0.6, title = "Class",cex=0.8))
      
    }
    #})
    
  }else{
    
    cl<-parallel::makeCluster(getOption("cl.cores", numnodes))
    clusterEvalQ(cl,library(ggplot2))
    clusterEvalQ(cl,library(rstatix))
    clusterEvalQ(cl,library(dplyr))
    clusterEvalQ(cl,library(gridExtra))
    clusterExport(cl,"replace_outliers")
    clusterExport(cl,"get_pval_boxplots")
    

    
    clusterExport(cl,"diffexplmtwowayanova")
    
  #  plot_res<-lapply(1:dim(goodfeats)[1],function(m,mzvec,timevec,check_names,name,class_labels_levels,sampleclass,col_vec,goodfeats,pairedanalysis,connectpairedsamples,boxplot.type,
   #                                                                                       ggplot.type1,group_by_mat,cex.plots,boxplot.col.opt,add.jitter,add.pvalues,fill.plots,multiple.figures.perpanel,ylim.val,pval.reporting.method)
                                                  
    plot_res<-parLapply(cl,1:dim(goodfeats)[1],function(m,mzvec,timevec,check_names,name,class_labels_levels,sampleclass,col_vec,goodfeats,pairedanalysis,connectpairedsamples,boxplot.type,
                                                       ggplot.type1,group_by_mat,cex.plots,boxplot.col.opt,add.jitter,add.pvalues,fill.plots,multiple.figures.perpanel,ylim.val,
                                                      pval.reporting.method,ref.group.val,subset.factor1,subset.factor2,asterisk.size,posthoc.multcomp.test)
      
    #  plot_res<-lapply(1:dim(goodfeats)[1],function(m,mzvec,timevec,check_names,name,class_labels_levels,sampleclass,col_vec,goodfeats,pairedanalysis,connectpairedsamples,boxplot.type,
     #                                                     ggplot.type1,group_by_mat,cex.plots,boxplot.col.opt,add.jitter,add.pvalues,fill.plots,multiple.figures.perpanel,ylim.val,
      #                                                    pval.reporting.method,ref.group.val,subset.factor1,subset.factor2,asterisk.size,posthoc.multcomp.test)
    {
      pval_res={}
      
      print(class_labels_levels)
      
      if(m%%9==0){
        
        file_ind<-file_ind+1
        boxplots_fname<-paste("boxplots_file",file_ind,".tiff",sep="")
        
      }
      
     round_mzval<-mzvec[m] #sprintf("%.4f",mzvec[m])
      
     round_timeval<-timevec[m] #sprintf("%.1f",timevec[m])
      
      if(is.na(name[1])==TRUE){            
        
        if(length(check_names)>0){	
          if(check_names==1){
            
            mzname<-as.character(names_with_mz_time[m,1])
          }else{  
            
            mzname<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
          }
          
        }else{
          
          mzname<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
        }
      }else{
        
        mzname=as.character(name[m])
      }
     
   #  save(class_labels_levels,goodfeats,groupwiseindex,file="test2.Rda")
     
      if(length(class_labels_levels)>=2)
      {
        if(length(class_labels_levels)>=1)
        {
          t1<-table(sampleclass)
          cur_d<-new("list")
          feat_vec<-{}
          class_vec<-{}
          sid_vec<-{}
          
         # print("DOING THIS2!!!")
          fname1<-paste(m,".Rda",sep="")
       # save(goodfeats,m,class_labels_levels,groupwiseindex,t1,num_samps_group,file=fname1)
           for(c in 1:length(class_labels_levels))
          {
            num_samps_group[[1]]<-t1[1]
            cvec<-as.vector(t(goodfeats[m,c(groupwiseindex[[c]])]))
            if(replace.outliers==TRUE){
              cvec<-as.numeric(as.character(cvec))
            cvec<-replace_outliers(cvec,replace.by.NA,replace.by.median=replace.by.median)
            }
            cur_d[[c]]<-cvec
            feat_vec<-c(feat_vec,cvec)
            class_vec<-c(class_vec,rep(class_labels_levels[c],length(which(Class==class_labels_levels[c]))))
            sid_vec<-c(sid_vec,names((goodfeats[m,c(groupwiseindex[[c]])])))  
          }
          
          
          temp_dm<-cbind(as.character(sid_vec),as.character(class_vec),as.vector(feat_vec))
          
          temp_dm2<-temp_dm #[,c(1,(m+1))]
          temp_dm2<-as.data.frame(temp_dm2)
          colnames(temp_dm2)<-c("SID","Class","Feature")
          temp_dm2$Feature<-as.numeric(as.character(temp_dm2$Feature))
          
          sum_yval1=summary(temp_dm2$Feature,na.rm=TRUE)
          max_yval1=max(temp_dm2$Feature,na.rm=TRUE)+(sum_yval1[5]-sum_yval1[2])
          
          if(alphabetical.order==FALSE){
            temp_dm2$Class <- factor(temp_dm2$Class, levels=unique(temp_dm2$Class))
          }
          
          fname1<-paste("temp_dm2",mzname,"A1.Rda")
          
         #save(temp_dm2,group_by_mat,file="temp_dm2.Rda")
       #   save(Class,class.levels,temp_dm2,alphabetical.order,file=fname1)
          Class<-temp_dm2
          
          if(is.na(class.levels)==FALSE){
            
            match_test<-match(class.levels,levels(as.factor(temp_dm2$Class)))
            if(length(which(is.na(match_test)==TRUE))<1){
              
              if(alphabetical.order==FALSE){
                temp_dm2$Class <- factor(temp_dm2$Class, levels=unique(class.levels))
              }
            }else{
              stop(paste("User defined class.levels ", paste(class.levels,sep=" ",collapse=""), " do not match the levels in the class labels matrix, ",paste(class_levels,sep=" ",collapse=""),sep=""))
            }
          }
          
          
          if(multiple.groups==TRUE){
            Factor1<-gsub(temp_dm2$Class,pattern=":([\\w|\\W])*",replacement="",perl=TRUE)
            Factor2<-gsub(temp_dm2$Class,pattern="([\\w|\\W])*:",replacement="",perl=TRUE)
            
       
            fname1<-paste("temp_dm2",mzname,"A.Rda")
            #save(Class,Factor1,Factor2,temp_dm2,file=fname1)
            temp_dm2<-cbind(temp_dm2,Factor1,Factor2)
            
            temp_dm2<-as.data.frame(temp_dm2)
            
            if(alphabetical.order==FALSE){
              temp_dm2$Factor1 <- factor(temp_dm2$Factor1, levels=unique(Factor1))
              
              temp_dm2$Factor2 <- factor(temp_dm2$Factor2, levels=unique(Factor2))
            }
            
          }
         #save(temp_dm2,group_by_mat,file="d1.Rda")
          if(is.na(group_by_mat)==FALSE){
          
            colnames(group_by_mat)<-c("SID","GroupBy")
            
              save(temp_dm2,group_by_mat,file="d1.Rda")
             temp_dm2<-merge(temp_dm2,group_by_mat,by="SID")
          }
          
          if(pairedanalysis==TRUE && connectpairedsamples==TRUE){
            
            
            colnames(paireddesign)<-c("SID","SubjectID")
            temp_dm2<-merge(temp_dm2,paireddesign,by="SID")
          }
          
          
          
          #  par(mfrow=c(2,2),family="sans",cex=cex.plots)
          
          w <- 0.1
          par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
          
          #    print(cex)
          #save(temp_dm2,cur_d,mzname,boxplot.col.opt,col_vec,ylabel,Class,goodfeats,class_labels_levels,cex.plots,boxplot.type,multiple.groups,add.jitter,add.pvalues,fill.plots,file="temp_dm2.Rda")
          
          if(boxplot.type=="simple"){
            
            
            boxplot(cur_d,ylab=ylabel,main=mzname,xaxt="n",cex.main=0.7,col="white") #,ylim=range(pretty(c(0,max_yval))))
            
            for(i in 1:length(class_labels_levels)){
              axis(side=1,at=c(i),labels=class_labels_levels[i], col=col_vec[i],cex.axis=cex.plots,srt=45)
              
              
            }
            
            (legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec[1:length(class_labels_levels)],pch = rep(19,length(col_vec[1:length(class_labels_levels)])), pt.cex = 0.6, title = "Class",cex=0.8))
            
            
            #boxplot(cur_d)
          }else{
            
           # facet.nrow=1
            
            fname1<-paste("temp_dm2",mzname,".Rda")
        
            if(pairedanalysis==TRUE && connectpairedsamples==TRUE){    
                if(is.na(paireddesign)==FALSE){
                  
                  temp_dm2$SubjectID=as.numeric(as.factor(temp_dm2$SubjectID))
                }
            }
           #fname1<-paste()
           #save(temp_dm2,file="temp_dm2.Rda")
           
           if(is.na(subset.factor1)==FALSE){
             
             temp_dm2<-subset(temp_dm2,Factor1%in%c(subset.factor1))
           }
           
           if(is.na(subset.factor2)==FALSE){
             
             temp_dm2<-subset(temp_dm2,Factor2%in%c(subset.factor2))
           }
           
           
            #if(add.pvalues==FALSE && fill.plots==TRUE){
            if(TRUE){
              suppressMessages(library(ggplot2))
              
              
              if(multiple.groups==FALSE){
                #p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Class,fill=Class)) + labs(title=mzname)
                
                if(is.na(group_by_mat)==FALSE){
                  #if(ggplot.type1==TRUE){
                  p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Class,fill=Class)) +labs(title=mzname) + facet_wrap(~GroupBy, scale="free_x",nrow=facet.nrow,ncol=facet.ncol)  
                    
                  #}
                }else{
                  p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Class,fill=Class)) + labs(title=mzname)
                  
                }
                
        
                }else{
                            
                          if(is.na(group_by_mat)==TRUE){
                            #p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=Factor2)) + labs(title=mzname) + facet_wrap(~Factor2, scale="free")  
                           
                          if(is.na(ggplot.type1)==FALSE){
                           if(ggplot.type1==TRUE){
                             
                             #print("DOing this")
                             
                          #  save(temp_dm2,mzname,facet.nrow,facet.ncol,file="debugbox.Rda")
                          
                              p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=Factor1)) +labs(title=mzname) + facet_wrap(~Factor2, scale="free_x",nrow=facet.nrow,ncol=facet.ncol,strip.position = boxplot.strip.position)  
                            }else{
                              
                              p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor2,fill=Factor2)) +labs(title=mzname) + facet_wrap(~Factor1, scale="free_x",nrow=facet.nrow,ncol=facet.ncol,strip.position = boxplot.strip.position)  
                              
                              
                            }
                          }else{
                            p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=Factor2)) +labs(title=mzname)
                          }
                            
                          }else{
                          #  save(temp_dm2,mzname,facet.nrow,facet.ncol,group_by_mat,file="debugbox.Rda")
                              if(is.na(ggplot.type1)==FALSE){
                              if(ggplot.type1==TRUE){
                                #fill=factor(GroupBy)#aes(color=factor(GroupBy)) geom_point(aes(group=SubjectID))+geom_line(aes(group=SubjectID))+
                              
                                #change: 1052022
                              #  p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=GroupBy)) +labs(title=mzname) + facet_wrap(~Factor2, scale="free_x",nrow=facet.nrow,ncol=facet.ncol)  
                              
                                
                                  p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=Factor1)) +labs(title=mzname) + facet_grid(GroupBy~Factor2, scale="free",switch="x") #,nrow=facet.nrow,ncol=facet.ncol)  
                                
                              }else{
                                 
                                p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor2,fill=GroupBy)) +labs(title=mzname) + facet_wrap(~Factor1, scale="free_x",nrow=facet.nrow,ncol=facet.ncol)  
                                
                              }
                              }else{
                                
                                p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=GroupBy)) +labs(title=mzname)
                              }
                            
                         }
                
                
                }
            
            if(is.na(boxplot.col.opt)==FALSE){
              
              p=p+stat_boxplot(geom='errorbar',width=0.15)
              
              if(boxplot.col.opt=="white"){
                p<-p + geom_boxplot(lwd=boxplot.lwd)
              }else{
                geom_col_vec=(col_vec[1:length(class_labels_levels)])
                
                p<-p + geom_boxplot(alpha=alphacol,lwd=boxplot.lwd) #,colour=geom_col_vec) #outlier.shape=NA,
                
              }
            }
              
              
           fname_c<-paste("d2",m,".Rda",sep="")
           #save(p,temp_dm2,file=fname_c)
              
              if(pairedanalysis==TRUE)
                {
                
                if(connectpairedsamples==TRUE){
                  
                  if(is.na(ggplot.type1)==FALSE){
                    if(ggplot.type1==TRUE){
                    p=p+geom_line(aes(Factor1, as.numeric(Feature),fill=factor(GroupBy),group=SubjectID),
                              position = position_dodge2(position_dodge_width))
                    }else{
                      p=p+geom_line(aes(Factor2, as.numeric(Feature),fill=factor(GroupBy),group=SubjectID),
                                    position = position_dodge2(position_dodge_width))
                      
                    }
                  }else{
                    p=p+geom_line(aes(Factor1, as.numeric(Feature),fill=factor(GroupBy),group=SubjectID),
                                  position = position_dodge2(position_dodge_width))
                    
                  }
                }
        
        #         p<-p+geom_line(aes(y  = as.numeric(Feature), x = Factor1)) #, group = SubjectID))
                  
                       if(add.jitter==TRUE){
                         
                         #p<-p+geom_jitter(aes(colour=factor(GroupBy)))
                         #position = position_jitterdodge(),
                        if(is.na(ggplot.type1)==FALSE){
                               if(ggplot.type1==TRUE){
                                          p=p+ geom_point(aes(Factor1, as.numeric(Feature),fill=GroupBy),
                                          shape=21, #factor(gsub(temp_dm2$SID,pattern="[a-z|A-Z|0-9]*_",replacement="")),
                                          position = position_dodge(position_dodge_width))
                               }else{
                                           p=p+ geom_point(aes(Factor2, as.numeric(Feature),fill=GroupBy),
                                                 shape=21, #factor(gsub(temp_dm2$SID,pattern="[a-z|A-Z|0-9]*_",replacement="")),
                                                 position = position_dodge(position_dodge_width))
                                 
                               }
                        }else{
                          p=p+ geom_point(aes(Factor1, as.numeric(Feature),fill=GroupBy),
                                          shape=21, #factor(gsub(temp_dm2$SID,pattern="[a-z|A-Z|0-9]*_",replacement="")),
                                          position = position_dodge(position_dodge_width))
                          
                        }
                         
                         if(highlight.points==TRUE){
                           #p=p+geom_point(data=subset(df.2, highlight),aes(x=variable, y=value), color="red", size=5)
                         }
                    
                      }
                #  p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=Factor1)) +
              }
              else
                {
                  
                 # print("DOING THIS")
              if(add.jitter==TRUE){
                
                if(multiple.groups==FALSE){
                  
                      p=p+ geom_point(aes(Class, as.numeric(Feature),fill=Class),
                                      shape=21, #factor(gsub(temp_dm2$SID,pattern="[a-z|A-Z|0-9]*_",replacement="")),
                                      position = position_dodge(position_dodge_width),size=jitter.size)
                }else{
                #p<-p+geom_jitter()
                if(is.na(ggplot.type1)==FALSE){
                      if(ggplot.type1==TRUE){
                        p=p+ geom_point(aes(Factor1, as.numeric(Feature),fill=Factor1),
                                        shape=21, #factor(gsub(temp_dm2$SID,pattern="[a-z|A-Z|0-9]*_",replacement="")),
                                        position = position_dodge(position_dodge_width),size=jitter.size)
                      }else{
                        p=p+ geom_point(aes(Factor2, as.numeric(Feature),fill=Factor2),
                                        shape=21, #factor(gsub(temp_dm2$SID,pattern="[a-z|A-Z|0-9]*_",replacement="")),
                                        position = position_dodge(position_dodge_width),size=jitter.size)
                        
                      }
                }else{
                  p=p+ geom_point(aes(Factor1, as.numeric(Feature),fill=Factor1),
                                  shape=21, #factor(gsub(temp_dm2$SID,pattern="[a-z|A-Z|0-9]*_",replacement="")),
                                  position = position_dodge(position_dodge_width),size=jitter.size)
                  
                }
                
                }
              }
              
                }
              
              
              if(add.pvalues==TRUE){
                
                fname_pval<-paste(mzname,"pval.Rda",sep="")
               # save(temp_dm2,file=fname_pval)
                
                suppressMessages(library(ggpubr))
                var.equal.bool=TRUE
                pool.sd.bool=FALSE
                if(pval.reporting.method=="Student.t.test"){
                  
                  var.equal.bool=TRUE
                  pool.sd.bool=FALSE
                  pval.reporting.method="t.test"
                }else{
                  
                  if(pval.reporting.method=="Welch.t.test"){
                    
                    var.equal.bool=FALSE
                    pool.sd.bool=FALSE
                    pval.reporting.method="t.test"
                  }else{
                    
                    
                    if(pval.reporting.method=="t.test"){
                      
                      var.equal.bool=FALSE
                      pool.sd.bool=FALSE
                      pval.reporting.method="t.test"
                    }
                  }
                }
              
               # max_yval1=max_yval1*0.5
                if(multiple.groups==FALSE){
                  p<-p + stat_compare_means(data=temp_dm2,aes(group = Class),size = 5*cex.plots,label = "p.format",
                                            label.x = 0.5, label.y = max_yval1,size = 5*cex.plots,method=pval.reporting.method)
                }else{
                  
                
                 
                  if(pairedanalysis==FALSE){
                    
                  # save(temp_dm2,p,var.equal.bool,pool.sd.bool,ref.group=ref.group.val,file="temp_dm2_file.Rda")
                    pval_res<-try(get_pval_boxplots(temp_dm2,pval.reporting.method = pval.reporting.method,ref.group=ref.group.val,pool.sd.bool=pool.sd.bool,
                                                    var.equal.bool=var.equal.bool,p.adjust.method = posthoc.multcomp.test),silent=TRUE)
                    
                    #,p.adjust.method = posthoc.multcomp.test
                    
                    if(is(pval_res,"try-error"))
                    {
                      pval_res<-NA
                          
                    }
                    
                    print("done")
                   
                    #label = "p.format",
                    if(ggplot.type1==TRUE){
                      
                      if(is.na(ref.group.val)==TRUE){
                        ref.group.val<-unique(temp_dm2$Factor1)[1] 
                      }else{
                        if(ref.group.val==FALSE){
                          
                          p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),label = "p.format",
                                                    size = 4*cex.plots,method=pval.reporting.method)
                        }else{
                          
                          if(pval.reporting.method=="wilcox.test"){
                          p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),label = "p.signif",
                                                    size = asterisk.size*cex.plots,ref.group = ref.group.val,hide.ns=T,method="wilcox.test",
                                                    method.args=list("paired"=FALSE))
                          
                          #stat_compare_means(label = "p.signif", method = "wilcox.test", paired = F, hide.ns = T, show.legend = F, size = 8, label.y = 0.7)
                          
                          
                          }else{
                           # p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),label = "p.format",
                            #                          size = 2*cex.plots,ref.group = ref.group.val)
                            if(pval.reporting.method=="kruskal.test"){
                              p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),
                                                       size = asterisk.size*cex.plots,hide.ns=T,method="kruskal.test",label = "p.signif")
                        
                              
                            }else{
                              
                              if(pval.reporting.method=="t.test"){
                               
                                p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),
                                                          size = asterisk.size*cex.plots,ref.group = ref.group.val,hide.ns=T,method="t.test",label = "p.signif",
                                                          method.args=list("var.equal"=var.equal.bool,"paired"=FALSE))
                                
                                
                              }
                              
                            }
                            
                            
                          }
                        }
                      }
                    }else{
                      if(is.na(ref.group.val)==TRUE){
                        ref.group.val<-unique(temp_dm2$Factor2)[1] 
                      }else{
                        if(ref.group.val==FALSE){
                          
                          p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),label = "p.format",
                                                    size = 5*cex.plots,method=pval.reporting.method)
                        }else{
                          p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),label = "p.format",
                                                    size = 5*cex.plots,ref.group = ref.group.val,method=pval.reporting.method)
                        }
                      }
                    p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor2),label = "p.format",
                                              size = 5*cex.plots,ref.group = ref.group.val,method=pval.reporting.method)
                    }
                  }else{
                    
                    if(ggplot.type1==TRUE){
                    p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor1),label = "p.format",
                                              size = 5*cex.plots,method=pval.reporting.method)
                    }else{
                    p<-p + stat_compare_means(data=temp_dm2,aes(group = Factor2),paired=TRUE,label = "p.format",
                                              size = 5*cex.plots,method=pval.reporting.method)
                    }
                  }
                }
              }
            #  p=p+geom_line(aes(group=SubjectID))
             # save(p,ylabel,cex.plots,col_vec,class_labels_levels,file="p.Rda")
              #,margin=margin(30,0,0,0)
              #,margin=margin(0,30,0,0)
              
              if(is.na(group_by_mat)==FALSE){
                
                p<-p+ labs(y=ylabel) + theme_bw() + theme(panel.grid.major = element_blank(),
                  panel.grid.minor = element_blank(),panel.border = element_rect(colour = "black", fill=NA, size=5), panel.spacing=unit(1.25,"lines"),
                  axis.line = element_line(colour = "black",size=1),
                  axis.text= element_text(size=12*cex.plots,family="sans",colour = "black"),
                  axis.title.x=element_text(size=13*cex.plots,face="bold",colour = "black"),
                  axis.title.y=element_text(size=13*cex.plots,face="bold",colour = "black"),
                  plot.title = element_text(hjust = 0.5,size=16*cex.plots),
                  
                  legend.background = element_rect(color = "black", fill = "white"),
                  strip.background=element_rect(colour="white",fill="white"),
                #  strip.text.x = element_text(size = 13*cex.plots, colour = "black"), 
                  #strip.text.y = element_text(size = 13*cex.plots, colour = "black"), 
                strip.text.x = element_text(size = 11*cex.plots, colour = "black"), 
                strip.text.y = element_text(size = 11*cex.plots, colour = "black",angle=0), 
                  strip.text = element_text(face="bold"),strip.placement = "outside") + scale_fill_manual(values=(col_vec[1:length(class_labels_levels)])) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
                
                
              }else{
              p<-p+ labs(y=ylabel) + theme_bw() + theme(panel.border = element_blank(), 
                                                        panel.grid.major = element_blank(),
                                                        panel.grid.minor = element_blank(),
                                                        panel.spacing=unit(1.25,"lines"),
                                                        axis.line = element_line(colour = "black",size=1),
                                                        axis.text= element_text(size=12*cex.plots,family="sans",colour = "black"),
                                                        axis.title.x=element_text(size=13*cex.plots,face="bold",colour = "black"),
                                                        axis.title.y=element_text(size=13*cex.plots,face="bold",colour = "black"),
                                                        plot.title = element_text(hjust = 0.5,size=16*cex.plots),
                                                        
                                                        legend.background = element_rect(color = "black", fill = "white"),
                                                        strip.background=element_rect(colour="white",fill="white"),
                                                        strip.text.x = element_text(size = 11*cex.plots, colour = "black"), 
                                                        strip.text.y = element_text(size = 11*cex.plots, colour = "black",angle=0), 
                                                       strip.text = element_text(face="bold"),strip.placement = "outside") + scale_fill_manual(values=(col_vec[1:length(class_labels_levels)])) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
              }
              p=p + theme(legend.text = element_text(size=10*cex.plots),legend.key.size = unit(3,"line"),legend.background = element_rect(color = NA),legend.title = element_blank()) #+ theme_set(theme_gray(base_size = 20, base_family = 'Font Name' ))
              
        #      
         
              if(remove.xaxis.labels==TRUE){
                
                p=p+theme(axis.text.x=element_blank(),
                      axis.ticks.x=element_blank())
              }
              
              
              p=p+theme(
                axis.ticks = element_line(size = axis.ticks.size, color="black") , 
                axis.ticks.length = unit(.5, "cm"), axis.line = element_line(size = axis.line.size, linetype=1))
              
              if(is.na(xlabel)==FALSE){
               
                  p=p+labs(x=xlabel)
              }
             
             # p=p+theme(axis.text.x = element_text(angle = 45, hjust = 1,margin = margin(t = 20)))
                    
            # p=p+theme(axis.title.x = element_text(vjust=-0.5)) #opts(axis.title.x = theme_text(vjust=-0.5))
              
              p=p+theme(legend.position = "none")
              
              p=p+scale_y_continuous(labels = function(x) format(x, scientific = FALSE))
              
           #   if(facet.placement=="outside"){
           #     p=p+theme(strip.placement = "outside")
                
            #  }
              
              ##addhere
              fname1=paste("boxplot",mzname,".Rda")
             # save(p,col_vec,ylabel,class_labels_levels,cex.plots,file=fname1)
            #  ggpubr::ggexport(p,filename =fname1,width=unit(plot.width-0.5, "in"),
             #                  height=unit(plot.height-0.5, "in"),res=600)
              
            }
            else{
              
              suppressMessages(library(ggpubr))
              #if(boxplot.col.opt=="white" | boxplot.col.opt=="journal")
              {
                
                
                geom_col_vec=(col_vec[1:length(class_labels_levels)])
                
                if(boxplot.col.opt=="white" || length(unique(geom_col_vec))==1){
                  #geom_col_vec<-c("white")
                  
                  geom_col_vec<-NULL
                  
                  
                  if(multiple.groups==FALSE){
                    if(add.jitter==TRUE){
                      p<-ggboxplot(temp_dm2,x="Class",y="Feature",palette=geom_col_vec,add="jitter",title=mzname)
                    }else{
                      p<-ggboxplot(temp_dm2,x="Class",y="Feature",palette=geom_col_vec,title=mzname)
                      
                    }
                  }else{
                    
                    if(pairedanalysis==TRUE && connectpairedsamples==TRUE){
                      
                      if(add.jitter==TRUE){
                        p<-ggpaired(temp_dm2,x="Factor1",y="Feature",palette=geom_col_vec,add="jitter",title=mzname,line.color = "gray", line.size = 0.4)
                      }else{
                        p<-ggpaired(temp_dm2,x="Factor1",y="Feature",palette=geom_col_vec,title=mzname,line.color = "gray", line.size = 0.4)
                        
                      }
                      
                    }else{
                      if(add.jitter==TRUE){
                        p<-ggboxplot(temp_dm2,x="Factor1",y="Feature",palette=geom_col_vec,add="jitter",title=mzname)
                      }else{
                        p<-ggboxplot(temp_dm2,x="Factor1",y="Feature",palette=geom_col_vec,title=mzname)
                        
                      }
                    }
                  }
                  
                }else{
                  
                  
                  if(multiple.groups==FALSE){
                    if(add.jitter==TRUE){
                      p<-ggboxplot(temp_dm2,x="Class",y="Feature",color="Class",palette=geom_col_vec,add="jitter",title=mzname)
                    }else{
                      p<-ggboxplot(temp_dm2,x="Class",y="Feature",color="Class",palette=geom_col_vec,title=mzname)
                      
                    }
                  }else{
                    
                    if(pairedanalysis==TRUE && connectpairedsamples==TRUE){
       #               print(head(temp_dm2))
                      
                      if(add.jitter==TRUE){
                        p<-ggpaired(temp_dm2,x="Factor1",y="Feature",color="Factor2",palette=geom_col_vec,add="jitter",title=mzname,line.color = "gray", line.size = 0.4)
                      }else{
                        p<-ggpaired(temp_dm2,x="Factor1",y="Feature",color="Factor2",palette=geom_col_vec,title=mzname,line.color = "gray", line.size = 0.4)
                        
                      }
                      
                    }else{
                      if(add.jitter==TRUE){
                        p<-ggboxplot(temp_dm2,x="Factor1",y="Feature",color="Factor2",palette=geom_col_vec,add="jitter",title=mzname)
                      }else{
                        p<-ggboxplot(temp_dm2,x="Factor1",y="Feature",color="Factor2",palette=geom_col_vec,title=mzname)
                        
                      }
                    }
                  }
                }
                
                
                if(add.pvalues==TRUE){
                  
                  if(multiple.groups==FALSE){
                    p<-p + stat_compare_means(size = 5*cex.plots,label = "p.format",label.x = 0.5, label.y = max_yval1,size = 5*cex.plots)
                  }else{
                    if(pairedanalysis==FALSE){
                      #label = "p.format",
                      
                      p<-p + stat_compare_means(aes(group = Factor1),label = "p.format",label.x = 0.5, label.y = max_yval1,size = 5*cex.plots)
                      p<-p + stat_compare_means(aes(group = Factor2),label = "p.format",size = 5*cex.plots)
                    }else{
                      
                      p<-p + stat_compare_means(aes(group = Factor1),label = "p.format",label.x = 0.5, label.y = max_yval1,size = 5*cex.plots)
                      p<-p + stat_compare_means(aes(group = Factor2),paired=TRUE,label = "p.format",size = 5*cex.plots)
                    }
                  }
                }
              }
              
              
              p=p + font("axis.text", size = 12*cex.plots, color = "black") + font("axis.title", size = 13*cex.plots, color = "black")
              p=p + font("legend.text", size = 12*cex.plots, color = "black") #theme(legend.position = "right")
              p=p+theme(plot.title = element_text(hjust = 0.5,size=16*cex.plots),legend.position = "right") + labs(y=ylabel) + theme(axis.text.x = element_text(angle = 45, hjust = 1,vjust=-0.5))
              
              
            } 
            
            
           # p=p+scale_y_continuous(labels = scales::number)
            
            
            if(is.na(ylim.val)==FALSE){
              
              p=p+ylim(ylim.val[1], ylim.val[2])
            }
            
            return(list("plot_res"=p,"pval_res"=pval_res))
            #print(p)
          }
          
          
          
        }
        
        
        
      }
    },mzvec,timevec,check_names,name,class_labels_levels,sampleclass,col_vec,goodfeats,pairedanalysis,connectpairedsamples,boxplot.type,
    ggplot.type1,group_by_mat,cex.plots,boxplot.col.opt,add.jitter,add.pvalues,
    fill.plots,multiple.figures.perpanel,ylim.val,pval.reporting.method,ref.group.val,subset.factor1,subset.factor2,asterisk.size,posthoc.multcomp.test)
    
  #  save(plot_res,multiple.figures.perpanel,plot.height,plot.width,file="boxplot_plot.Rda")
      stopCluster(cl)
      
      if(add.pvalues==FALSE){
        
        pval.reporting.method="none"
      }
      
      #pval_res<-plot_res$pval_res
      #plot_res<-plot_res$plot_res
    if(boxplot.type=="ggplot"){
      
      suppressMessages(library(ggpubr))
      suppressMessages(library(gridExtra))
      suppressMessages(library(gtable))
        if(length(plot_res)>0){
          if(multiple.figures.perpanel==FALSE){
           
            mytheme <- gridExtra::ttheme_default(
              core = list(fg_params=list(cex = 1.2)),
              colhead = list(fg_params=list(cex = 1.3)),
              rowhead = list(fg_params=list(cex = 1.3)))
           
            if(pval.reporting.method=="twowayanova"){ 
            res<-lapply(seq(1,length(plot_res),1),function(i){
              
              p1=plot_res[[i]][[1]]
              mytheme <- gridExtra::ttheme_default(
                core = list(fg_params=list(cex = 1.2)),
                colhead = list(fg_params=list(cex = 1.3)),
                rowhead = list(fg_params=list(cex = 1.3)))
              tg1<-tableGrob(round(plot_res[[i]][[2]],5),theme = mytheme)
              
              #using the buffer group as reference\n
              
              title <- textGrob(paste("Two-way ANOVA with Tukey's HSD post-hoc comparisons\nFactor1 - Treatment; Factor2 - Time; Factor1:Factor2 - Interaction",sep=""),gp=gpar(fontsize=18))
              padding <- unit(5,"mm")
              
              text_high<-""
              
              text_high<-"Statistical significance is based on two-way ANOVA with Tukey's HSD post-hoc comparisons. Only post-hoc comparisons with the buffer group are shown here."
              p1=p1+ labs(caption = text_high)+theme(plot.caption = element_text(size=9*cex.plots,hjust=0,vjust=(0)))
              
              
              #tg1A<-gtable_add_grob(tg1,"Pairwise comparisons",1,1,1,ncol(tg1))
              tg1A <- gtable_add_rows(
                tg1, 
                heights = grobHeight(title) + padding,
                pos = 0)
              
              tg1A <- gtable_add_grob(
                tg1A, 
                title, 
                1, 1, 1, ncol(tg1A),clip='off')
              
              if(i==1){
                figure<-ggpubr::ggarrange(p1,tg1A,ncol = 2, nrow = 1,heights=c(plot.height),width=c(plot.width)) #,align = c("hv")) #,legend="right")
                
              }else{
                if(legend.all.pages==TRUE){
                  figure<-ggpubr::ggarrange(p1,tg1A,ncol = 2, nrow = 1,heights=c(plot.height),width=c(plot.width)) #,align = c("hv")) #,legend="right",align = c("hv"))
                  
                }else{
                  
                  figure<-ggpubr::ggarrange(p1,tg1A,ncol = 2, nrow = 1,heights=c(plot.height),width=c(plot.width)) #,align = c("hv")) #,legend="none",align = c("hv"))
                }    
              }
              return(figure)
            })
            }else{
             
              if(pval.reporting.method!="none"){
                res<-lapply(c(1,seq(1,length(plot_res),1)),function(i){
                  
                  p1=plot_res[[i]][[1]]
                  mytheme <- gridExtra::ttheme_default(
                    core = list(fg_params=list(cex = 1)),
                    colhead = list(fg_params=list(cex = 1)),
                    rowhead = list(fg_params=list(cex = 1)))
                  tg1<-tableGrob(round(plot_res[[i]][[2]],5),theme = mytheme)
                  
                  #using the buffer group as reference\n
                  
                  title <- textGrob(paste(""),gp=gpar(fontsize=18))
                  padding <- unit(5,"mm")
                  text_high<-""
                  text_high<-""
                  if(pval.reporting.method=="wilcox.test"){
                    text_high<-paste("The asterisks represent p-values from pairwise Wilcoxon rank-sum test results using the ",ref.group.val," group as reference.\nSee the pvalues.table_* file for all pairwise comparisons.",sep="")
                  }else{
                    if(pval.reporting.method=="kruskal.test"){
                      text_high<-"The asterisks represent p-values from Kruskal-Wallis one-way ANOVA. \nSee the pvalues.table for Dunn's post-hoc comparisons."
                    }else{
                      
                      if(pval.reporting.method=="t.test"){
                        text_high<-paste("The asterisks represent p-values from pairwise Welch's t-test results using the ",ref.group.val," group as reference.\nSee the pvalues.table_* file for all pairwise comparisons.",sep="")
                      }
                      
                    }
                  }
                  p1=p1+ labs(caption = text_high)+theme(plot.caption = element_text(size=9*cex.plots,hjust=0,vjust=(0)))
                  
                  
                  #tg1A<-gtable_add_grob(tg1,"Pairwise comparisons",1,1,1,ncol(tg1))
                  tg1A <- gtable_add_rows(
                    tg1, 
                    heights = grobHeight(title) + padding,
                    pos = 0)
                  
                  tg1A <- gtable_add_grob(
                    tg1A, 
                    title, 
                    1, 1, 1, ncol(tg1A),clip='off')
                  
                  
                  if(i==1){
                    figure<-ggpubr::ggarrange(p1,tg1A,ncol = 1, nrow = 1,heights=c(plot.height),width=c(plot.width),legend="right") #align = c("hv"),
                    
                  }else{
                    if(legend.all.pages==TRUE){
                      figure<-ggpubr::ggarrange(p1,tg1A,ncol = 1, nrow = 1,heights=c(plot.height),width=c(plot.width),legend="right") #,align = c("hv")) #,legend="right",align = c("hv"))
                      
                    }else{
                      
                      figure<-ggpubr::ggarrange(p1,tg1A,ncol = 1, nrow = 1,heights=c(plot.height),width=c(plot.width),legend="right") #,align = c("hv")) #,legend="none",align = c("hv"))
                    }    
                  }
                  return(figure)
                }) 
                
                  
                  res2<-lapply(seq(1,length(plot_res),1),function(i){
                    
                    p1=plot_res[[i]][[1]]
                    mytheme <- gridExtra::ttheme_default(
                      core = list(fg_params=list(cex = 1.1)),
                      colhead = list(fg_params=list(cex = 1.1)),
                      rowhead = list(fg_params=list(cex = 1.1)))
                    tg1<-tableGrob(round(plot_res[[i]][[2]],5),theme = mytheme)
                    
                    #using the buffer group as reference\n
                    
                    title <- textGrob(paste(""),gp=gpar(fontsize=18))
                    padding <- unit(5,"mm")
                    text_high<-""
                    if(pval.reporting.method=="wilcox.test"){
                      text_high<-paste("The asterisks represent p-values from pairwise Wilcoxon rank-sum test results using the ",ref.group.val," group as reference.\nSee the pvalues.table_* file for all pairwise comparisons.",sep="")
                    }else{
                      if(pval.reporting.method=="kruskal.test"){
                        text_high<-"The asterisks represent p-values from Kruskal-Wallis one-way ANOVA. \nSee the pvalues.table for Dunn's post-hoc comparisons."
                      }else{
                        
                        if(pval.reporting.method=="t.test"){
                        text_high<-paste("The asterisks represent p-values from pairwise Welch's t-test results using the ",ref.group.val," group as reference.\nSee the pvalues.table_* file for all pairwise comparisons.",sep="")
                        }
                        
                      }
                    }
                    p1=p1+ labs(caption = text_high)+theme(plot.caption = element_text(size=9*cex.plots,hjust=0,vjust=(0)))
                    
                    
                    #tg1A<-gtable_add_grob(tg1,"Pairwise comparisons",1,1,1,ncol(tg1))
                    tg1A <- gtable_add_rows(
                      tg1, 
                      heights = grobHeight(title) + padding,
                      pos = 0)
                    
                    tg1A <- gtable_add_grob(
                      tg1A, 
                      title, 
                      1, 1, 1, ncol(tg1A),clip='off')
                    
                    if(i==1){
                      figure<-ggpubr::ggarrange(p1,tg1A,ncol = 2, nrow = 1,heights=c(plot.height),width=c(plot.width)) #align = c("hv"),
                      
                    }else{
                      if(legend.all.pages==TRUE){
                        figure<-ggpubr::ggarrange(p1,tg1A,ncol = 2, nrow = 1,heights=c(plot.height),width=c(plot.width)) #,align = c("hv")) #,legend="right",align = c("hv"))
                        
                      }else{
                        
                        figure<-ggpubr::ggarrange(p1,tg1A,ncol = 2, nrow = 1,heights=c(plot.height),width=c(plot.width)) #,align = c("hv")) #,legend="none",align = c("hv"))
                      }    
                    }
                    return(figure)
                  }) 
                
              }else{
                
                
                res<-lapply(seq(1,length(plot_res),1),function(i){
                  
                  p1=plot_res[[i]][[1]]
                  mytheme <- gridExtra::ttheme_default(
                    core = list(fg_params=list(cex = 0.75)),
                    colhead = list(fg_params=list(cex = 1)),
                    rowhead = list(fg_params=list(cex = 1)))
                  
                  
                  if(i==1){
                    figure<-ggpubr::ggarrange(p1,ncol = 1, nrow = 1,heights=c(plot.height),width=c(plot.width),legend="right") #align = c("hv"),
                    
                  }else{
                    if(legend.all.pages==TRUE){
                      figure<-ggpubr::ggarrange(p1,ncol =1, nrow = 1,heights=c(plot.height),width=c(plot.width),legend="right") #,align = c("hv")) #,legend="right",align = c("hv"))
                      
                    }else{
                      
                      figure<-ggpubr::ggarrange(p1,ncol = 1, nrow = 1,heights=c(plot.height),width=c(plot.width),legend="right") #,align = c("hv")) #,legend="none",align = c("hv"))
                    }    
                  }
                  return(figure)
                })  
              }
                
            }
                
            
          }
          
          }else{
            res<-lapply(seq(1,length(plot_res),4),function(i){
              p1=plot_res[[i]]
              p1=plot_res[[i]]
              p2={}
              p3={}
              p4={}
              
              if((i+1)<length(plot_res)){
                p2=plot_res[[i+1]]
              }
              if((i+2)<length(plot_res)){
                p3=plot_res[[i+2]]
              }
              if((i+3)<length(plot_res)){
                
                p4=plot_res[[i+3]]
              }
              figure<-ggarrange(p1,p2,p3,p4,ncol = 2, nrow = 2,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
              # gg##save(res,file="t.pdf")
              #figure<-ggarrange(p1,ncol = 2, nrow = 2,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
              return(figure)
            })
            
          }
          
        
          
      
      library(ggpubr)
     # library(cowplot)
      feature.names<-names_with_mz_time[,c(1)]
      names(plot_res)<-feature.names
      
      if(pval.table.report==TRUE){
      pval_table<-lapply(1:length(plot_res),function(j){as.data.frame(t(plot_res[[j]][[2]]))})
      
      pval_table<-ldply(pval_table,rbind)
      #pval_table<-round(pval_table,5)
      rownames(pval_table)<-names(plot_res)
      pval_table<-cbind(names(plot_res),pval_table)
      
      pval_table<-cbind(colnames(pval_table[,-c(1)]),t(pval_table[,-c(1)]))
      
      pval_table<-as.data.frame(pval_table)
      
      colnames(pval_table)<-c("Comparison",names(plot_res))
      
      boxplots_fname1=gsub(boxplots_fname,pattern=".pdf$",replacement="")
      
      fname_temp<-paste("pvalues.table_",boxplots_fname1,".txt",sep="")
      write.table(pval_table,file=fname_temp,sep="\t",row.names=FALSE)
      
      # save(res,plot_res,feature.names,file="res_with_pvalues.Rda")
      }
      #if(FALSE)
      {
        res<-lapply(1:length(res),function(x){
          return(res[[x]][[1]])
          # print(res[[x]][[1]])
        })
        
      }
     res<-append(res, ggpubr::get_legend(plot_res[[1]][[1]]))
      #res[[length(res)+1]][[1]] <- ggpubr::get_legend(plot_res[[i]])
      
      ggpubr::ggexport(res,filename =boxplots_fname,width=unit(plot.width-0.5, "in"),
                       height=unit(plot.height-0.5, "in"))
        if(FALSE)
          {
            if(pval.table.report==TRUE){
        res2<-lapply(1:length(res2),function(x){
          return(res2[[x]][[1]])
          # print(res[[x]][[1]])
        })
        boxplots_fname2<-paste("pvalues",boxplots_fname,sep="")
        
       # ggpubr::ggexport(res2,filename =boxplots_fname2,width=unit(plot.width-0.5, "in"),
        #                 height=unit(plot.height-0.5, "in"))
        
        #save(res2,name,file="res_with_pvalues.Rda")
        }
        }
   # ggpubr::ggexport(res,filename =boxplots_fname)
        
      
    }
      
  }
 
  if(newdevice==TRUE){
    try(dev.off(boxplots_fname),silent=TRUE)
  }else{
    try(dev.off(boxplots_fname),silent=TRUE)
  }
  try(unlink("Name_mz_time_mapping.txt"))

  #par(mfrow=c(1,1))
  options(warn=0)
  return(res)
}


get_spaghettiplots<-function(X,Y,feature_table_file,parentoutput_dir,class_labels_file,boxplot.col.opt="journal",alphacol=0.3,newdevice=TRUE,cex.plots=0.8,
                             replace.by.NA=FALSE,pairedanalysis=FALSE,filename="",ylabel="Intensity",
                             alphabetical.order=FALSE,name=NA,add.jitter=TRUE,add.pvalues=TRUE,class.levels=NA,fill.plots=FALSE,connectpairedsamples=FALSE,
                             boxplot.type="ggplot",study.design=c("multiclass","onewayanova","twowayanova","onewayanovarepeat",
                                                                  "twowayanovarepeat"),multiple.figures.perpanel=TRUE,
                             ggplot.type1=TRUE,replace.outliers=FALSE,plot.height=8,plot.width=8,...)
{
  
  analysistype=study.design[1]
  
  if(boxplot.type=="ggplot"){
    suppressMessages(library(ggplot2))
  }else{
    suppressMessages(library(ggpubr))
  }
  
  # multiple.figures.perpanel=TRUE
  
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }else{
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
  }else{
    classlabels<-Y
  }
  rm(X)
  rm(Y)
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame(data_matrix)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  
  
  
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  mzvec<-data_matrix[,1]
  timevec<-data_matrix[,2]
  goodfeats<-data_m			
  rm(data_m)
  
  #library(extrafont)
  #loadfonts()
  
  multiple.groups=FALSE
  
  #c("multiclass","onewayanova","twowayanova","onewayanovarepeat","twowayanovarepeat")
  
  if(study.design=="onewayanovarepeat" | study.design=="twowayanovarepeat" | study.design=="twowayrepeat" | study.design=="onewayrepeat"){
    
    pairedanalysis=TRUE
  }
  
  if(pairedanalysis==TRUE){
    
    print("Using column 2 as subject identifiers")
    paireddesign=classlabels[,2]
    
    classlabels<-classlabels[,-c(2)]
  }
  
  
  
  if(dim(classlabels)[2]>2){
    
    
    if(study.design=="twowayanova" | study.design=="twowayanovarepeat" | study.design=="twoway" | study.design=="twowayrepeat"){
      # print("More than two columns found in the class labels file. ")
      
      
      Class<-paste(classlabels[,2],":",classlabels[,3],sep="") #classlabels[,2]:classlabels[,3]
      
      multiple.groups=TRUE
      
    }else{
      
      if(study.design=="onewayanova" | study.design=="onewayanovarepeat" | study.design=="oneway"){
        #     print("More than two columns found in the class labels file. ")
        
        
        Class<-classlabels[,2] #classlabels[,2]:classlabels[,3]
        
        
      }else{
        Class<-classlabels[,2]
        
      }
      
    }
    
  }else{
    
    Class<-classlabels[,2]
  }
  
  
  #par(mfrow=c(2,2),family="sans",cex=cex.plots)
  
  if(alphabetical.order==FALSE){
    Class <- factor(Class, levels=unique(Class))
  }
  
  class_levels<-levels(as.factor(Class))
  
  class_labels_levels<-levels(as.factor(Class))
  ordered_labels<-Class
  
  class_label_alphabets<-paste("C",1:length(class_labels_levels),sep="") #c("A","B","C","D","E","F","G","H","I","J","K","L","M")
  
  if(is.na(boxplot.col.opt)==TRUE){
    
    col_vec<-rep(c("white"),length(class_labels_levels))
    boxplot.col.opt<-col_vec
  }
  
  if(boxplot.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{ 
    if(boxplot.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels)) 
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(boxplot.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(boxplot.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(boxplot.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(boxplot.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #   col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=boxplot.col.opt)
              
              if(length(check_brewer)>0){
                
                boxplot.col.opt=gsub(x=boxplot.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, boxplot.col.opt))(length(class_labels_levels))
                
              }else{
                
                if(boxplot.col.opt=="journal"){
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                  
                  
                }else{
                  col_vec <-boxplot.col.opt
                  col_vec <- rep(col_vec,length(class_labels_levels))
                }
                
              }
              
            }
          }
          
          
        }
        
      }
      
    }	
  }
  
  
  
  ordered_labels={}
  num_samps_group<-new("list")
  num_samps_group[[1]]<-0
  groupwiseindex<-new("list")
  groupwiseindex[[1]]<-0
  
  for(c in 1:length(class_labels_levels))
  {
    
    classlabels_index<-which(Class==class_labels_levels[c])
    #ordered_labels<-c(ordered_labels,as.character(classlabels[classlabels_index,2]))
    num_samps_group[[c]]<-length(classlabels_index)
    groupwiseindex[[c]]<-classlabels_index
  }
  
  sampleclass<-{}
  patientcolors<-{}
  
  if(length(mzvec)>4){
    max_per_row<-3
    
    
    par_rows<-ceiling(9/max_per_row)
    
  }else{
    max_per_row<-length(mzvec)
    par_rows<-1
  }
  
  
  #name=goodfeats_name,
  #class_labels_levels<-paste("x",seq(1,length(class_labels_levels)),sep="")
  
  file_ind<-0
  boxplots_fname<-paste(filename,".pdf",sep="")
  #tiff(boxplots_fname, width=plots.width,height=plots.height,res=plots.res, compression="lzw")
  
  #tiff(boxplots_fname, width=2000,height=3000,res=plots.res, compression="lzw")
  
  if(newdevice==TRUE){
    pdf(boxplots_fname,width=plot.width,height=plot.height)
  }
  #par(mfrow=c(par_rows,max_per_row))
  #save(Class,goodfeats,class_labels_levels,file="debug1.Rda")
  
  plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
  
  
  # text(5,9,"Description:",font=2,col="blue")
  
  text(5, 8, "This PDF includes spaghetti plots for each variable representing\n the longitudinal variation in
  individual subjects over time.
       \n\n\n Note: The panels are grouped by factor 1 (e.g. group).",cex=1.5,font=2)
  
  
  temp_dm<-cbind(as.character(Class),(t(goodfeats)))
  temp_dm<-as.data.frame(temp_dm)
  colnames(temp_dm)<-c("Class",rownames(goodfeats))
  class_levels<-levels(as.factor(temp_dm$Class))
  
  #save(temp_dm,file="temp_dm.Rda")
  #keeps the class order same as in the input file; avoids arrangement by alphabetical order
  if(alphabetical.order==FALSE){
    temp_dm$Class <- factor(temp_dm$Class, levels=unique(temp_dm$Class))
  }
  
  #save(temp_dm,file="temp_dm1.Rda")
  
  if(is.na(class.levels)==FALSE){
    
    match_test<-match(class.levels,levels(as.factor(temp_dm$Class)))
    if(length(which(is.na(match_test)==TRUE))<1){
      
      if(alphabetical.order==FALSE){
        temp_dm$Class <- factor(temp_dm$Class, levels=unique(class.levels))
      }
    }else{
      stop(paste("User defined class.levels ", paste(class.levels,sep=" ",collapse=""), " do not match the levels in the class labels matrix, ",paste(class_levels,sep=" ",collapse=""),sep=""))    
    }
  }
  
  #par(mfrow=c(1,1),family="sans",cex=cex.plots)
  

    {
    
    plot_res<-lapply(1:dim(goodfeats)[1],function(m)
    {
      
      if(m%%9==0){
        
        file_ind<-file_ind+1
        boxplots_fname<-paste("boxplots_file",file_ind,".tiff",sep="")
        
      }
      
      round_mzval<-mzvec[m] #sprintf("%.4f",mzvec[m])
      
      round_timeval<-timevec[m] #sprintf("%.1f",timevec[m])
      
      if(is.na(name[1])==TRUE){            
        
        if(length(check_names)>0){	
          if(check_names==1){
            
            mzname<-as.character(names_with_mz_time[m,1])
          }else{  
            
            mzname<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
          }
          
        }else{
          
          mzname<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
        }
      }else{
        
        mzname=as.character(name[m])
      }
      if(length(class_labels_levels)>=2)
      {
        if(length(class_labels_levels)>=1)
        {
          t1<-table(sampleclass)
          cur_d<-new("list")
          feat_vec<-{}
          class_vec<-{}
          id_vec<-{}
          
          
          for(c in 1:length(class_labels_levels))
          {
            num_samps_group[[1]]<-t1[1]
            cvec<-as.vector(t(goodfeats[m,c(groupwiseindex[[c]])]))
            if(replace.outliers==TRUE){
              cvec<-replace_outliers(cvec,replace.by.NA)
            }
            cur_d[[c]]<-cvec
            feat_vec<-c(feat_vec,cvec)
            class_vec<-c(class_vec,rep(class_labels_levels[c],length(which(Class==class_labels_levels[c]))))
            id_vec<-c(id_vec,names(goodfeats[m,c(groupwiseindex[[c]])]))
          }
          
          
          temp_dm<-cbind(as.character(class_vec),as.vector(feat_vec),as.vector(id_vec))
          
          temp_dm<-as.data.frame(temp_dm)
          #save(temp_dm,class_labels_levels,goodfeats,Class,groupwiseindex,file="t1.Rda")
          temp_dm2<-temp_dm #[,c(1,(m+1))]
          temp_dm2<-as.data.frame(temp_dm2)
          colnames(temp_dm2)<-c("Class","Feature","SubjectID")
          temp_dm2$Feature<-as.numeric(as.character(temp_dm2$Feature))
          
          sum_yval1=summary(temp_dm2$Feature,na.rm=TRUE)
          max_yval1=max(temp_dm2$Feature,na.rm=TRUE)+(sum_yval1[5]-sum_yval1[2])
          
         
          
          fname1<-paste("temp_dm2",mzname,"A1.Rda")
          #save(Class,class.levels,temp_dm2,alphabetical.order,file=fname1)
          Class<-temp_dm2
          
          if(is.na(class.levels)==FALSE){
            
            match_test<-match(class.levels,levels(as.factor(temp_dm2$Class)))
            if(length(which(is.na(match_test)==TRUE))<1){
              
              if(alphabetical.order==FALSE){
                temp_dm2$Class <- factor(temp_dm2$Class, levels=unique(class.levels))
              }
            }else{
              stop(paste("User defined class.levels ", paste(class.levels,sep=" ",collapse=""), " do not match the levels in the class labels matrix, ",paste(class_levels,sep=" ",collapse=""),sep=""))
            }
          }
          
          
          if(multiple.groups==TRUE){
            Factor1<-gsub(temp_dm2$Class,pattern=":([\\w|\\W])*",replacement="",perl=TRUE)
            Factor2<-gsub(temp_dm2$Class,pattern="([\\w|\\W])*:",replacement="",perl=TRUE)
            
            
            fname1<-paste("temp_dm2",mzname,"A.Rda")
            #save(Class,Factor1,Factor2,temp_dm2,file=fname1)
            temp_dm2<-cbind(temp_dm2,Factor1,Factor2)
          }
          
          
          
          
          #  par(mfrow=c(2,2),family="sans",cex=cex.plots)
          
          w <- 0.1
          par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
          
          #    print(cex)
          ###save(temp_dm2,cur_d,mzname,boxplot.col.opt,col_vec,ylabel,Class,goodfeats,class_labels_levels,cex,boxplot.type,multiple.groups,add.jitter,add.pvalues,fill.plots,file="temp_dm2.Rda")
          
          #ID<-paste("SID",seq(1,nrow(temp_dm2)),sep="")
          temp_dm2$SubjectID<-gsub(temp_dm2$SubjectID,pattern="[a-z|0-9|A-Z]*_",replacement="")
          
         # temp_dm2<-cbind(ID,temp_dm2)
          temp_dm2<-as.data.frame(temp_dm2)
            
            
           
              
              suppressMessages(library(ggplot2))
              if(multiple.groups==FALSE){
                p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Class,group=SubjectID)) + geom_line() + labs(title=mzname)
                
              }else{
                
                fname1<-paste("temp_dm2",mzname,".Rda")
                
                #save(temp_dm2,mzname,class_labels_levels,col_vec,file=fname1)
                
                 #p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,fill=Factor2)) + labs(title=mzname) + facet_wrap(~Factor2, scale="free")  
                if(ggplot.type1==TRUE){
                  p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor1,group=SubjectID,color=SubjectID)) + geom_point()+geom_line(size=1.25)+labs(title=mzname) + facet_wrap(~Factor2, scale="free_x")  
                }else{
                  p <- ggplot(temp_dm2, aes(y=as.numeric(Feature),x=Factor2,group=SubjectID,color=SubjectID))+ geom_point()+geom_line(size=1.25)+labs(title=mzname) + facet_wrap(~Factor1, scale="free_x")  
                  
                  
                }
                
              }
              
             if(FALSE){
               
              p<-p+ labs(y=ylabel) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                        panel.grid.minor = element_blank(),
                                                        panel.spacing=unit(1,"lines"),
                                                        axis.line = element_line(colour = "black",size=1),
                                                        axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=18*cex.plots,face="bold"),
                                                        plot.title = element_text(hjust = 0.5,size=18*cex.plots),
                                                        axis.ticks.length = unit(-0.05, "in"),
                                                        axis.text.y = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
                                                        axis.text.x = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
                                                        axis.ticks.x = element_blank(),
                                                        aspect.ratio = 1,
                                                        legend.background = element_rect(color = "black", fill = "white"),
                                                        strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                        strip.text.x = element_text(size = 14*cex.plots, colour = "black"),
                                                        strip.text = element_text(face="bold")) +scale_fill_manual(values=(col_vec[1:length(unique(temp_dm2$ID))]))+ scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
             }
              
              p<-p+ labs(y=ylabel) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                        panel.grid.minor = element_blank(),
                                                        panel.spacing=unit(1,"lines"),
                                                        axis.line = element_line(colour = "black",size=1),
                                                        axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=18*cex.plots,face="bold"),
                                                        plot.title = element_text(hjust = 0.5,size=18*cex.plots),
                                                       
                                                        legend.background = element_rect(color = "black", fill = "white"),
                                                        strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                        strip.text.x = element_text(size = 14*cex.plots, colour = "black"),
                                                       strip.text = element_text(face="bold")) +scale_fill_manual(values=(col_vec[1:length(unique(temp_dm2$ID))]))+ scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
              p=p + theme(legend.title = element_text(size = 13*cex.plots),
                          legend.text = element_text(size=13*cex.plots))
              
              #save(p,file="p1.Rda")
            
             
            
            return(p)
            #print(p)
        }}
          
    })
    
    #save(plot_res,multiple.figures.perpanel,file="boxplot_plot.Rda")
    
    if(boxplot.type=="ggplot"){
      
      suppressMessages(library(ggpubr))
      
      
      
      if(length(plot_res)>0){
        if(multiple.figures.perpanel==FALSE){
          res<-lapply(seq(1,length(plot_res),1),function(i){
            p1=plot_res[[i]]
            figure<-ggpubr::ggarrange(p1,ncol = 1, nrow = 1,heights=c(6),width=c(10),legend=TRUE,align = c("hv"))
            return(figure)
          })
        }else{
          res<-lapply(seq(1,length(plot_res),4),function(i){
            p1=plot_res[[i]]
            p1=plot_res[[i]]
            p2={}
            p3={}
            p4={}
            
            if((i+1)<length(plot_res)){
              p2=plot_res[[i+1]]
            }
            if((i+2)<length(plot_res)){
              p3=plot_res[[i+2]]
            }
            if((i+3)<length(plot_res)){
              
              p4=plot_res[[i+3]]
            }
            figure<-ggarrange(p1,p2,p3,p4,ncol = 2, nrow = 2,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
            # gg##save(res,file="t.pdf")
            #figure<-ggarrange(p1,ncol = 2, nrow = 2,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
            return(figure)
          })
          
        }
        
      }
      
      
      
      #save(res,file="res.Rda")
      
      for(i in 1:length(res)){
        p_fixed <- set_panel_size(res[[i]][[1]],
                                  width  = unit(plot.width-0.5, "in"),
                                  height = unit(plot.height-0.5, "in"))
        
        
        grid.newpage()
        grid.draw(p_fixed)
        
        #print(p_fixed) #res[[i]][[1]])
      }
      
      
      legend <- ggpubr::get_legend(plot_res[[i]])
      
      suppressMessages(library(grid))
      
      grid.newpage()
      grid.draw(legend)
      
      
    }
  }
  
  if(newdevice==TRUE){
    try(dev.off(boxplots_fname),silent=TRUE)
  }
  
  par(mfrow=c(1,1))
}





#X: mz, time, Sample data or Name, Sample data
#Y: SID, Class
get_pcascoredistplots<-function(X=NA,Y=NA,feature_table_file,parentoutput_dir,class_labels_file,
                                sample.col.opt=c("journal", "npg", "nejm", "jco", "lancet", "custom1", "brewer.RdYlBu", "brewer.RdBu", "brewer.PuOr", 
                                                 "brewer.PRGn", "brewer.PiYG", "brewer.BrBG", "brewer.Set2", "brewer.Paired", "brewer.Dark2", "brewer.YlGnBu", "brewer.YlGn",
                                                 "brewer.YlOrRd", "brewer.YlOrBr", "brewer.PuBuGn", "brewer.PuRd", "brewer.PuBu", "brewer.OrRd", "brewer.GnBu", "brewer.BuPu",
                                                 "brewer.BuGn", "brewer.blues", "black", "grey65", "terrain", "rainbow", "heat", "topo"),
                                plots.width=2000,plots.height=2000,plots.res=300,
                                alphacol=0.3,col_vec=NA,pairedanalysis=FALSE,pca.cex.val=3,
                                legendlocation="topright",pca.ellipse=FALSE,ellipse.conf.level=0.95,
                                filename="all",paireddesign=NA,error.bar=TRUE,lineplot.col.opt="black",
                                lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),
                                newdevice=FALSE,timeseries.lineplots=FALSE,alphabetical.order=FALSE,pcascale=TRUE,
                                pcacenter=TRUE,study.design="oneway",lme.modeltype="RI",cex.plots=0.8,
                                ypos.adj.factor=0.5,...)
{
  if(FALSE){
  if(length(sample.col.opt)==1){
  sample.col.opt=tolower(sample.col.opt)
  sample.col.opt=get_hexcolors_for_palettes(color.palette=sample.col.opt[1],alpha.col=alphacol[1])
  }
  
  if(length(lineplot.col.opt)==1){
    lineplot.col.opt=tolower(lineplot.col.opt)
    lineplot.col.opt=get_hexcolors_for_palettes(color.palette=lineplot.col.opt[1],alpha.col=alphacol[1])
  }
  }  
  
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  
  match_col.opt=match(sample.col.opt,c("journal","npg","nejm","jco","lancet","custom1","brewer.RdYlBu","brewer.RdBu","brewer.PuOr","brewer.PRGn","brewer.PiYG","brewer.BrBG",
                                       "brewer.Set2","brewer.Paired","brewer.Dark2","brewer.YlGnBu","brewer.YlGn","brewer.YlOrRd","brewer.YlOrBr","brewer.PuBuGn",
                                       "brewer.PuRd","brewer.PuBu",
                                       "brewer.OrRd","brewer.GnBu","brewer.BuPu","brewer.BuGn","brewer.blues","black","grey65","terrain","rainbow","heat","topo"))
  
  match_col.opt=length(which(is.na(match_col.opt)==TRUE))
    
  if(length(match_col.opt)<1){
    
    sample.col.opt=sample.col.opt[1]
  }else{
    
    if(length(grep(sample.col.opt,pattern="brewer."))>1){
      
      sample.col.opt=sample.col.opt[1]
    }
  }
  
  if(length(sample.col.opt)==1){
    sample.col.opt=tolower(sample.col.opt)
    sample.col.opt=get_hexcolors_for_palettes(color.palette=sample.col.opt[1],alpha.col=alphacol[1])
  }
  
  lineplot.col.opt=sample.col.opt
  
  res<-get_pcascoredistplots_child(X=X,Y=Y,feature_table_file=feature_table_file,parentoutput_dir=parentoutput_dir,
                                   class_labels_file=class_labels_file,sample.col.opt=sample.col.opt,plots.width=plots.width,
                                   plots.height=plots.height,plots.res=plots.res, alphacol=alphacol,col_vec=col_vec,
                                   pairedanalysis=pairedanalysis,pca.cex.val=pca.cex.val,legendlocation=legendlocation,
                                   pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,filename=filename,
                                   paireddesign=paireddesign,error.bar=error.bar,lineplot.col.opt=lineplot.col.opt,
                                   lineplot.lty.option=lineplot.lty.option,newdevice=newdevice,timeseries.lineplots=timeseries.lineplots,
                                   alphabetical.order=alphabetical.order,pcascale=pcascale,pcacenter=pcacenter,study.design=study.design,lme.modeltype=lme.modeltype,cex.plots=cex.plots,ypos.adj.factor=ypos.adj.factor,...)
  
  
  return(res)
}


get_pcascoredistplots_child<-function(X,Y,feature_table_file,parentoutput_dir,class_labels_file,
                                      sample.col.opt="rainbow",plots.width=2000,plots.height=2000,plots.res=300,
                                      alphacol=0.3,col_vec=NA,pairedanalysis=FALSE,pca.cex.val=4,legendlocation="topright",pca.ellipse=TRUE,ellipse.conf.level=0.95,filename="all",paireddesign=NA,
                                      error.bar=TRUE,lineplot.col.opt="black",lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),newdevice=FALSE,timeseries.lineplots=FALSE,alphabetical.order=FALSE,pcascale=TRUE,pcacenter=TRUE,study.design="oneway",lme.modeltype="RI",cex.plots=0.8,ypos.adj.factor=0.5,...)
{
  
  analysistype=study.design
  
  if(is.na(X)[1]==TRUE){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  }else{
    
    data_matrix<-X
  }
  
  
  
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
  }else{
    
    classlabels<-Y
  }
  
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  if(newdevice==TRUE){
    
    fname<-paste("pcaplots",filename,".pdf",sep="")
    pdf(fname)
    
    
  }
  
  
  
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        
        rownames(data_matrix)<-Name
        
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame(data_matrix)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  check_rnames<-rownames(data_matrix)
  
  
  mzvec<-data_matrix[,1]
  rtvec<-data_matrix[,2]
  
  if(length(check_rnames)<1){
    if(length(check_names)<1){
    rnames<-paste(mzvec,rtvec,sep="_")
    
    rownames(data_m)<-as.character(rnames)
    }
    
  }else{
  #if(length(check_names)<1){ 
   rownames(data_m)<-rownames(data_matrix)
    
  }
  #rnames<-paste(mzvec,rtvec,sep="_")
  
  #rownames(data_m)<-as.character(rnames)
  
  
  classlabels_orig<-classlabels
  
  #classlabelsorig<-classlabelsorig[match(rownames(X),classlabelsorig[,1]),]
  
 #save(data_m,classlabels,file="pcaclasslabels.Rda")
  
  if(analysistype=="twowayrepeat" | analysistype=="2wayrepeat" | analysistype=="onewayrepeat" | analysistype=="1wayrepeat"){
    
    pairedanalysis=TRUE
  }
  
  if(dim(classlabels)[2]>2){
    
    if(pairedanalysis==TRUE){
      
      if(is.na(paireddesign)==TRUE){
        paireddesign=classlabels_orig[,2]
      }
      classlabels_orig<-classlabels_orig[,-c(2)]
    }
    
   # print("here0")
    if(analysistype=="twoway" | analysistype=="2way" | analysistype=="twowayrepeat" | analysistype=="2wayrepeat"){
      if(dim(classlabels_orig)[2]>2){
        classgroup<-paste(classlabels_orig[,2],":",classlabels_orig[,3],sep="") #classlabels_orig[,2]:classlabels_orig[,3]
      }
      
     # print("here1")
     # print(head(classlabels_orig))
     # print(head(classgroup))
      
    }else{
      
      classgroup<-classlabels_orig[,2]
    }
    
    
    
    do_pca_anova=FALSE
  }else{
    
    if(analysistype=="regression"){
      
      classgroup<-rep("A",nrow(classlabels_orig))
      do_pca_anova=FALSE
      
    }else{
      classgroup<-classlabels_orig[,2]
      
      do_pca_anova=TRUE
    }
  }
  
  ##save(classgroup,file="classgroup.Rda")
  if(alphabetical.order==FALSE){
    classgroup <- factor(classgroup, levels=unique(classgroup))
  }
  
  # do_pca_anova=FALSE
  
  class_labels_levels<-levels(as.factor(classgroup))
  
  
  ordered_labels<-classgroup
  
  class_label_alphabets<-paste("C",1:length(class_labels_levels),sep="") #c("A","B","C","D","E","F","G","H","I","J","K","L","M")
  
  classlabels<-classlabels_orig
  
  if(is.na(col_vec)[1]==TRUE)
  {
    if(sample.col.opt=="default"){
      
      col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
                 "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
                 "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
                 "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
      
    }else{
      if(sample.col.opt=="topo"){
        #col_vec<-topo.colors(256) #length(class_labels_levels))
        
        #col_vec<-col_vec[seq(1,length(col_vec),)]
        
        col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="heat"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          
          col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          if(sample.col.opt=="rainbow"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="terrain"){
              #col_vec<-heat.colors(256) #length(class_labels_levels))
              #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
              
              col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
            }else{
              
              if(sample.col.opt=="colorblind"){
                #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                
                if(length(class_labels_levels)<9){
                  
                  col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                  
                }else{
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                             "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                  
                  #colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels)))
                }
                
                
              }else{
                
                check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                
                if(length(check_brewer)>0){
                  
                  sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                  
                  col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                  
                }else{
                  
                  if(sample.col.opt=="journal"){
                    
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                               "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                               "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                               
                               "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                               "#E64B3519","#4DBBD519","#631879E5","grey75")
                    if(length(class_labels_levels)<8){
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                      
                      #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                      
                    }else{
                      if(length(class_labels_levels)<=28){
                        # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                        
                        col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                   "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                   "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                   
                                   "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                   "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                        
                      }else{
                        
                        
                        
                        
                        colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                        
                        col_vec<-col_vec[sample(col_vec)]
                        
                        
                      }
                    }
                  }else{
                    #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                 #   if(length(sample.col.opt)==1){
                  #    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                   # }else{
                      
                    #  colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                      
                    #}
                    
                    if(length(sample.col.opt)==1){
                      col_vec <-rep(sample.col.opt,length(class_labels_levels))
                    }else{
                      
                      if(length(sample.col.opt)>=length(class_labels_levels)){
                        
                        col_vec <-sample.col.opt
                        col_vec <- rep(col_vec,length(class_labels_levels))
                        
                        
                      }else{
                        colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                      }
                      
                    }
                    
                    
                  }
                }
                
              }
              
            }
          }
          
        }
        
      }
    }
  }else{
    
    colfunc <-colorRampPalette(col_vec);col_vec<-colfunc(length(class_labels_levels))
  }
  
  class_col_vec=rep("red",nrow(classlabels))
  #    print(class_labels_levels)
  
  ordered_labels={}
  num_samps_group<-new("list")
  num_samps_group[[1]]<-0
  groupwiseindex<-new("list")
  groupwiseindex[[1]]<-0
  
  S<-new("list")
  
# save(class_labels_levels,col_vec,sample.col.opt,lineplot.col.opt,classlabels,file="pcaclass_labels_levels.Rda")
  for(c in 1:length(class_labels_levels))
  {
    
    classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
    #ordered_labels<-c(ordered_labels,as.character(classlabels[classlabels_index,2]))
    num_samps_group[[c]]<-length(classlabels_index)
    groupwiseindex[[c]]<-classlabels_index
    
    class_col_vec[which(classlabels[,2]==class_labels_levels[c])]<-col_vec[c]
    # S[[c]]<-cov(t(data_m[,c(classlabels_index)]))
    
  }
  
  
  
  sampleclass<-{}
  patientcolors<-{}
  
  classlabels<-as.data.frame(classlabels)
  
  
  for(c in 1:length(class_labels_levels)){
    
    num_samps_group_cur=length(which(ordered_labels==class_labels_levels[c]))
    
    
    sampleclass<-c(sampleclass,rep(paste("Class",class_label_alphabets[c],sep=""),num_samps_group_cur))
    
    patientcolors <-c(patientcolors,rep(col_vec[c],num_samps_group[[c]]))
  }
  
  if(length(mzvec)>4){
    max_per_row<-3
    
    
    par_rows<-ceiling(9/max_per_row)
    
  }else{
    max_per_row<-length(mzvec)
    par_rows<-1
  }
  
  file_ind<-0
  boxplots_fname<-paste("xyplots.pdf",sep="")
  
  suppressWarnings(dir.create("Tables",showWarnings = FALSE))
  t1<-table(classgroup)
  
  l1<-levels(as.factor(classgroup))
  
  
  patientcolors <- rep(col_vec[1:length(t1)], t1)
  
 # save(data_m,classgroup,legendlocation,filename,pcacenter,paireddesign,pcascale,col_vec,
  #     sample.col.opt,pca.cex.val,pca.ellipse,do_pca_anova,paireddesign,classlabels_orig,
   #   alphabetical.order,analysistype,file="pcad1A.Rda")
  
  #save(data_m,file="data_m.Rda")
  
  if(dim(data_m)[1]>2){
    
    
    res<-get_pca(X=data_m,samplelabels=classgroup,legendlocation=legendlocation,filename=filename,ncomp=10,pcacenter=pcacenter,pcascale=pcascale,legendcex=0.5,outloc=getwd(),
                 col_vec=col_vec,sample.col.opt=sample.col.opt,alphacol=0.3,class_levels=NA,pca.cex.val=pca.cex.val,pca.ellipse=pca.ellipse,do_pca_anova=do_pca_anova,
                 paireddesign=paireddesign,classlabelsorig=classlabels_orig,alphabetical.order=alphabetical.order,analysistype=analysistype,pairedanalysis=pairedanalysis,lme.modeltype=lme.modeltype)
    numcomp_plot<-res$numcomp_plot
    pcnum_limit=numcomp_plot
   
    pc_pval_vec<-res$pca_pval_vec
    res<-res$result
   
   
    
    fname<-paste("Tables/PCAloadings_",filename,"features.txt",sep="")
    
    loadings_res<-res$rotation
    scores_res<-res$x
    
    loadings_res<-round(loadings_res,2)
    scores_res<-round(scores_res,2)
    
    if(dim(loadings_res)[2]>10){
      loadings_res<-loadings_res[,c(1:10)]
      scores_res<-scores_res[,c(1:10)]
    }
    
    write.table(loadings_res,file=fname,sep="\t")
    
    fname<-paste("Tables/PCAscores_",filename,"features.txt",sep="")
    
    #save(classlabels_orig,scores_res,file="c2.Rda")
    
    classlabels_orig<-classlabels_orig[match(rownames(scores_res),classlabels_orig[,1]),]
    scores_res1<-cbind(classlabels_orig,scores_res)
    
    
    write.table(scores_res1,file=fname,sep="\t",row.names=FALSE)
    
    #pcnum_limit<-res$numcomp_plot #min(2,dim(scores_res)[2])
    
    get_pooled_sp<-function(n1,n2,S1,S2){a<-(n1-1)*S1;b<-(n2-1)*S2;c<-(n1+n2-2);return((a+b)/c)}
    
    
    if(analysistype=="regression"){
      
      
      df.sub1<-cbind(classlabels_orig[,2],scores_res[,1])
      
      
      colnames(df.sub1)<-c("Outcome","PCscore")
      df.sub1<-as.data.frame(df.sub1)
      
      s1<-summary(df.sub1$PCscore)
      sadj=(s1[5]-s1[3])*0.5
      
      plot_res<-suppressMessages(ggscatter(df.sub1,x="Outcome",y="PCscore",xlab="Outcome",ylab="PC1score",
                          title="Outcome vs PC1 scores scatter plot",col="darkblue",
                          palette="jco", shape = 20, size = 3, # Points color, shape and size
                          add = "reg.line",  # Add regressin line
                          add.params = list(color = "#0072B2", fill = "lightgray"), # Customize reg. line
                          conf.int = TRUE))+theme(plot.title = element_text(hjust = 0.5,size=10))+stat_cor(method = "spearman",
                                                                                                          label.y=max(df.sub1$PCscore+sadj))
      
      suppressMessages(print(plot_res))
      if(pcnum_limit>1){
      df.sub1<-cbind(classlabels_orig[,2],scores_res[,2])
      df.sub1<-as.data.frame(df.sub1)
      colnames(df.sub1)<-c("Outcome","PCscore")
      
      s1<-summary(df.sub1$PCscore)
      sadj=(s1[5]-s1[3])*0.5
      
      plot_res<-suppressMessages(ggscatter(df.sub1,x="Outcome",y="PCscore",xlab="Outcome",ylab="PC2score",
                          title="Outcome vs PC2 scores scatter plot",col="darkblue",
                          palette="jco", shape = 20, size = 3, # Points color, shape and size
                          add = "reg.line",  # Add regressin line
                          add.params = list(color = "#0072B2", fill = "lightgray"), # Customize reg. line
                          conf.int = TRUE))+theme(plot.title = element_text(hjust = 0.5,size=10))+stat_cor(method = "spearman",
                                                                                                          label.y=max(df.sub1$PCscore+sadj))
      
      
      suppressMessages(print(plot_res))
      }
      
      if(pcnum_limit>2){
      df.sub1<-cbind(classlabels_orig[,2],scores_res[,3])
      
      df.sub1<-as.data.frame(df.sub1)
      colnames(df.sub1)<-c("Outcome","PCscore")
      
      s1<-summary(df.sub1$PCscore)
      sadj=(s1[5]-s1[3])*0.5
      
      plot_res<-suppressMessages(ggscatter(df.sub1,x="Outcome",y="PCscore",xlab="Outcome",ylab="PC3score",
                          title="Outcome vs PC3 scores scatter plot",col="darkblue",
                          palette="jco", shape = 20, size = 3, # Points color, shape and size
                          add = "reg.line",  # Add regressin line
                          add.params = list(color = "#0072B2", fill = "lightgray"), # Customize reg. line
                          conf.int = TRUE))+theme(plot.title = element_text(hjust = 0.5,size=10))+stat_cor(method = "spearman",
                                                                                                          label.y=max(df.sub1$PCscore+sadj))
      
      suppressMessages(print(plot_res))
      }
      
      
    }else{
      
      class_levels<-levels(as.factor(classlabels_orig[,2]))
      
      
      if(alphabetical.order==FALSE){
        classlabels_orig[,2]<- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
        
        if(dim(classlabels_orig)[2]>2){
          
          classlabels_orig[,3]<- factor(classlabels_orig[,3], levels=unique(classlabels_orig[,3]))
        }
      }
      
      
      
      #sample.col.opt=lineplot.col.opt
      
      {
        if(sample.col.opt=="default"){
          
          col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
                     "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
                     "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
                     "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
          
        }else{
          if(sample.col.opt=="topo"){
            #col_vec<-topo.colors(256) #length(class_labels_levels))
            
            #col_vec<-col_vec[seq(1,length(col_vec),)]
            
            col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            if(sample.col.opt=="heat"){
              #col_vec<-heat.colors(256) #length(class_labels_levels))
              
              col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
            }else{
              if(sample.col.opt=="rainbow"){
                #col_vec<-heat.colors(256) #length(class_labels_levels))
                col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
                
                #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
              }else{
                
                if(sample.col.opt=="terrain"){
                  #col_vec<-heat.colors(256) #length(class_labels_levels))
                  #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
                  
                  col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
                }else{
                  
                  if(sample.col.opt=="colorblind"){
                    
                    if(length(class_labels_levels)<9){
                      
                      col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                      
                    }else{
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                                 "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                      
                      
                    }
                    
                    
                  }else{
                    
                    check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                    
                    if(length(check_brewer)>0){
                      
                      sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                      
                      col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                      
                    }else{
                      
                      if(sample.col.opt=="journal"){
                        
                        
                        col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                   "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                   "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                   
                                   "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                   "#E64B3519","#4DBBD519","#631879E5","grey75")
                        if(length(class_labels_levels)<8){
                          col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                          
                          #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                          
                        }else{
                          if(length(class_labels_levels)<=28){
                            # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                            
                            col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                       "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                       "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                       
                                       "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                       "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                            
                          }else{
                            
                            
                            
                            
                            colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                            
                            col_vec<-col_vec[sample(col_vec)]
                            
                            
                          }
                        }
                        
                      }else{
                        #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                      #  if(length(sample.col.opt)==1){
                          
                          ###save(sample.col.opt,file="sample.col.opt.Rda")
                          ###save(class_labels_levels,file="class_labels_levels.Rda")
                       #   col_vec <-rep(sample.col.opt,length(class_labels_levels))
                      #  }else{
                          #fixthis2
                          #colfunc <-colorRampPalette(sample.col.opt)
                          
                       #   col_vec<-sample.col.opt #colfunc(length(class_labels_levels))
                          
                        #}
                        
                        if(length(sample.col.opt)==1){
                          col_vec <-rep(sample.col.opt,length(class_labels_levels))
                        }else{
                          
                          #if(length(sample.col.opt)>=length(class_labels_levels)){
                            
                            col_vec <-sample.col.opt
                            #col_vec <- rep(col_vec,length(class_labels_levels))
                            
                            
                          #}else{
                          #  colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                          #}
                          
                        }
                      }
                    }
                    
                  }
                  
                }
              }
              
            }
            
          }
        }
      }
      df_matrix<-{}
      
      
      #lineplot.lty.option={}
      
      
      
      class_levels<-levels(as.factor(classlabels_orig[,2]))
      
      
      
      if(length(class_levels)>6){
        
        lineplot.lty.option=c(lineplot.lty.option,rep("solid",(length(class_levels)-6)))
      }
      #if(filename=="all")
      {
        
        
        fname<-paste("PCAloadings_",filename,"features.txt",sep="")
        
        loadings_res<-res$rotation
        scores_res<-res$x
        
        loadings_res<-round(loadings_res,2)
        scores_res<-round(scores_res,2)
        
        if(dim(loadings_res)[2]>10){
          loadings_res<-loadings_res[,c(1:10)]
          scores_res<-scores_res[,c(1:10)]
        }
        #   ##save(res,file="res.Rda")
        # write.table(loadings_res,file=fname,sep="\t")
        
        fname<-paste("PCAscores_",filename,"features.txt",sep="")
        
        scores_res1<-cbind(classlabels_orig,scores_res)
        
        
        # write.table(scores_res1,file=fname,sep="\t",row.names=FALSE)
        
        
      }
      
      #pcnum_limit<-res$numcomp_plot #min(5,dim(scores_res)[2])
      
      get_pooled_sp<-function(n1,n2,S1,S2){a<-(n1-1)*S1;b<-(n2-1)*S2;c<-(n1+n2-2);return((a+b)/c)}
      #S2<-cov(scores_res[16:46,1:2])
      #S1<-cov(scores_res[1:15,1:2])
      
      if(alphabetical.order==FALSE){
        
        
      }
      class_levels<-levels(as.factor(classlabels_orig[,2]))
      
      #if(length(class_labels_levels)==2)
      if(do_pca_anova==TRUE)
      {
        if(FALSE){
          h1<-hotelling.test(scores_res[1:num_samps_group[[1]],c(1)],scores_res[(1+num_samps_group[[1]]):(num_samps_group[[1]]+num_samps_group[[2]]),c(1)],shrinkage=FALSE)
          print("Hotelling test using PC1: ")
          print(h1)
          
          h2<-hotelling.test(scores_res[1:num_samps_group[[1]],c(2)],scores_res[(1+num_samps_group[[1]]):(num_samps_group[[1]]+num_samps_group[[2]]),c(2)],shrinkage=FALSE)
          print("Hotelling test using PC2: ")
          print(h2)
          
          h3<-hotelling.test(scores_res[1:num_samps_group[[1]],c(3)],scores_res[(1+num_samps_group[[1]]):(num_samps_group[[1]]+num_samps_group[[2]]),c(3)],shrinkage=FALSE)
          print("Hotelling test using PC3: ")
          print(h3)
        }
        
        pc_pval_vec<-{}
        
        
        
        for(pcnum in 1:pcnum_limit){
          
          pc1_pval<-anova(lm(cbind(scores_res[,pcnum])~classlabels_orig[,2]))
          pc1_pval<-round(pc1_pval[[5]][1],3)
          pc_pval_vec<-c(pc_pval_vec,pc1_pval)
        }
        
        
        
        
      }
      # #savenum_samps_group,scores_res,file="HotellingTestInput.Rda")
      #h1<-hotelling.test(scores_res[1:15,c(4:5)],scores_res[16:46,c(4:5)],shrinkage=FALSE)
      #h1<-hotelling.test(scores_res[1:15,c(2:3)],scores_res[16:46,c(2:3)],shrinkage=FALSE)
      
      df_matrix<-{}
      
      #keeps the class order same as in the input file; avoids arrangement by alphabetical order
      if(alphabetical.order==FALSE){
        classlabels_orig[,2] <- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
      }
      
      class_col_vec=col_vec
      
     # save(res,classlabels_orig,file="df1.Rda")
      #save(pc_pval_vec,file="pc_pval_vec.Rda")
      
      #if(pairedanalysis==TRUE)
      {
        if(dim(classlabels_orig)[2]>2){
          class_levels<-levels(as.factor(classlabels_orig[,2]))
          t1<-table(classlabels_orig[,3])
          
          for(c in 1:length(class_levels))
          {
            
            
            #  class_col_vec[which(classlabels[,2]==class_levels[c])]<-col_vec[c]
            
            
          }
          #print("Doing two factors")
          
          # for(pc in 1:pcnum_limit)
          lapply(1:pcnum_limit,function(pc)
          {
            
            ylabel_text=paste("PC",pc,"score",sep="")
            
            classlabels_orig<-as.data.frame(classlabels_orig)
            classgroup<-as.data.frame(classgroup)
            res$x<-as.data.frame(res$x)
            if(pairedanalysis==FALSE){
              df<-cbind(res$x[,pc],classgroup,classlabels_orig[,2],classlabels_orig[,3])
              
              mzname<-paste("PC",pc," scores distribution with 95% confidence interval \n in each group using ",filename," feats vs factors",sep="")
              
            }else{
              
              
              df<-cbind(res$x[,pc],classgroup,classlabels_orig[,2],classlabels_orig[,3])
              
              mzname<-paste("PC",pc," scores distribution with 95% confidence interval \n in each group using ",filename," feats vs time",sep="")
              
            }
            
            fname<-paste("pc_",pc,"_scoreplot",".tiff",sep="")
            par_rows=3
            
            colnames(df)<-c("y","x","Class","time")
            df=as.data.frame(df)
            df$y<-as.numeric(as.character(df$y))
            
            
            
           #save(df,file="df.Rda")
            
            df_fname<-paste("dftable_pc",pc,".txt",sep="")
            
            if(pc>1){
              if(pc==2){
                PC2Score=df[,1]
                df_matrix<-cbind(df_matrix,PC2Score)
              }else{
                
                
                PC3Score=df[,1]
                df_matrix<-cbind(df_matrix,PC3Score)
                
                
              }
            }else{
              PC1Score<-df[,1]
              df_matrix<-cbind(df[,-c(1)],PC1Score)
              
            }
            
            if(alphabetical.order==FALSE){
              df$Class <- factor(df$Class, levels=unique(df$Class))
              df$time <- factor(df$time, levels=unique(df$time))
              
            }
            
            
            df.summary <- aggregate(df$y,
                                    by = list(df$Class,df$time),
                                    FUN = function(y) c(ysd = sd(y),
                                                        yse =sd(y)/sqrt(length(y)),
                                                        Score = mean(y),number=length(y)))
           # save(df.summary,file="df.summary.Rda")
            df.summary<-do.call(data.frame, df.summary)
            
            df.summary<-cbind(df.summary[,c(1,3,4,5,6,1,2)])
            
            colnames(df.summary)<-c("x","sd","se","PCscore","number","Class","time")
            df.summary<-as.data.frame(df.summary)
            
            ymax = df.summary$PCscore + 1.96* df.summary$se
            
            ymin =  df.summary$PCscore - 1.96* df.summary$se
            
            max_yval<-ceiling(max((df.summary$PCscore + (6* df.summary$se)),na.rm=TRUE)) #round(max( df.summary$Intensity+(4* df.summary$se),na.rm=TRUE))
            
            
            min_yval<-floor(min((df.summary$PCscore - (6*df.summary$se)),na.rm=TRUE))
            
            class_levels_time<-levels(as.factor(classlabels_orig[,3]))
            
            df.summary$Class<-as.numeric(as.factor(df.summary$Class))
            
            Class<-{}
            for(cnum in 1:length(class_levels)){
              
              Class<-c(Class,rep(class_levels[cnum],length(t1)))
              
              df.summary$Class[which(df.summary$Class==cnum)]<-class_levels[cnum]
              
            }
            
            df_time<-df.summary$time
            df.summary$time<-as.numeric(as.factor(df.summary$time))
            
            
            Class<-unique(Class)
            if(alphabetical.order==FALSE){
              df.summary$Class <- factor(df.summary$Class, levels=unique(df.summary$Class))
            }
            ###save(df.summary,file="df.summary.Rda")
            df.summary$x<- df.summary$time
            
            #savelist=ls(),file="pcadebugfactor.Rda")
            
            shape_vec=c(0:2,5:25)
            t1shape=levels(factor(df.summary$Class))
            
            shape_vec1<-df.summary$Class
            
            for(i in 1:length(t1shape)){
              shape_vec1[which(shape_vec1==t1shape[i])]<-shape_vec[i]
            }
            
            
            pca_plot_fname<-paste("pca_plots_",pc,".Rda",sep="")
            
            unique_class_col_vec=unique(class_col_vec)
            
            #save(df.summary,shape_vec1,df_time,col_vec,classlabels,
            #  classgroup,classlabels_orig,unique_class_col_vec,class_col_vec,ymin,ymax,pca.cex.val,df_time,file=pca_plot_fname)
            
            
            if(pairedanalysis==TRUE){
              
              
              sizeval=1.5
              #plot.margin=unit(c(10,8,8,8),"mm"),
              
              #+ labs(color = "Class")
              shape_vec1<-as.numeric(as.character(shape_vec1))
              
              
              
              
              plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(x), y = PCscore,
                                                                color = as.factor(Class),linetype=Class)) + 
                                           labs(color = "Class",linetype="Class") + 
                                           geom_point(size = pca.cex.val,shape=shape_vec1) + 
                                           geom_line(aes(group =as.factor(Class)),size=sizeval) + 
                                           geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1) + 
                                           xlab("TimePoint") + theme_bw() + 
                                           theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                 panel.grid.minor = element_blank(),
                                                 axis.line = element_line(colour = "black",size=sizeval),
                                                 axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                 
                                                 strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                 strip.text = element_text(face="bold")) + 
                                           scale_y_continuous(breaks = scales::pretty_breaks(n = 10)))
              
              
              
              if(length(unique_class_col_vec)==1){
                plot_res<-plot_res+scale_color_manual(values=rep(unique(class_col_vec),length(class_labels_levels)))
                
              }else{
                plot_res<-plot_res+scale_color_manual(values=unique(class_col_vec))
              }
              
              plot_res<-plot_res+scale_x_discrete(name ="Time",labels=as.factor(unique(df_time)))
              
              plot_res<-plot_res+theme(legend.text = element_text(size = 11*cex.plots))+guides(fill = guide_legend(title = NULL))+theme(axis.text.x = element_text(angle = 45, hjust = 1))
              
              #if(FALSE)
              {
                plot_res<-plot_res+guides(fill = guide_legend(title = FALSE),colour=FALSE)+guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))
              }
              
              #  plot_res<-plot_res+guides(fill = guide_legend(title = FALSE),colour=FALSE)+guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))
              
              # plot_res+guides(color=FALSE,linetype=FALSE)
              
              
            }else{
              
              
              
              if(timeseries.lineplots==TRUE){
                
                
                shape_vec1<-as.numeric(as.character(shape_vec1))
                sizeval=1.5
                
                
                if(is.na(lineplot.lty.option)==TRUE){
                  plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(x), y = PCscore,colour = as.factor(Class),linetype=Class)) + geom_point(size = pca.cex.val,shape=shape_vec1) + geom_line(aes(group =Class),size=sizeval)  + labs(colour = "Class") + geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1)  + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                                                                                                           panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                                                                                                                                                                                                                                                                                                           axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                                                                                                                                                                                                                                                                                                                           strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                                                                                                           strip.text = element_text(face="bold")) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)))
                }else{
                  plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(x), y = PCscore,colour = as.factor(Class))) + geom_point(size = pca.cex.val,shape=shape_vec1) + geom_line(aes(group =Class),size=sizeval)  + labs(colour = "Class") + geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1)  + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                                                                                            panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                                                                                                                                                                                                                                                                                            axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                                                                                                                                                                                                                                                                                                            strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                                                                                            strip.text = element_text(face="bold")) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)))
                }
                
                
                if(length(unique_class_col_vec)==1){
                  plot_res<-plot_res+scale_color_manual(values=rep(unique(class_col_vec),length(class_labels_levels)))
                  
                }else{
                  plot_res<-plot_res+scale_color_manual(values=unique(class_col_vec))
                }
                plot_res<-plot_res+scale_x_discrete(name ="Time",labels=unique(df_time))
                plot_res<-plot_res+theme(legend.text = element_text(size = 11*cex.plots))+guides(fill = guide_legend(title = NULL))
                
                #legend.labs=levels(factor(df.summary$Class)), color = "strata")
                #plot.margin = unit(c(25,25,5.5,28), "pt"),
                
                uniq_class<-unique(df.summary$Class)
                plot_res<-plot_res+guides(fill = guide_legend(title = FALSE),colour=FALSE)+guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))+theme(axis.text.x = element_text(angle = 45, hjust = 1))
                
                
                
                #    plot_res<-plot_res+guides(linetype=FALSE)
                
              }else{
                sizeval=1.5
                
                
                
                plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(x), y = PCscore,color = as.factor(Class))) + geom_point(size = pca.cex.val,shape=shape_vec1) + labs(color = "Class") +  geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1) + xlab("") + scale_color_manual(values=unique(class_col_vec)) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                                                                                                         panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                                                                                                                                                                                                                                                                                                         axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                                                                                                                                                                                                                                                                                                                         strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                                                                                                         strip.text = element_text(face="bold")) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)) + scale_fill_manual(values=unique(class_col_vec)))
                
                
                plot_res<-plot_res+theme(legend.text = element_text(size = 11*cex.plots))+guides(fill = guide_legend(title = NULL))
                
                
                plot_res<-plot_res+scale_x_discrete(name ="Factor2",labels=as.factor(unique(df_time)))
                
                plot_res<-plot_res+guides(fill = guide_legend(title = FALSE),colour=FALSE)+guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))+theme(axis.text.x = element_text(angle = 45, hjust = 1))
                
                
              }
              
              
              
            }
            
            plot_res<-plot_res + ggtitle(mzname)
            
            plot_res<-plot_res + theme(plot.title = element_text(size=8))
            # x axis title
            plot_res<-plot_res + theme(axis.title.x = element_text(size=14*cex.plots))
            # y axis title
            plot_res<-plot_res + theme(axis.title.y = element_text(size=14*cex.plots))+theme(axis.text.x = element_text(angle = 45, hjust = 1,size=11**cex.plots))
            
            # plot_res<-plot_res + theme(axis.title.x=element_blank(),axis.text.x=element_blank(),axis.ticks.x=element_blank())
            
            
            #plot_res
            print(plot_res)
            
          })
          
          ##############
        }else{
          
          if(alphabetical.order==FALSE){
            classgroup <- factor(classgroup, levels=unique(classgroup))
          }
          class_levels<-levels(as.factor(classgroup))
          t1<-table(classgroup)
          
          
          for(c in 1:length(class_levels))
          {
            
            
            class_col_vec[which(as.factor(classgroup)==class_levels[c])]<-col_vec[c]
            
            
          }
          
          # for(pc in 1:pcnum_limit)
          
          
          #save(classgroup,class_levels,pcnum_limit,classlabels_orig,res,pairedanalysis,col_vec,pc_pval_vec,file="debuglpA.Rda")
          lapply(1:pcnum_limit,function(pc)
          {
            ylabel_text<-paste("PC",pc,"score",sep="")
            df<-cbind(res$x[,pc],as.character(classlabels_orig[,2]),as.character(classlabels_orig[,2]))
            
            df=as.data.frame(df)
            
            if(pairedanalysis==FALSE){
              #  mzname<-paste("PC",pc," scores distribution (25th percentile, median, 75th percentile) \n in each group using ",filename," feats vs factors (p=",pc_pval_vec[pc],")",sep="")
              
              mzname<-paste("PC",pc," scores distribution with 95% confidence interval in each group using ",filename," feats vs factors (p=",pc_pval_vec[pc],")",sep="")
            }else{
              
              #mzname<-paste("PC",pc," scores distribution (25th percentile, median, 75th percentile) \n in each group using ",filename," feats vs time",sep="")
              mzname<-paste("PC",pc," scores distribution with 95% confidence interval in each group using ",filename," feats vs time (p=",pc_pval_vec[pc],")",sep="")
              
            }
            
            fname<-paste("pc_",pc,"_scoreplot",".tiff",sep="")
            par_rows=3
            
            colnames(df)<-c("y","x","Class")
            df=as.data.frame(df)
            df$y<-as.numeric(as.character(df$y))
            
            
            
            #savedf,file="pcadf.Rda")
            
            df_fname<-paste("dftable_pc",pc,".txt",sep="")
            # write.table(df,file=df_fname,sep="\t",row.names=FALSE)
            
            if(pc>1){
              if(pc==2){
                PC2Score=df[,1]
                df_matrix<-cbind(df_matrix,PC2Score)
              }else{
                
                
                PC3Score=df[,1]
                df_matrix<-cbind(df_matrix,PC3Score)
                
                
              }
            }else{
              PC1Score<-df[,1]
              df_matrix<-cbind(df[,-c(1)],PC1Score)
              
            }
            
            
            if(FALSE){
              df.summary <- aggregate(df$y,
                                      by = list(df$Class),
                                      FUN = function(y) c(ymin = quantile(y,0.25),
                                                          ymax = quantile(y,0.75),
                                                          Score = median(y),number=length(y)))
            }
            
            if(alphabetical.order==FALSE){
              df$Class <- factor(df$Class, levels=unique(df$Class))
              
              
            }
            df.summary <- aggregate(df$y,
                                    by = list(df$Class),
                                    FUN = function(y) c(ysd = sd(y),
                                                        yse =sd(y)/sqrt(length(y)),
                                                        Score = mean(y),number=length(y)))
            
            df.summary<-do.call(data.frame, df.summary)
            
            df.summary<-cbind(df.summary[,c(1,2:5,1)])
            
            colnames(df.summary)<-c("x","sd","se","PCscore","number","Class")
            df.summary<-as.data.frame(df.summary)
            ymax = df.summary$PCscore + 1.96* df.summary$se
            
            df.summary<-as.data.frame(df.summary)
            
            ymin =  df.summary$PCscore - 1.96* df.summary$se
            
            max_yval<-ceiling(max((df.summary$PCscore + (6* df.summary$se)),na.rm=TRUE)) #round(max( df.summary$Intensity+(4* df.summary$se),na.rm=TRUE))
            
            
            min_yval<-floor(min((df.summary$PCscore - (6*df.summary$se)),na.rm=TRUE))
            
            # ##save(df.summary,ymin,ymax,classlabels_orig,class_levels,file="df.summary.Rda")
            
            time.hour<- c(unique(as.character(classlabels_orig[,2])),
                          unique(as.character(classlabels_orig[,2])))
            
            
            ##save(df.summary,class_col_vec,pca.cex.val,file="pca_plots.Rda")
            
            
            sizeval=1.5
            
            #save(df.summary,df,pca.cex.val,class_levels,class_labels_levels,pairedanalysis,timeseries.lineplots,ymin,ymax,
            #class_col_vec,sizeval,classlabels_orig,file="pcad1plotB.Rda")
            
            
            
            {
              if(pairedanalysis==FALSE){
                
                if(timeseries.lineplots==TRUE){
                  sizeval=1.5
                  plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(Class), y = PCscore,group=1)) 
                                             + geom_point(size = cex.plots) + geom_line(size=sizeval)
                                             + geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1) + xlab("") 
                                             + scale_color_manual(values=unique(class_col_vec)) + scale_size_manual(values=c(sizeval)) 
                                             + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                  panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                  axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                                  strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                  strip.text = element_text(face="bold")) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)))
                  
                  plot_res<-plot_res+scale_x_discrete(name ="Time",labels=unique(df.summary$Class))
                  plot_res<-plot_res+theme(legend.text = element_text(size = 12))+guides(fill = guide_legend(title = NULL))
                  
                  
                }else{
                  
                  sizeval=1.5
                  # #save(df.summary,pca.cex.val,ymin,ymax,sizeval,class_col_vec,cex.plots,file="debug1.Rda")
                  if(length(unique(class_col_vec))==1){  
                    if(length(unique(class_col_vec))==1 && analysistype=="regression"){
                      
                      df.sub1<-df.summary[,c("x","PCscore")]
                      df.sub1<-apply(df.sub1,2,as.numeric)
                      df.sub1<-as.data.frame(df.sub1)
                      
                      s1=summary(df.sub1$PCscore)
                      
                      sadj=(s1[5]-s1[3])*ypos.adj.factor
                      
                      plot_res<-suppressMessages(ggscatter(df.sub1,x="x",y="PCscore",xlab="Outcome",col=class_col_vec,
                                          palette="jco", shape = 20, size = 3, # Points color, shape and size
                                          add = "reg.line",  # Add regressin line
                                          add.params = list(color = "#0072B2", fill = "lightgray"), # Customize reg. line
                                          conf.int = TRUE))+stat_cor(method = "spearman",
                                 #aes(label = paste(..r.label.., ..p.label..),
                                 label.x = 3,label.y=max(df.sub1$PCscore+sadj)
                      )
                      
                      
                      
                      
                    }else{
                      plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(Class), y = PCscore)
                                                        + geom_point(size = pca.cex.val) +
                                                          geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1) + xlab("") +
                                                          theme_bw() +
                                                          scale_size_manual(values=c(sizeval)) +
                                                          theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                                strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                strip.text = element_text(face="bold")) +
                                                          scale_y_continuous(breaks = scales::pretty_breaks(n = 10))))
                      
                    }
                    
                    #   if(length(unique_class_col_vec)==1){
                    plot_res<-plot_res+scale_color_manual(values=class_col_vec) #rep(unique(class_col_vec),length(class_labels_levels)))
                    
                    plot_res<-plot_res+theme(legend.title = element_blank())
                    
                    # plot_res<-plot_res+theme(legend=FALSE)
                  }else{
                    #   print("here1")
                    
                    plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(Class), y = PCscore,color = as.factor(Class))) 
                                               + geom_point(size = pca.cex.val) + labs(color = "Class") + 
                                                 geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1) + xlab("") +
                                                 scale_color_manual(values=unique(class_col_vec)) + theme_bw() +
                                                 scale_size_manual(values=c(sizeval)) + 
                                                 theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                       axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                       strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                       strip.text = element_text(face="bold")) + 
                                                 scale_y_continuous(breaks = scales::pretty_breaks(n = 10)))
                    plot_res<-plot_res+scale_x_discrete(name ="",labels=as.factor(class_levels))
                    plot_res<-plot_res+theme(legend.text = element_text(size = 11*cex.plots))+guides(fill = guide_legend(title = NULL))
                    
                  }
                  
                  
                  #,legend.position="none",
                }
              }else{
                #print("here2")
                
                 #save(df.summary,pca.cex.val,ymin,ymax,class_col_vec,class_levels,classgroup,file="t1.Rda")
                sizeval=1.5
                plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(x), y = PCscore,group=1)) +  geom_point(size = pca.cex.val) + geom_line(size=sizeval) + geom_errorbar(aes(ymin = ymin, ymax = ymax),size=1,width=0.1) + scale_color_manual(values=unique(class_col_vec)) + scale_size_manual(values=c(sizeval)) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                                                                                                     panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                                                                                                                                                                                                                                                                                                     axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=16*cex.plots,face="bold"),
                                                                                                                                                                                                                                                                                                                                                     strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                                                                                                     strip.text = element_text(face="bold")) + scale_y_continuous(breaks = scales::pretty_breaks(n = 10)))
                
                #plot_res<-plot_res+suppressWarnings(scale_x_discrete(name ="Time",labels=unique(Class)))
                plot_res<-plot_res+scale_x_discrete(name ="",labels=as.factor(class_levels))
                plot_res<-plot_res+theme(legend.text = element_text(size = 11*cex.plots))+guides(fill = guide_legend(title = NULL))
                
                
                
              }
            }
            
            
            plot_res<-plot_res + ggtitle(mzname)
            
            plot_res<-plot_res + theme(plot.title = element_text(size=8))
            # x axis title
            plot_res<-plot_res + theme(axis.title.x = element_text(size=14*cex.plots))
            # y axis title
            plot_res<-plot_res + theme(axis.title.y = element_text(size=14*cex.plots))+theme(axis.text.x = element_text(angle = 45, hjust = 1,size=11*cex.plots))
            
            #    plot_res<-plot_res + theme(axis.title.x=element_blank(),axis.text.x=element_blank(),axis.ticks.x=element_blank())
            
            suppressMessages(print(plot_res))
            
          })
        }
        
      }
    }
  }
  
  df_fname<-paste("PC_score_distribution_matrix_",filename,"features.txt",sep="")
  
  if(newdevice==TRUE){
    
    dev.off()
  }
  
  return(res)
}







get_biorep.cor.plots<-function(X=NA,Y=NA,feature_table_file=NA,parentoutput_dir=NA,
                               class_labels_file=NA,alphacol=0.3,col_vec=NA,pairedanalysis=FALSE,
                               point.cex.val=4,legendlocation="topright",pca.ellipse=TRUE,
                               ellipse.conf.level=0.95,filename="QC_Correlation.Intragroup.Replicates",newdevice=TRUE,
                               lineplot.col.opt=c("grey57"),ylabel="Intensity",error.bar=TRUE,
                               cex.plots=0.8,
                               lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),
                               timeseries.lineplots=FALSE,name=NA,study.design="oneway",
                               alphabetical.order=TRUE,output.format="pdf",multiple.figures.perpanel=TRUE)
{
  
  
  cex.val=cex.plots
  
  suppressMessages(library(ggpubr))
  suppressMessages(library(ggplot2))
  
  analysistype=study.design
  
  if(is.na(parentoutput_dir)==TRUE){
    
    parentoutput_dir=getwd()
  }
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  }else{
    
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
  }else{
    
    classlabels<-Y
  }
  
  #addition start
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame(data_matrix)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  
  #addition end
  
  sample.col.opt=lineplot.col.opt
  
  par(mfrow=c(1,1),family="sans",cex=cex.val)
  
  #print("here")
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  mzvec<-data_matrix[,1]
  rtvec<-data_matrix[,2]
  
  rnames<-paste(mzvec,rtvec,sep="_")
  
  
  if(is.na(name[1])==TRUE){
    
    #mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
    rownames(data_m)<-as.character(rnames)
  }else{
    
    rownames(data_m)<-name
    
    rnames<-name
  }
  
  #  rownames(data_m)<-as.character(rnames)
  
  
  classlabels_orig<-classlabels
  
  if(analysistype=="onewayrepeat" | analysistype=="twowayrepeat" | analysistype=="onewayanovarepeat" | analysistype=="twowayanovarepeat"){
    
    pairedanalysis=TRUE
  }
  
  if(pairedanalysis==TRUE){
    
    # paireddesign=classlabels_orig[,2]
    
    #classlabels_orig<-classlabels_orig[,-c(2)]
  }
  
  if(dim(classlabels_orig)[2]>2){
    
    #classlabels_orig[,2]<-as.factor(paste("A",as.character(classlabels_orig[,2]),sep=""))
    #classlabels_orig[,3]<-as.factor(paste("B",as.character(classlabels_orig[,3]),sep=""))
    # print(head(classlabels_orig))
    
    if(analysistype=="twoway" | analysistype=="twowayrepeat" | analysistype=="twowayanova"){
      
      classgroup<-paste(classlabels_orig[,2],":",classlabels_orig[,3],sep="") #classlabels_orig[,2]:classlabels_orig[,3]
      do_pca_anova=FALSE
    }else{
      classgroup<-classlabels_orig[,2]
      do_pca_anova=TRUE
    }
    
    col_class_levels<-levels(as.factor(classlabels_orig[,2]))
  }else{
    
    classgroup<-classlabels_orig[,2]
    col_class_levels<-levels(as.factor(classlabels_orig[,2]))
    
    do_pca_anova=TRUE
  }
  
  
  
  
  
  
  
  
  
  class_labels_levels<-levels(as.factor(classgroup))
  ordered_labels<-classgroup
  
  class_label_alphabets<-paste("C",1:length(class_labels_levels),sep="") #c("A","B","C","D","E","F","G","H","I","J","K","L","M")
  
  if(newdevice==TRUE){
    
    fname<-paste("",filename,".pdf",sep="")
    pdf(fname)
  }
  
  plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
  
  
 # text(5,9,"Description:",font=2,col="blue")
  text(5, 8, "This PDF includes QC plots to evaluate intra-group heterogeneity\n based on the mean pairwise Pearson correlation between \nthe biological replicates in each group.\n\n\n Note: Wider error bars indicate higher intra-group heterogeneity.",cex=0.9,font=2)
 # text(5, 7, "The figures include: ")
  #text(5, 6, "a. pairwise PC score plots ")
  #text(5, 5, "b. scores for individual samples on each PC")
  #text(5, 4, "c. Lineplots using PC scores for data with repeated measurements")
  
  
  if(is.na(sample.col.opt)==FALSE)
  {
    if(sample.col.opt=="default"){
      
      col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
                 "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
                 "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
                 "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
      
    }else{
      if(sample.col.opt=="topo"){
        #col_vec<-topo.colors(256) #length(class_labels_levels))
        
        #col_vec<-col_vec[seq(1,length(col_vec),)]
        
        col_vec <- topo.colors(length(col_class_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="heat"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          
          col_vec <- heat.colors(length(col_class_levels), alpha=alphacol)
        }else{
          if(sample.col.opt=="rainbow"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            col_vec<-rainbow(length(col_class_levels), start = 0, end = alphacol)
            
            #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="terrain"){
              #col_vec<-heat.colors(256) #length(class_labels_levels))
              #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
              
              col_vec <- cm.colors(length(col_class_levels), alpha=alphacol)
            }else{
              if(is.na(sample.col.opt)==TRUE){
                col_vec<-c("black")
              }else{
                
                if(sample.col.opt=="colorblind"){
                  #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                  # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                  
                  if(length(col_class_levels)<9){
                    
                    col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                    
                  }else{
                    
                    #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                               "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                    
                  }
                  
                  
                }else{
                  
                  check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                  
                  if(length(check_brewer)>0){
                    
                    sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                    
                    col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(col_class_levels))
                    
                  }else{
                    
                    #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    if(sample.col.opt=="journal"){
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                 "#E64B3519","#4DBBD519","#631879E5","grey75")
                      if(length(class_labels_levels)<8){
                        col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                        
                        #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                        
                      }else{
                        if(length(class_labels_levels)<=28){
                          # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                          
                          col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                     "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                     "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                     
                                     "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                     "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                          
                        }else{
                          
                          
                          
                          
                          colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                          
                          col_vec<-col_vec[sample(col_vec)]
                          
                          
                        }
                      }
                      
                      
                      
                    }else{
                      #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                      
                     # if(length(sample.col.opt)==1){
                      #  col_vec <-rep(sample.col.opt,length(col_class_levels))
                      #}else{
                        
                       # colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(col_class_levels))
                        
                        ##savecolfunc,file="colfunc.Rda")
                        
                    #  }
                      
                      if(length(sample.col.opt)==1){
                        col_vec <-rep(sample.col.opt,length(class_labels_levels))
                      }else{
                        
                        if(length(sample.col.opt)>=length(class_labels_levels)){
                          
                          col_vec <-sample.col.opt
                          col_vec <- rep(col_vec,length(class_labels_levels))
                          
                          
                        }else{
                          colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                        }
                        
                      }
                    }
                    
                  }
                  
                }
              }
            }
            
            
          }
          
        }
        
      }
    }
  }else{
    
    col_vec<-c("black")
    
  }
  
  #    print(class_labels_levels)
  
  ordered_labels={}
  num_samps_group<-new("list")
  num_samps_group[[1]]<-0
  groupwiseindex<-new("list")
  groupwiseindex[[1]]<-0
  
  class_col_vec=col_vec
  S<-new("list")
  for(c in 1:length(class_labels_levels))
  {
    
    classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
    
    num_samps_group[[c]]<-length(classlabels_index)
    groupwiseindex[[c]]<-classlabels_index
    
    
    
    
  }
  
  
  
  sampleclass<-{}
  patientcolors<-{}
  
  classlabels<-as.data.frame(classlabels)
  
  
  for(c in 1:length(class_labels_levels)){
    
    num_samps_group_cur=length(which(ordered_labels==class_labels_levels[c]))
    
    
    sampleclass<-c(sampleclass,rep(paste("Class",class_label_alphabets[c],sep=""),num_samps_group_cur))
    
    patientcolors <-c(patientcolors,rep(col_vec[c],num_samps_group[[c]]))
  }
  
  pca.cex.val=point.cex.val
  
  if(length(mzvec)>4){
    max_per_row<-3
    
    
    par_rows<-ceiling(9/max_per_row)
    
  }else{
    max_per_row<-length(mzvec)
    par_rows<-1
  }
  
  # The palette with black:
  #col_vec <- c("#E69F00","#000000","#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
  
  # To use for fills, add
  # scale_fill_manual(values=col_vec)
  
  # To use for line and point colors, add
  #scale_colour_manual(values=col_vec)
  
  file_ind<-0
  boxplots_fname<-paste("xyplots.pdf",sep="")
  
  if(dim(data_m)[1]>=1){
    
    
    t1<-table(classgroup)
    l1<-levels(classgroup)
    
    l1<-levels(as.factor(classgroup))
    
    
    patientcolors <- rep(col_vec[1:length(t1)], t1)
    
    
    get_pooled_sp<-function(n1,n2,S1,S2){a<-(n1-1)*S1;b<-(n2-1)*S2;c<-(n1+n2-2);return((a+b)/c)}
    
    
    class_levels<-levels(as.factor(classlabels_orig[,2]))
    
    
    df_matrix<-{}
    
    class_col_vec=col_vec
    
    if(dim(classlabels_orig)[2]>2){
      class_levels<-levels(as.factor(classlabels_orig[,2]))
      t1<-table(classlabels_orig[,3])
      
      
      
      
    #  save(classlabels_orig,classgroup,data_m,file="myData.Rda")
      
      
      myData<-cbind(classgroup,as.data.frame(classlabels_orig[,2]),as.data.frame(classlabels_orig[,3]),t(data_m))
      
      myData<-as.data.frame(myData)
      
      #
      if(alphabetical.order==FALSE){
        myData[,2] <- factor(myData[,2], levels=unique(myData[,2]))
        myData[,3] <- factor(myData[,3], levels=unique(myData[,3]))
        
      }
      
      
      
      
      c1<-WGCNA::cor(t(myData[,-c(1:3)]),use = 'pairwise.complete.obs')
      diag(c1)<-NA
      c2=cbind(myData[,c(1:3)],c1)
      
      myData_sum_cor<-{}
      levels_groups<-levels(as.factor(c2[,1]))
      
      myData_sum_cor<-lapply(levels_groups,function(g){
        
        x<-c1[which(c2[,1]==g),which(c2[,1]==g)]
        
        x<-as.numeric(as.character(x))
        se_val<-round(sd(x,na.rm=TRUE)/sqrt(length(x)),2)
        mean_val<-round(mean(x,na.rm=TRUE),2)
        upper.conf.limit=mean_val+1.96*se_val
        lower.conf.limit=mean_val-1.96*se_val
        
        y=as.data.frame(c(group=g,mean.Pearson.cor = mean_val, 
                          sd.Pearson.cor = round(sd(x,na.rm=TRUE),2),n = length(which(c2[,1]==g)),se.Pearson.cor=se_val,
                          lower.conf.limit=lower.conf.limit, 
                          upper.conf.limit=upper.conf.limit,
                          width.conf.interval=round(upper.conf.limit-lower.conf.limit,2)))
        colnames(y)<-NULL
        return(t(y))
        
      })
      
      myData_sum_cor<-ldply(myData_sum_cor,rbind)    
      myData_sum_cor<-as.data.frame(myData_sum_cor)
      
      write.table(myData_sum_cor,file="myData_sum_cor.txt",sep="\t")
      myData_sum_cor$mean.Pearson.cor<-as.numeric(as.character(myData_sum_cor$mean.Pearson.cor))
      myData_sum_cor$lower.conf.limit<-as.numeric(as.character(myData_sum_cor$lower.conf.limit))
      myData_sum_cor$upper.conf.limit<-as.numeric(as.character(myData_sum_cor$upper.conf.limit))
      
     # save(myData_sum_cor,sizeval,cex.val,class_col_vec,shape_vec1,file="mysamp.Rda")
      group_num<-gsub(myData_sum_cor$group,pattern=":[a-z|A-Z|0-9|_|-]*",replacement="")
      myData_sum_cor<-cbind(myData_sum_cor,group_num)
      Factor2<-gsub(myData_sum_cor$group,pattern="[a-z|A-Z|0-9|-|_]*:",replacement="")
      myData_sum_cor<-cbind(myData_sum_cor,Factor2)
      
      plot_sample_cor<-ggplot(myData_sum_cor,aes(y=mean.Pearson.cor,x=Factor2,color=Factor2))+
        geom_point()+facet_wrap(~group_num, scale="free_x")+
        geom_errorbar(aes(ymin=lower.conf.limit,ymax=upper.conf.limit))+ 
        theme_bw() + theme(panel.border = element_blank(), 
                                                                                                                                       panel.grid.major = element_blank(),
                                                                                                                                       panel.grid.minor = element_blank(),
                                                                                                                                       axis.line = element_line(colour = "black",size=1),
                                                                                                                                       axis.text= element_text(size=14*cex.val), 
                                                                                                                                       axis.title=element_text(size=16*cex.val,face="bold"),
                                                                                                                                       strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                       strip.text = element_text(face="bold"))+scale_y_continuous(name="mean Pearson correlation\nbetween biological replicates in each group",breaks = scales::pretty_breaks(n = 10))
      #plot_sample_cor<-plot_sample_cor+scale_color_manual(values=unique(class_col_vec))
      #plot_sample_cor<-plot_sample_cor+scale_x_discrete(name ="Class")
      plot_sample_cor<-plot_sample_cor+theme(axis.text.x = element_text(angle = 45, hjust = 1))
      #guides(fill = guide_legend(title = FALSE),colour=FALSE)+
      #  guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))+
      
      print(plot_sample_cor)
      if(newdevice==TRUE){
        try(dev.off())
        }
      #
    }
  }
}



#generate line plots
get_lineplots<-function(X=NA,Y=NA,feature_table_file=NA,parentoutput_dir=NA,
                        class_labels_file=NA,alphacol=0.3,col_vec=NA,pairedanalysis=FALSE,
                        point.cex.val=4,legendlocation="topright",pca.ellipse=TRUE,
                        ellipse.conf.level=0.95,filename="all",newdevice=FALSE,
                        lineplot.col.opt=c("journal"),ylabel="Intensity",error.bar=TRUE,
                        cex.plots=0.8,
                        lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),
                        timeseries.lineplots=FALSE,name=NA,study.design="oneway",
                        alphabetical.order=TRUE,output.format="pdf",
                        multiple.figures.perpanel=TRUE,sizeval=1.5,plot.height=8,plot.width=8)
{
  
  
  cex.val=cex.plots
  
  suppressMessages(library(ggpubr))
  suppressMessages(library(ggplot2))
  
  analysistype=study.design
  
  #lineplot.col.opt=tolower(lineplot.col.opt)
  if(length(lineplot.col.opt)==1){
  lineplot.col.opt=get_hexcolors_for_palettes(color.palette=lineplot.col.opt,alpha.col=alphacol[1])
  }
  
  if(is.na(parentoutput_dir)==TRUE){
    
    parentoutput_dir=getwd()
  }
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  }else{
    
    data_matrix<-X
  }
  if(typeof(Y)=="logical"){
    classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
  }else{
    
    classlabels<-Y
  }
  
  #addition start
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        name=Name
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          name=Name
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame(data_matrix)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  
  #addition end
  
  sample.col.opt=lineplot.col.opt
  
  par(mfrow=c(1,1),family="sans",cex=cex.val)
  
  #print("here")
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  mzvec<-data_matrix[,1]
  rtvec<-data_matrix[,2]
  
  rnames<-paste(mzvec,rtvec,sep="_")
  
  
  if(is.na(name[1])==TRUE){
    
    #mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
    rownames(data_m)<-as.character(rnames)
  }else{
    
    rownames(data_m)<-name
    
    rnames<-name
  }
  
  #  rownames(data_m)<-as.character(rnames)
  
  
  classlabels_orig<-classlabels
  
  if(analysistype=="onewayrepeat" | analysistype=="twowayrepeat" | analysistype=="onewayanovarepeat" | analysistype=="twowayanovarepeat"){
    
    pairedanalysis=TRUE
  }
  
  if(pairedanalysis==TRUE){
    
    # paireddesign=classlabels_orig[,2]
    
    #classlabels_orig<-classlabels_orig[,-c(2)]
  }
  
  if(dim(classlabels_orig)[2]>2){
    
    #classlabels_orig[,2]<-as.factor(paste("A",as.character(classlabels_orig[,2]),sep=""))
    #classlabels_orig[,3]<-as.factor(paste("B",as.character(classlabels_orig[,3]),sep=""))
    # print(head(classlabels_orig))
    
    if(analysistype=="twoway" | analysistype=="twowayrepeat" | analysistype=="twowayanova"){
      
      if(alphabetical.order==FALSE){
        
        classlabels_orig[,2]<-factor(classlabels_orig[,2],levels=unique(classlabels_orig[,2]))
        
        classlabels_orig[,3]<-factor(classlabels_orig[,3],levels=unique(classlabels_orig[,3]))
      }
      
      classgroup<-paste(classlabels_orig[,2],":",classlabels_orig[,3],sep="") #classlabels_orig[,2]:classlabels_orig[,3]
      do_pca_anova=FALSE
    }else{
      
      if(alphabetical.order==FALSE){
        
        classlabels_orig[,2]<-factor(classlabels_orig[,2],levels=unique(classlabels_orig[,2]))
      }
      
      
      classgroup<-classlabels_orig[,2]
      do_pca_anova=TRUE
    }
    
    col_class_levels<-levels(as.factor(classlabels_orig[,2]))
  }else{
    
    if(alphabetical.order==FALSE){
      
      classlabels_orig[,2]<-factor(classlabels_orig[,2],levels=unique(classlabels_orig[,2]))
    }
    
    classgroup<-classlabels_orig[,2]
    col_class_levels<-levels(as.factor(classlabels_orig[,2]))
    
    do_pca_anova=TRUE
  }
  
  
  
  
  
  
  
  
  
  class_labels_levels<-levels(as.factor(classgroup))
  ordered_labels<-classgroup
  
  class_label_alphabets<-paste("C",1:length(class_labels_levels),sep="") #c("A","B","C","D","E","F","G","H","I","J","K","L","M")
  
  if(newdevice==TRUE){
    
    fname<-paste("timeseriesplots",filename,".pdf",sep="")
    pdf(fname)
  }
  
  if(is.na(sample.col.opt)==FALSE)
  {
    if(sample.col.opt=="default"){
      
      col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
                 "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
                 "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
                 "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
      
    }else{
      if(sample.col.opt=="topo"){
        #col_vec<-topo.colors(256) #length(class_labels_levels))
        
        #col_vec<-col_vec[seq(1,length(col_vec),)]
        
        col_vec <- topo.colors(length(col_class_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="heat"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          
          col_vec <- heat.colors(length(col_class_levels), alpha=alphacol)
        }else{
          if(sample.col.opt=="rainbow"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            col_vec<-rainbow(length(col_class_levels), start = 0, end = alphacol)
            
            #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="terrain"){
              #col_vec<-heat.colors(256) #length(class_labels_levels))
              #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
              
              col_vec <- cm.colors(length(col_class_levels), alpha=alphacol)
            }else{
              if(is.na(sample.col.opt)==TRUE){
                col_vec<-c("black")
              }else{
                
                if(sample.col.opt=="colorblind"){
                  #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                  # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                  
                  if(length(col_class_levels)<9){
                    
                    col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                    
                  }else{
                    
                    #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                               "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                    
                  }
                  
                  
                }else{
                  
                  check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                  
                  if(length(check_brewer)>0){
                    
                    sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                    
                    col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(col_class_levels))
                    
                  }else{
                    
                    #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    if(sample.col.opt=="journal"){
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                 "#E64B3519","#4DBBD519","#631879E5","grey75")
                      if(length(class_labels_levels)<8){
                        col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                        
                        #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                        
                      }else{
                        if(length(class_labels_levels)<=28){
                          # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                          
                          col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                     "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                     "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                     
                                     "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                     "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                          
                        }else{
                          
                          
                          
                          
                          colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                          
                          col_vec<-col_vec[sample(col_vec)]
                          
                          
                        }
                      }
                      
                      
                      
                    }else{
                      #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                      
                    #  if(length(sample.col.opt)==1){
                       # col_vec <-rep(sample.col.opt,length(col_class_levels))
                      #}else{
                        
                       # colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(col_class_levels))
                        
                      #}
                      
                      
                      if(length(sample.col.opt)==1){
                        col_vec <-rep(sample.col.opt,length(class_labels_levels))
                      }else{
                        
                        #if(length(sample.col.opt)>=length(class_labels_levels)){
                          
                          col_vec <-sample.col.opt
                          col_vec <- rep(col_vec,length(class_labels_levels))
                          
                          
                        #}else{
                         # colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                        #}
                        
                      }
                      
                    }
                    
                  }
                  
                }
              }
            }
            
            
          }
          
        }
        
      }
    }
  }else{
    
    col_vec<-c("black")
    
  }
  
  #    print(class_labels_levels)
  
  ordered_labels={}
  num_samps_group<-new("list")
  num_samps_group[[1]]<-0
  groupwiseindex<-new("list")
  groupwiseindex[[1]]<-0
  
  
  col_vec=alpha(colour=col_vec,alpha=alphacol)
  
  class_col_vec=col_vec
  S<-new("list")
  for(c in 1:length(class_labels_levels))
  {
    
    classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
    
    num_samps_group[[c]]<-length(classlabels_index)
    groupwiseindex[[c]]<-classlabels_index
    
    
    
    
  }
  
  
  
  sampleclass<-{}
  patientcolors<-{}
  
  classlabels<-as.data.frame(classlabels)
  
  
  for(c in 1:length(class_labels_levels)){
    
    num_samps_group_cur=length(which(ordered_labels==class_labels_levels[c]))
    
    
    sampleclass<-c(sampleclass,rep(paste("Class",class_label_alphabets[c],sep=""),num_samps_group_cur))
    
    patientcolors <-c(patientcolors,rep(col_vec[c],num_samps_group[[c]]))
  }
  
  pca.cex.val=point.cex.val
  
  if(length(mzvec)>4){
    max_per_row<-3
    
    
    par_rows<-ceiling(9/max_per_row)
    
  }else{
    max_per_row<-length(mzvec)
    par_rows<-1
  }
  
  # The palette with black:
  #col_vec <- c("#E69F00","#000000","#56B4E9", "#009E73", "#F0E442", "#0072B2", "#D55E00", "#CC79A7")
  
  # To use for fills, add
  # scale_fill_manual(values=col_vec)
  
  # To use for line and point colors, add
  #scale_colour_manual(values=col_vec)
  
  file_ind<-0
  boxplots_fname<-paste("xyplots.pdf",sep="")
  
  if(dim(data_m)[1]>=1){
    
    
    t1<-table(classgroup)
    l1<-levels(classgroup)
    
    l1<-levels(as.factor(classgroup))
    
    
    patientcolors <- rep(col_vec[1:length(t1)], t1)
    
    
    get_pooled_sp<-function(n1,n2,S1,S2){a<-(n1-1)*S1;b<-(n2-1)*S2;c<-(n1+n2-2);return((a+b)/c)}
    
    
    class_levels<-levels(as.factor(classlabels_orig[,2]))
    
    
    df_matrix<-{}
    
    class_col_vec=col_vec
    
    if(dim(classlabels_orig)[2]>2){
      class_levels<-levels(as.factor(classlabels_orig[,2]))
      t1<-table(classlabels_orig[,3])
      
      
      
      
  #  save(classlabels_orig,classgroup,data_m,file="myData1.Rda")
      
      
      myData<-cbind(classgroup,as.data.frame(classlabels_orig[,2]),as.data.frame(classlabels_orig[,3]),t(data_m))
      
      myData<-as.data.frame(myData)
      
      #
      if(alphabetical.order==FALSE){
        myData[,2] <- factor(myData[,2], levels=unique(myData[,2]))
        myData[,3] <- factor(myData[,3], levels=unique(myData[,3]))
        t1=table(myData[,3])
      }
      
      
     # save(myData,file="myData_A.Rda")
     if(FALSE){ 
      c1<-WGCNA::cor(t(myData[,-c(1:3)]),use = 'pairwise.complete.obs')
      diag(c1)<-NA
      c2=cbind(myData[,c(1:3)],c1)
      
      myData_sum_cor<-{}
      levels_groups<-levels(as.factor(c2[,1]))
      
      myData_sum_cor<-lapply(levels_groups,function(g){
        
        x<-c1[which(c2[,1]==g),which(c2[,1]==g)]
        
        x<-as.numeric(as.character(x))
        se_val<-round(sd(x,na.rm=TRUE)/sqrt(length(x)),2)
        mean_val<-round(mean(x,na.rm=TRUE),2)
        upper.conf.limit=mean_val+1.96*se_val
        lower.conf.limit=mean_val-1.96*se_val
        
        y=as.data.frame(c(group=g,mean.Pearson.cor = mean_val, 
                          sd.Pearson.cor = round(sd(x,na.rm=TRUE),2),n = length(which(c2[,1]==g)),se.Pearson.cor=se_val,
          lower.conf.limit=lower.conf.limit, 
          upper.conf.limit=upper.conf.limit,
          width.conf.interval=round(upper.conf.limit-lower.conf.limit,2)))
        colnames(y)<-NULL
        return(t(y))
        
      })
      
     myData_sum_cor<-ldply(myData_sum_cor,rbind)    
     myData_sum_cor<-as.data.frame(myData_sum_cor)
     
     #write.table(myData_sum_cor,file="myData_sum_cor.txt",sep="\t")
     myData_sum_cor$mean.Pearson.cor<-as.numeric(as.character(myData_sum_cor$mean.Pearson.cor))
     myData_sum_cor$lower.conf.limit<-as.numeric(as.character(myData_sum_cor$lower.conf.limit))
     myData_sum_cor$upper.conf.limit<-as.numeric(as.character(myData_sum_cor$upper.conf.limit))
     
   #  save(myData_sum_cor,sizeval,cex.val,class_col_vec,file="mysamp.Rda")
     group_num<-gsub(myData_sum_cor$group,pattern=":[a-z|A-Z|0-9|_|-]*",replacement="")
     myData_sum_cor<-cbind(myData_sum_cor,group_num)
     Factor2<-gsub(myData_sum_cor$group,pattern="[a-z|A-Z|0-9|-|_]*:",replacement="")
     myData_sum_cor<-cbind(myData_sum_cor,Factor2)
     
     plot_sample_cor<-ggplot(myData_sum_cor,aes(y=mean.Pearson.cor,x=Factor2,color=group_num2))+
       geom_point()+facet_wrap(~group_num,nrow=1)+geom_errorbar(aes(ymin=lower.conf.limit,ymax=upper.conf.limit))+ theme_bw() + theme(panel.border = element_blank(), 
                                       panel.grid.major = element_blank(),
                                       panel.grid.minor = element_blank(),
                                       axis.line = element_line(colour = "black",size=sizeval),
                                       axis.text= element_text(size=14*cex.val), 
                                       axis.title=element_text(size=16*cex.val,face="bold"),
                                       strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
strip.text = element_text(face="bold"))+scale_y_continuous(name="mean Pearson correlation\nbetween biological replicates in each group",breaks = scales::pretty_breaks(n = 10))
     #plot_sample_cor<-plot_sample_cor+scale_color_manual(values=unique(class_col_vec))
     #plot_sample_cor<-plot_sample_cor+scale_x_discrete(name ="Class")
    plot_sample_cor<-plot_sample_cor+theme(axis.text.x = element_text(angle = 45, hjust = 1))
      #guides(fill = guide_legend(title = FALSE),colour=FALSE)+
    #  guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))+
      
   # print(plot_sample_cor)
    }
      
      
      
      myData_sum <- do.call(data.frame,aggregate(list(myData[,-c(1:3)]),
                                                 by = list(myData[,2],myData[,3]),
                                                 FUN = function(x){
                                                   
                                                   x<-as.numeric(as.character(x))
                                                   
                                                   c(mean = mean(x), sd = sd(x),n = length(x),se=sd(x)/sqrt(length(x)))
                                                   
                                                 }))
      
      
      
      label_inc_list<-seq(3,dim(myData_sum)[2],4)
      
   #   save(myData_sum,file="myDatasum.Rda")
      
      pch_vec<-c(19,17,23,22,13,0:12)
      #save(label_inc_list,file="label_inc_list.Rda")
      #save(rnames,file="rnames.Rda")
      #save(data_m,file="data_m.Rda")
      
      if(output.format=="pdf"){
        
        #par(mfrow=c(2,4),family="sans",cex=cex.val)
      }
      

      plot_res<-lapply(seq(3,dim(myData_sum)[2],4),function(pc)
      {
        
        df.summary<-myData_sum[,c(pc:(pc+3),1,2)] #cbind(xvec,classgroup,classlabels_orig[,2],classlabels_orig[,3])
        
        get_label_ind<-which(label_inc_list==pc)
        if(pairedanalysis==FALSE){
          
          
          if(error.bar==FALSE){
            #mzname<-paste(rnames[get_label_ind]," distribution in each group using ",filename," feats vs factors",sep="")
            
            
          }else{
            #mzname<-paste(rnames[get_label_ind]," distribution with 95% confidence interval in each group using ",filename," feats vs factors",sep="")
          }
        }else{
          
          if(error.bar==FALSE){
            mzname<-paste(rnames[get_label_ind]," distribution in each group using ",filename," feats vs time",sep="")
          }else{
            
            mzname<-paste(rnames[get_label_ind]," distribution 95% confidence interval in each group using ",filename," feats vs time",sep="")
          }
          
        }
        
        mzname<-rnames[get_label_ind]
        
        colnames(df.summary)<-c("Intensity","sd","number","se","Class","time")
        ymax = df.summary$Intensity + 1.96*df.summary$se
        
        ymin = df.summary$Intensity - 1.96*df.summary$se
        
        df_write_temp<-cbind(mzname,df.summary[,c(5,6,3,1,2,4)],ymin,ymax)
        colnames(df_write_temp)<-c("Name","Class","time","Number of subjects","mean","Std.deviation","Std.error","lower.limit.95%CI","upper.limit.95%CI")
        
       #write.table(df_write_temp,file=) 
        
        
        df.summary<-as.data.frame(df.summary)
        df.summary$Class<-as.numeric(as.factor(df.summary$Class))
        
        df_time<-levels(df.summary$time)
        #df.summary$time<-as.numeric(as.factor(df.summary$time))
        
       
        #   max_yval<-ceiling(max(df.summary$Intensity+(2.5* df.summary$se),na.rm=TRUE)) #max(ymax,na.rm=TRUE)
        
        #min_yval<-max(0,floor(min(df.summary$Intensity-(2.5* df.summary$se),na.rm=TRUE)))
        
        max_yval<-ceiling(max(df.summary$Intensity+(2.5* df.summary$se),na.rm=TRUE)) #round(max( df.summary$Intensity+(4* df.summary$se),na.rm=TRUE))
        
        
        min_yval<-floor(min(df.summary$Intensity-(2.5* df.summary$se),na.rm=TRUE))
        
        
        
        
        
        if(alphabetical.order==FALSE){
          classlabels_orig[,2] <- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
          classlabels_orig[,3] <- factor(classlabels_orig[,3], levels=unique(classlabels_orig[,3]))
          class_levels_time<-levels(as.factor(classlabels_orig[,3]))
          class_levels<-levels(as.factor(classlabels_orig[,2]))
        }else{
          
          class_levels_time<-levels(as.factor(classlabels_orig[,3]))
        }
        
        Class<-{}
        for(cnum in 1:length(class_levels)){
          
          Class<-c(Class,rep(class_levels[cnum],length(t1)))
          
          df.summary$Class[which(df.summary$Class==cnum)]<-class_levels[cnum]
          
        }
        
        if(alphabetical.order==FALSE){
        df.summary$Class<-factor(df.summary$Class,levels=unique(df.summary$Class))
        df.summary$time<-factor(df.summary$time,levels=unique(df.summary$time))
        
        }
        Class<-unique(Class)
        
        t1<-table(df.summary$Class)
        
        
        
        #print(df.summary)
        
        df.summary$x<-factor(df.summary$time) # time.hour
       # save(df.summary,file="df.summary.Rda")
        #savecol_vec,file="col_vec.Rda")
        #saveclass_levels,file="class_levels.Rda")
        #savelist=ls(),file="debuglinep.Rda")
        
        shape_vec=c(0:2,4:25)
        t1shape=levels(factor(df.summary$Class))
        
        shape_vec1<-(df.summary$Class)
        
        for(i in 1:length(t1shape)){
          shape_vec1[which(shape_vec1==t1shape[i])]<-shape_vec[i]
        }
        
        #  shape_vec1<-lapply(1:length(t1shape),function(i){
        
        #   return(rep(shape_vec[i],t1shape[i]))
        #})
        
        #shape_vec1<-unlist(shape_vec1)
        
        
        #col_vec<-colfunc(length(t1))
        #ylim(0,ymax) +
        sizeval=1.5
        
        unique_class_col_vec<-unique(class_col_vec)
        
        shape_vec1<-as.numeric(as.character(shape_vec1))
        
        
         fname1<-paste("lp",pc,".Rda",sep="")
      #  save(shape_vec1,df.summary,class_labels_levels,unique_class_col_vec,
       #      cex.val,sizeval,class_col_vec,ymin,ymax,pairedanalysis,ylabel,
        #     df_time,file=fname1) #"lp1.Rda")
        
        
        if(pairedanalysis==TRUE){
          
          options(repr.plot.width = 3, repr.plot.height = 2)
          #ylim(0,max_yval) +
          
          plot_res<-suppressWarnings(ggplot(df.summary, 
                                            aes(x = as.factor(x), y = Intensity,color = Class,linetype=Class)) +
                                       geom_point(size = cex.val,shape=shape_vec1) + 
                                       geom_line(aes(group =Class),size=sizeval)  + 
                                       geom_errorbar(aes(ymin = ymin, ymax = ymax),size=0.3,width=0.1) + 
                                       ylab(ylabel) + theme_bw() + theme(panel.border = element_blank(), 
                                                                         panel.grid.major = element_blank(),
                                                                         panel.grid.minor = element_blank(),
                                                                         axis.line = element_line(colour = "black",size=sizeval),
                                                                         axis.text= element_text(size=14*cex.val), axis.title=element_text(size=16*cex.val,face="bold"),
                                                                         strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                         strip.text = element_text(face="bold")) + 
                                       scale_y_continuous(name=ylabel,breaks = scales::pretty_breaks(n = 10)))
          
                                                                                                                                                                                                                                                                                                                 
          if(length(unique_class_col_vec)==1){
            plot_res<-plot_res+scale_color_manual(values=rep(unique(class_col_vec),length(class_labels_levels)))
            
          }else{
            plot_res<-plot_res+scale_color_manual(values=unique(class_col_vec))
          }
          
          plot_res<-plot_res+scale_x_discrete(name ="Time",limits=unique(df_time))
          
          plot_res<-plot_res+guides(fill = guide_legend(title = FALSE),colour=FALSE)+guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))+theme(axis.text.x = element_text(angle = 45, hjust = 1))
          
          
          
          #+ scale_colour_manual(values=col_vec)
        }else{
          
          if(timeseries.lineplots==TRUE){
            
            
            #savelist=ls(),file="r.Rda")
            #print("here this ABC")
            #ylim(0,max_yval) +
            
            
        #    save(shape_vec1,df.summary,class_labels_levels,sizeval,ymin, ymax,ylabel,cex.val,
         #        unique_class_col_vec,class_col_vec,ymin,ymax,pairedanalysis,
          #      timeseries.lineplots,df_time,file="lp2.Rda")
            
            
            #if(FALSE)
            {
              shape_vec1<-as.numeric(as.character(shape_vec1))
              options(repr.plot.width = 3, repr.plot.height = 2)
              
              if(is.na(lineplot.lty.option)==TRUE){
              plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(x), y = Intensity,colour = Class,
                                                                linetype=Class)) + 
                                           geom_point(size = 4,shape=shape_vec1) + 
                                           geom_line(aes(group =Class),size=sizeval) + 
                                           geom_errorbar(aes(ymin = ymin, ymax = ymax),size=0.3,width=0.1)+ ylab(ylabel) + theme_bw() +
                                           theme(panel.border = element_blank(),
                                                 panel.grid.major = element_blank(),
                                                 panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                 axis.text= element_text(size=14*cex.val), axis.title=element_text(size=16,face="bold"),
                                                 strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                 strip.text = element_text(face="bold")) + 
                                           scale_y_continuous(name=ylabel,
                                                              breaks = scales::pretty_breaks(n = 10)))
                                                                                                                                                                                                                                                                                                               
              }else{
                #linetype=lineplot.lty.option
                plot_res<-suppressWarnings(ggplot(df.summary, aes(x = as.factor(x), y = Intensity,colour = Class
                                                                  )) + 
                                             geom_point(size = 4,shape=shape_vec1) + 
                                             geom_line(aes(group =Class),size=sizeval) + 
                                             geom_errorbar(aes(ymin = ymin, ymax = ymax),size=0.3,width=0.1)+ ylab(ylabel) + theme_bw() +
                                             theme(panel.border = element_blank(),
                                                   panel.grid.major = element_blank(),
                                                   panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                   axis.text= element_text(size=14*cex.val), axis.title=element_text(size=16,face="bold"),
                                                   strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                   strip.text = element_text(face="bold")) + 
                                             scale_y_continuous(name=ylabel,
                                                                breaks = scales::pretty_breaks(n = 10)))
                
                
                
              }
              if(length(unique_class_col_vec)==1){
                plot_res<-plot_res+scale_color_manual(values=rep(unique(class_col_vec),length(class_labels_levels)))
                
              }else{
                plot_res<-plot_res+scale_color_manual(values=unique(class_col_vec))
              }
              #save(plot_res,file="p1.Rda")
              plot_res<-plot_res+scale_x_discrete(name ="Time",limits=unique(df_time))
              
              #save(plot_res,file="p2.Rda")
              plot_res<-plot_res+guides(fill = guide_legend(title = FALSE),colour=FALSE)+guides(colour = guide_legend(override.aes = list(shape = unique(shape_vec1))))+theme(axis.text.x = element_text(angle = 45, hjust = 1))
            }
            
            
        
            
            
            
            
            
            
            
          }else{
            #ylim(0,max_yval)
            options(repr.plot.width = 3, repr.plot.height = 2)
            
            plot_res<-ggplot(df.summary, aes(x = as.factor(x), y = Intensity,color = Class)) + geom_point(size = pca.cex.val,shape=shape_vec1) + geom_errorbar(aes(ymin = ymin, ymax = ymax),size=sizeval) + scale_color_manual(values=col_vec) + ylab(ylabel) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                         panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                                                                                                                                                                                                                         axis.text= element_text(size=14*cex.val), axis.title=element_text(size=16*cex.val,face="bold"),
                                                                                                                                                                                                                                                                         strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                         strip.text = element_text(face="bold")) + scale_y_continuous(name=ylabel,breaks = scales::pretty_breaks(n = 10))
            
            plot_res<-plot_res+scale_x_discrete(name ="Factor",limits=unique(df_time))
            
          }
          #+ scale_colour_manual(values=col_vec)
        }
        
        plot_res<-plot_res + ggtitle(mzname)
        
        plot_res<-plot_res + theme(plot.title = element_text(size=8))
        # x axis title
        plot_res<-plot_res + theme(axis.title.x = element_text(size=14*cex.val))
        # y axis title
        plot_res<-plot_res + theme(axis.title.y = element_text(size=14*cex.val))+theme(axis.text.x = element_text(angle = 45, hjust = 1,size=11*cex.val))
        
        
        # print(plot_res)
        
        
        
        plot_res<-plot_res+ggtitle(mzname)
        
        #return(plot_res)
        #print(plot_res + ggtitle(mzname))
        return(list("df_write_temp"=df_write_temp,"plot_res"=plot_res))
      })
      
   #   save(plot_res,file="plot_res.Rda")
      
      
      
      if(multiple.figures.perpanel==TRUE){
        
          res<-lapply(seq(1,length(plot_res),4),function(i){
            p1=plot_res[[i]]$plot_res
            p2={}
            p3={}
            p4={}
            if((i+1)<length(plot_res)){
              p2=plot_res[[i+1]]$plot_res
            }
            if((i+2)<length(plot_res)){
              p3=plot_res[[i+2]]$plot_res
            }
            if((i+3)<length(plot_res)){
              p4=plot_res[[i+3]]$plot_res
            }
            if(length(p2)>0 && length(p3)>0 && length(p4)>0){
              
                figure<-ggarrange(p1,p2,p3,p4,ncol = 2, nrow = 2,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
            }else{
              if(length(p2)>0 && length(p3)>0){
                
                figure<-ggarrange(p1,p2,p3,ncol = 2, nrow = 2,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
              }else{
                
                if(length(p2)>0){
                  
                  figure<-ggarrange(p1,p2,ncol = 2, nrow = 1,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
                }else{
                  
                  
                    figure<-ggarrange(p1,ncol = 1, nrow = 1,heights=c(4,4),width=c(6,6),legend=FALSE,align = c("hv"))
                  
                }
              }
              
            }
            
            
                   return(figure)
          })
      
      for(i in 1:length(res)){
        
        print(res[[i]][[1]])
      }
      
      legend <- ggpubr::get_legend(plot_res[[i]]$plot_res)
      
      suppressMessages(library(grid))
      
      grid.newpage()
      grid.draw(legend)
      }else{
      
        res<-lapply(seq(1,length(plot_res),1),function(i){
          p1=plot_res[[i]]$plot_res
         
          figure<-ggarrange(p1,ncol = 1, nrow = 1,heights=plot.height,width=plot.width,legend=TRUE,align = c("hv"))
          return(figure)
        })
        
        for(i in 1:length(res)){
          
          print(res[[i]][[1]])
        }
      
        legend <- ggpubr::get_legend(plot_res[[i]]$plot_res)
        
        suppressMessages(library(grid))
        
        grid.newpage()
        grid.draw(legend)
    }
      
     
    }else{
      
      
      #one-way anova or one-way with repeated measures
      class_levels<-levels(as.factor(classgroup))
      t1<-table(classgroup)
      
      
      
      myData<-cbind(classgroup,classlabels_orig[,2],t(data_m))
      
      myData<-as.data.frame(myData)
      
      if(alphabetical.order==FALSE){
        myData[,2] <- factor(myData[,2], levels=unique(myData[,2]))
        
        
      }
      
      myData_sum <- do.call(data.frame,aggregate(list(myData[,-c(1:2)]),
                                                 by = list(myData[,2]),
                                                 FUN = function(x){
                                                   
                                                   x<-as.numeric(as.character(x))
                                                   c(mean = mean(x), sd = sd(x),n = length(x),se=sd(x)/sqrt(length(x)))
                                                   
                                                 }))
      
      
      label_inc_list<-seq(2,dim(myData_sum)[2],4)
      
      ###savelabel_inc_list,file="label_inc_list.Rda")
      ###savernames,file="rnames.Rda")
      
      #savemyData_sum,classgroup,classlabels_orig,label_inc_list,rnames,file="myDatasum.Rda")
      plot_res<-lapply(seq(2,dim(myData_sum)[2],4),function(pc)
        #for(pc in seq(2,dim(myData_sum)[2],4))
      {
        
        #print("here 0705")
        #  print(pc)
        df.summary<-myData_sum[,c(pc:(pc+3),1)] #cbind(xvec,classgroup,classlabels_orig[,2],classlabels_orig[,3])
        
        get_label_ind<-which(label_inc_list==pc)
        if(pairedanalysis==FALSE){
          
          
          if(error.bar==FALSE){
            mzname<-paste(rnames[get_label_ind]," distribution \nin each group using ",filename," feats vs factors",sep="")
          }else{
            mzname<-paste(rnames[get_label_ind]," distribution \nwith 95% confidence interval in each group using ",filename," feats vs factors",sep="")
          }
        }else{
          
          if(error.bar==FALSE){
            mzname<-paste(rnames[get_label_ind]," distribution \nin each group using ",filename," feats vs time",sep="")
          }else{
            
            mzname<-paste(rnames[get_label_ind]," distribution \n95% confidence interval in each group using ",filename," feats vs time",sep="")
          }
          
        }
        
        colnames(df.summary)<-c("Intensity","sd","number","se","Class")
        df.summary<-as.data.frame(df.summary)
        
        df.summary$Class<-as.numeric(as.factor(df.summary$Class))
        
        
        ymax = df.summary$Intensity + 1.96*df.summary$se
        
        ymin = df.summary$Intensity - 1.96*df.summary$se
        
        df_write_temp<-cbind(mzname,df.summary[,c(5,3,1,2,4)],ymin,ymax)
        
        colnames(df_write_temp)<-c("Name","Class","Number of subjects","mean","Std.deviation","Std.error","lower.limit.95%CI","upper.limit.95%CI")
        
        
        max_yval<-ceiling(max(df.summary$Intensity+(2.5* df.summary$se),na.rm=TRUE)) #round(max( df.summary$Intensity+(4* df.summary$se),na.rm=TRUE))
        
        
        min_yval<-floor(min(df.summary$Intensity-(2.5* df.summary$se),na.rm=TRUE))
        
        
        Class<-{}
        for(cnum in 1:length(class_levels)){
          
          Class<-c(Class,rep(class_levels[cnum],length(t1)))
          
          df.summary$Class[which(df.summary$Class==cnum)]<-class_levels[cnum]
          
        }
        
        
        Class<-unique(Class)
        
        t1<-table(df.summary$Class)
        
        
        #print(df.summary)
        #savedf.summary,file="df.summarydotp1.Rda")
        # ##save(df.summary,class_levels,col_vec,ymin,ymax,pairedanalysis,ylabel,file="lp1.Rda")
        
        
        ##savelist=ls(),file="debuglinep1.Rda")
        time.hour<- c(unique(as.character(classlabels_orig[,2])),unique(as.character(classlabels_orig[,2])))
        #Score<-df.summary$Score
        #df.summary$x<-time.hour
        
        #print(Class)
        # scale_color_hue(l=40)
        sizeval=1.5
        if(pairedanalysis==FALSE){
          
          if(timeseries.lineplots==FALSE){
            #ylim(0,max(ymax,na.rm=TRUE)) +
            options(repr.plot.width = 3, repr.plot.height = 2)
            plot_res<-ggplot(df.summary, aes(x = Class, y = Intensity,color = Class)) + geom_point(size=pca.cex.val)  + geom_errorbar(aes(ymin = ymin, ymax = ymax),size=0.3,width=0.1) + ylab(ylabel) + scale_x_continuous(breaks=seq(1,length(class_levels))) + scale_color_manual(values=col_vec) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                                                                          panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                                                                                                                                                                                                                                                                          axis.text= element_text(size=14*cex.val), axis.title=element_text(size=16*cex.val,face="bold"),
                                                                                                                                                                                                                                                                                                                          strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                                                                          strip.text = element_text(face="bold")) + scale_y_continuous(name=ylabel,breaks = scales::pretty_breaks(n = 10))
            
            
            #plot_res<-plot_res+scale_x_discrete(name ="Factor",limits=unique(df.summary$time))
          }else{
            
            #ylim(0,max(ymax,na.rm=TRUE)) +
            options(repr.plot.width = 3, repr.plot.height = 2)
            plot_res<-ggplot(df.summary, aes(x = Class, y = Intensity,group=1)) + geom_point(size=pca.cex.val)  + geom_line(size=sizeval) + geom_errorbar(aes(ymin = ymin, ymax = ymax),size=0.3,width=0.1) + ylab(ylabel) +  scale_x_continuous(breaks=seq(1,length(class_levels))) + scale_color_manual(values=col_vec) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                                                                                               panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),
                                                                                                                                                                                                                                                                                                                                               axis.text= element_text(size=14*cex.val), axis.title=element_text(size=16*cex.val,face="bold"),
                                                                                                                                                                                                                                                                                                                                               strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                                                                                               strip.text = element_text(face="bold")) + scale_y_continuous(name=ylabel,breaks = scales::pretty_breaks(n = 10))
            
          }
          
          
          #+ scale_colour_manual(values=col_vec)
        }else{
          
          
          #plot_res<-ggplot(df.summary, aes(x = x, y = Score,color = Class)) + geom_point(size = 2) + geom_line()  #+ geom_errorbar(aes(ymin = ymin, ymax = ymax))
          
          #ylim(0,max(ymax,na.rm=TRUE)) +
          options(repr.plot.width = 3, repr.plot.height = 2)
          plot_res<-ggplot(df.summary, aes(x = Class, y = Intensity,group=1)) +  geom_point(size = pca.cex.val) + geom_line(size=sizeval)  + geom_errorbar(aes(ymin = ymin, ymax = ymax),width=0.2,size=sizeval) + ylab(ylabel) +  scale_color_manual(values=col_vec) + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                                           panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval),axis.text= element_text(size=14*cex.val), axis.title=element_text(size=16*cex.val,face="bold"),
                                                                                                                                                                                                                                                                                           strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                                           strip.text = element_text(face="bold")) + scale_y_continuous(name=ylabel,breaks = scales::pretty_breaks(n = 10))
          
          #+ scale_colour_manual(values=col_vec)
          
          #plot_res<-ggplot(df.summary, aes(x = x, y = Intensity,color = Class)) +  geom_point(size = pca.cex.val,colour=col_vec) + geom_line(aes(group =Class),colour=col_vec)  + geom_errorbar(aes(ymin = ymin, ymax = ymax),colour=col_vec) + scale_color_hue(l=40)
          
          #plot_res<-ggplot(df.summary, aes(x = x, y = Score,color = Class)) +  geom_point() + geom_line(aes(group =Class)) # + geom_line()
          
        }
        
        
        plot_res<-plot_res + ggtitle(mzname)
        
        plot_res<-plot_res + theme(plot.title = element_text(size=8))
        # x axis title
        plot_res<-plot_res + theme(axis.title.x = element_text(size=14*cex.val))
        # y axis title
        plot_res<-plot_res + theme(axis.title.y = element_text(size=14*cex.val))+theme(axis.text.x = element_text(angle = 45, hjust = 1,size=11*cex.val))
        
        #  print(plot_res) #
        
        
      #  return(plot_res)
       
        return(list("plot_res"=plot_res,"df_write_temp"=df_write_temp)) 
        
        
      }) #return plot
      ##save(plot_res,file="plot_res.Rda")
      
      #pdf("t.pdf",onefile=TRUE)
      
      
      if(multiple.figures.perpanel==TRUE){
      
      res<-lapply(seq(1,length(plot_res),4),function(i){
        #for(i in seq(1,length(plot_res),4)){
        p1=plot_res[[i]]$plot_res
        p2=""
        p3=""
        p4=""
        
        if((i+1)<length(plot_res)){
          p2=plot_res[[i+1]]$plot_res
        }
        if((i+2)<length(plot_res)){
          p3=plot_res[[i+2]]$plot_res
        }
        if((i+3)<length(plot_res)){
          
          p4=plot_res[[i+3]]$plot_res
        }
        
        figure<-ggarrange(p1,p2,p3,p4,ncol = 2, nrow = 2,heights=c(4,4),width=c(6,6),
                          legend=FALSE,align = c("hv"))
        return(figure)
      })
      
      
      for(i in 1:length(res)){
        
        print(res[[i]][[1]])
      }
      
      legend <- ggpubr::get_legend(plot_res[[i]]$plot_res)
      
      suppressMessages(library(grid))
      
      grid.newpage()
      grid.draw(legend)
      
      }else{
        
        
        res<-lapply(seq(1,length(plot_res),1),function(i){
          #for(i in seq(1,length(plot_res),4)){
          p1=plot_res[[i]]$plot_res
          p2=""
          p3=""
          p4=""
          
        
        
          
          figure<-ggarrange(p1,ncol = 1, nrow = 1,heights=c(4,4),width=c(6,6),
                            legend=FALSE,align = c("hv"))
          return(figure)
        })
        
        
        for(i in 1:length(res)){
          
          print(res[[i]][[1]])
        }
        
        legend <- ggpubr::get_legend(plot_res[[i]]$plot_res)
        
        suppressMessages(library(grid))
        
        grid.newpage()
        grid.draw(legend)
        
      }
      
    }
  }else{
    
    
    
  }
  #df_fname<-paste("PC_score_distribution_matrix_",filename,"features.txt",sep="")
  #write.table(df_matrix,file=df_fname,sep="\t",row.names=TRUE)
  if(newdevice==TRUE){
    
    try(dev.off(),silent=TRUE)
  }
  try(dev.off(),silent=TRUE)
  return(plot_res)
  
}


get_pca<-function(X,samplelabels,legendlocation="topright",filename=NA,ncomp=5,pcacenter=TRUE,pcascale=TRUE,legendcex=0.5,
                  outloc=getwd(),col_vec=NA,sample.col.opt="default",alphacol=0.3,class_levels=NA,pca.cex.val=3,pca.ellipse=TRUE,
                  ellipse.conf.level=0.95,samplenames=FALSE,do_pca_anova=FALSE,paireddesign=NA,pairedanalysis=FALSE,
                  classlabelsorig=NA,alphabetical.order=FALSE,analysistype="oneway",lme.modeltype="RI"){
  
  suppressMessages(library(mixOmics))
  #suppressMessages(library(car))
  
  X<-as.matrix(t(X))
  
  par(mfrow=c(1,1),family="sans",cex=0.9)
  pch.val<-19
  
  samplelabels<-as.data.frame(samplelabels)
  
  samplelabels<-paste("",as.factor(samplelabels[,1]),sep="")
  
  if(alphabetical.order==FALSE){
    samplelabels <- factor(samplelabels, levels=unique(samplelabels))
  }
  
  if(analysistype=="twowayrepeat" | analysistype=="2wayrepeat" | analysistype=="onewayrepeat" | analysistype=="1wayrepeat"){
    
    pairedanalysis=TRUE
    
    
  }
  
  

  
  classlabelsorig<-classlabelsorig[match(rownames(X),classlabelsorig[,1]),]
  
  if(alphabetical.order==FALSE){
    samplelabels <- factor(samplelabels, levels=unique(samplelabels))
  }
  l2<-levels(as.factor(samplelabels))
  
 
  
  col_all=topo.colors(256)
  
  t1<-table(samplelabels)
  if(is.na(class_levels)[1]==TRUE){
    
    l1<-levels(as.factor(samplelabels))
  }else{
    l1<-class_levels
    
    
  }
  l1<-levels(as.factor(samplelabels))
 # save(X,classlabelsorig,samplelabels,file="pcaX.Rda")
  #print(dim(X))
  if(pcascale=="pareto"){
    
    X<-apply(X,2,function(x){y<-(x-mean(x,na.rm=TRUE))/sqrt(sd(x,na.rm=TRUE));return(y)})
    
    pcascale=FALSE
  }else{
    
    if(pcascale=="uv" || pcascale=="autoscale"){
      
      #X<-apply(X,2,function(x){y<-(x-mean(x,na.rm=TRUE))/(sd(x,na.rm=TRUE));return(y)})
      
      pcascale=TRUE
    }
    
  }
  
 # save(X,file="pcaX1.Rda")
  class_labels_levels<-l1
  
  ncomp=min(c(10,dim(X)[1],dim(X)[2]))
  
  #   p1<-pcaMethods::pca(t(X),method="svd",center=TRUE,scale="uv",cv="q2",nPcs=10)
  if(is.na(paireddesign)==TRUE){
    metabpcaresultlog2allmetabs5pcs<-mixOmics::pca(X,ncomp=ncomp,center=pcacenter,scale=pcascale)
  }else{
    metabpcaresultlog2allmetabs5pcs<-mixOmics::pca(X,ncomp=ncomp,center=pcacenter,scale=pcascale) #,multilevel=paireddesign)
    
  }
  result<-metabpcaresultlog2allmetabs5pcs
  
  
  fname1<-paste("pcares",filename,".Rda",sep="")
 # save(result,X,ncomp,pcacenter,pcascale,file=fname1)
  if(analysistype=="regression"){
    
  }
 save(X,result,ncomp,pcacenter,pcascale,samplelabels,ellipse.conf.level,classlabelsorig,analysistype,file="pcadebug3.Rda")
  
 
  
#  s1<-summary(result)
  r1<-result$prop_expl_var #s1$importance[2,]
  r1<-round(r1$X,2)*100
  
  barplot(r1,beside=TRUE,main="% variation explained by each component",ylab="% variation",col=c("#0072B2"),cex.main=0.7,ylim=range(pretty(c(0,max(r1)))))
  abline(h=10,lty=5,lwd=2)
  
  ncomp_plot<-max(2,length(which(r1>10)))
  numcomp_plot<-ncomp_plot
 
  if(is.na(col_vec)[1]==TRUE){
    col_vec<-c("mediumpurple4","mediumpurple1","blueviolet","darkblue","blue","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }
  
  if(sample.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{
    if(sample.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels))
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(sample.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(sample.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=sample.col.opt)
              
              if(length(check_brewer)>0){
                
                sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                
              }else{
                
                if(sample.col.opt=="journal"){
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                }else{
                  #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                  if(length(sample.col.opt)==1){
                    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  }else{
                    
                    if(length(sample.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-sample.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                    
                      
                    }else{
                          colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    }
                    
                  }
                }
                
              }
              
            }
            
          }
          
          
        }
        
      }
      
    }
  }
  #col_vec<-col_vec[sample(1:length(col_vec),length(col_vec))]
  
  l1<-gsub(x=l1,pattern="Class",replacement="")
  
  dir.create(outloc,showWarnings=FALSE)
  setwd(outloc)
  # print(paste("Generating PCA plots",sep=""))
  
  fname<-paste("PCA_eval",filename,".tiff",sep="")
  ## 1) raw data
  #tiff(fname,res=300, width=2000,height=2000)
  col <- rep(col_vec[1:length(t1)], t1)
  
  #col<-rep(col_all[1:length(l1)],t1)
  ## Choose different size of points
  cex <- rep(pca.cex.val, dim(X)[1])
  ## Choose the form of the points (square, circle, triangle and diamond-shaped
  
  #pch_vec<-seq(1,50) #c(3,5,7,9,12,13,2,17,21) #seq(1,50) #
  #pch <- rep(pch.val,dim(X)[1])
  #pch_vec <- rep(pch.val,dim(X)[1])
  
  
  pch_vec<-rep(seq(0,25),2) #sample(seq(1,50),50) #c(3,5,7,9,12,13,2,17,21) # #
  pch <- rep(pch_vec[1:length(t1)], t1)
  
  
  
  cex <- pca.cex.val #rep(pca.cex.val, dim(X)[1])
  cex.plots=pca.cex.val
  col_per_group<-{}
  pch_per_group<-{}
  for(p1 in 1:length(l1)){
    col[which(samplelabels==l1[p1])]=col_vec[p1]
    pch[which(samplelabels==l1[p1])]=pch_vec[p1]
    
    col_per_group<-c(col_per_group,col_vec[p1])
    pch_per_group<-c(pch_per_group,pch_vec[p1])
  }
  pch=pch_per_group
  # print(table(pch))
  
  main_text=paste("Pairwise PC score plots using ",filename," features after preprocessing",sep="")
  
  legendcex<-0.7 #0.5*pca.cex.val
  
 # result$x<-result$variates
  save(result,file="result_pca.Rda")
  
  #if(pca.ellipse=="car")
  {
    
    
    pc_pval_single<-{}
    
    #    do_pca_anova=FALSE
    
    
    if(do_pca_anova==TRUE)
    {
      scores_res<-result$x
      
      
      if(dim(classlabelsorig)[2]==2){
        dtemp<-cbind(classlabelsorig,scores_res)
        dtemp<-as.data.frame(dtemp)
        
        pc1_pval<-anova(lm(cbind(scores_res[,1],scores_res[,2])~samplelabels))
        
        pc1_pval<-pc1_pval[[6]][2]
        pc2_pval<-anova(lm(cbind(scores_res[,1],scores_res[,3])~samplelabels))
        
        pc2_pval<-pc2_pval[[6]][2]
        
        pc3_pval<-anova(lm(cbind(scores_res[,2],scores_res[,3])~samplelabels))
        pc3_pval<-pc3_pval[[6]][2]
        ###save(dtemp,samplelabels,classlabelsorig,scores_res,paireddesign,file="pcdtemp.Rda")
        if(is.na(paireddesign)==TRUE){
          
          
          testname="one-way ANOVA"
          pc_pval_single<-lapply(1:min(5,ncol(scores_res)),function(pcn1){
            pc1_only<-anova(lm(scores_res[,pcn1]~samplelabels))
            pc1_only<-pc1_only[[5]][1]
            return(pc1_only)
            
          })
          
          pc_pval_single<-unlist(pc_pval_single)
        }else{
          
          testname="one-way ANOVA with repeated measures"
          
          #one-way ANOVA repeat
          pc_pval_single<-lapply(3:ncol(dtemp),function(pcn1){
            dataA<-cbind(dtemp[,pcn1],dtemp[,c(2)])
            
            colnames(dataA)<-c("Response","Factor1")
            
            #pcalmonewayanova
            pc1_res<-diffexplmonewayanovarepeat(dataA=dataA,subject_inf=paireddesign,modeltype=lme.modeltype)
            
            return(pc1_res$mainpvalues)
            
          })
          
          pc_pval_single<-unlist(pc_pval_single)
          
        }
        
      }else{
        
        dtemp<-cbind(classlabelsorig,scores_res)
        dtemp<-as.data.frame(dtemp)
        
        ##save(dtemp,classlabelsorig,paireddesign,file="pcdtemp2.Rda")
        
        if(dim(classlabelsorig)[2]>=2){
          
          if(is.na(paireddesign)==FALSE){
            
            testname="two-way ANOVA with repeated measures in one factor"
            #two-way ANOVA repeat
            pc_pval_single<-lapply(4:ncol(dtemp),function(pcn1){
              dataA<-cbind(dtemp[,pcn1],dtemp[,c(2:3)])
              
              colnames(dataA)<-c("Response","Factor1","Factor2")
              
              dataA$Response<-dtemp[,pcn1]
              
              ##save(dataA,paireddesign,file="pcdataA.rda")
              pc1_res<-diffexplmtwowayanovarepeat(dataA=dataA,subject_inf=paireddesign,modeltype=lme.modeltype)
              
              return(pc1_res$mainpvalues)
              
            })
            pc_pval_single<-unlist(pc_pval_single)
          }else{
            
            testname="two-way ANOVA"
            #two-way ANOVA
            pc_pval_single<-lapply(4:ncol(dtemp),function(pcn1){
              dataA<-cbind(dtemp[,pcn1],dtemp[,c(2:3)])
              
              colnames(dataA)<-c("Response","Factor1","Factor2")
              
              dataA$Response<-dtemp[,pcn1]
              
              ###savedataA,file="pcdataA.rda")
              pc1_res<-diffexplmtwowayanova(dataA=dataA)
              
              return(pc1_res$mainpvalues)
              
              
              
            })
            pc_pval_single<-unlist(pc_pval_single)
            
          }
          
        }
        
      }
      
      if(dim(classlabelsorig)[2]==2){
        pc_pval_vec<-c(pc1_pval,pc2_pval,pc3_pval)
        
      }
      
      pc_pval_single<-round(pc_pval_single,3)
    }
    
   
    
    
    if(dim(classlabelsorig)[2]==2){
      if(do_pca_anova==TRUE){
        main_text=paste("Pairwise PC score plots using ",filename," features\np-value for differences between groups using PC1 and PC2 in a multivariate\n ANOVA model=",round(pc_pval_vec[1],3),sep="")
      }
      
    }
    #debugpca
   # save(result,samplelabels,col_per_group,pca.ellipse,filename,file="pcaplotd.Rda")
    
    # plot(c(1,1),plot=FALSE)
    #l <- legend(0, 0, bty='n', l1,plot=FALSE, pch = pch_per_group, pt.cex = 0.6)
    # calculate right margin width in ndc
    w <- 0.1 #grconvertX(l$rect$w, to='ndc') - grconvertX(0, to='ndc')
    par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
    
    iqr_xlim=0.1*sd(result$variates$X[,1],na.rm=TRUE) #4*(summary(result$variates$X[,1])[5]-summary(result$variates$X[,1])[3])
    iqr_ylim=0.1*sd(result$variates$X[,2],na.rm=TRUE) #4*(summary(result$variates$X[,2])[5]-summary(result$variates$X[,2])[3])
    
    save(X,result,samplelabels,ellipse.conf.level,iqr_ylim,iqr_xlim,r1,classlabelsorig,col_per_group,main_text,analysistype,l1,pch,file="debug3.Rda")
    
    plotIndiv(result,comp=c(1,2),group=as.factor(samplelabels),legend = TRUE,
    ellipse=pca.ellipse,style="lattice",
    title = paste("PCA using ",filename, "features (with names)",sep=""),col.per.group=col_per_group)
    
    
    plotIndiv(result,comp=c(1,2),group=as.factor(samplelabels),legend = TRUE,ellipse=pca.ellipse,
              style="lattice",title = paste("PCA using ",filename, "features",sep=""),col.per.group=col_per_group,ind.names=FALSE)
    
    
    
    
    if(ncomp_plot>2){
      
      if(dim(classlabelsorig)[2]==2){
        if(do_pca_anova==TRUE){
          main_text=paste("Pairwise PC score plots using ",filename," features after preprocessing\np-value for overall differences between groups using PC1 and PC3 in a multivariate\n ANOVA model=",round(pc2_pval,3),sep="")
        }
      }
      
      
      
      w <- 0.1
      par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
      
      iqr_xlim=0.1*sd(result$variates$X[,1],na.rm=TRUE) #(summary(result$variates$X[,1])[5]-summary(result$variates$X[,1])[3])
      iqr_ylim=0.1*sd(result$variates$X[,3],na.rm=TRUE) #(summary(result$variates$X[,3])[5]-summary(result$variates$X[,3])[3])
      
      plotIndiv(result,comp=c(1,3),group=as.factor(samplelabels),legend = TRUE,ellipse=pca.ellipse,style="lattice",
                title=paste("PCA using ",filename, "features (with names)",sep=""),col.per.group=col_per_group)
      #,ind.names=FALSE)
      
      plotIndiv(result,comp=c(1,3),group=as.factor(samplelabels),legend = TRUE,ellipse=pca.ellipse,style="lattice",
                title = paste("PCA using ",filename, "features",sep=""),col.per.group=col_per_group,ind.names=FALSE)
      
      w <- 0.1
      par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
      
      iqr_xlim=0.1*sd(result$variates$X[,2],na.rm=TRUE) #2.5*(summary(result$variates$X[,2])[5]-summary(result$variates$X[,2])[3])
      iqr_ylim=0.1*sd(result$variates$X[,3],na.rm=TRUE) #2.5*(summary(result$variates$X[,3])[5]-summary(result$variates$X[,3])[3])
      
      if(dim(classlabelsorig)[2]==2){
        if(do_pca_anova==TRUE){
          
          main_text=paste("Pairwise PC score plots using ",filename," features after preprocessing\np-value for overall differences between groups using PC2 and PC3 in a multivariate\n ANOVA model=",round(pc3_pval,3),sep="")
        }
      }
      
      if(dim(classlabelsorig)[2]==2){
        if(do_pca_anova==TRUE){
          
          main_text=paste("Pairwise PC score plots using ",filename," features after preprocessing\np-value for overall differences between groups using PC2 and PC3 in a multivariate\n ANOVA model=",round(pc3_pval,3),sep="")
        }
      }
      
      plotIndiv(result,comp=c(2,3),group=as.factor(samplelabels),legend = TRUE,ellipse=pca.ellipse,style="lattice",layout=c(8,8),title = paste("PCA using ",filename, "features (with names)",sep=""),col.per.group=col_per_group)
      plotIndiv(result,comp=c(2,3),group=as.factor(samplelabels),legend = TRUE,ellipse=pca.ellipse,style="lattice",layout=c(8,8),title = paste("PCA using ",filename, "features",sep=""),col.per.group=col_per_group,ind.names=FALSE)
        
    }
    
    
    
    
  }
  
  suppressMessages(library(reshape2))
  
  
  Class<-samplelabels
  
  if(ncol(result$x)>5){
    
    melted <- cbind(Class, melt(result$x[,1:5]))
    
  }else{
    
    melted <- cbind(Class, melt(result$x))
  }
  
  colnames(melted)<-c("Class","Samples","Var2","PCscore")
  melted$Samples<-seq(1,nrow(result$x))
  
  ###save(pc_pval_single,file="pc_pval_single.Rda")
  # for(i in 1:5)
  ###save(melted,result,samplelabels,Class,col,col_per_group,col_vec,file="pc_score_plots.Rda")
  testname=""
  lapply(1:min(ncomp_plot,ncol(result$x)),function(i){
    
    pcname<-paste("PC",i,sep="")
    melted_pc1<-melted[which(melted$Var2==pcname),]
    
    melted_pc1
    
    if(do_pca_anova==TRUE){
      
      
      main_text=paste("PC score plots using ",filename," features after preprocessing\np-value for differences between groups ",testname," using ",pcname,"\n",testname," p=",round(pc_pval_single[i],3),sep="")
    }else{
      
      main_text=paste("PC score plots using ",filename," features after preprocessing",sep="")
    }
    
    
    w <- 0.1
    par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
    
    # barCenters=barplot(myData$Intensity,ylab="Intensity",xlab="Class",main=mzlabel_cur,col=barplot.col.opt1,ylim=c(0,max_yval))
    #arrows(barCenters, ymin,barCenters, ymax,angle=90,code=3,lty=1,lwd=1.25,length=0.05)
    ylab1<-paste(pcname,"score",sep="")
    (plot(as.vector(melted_pc1[,4]),col=c(col),main=main_text, ylab=ylab1,xlab="Sample",type="h",lwd=2,cex.main=0.7))
    
    le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,unique(melted_pc1$Class), col = col_per_group,pch = rep(19,length(col_per_group)), pt.cex = 0.6, title = "Class",cex=0.8))
    
    
    #print(barplot1)
    
    
    
  })
  
  ##savelist=ls(),file="getpcadebug.Rda")
  
  if(nrow(result$loadings$X)<30){
    
    if(ncol(result$loadings$X)>ncomp_plot){
      df.prcomp=as.data.frame(result$loadings$X[,c(1:ncomp_plot)])
    }else{
       df.prcomp=as.data.frame(result$loadings$X)
    }
  df.prcomp$varName=rownames(result$loadings$X)
  suppressMessages(library(tidyr))
  df.long.prcomp=gather(df.prcomp,"PC","loading",starts_with("PC"))
  cex.plots=0.8
  p=ggplot(df.long.prcomp,aes_string(x="varName",y="loading",ymax="loading"))+geom_point()+geom_linerange(aes(ymin=0))+facet_wrap(~PC,nrow=1)+coord_flip()+ggtitle("variable loadings for PCs")
  
  p=p+theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                         panel.grid.minor = element_blank(),
                         panel.spacing=unit(1,"lines"),
                         axis.line = element_line(colour = "black",size=1),
                         
                         
                         legend.background = element_rect(color = "black", fill = "white"),
                         strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"))
                         
 
  
  print(p)
  }else{
    if(ncol(result$loadings$X)>ncomp_plot){
      df.prcomp=as.data.frame(result$loadings$X[,c(1:ncomp_plot)])
    }else{
      df.prcomp=as.data.frame(result$loadings$X)
    }
    max.abs.loading<-apply(df.prcomp,1,function(x){
          
      return(max(abs(x),na.rm=TRUE))
    })
    
    max.abs.loading<-unlist(max.abs.loading)
    df.prcomp=df.prcomp[order(max.abs.loading,decreasing=TRUE)[1:30],]
    
    df.prcomp$varName=rownames(result$loadings$X[order(max.abs.loading,decreasing=TRUE)[1:30],])
    suppressMessages(library(tidyr))
    df.long.prcomp=gather(df.prcomp,"PC","loading",starts_with("PC"))
    
    p=ggplot(df.long.prcomp,aes_string(x="varName",y="loading",ymax="loading"))+geom_point()+geom_linerange(aes(ymin=0))+facet_wrap(~PC,nrow=1)+coord_flip()+ggtitle("top 30 variable loadings for PCs")
    p=p+theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                           panel.grid.minor = element_blank(),
                           panel.spacing=unit(1,"lines"),
                           axis.line = element_line(colour = "black",size=1),
                           
                           
                           legend.background = element_rect(color = "black", fill = "white"),
                           strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"))
    
    
    print(p)
    
        
  }
  
  return(list("result"=result,"pca_pval_vec"=pc_pval_single,"numcomp_plot"=ncomp_plot))
}




#get pls plots _v1.0.9.14
get_plsplots<-function(X,plsres,plsvar,samplelabels,filename=NA,ncomp=5,center=TRUE,scale=TRUE,legendcex=0.5,
                       outloc=getwd(),col_vec=NA,sample.col.opt="default",alphacol=0.3,legendlocation="topright",
                       class_levels=NA,pca.cex.val=0.8,pls.ellipse=TRUE,ellipse.conf.level=0.95,main_text="PLS-DA score plots",alphabetical.order=FALSE){
  
  result<-plsres
  r1<-plsvar
  
  pch.val=19
  legendlocation="bottomleft"
  
  samplelabels<-as.data.frame(samplelabels)
  samplelabels<-as.factor(samplelabels[,1])
  if(alphabetical.order==FALSE){
    
    samplelabels=factor(samplelabels,levels=unique(samplelabels))
  }
  l2<-levels(as.factor(samplelabels))
  col_all=topo.colors(256)
  
  t1<-table(samplelabels)
  t1=t1[which(t1>0)]
  
  if(is.na(class_levels)[1]==TRUE){
    
    l1<-levels(as.factor(samplelabels))
  }else{
    l1<-class_levels
    
    
  }
  
  class_labels_levels<-l1
  
  ncomp=min(dim(X)[1],dim(X)[2])
  
  if(is.na(col_vec)[1]==TRUE){
    col_vec<-c("mediumpurple4","mediumpurple1","blueviolet","darkblue","blue","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }
  
  if(sample.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{
    if(sample.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels))
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(sample.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(sample.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            if(sample.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=sample.col.opt)
              
              if(length(check_brewer)>0){
                
                sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                
              }else{
                
                #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                if(sample.col.opt=="journal"){
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                  
                }else{
                  
                 # if(length(sample.col.opt)==1){
                  #  col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  #}else{
                    
                   # colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    
                  #}
                  
                  
                  if(length(sample.col.opt)==1){
                    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  }else{
                    
                    if(length(sample.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-sample.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                      
                      
                    }else{
                      colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    }
                    
                  }
                }
                
              }
              
            }
            
          }
          
          
        }
        
      }
      
    }
  }
  #col_vec<-col_vec[sample(1:length(col_vec),length(col_vec))]
  
  l1<-gsub(x=l1,pattern="Class",replacement="")
  
  dir.create(outloc,showWarnings=FALSE)
  setwd(outloc)
  
  ## 1) raw data
  #tiff(fname,res=300, width=2000,height=2000)
  col <- rep(col_vec[1:length(t1)], t1)
  #col<-rep(col_all[1:length(l1)],t1)
  ## Choose different size of points
  cex <- rep(pca.cex.val, dim(X)[1])
  ## Choose the form of the points (square, circle, triangle and diamond-shaped
  
  
  
  #  pch_vec=c(3,5,7,9,12,13,2,17,21,23) 
  #}else{
   # set.seed(999)
  pch_vec<-rep(seq(0,25),2) #sample(seq(1,50),50) #c(3,5,7,9,12,13,2,17,21) # #
  #}
  #pch_vec <- rep(pch.val,dim(X)[1])
  #pch=pch_vec
  
  pch <- rep(pch_vec[1:length(t1)], t1)
  
  cex <- rep(pca.cex.val, dim(X)[1])
  col_per_group<-{}
  pch_per_group<-{}
  for(p1 in 1:length(l2)){
    
    pch[which(samplelabels==l2[p1])]=pch_vec[p1]
    col[which(samplelabels==l2[p1])]=col_vec[p1]
    col_per_group<-c(col_per_group,col_vec[p1])
    pch_per_group<-c(pch_per_group,pch_vec[p1])
  }
  
  
  #pch_vec<-seq(1,50) #c(3,5,7,9,12,13,2,17,21) #seq(1,50) #
  #pch_vec <- rep(pch.val,dim(X)[1])
  cex <- rep(pca.cex.val, dim(X)[1])
  
  
  ####savelist=ls(),file="plsdebug.Rda")
  
  #print(plotIndiv(result, comp = c(1,2),ind.names = FALSE, group=samplelabels, cex = cex[1], pch = pch, ellipse=FALSE, ellipse.level = 0.95, X.label=paste("PLS1 (",r1[1],"% variation)",sep=""),Y.label=paste("PLS2 (",r1[2],"% variation)",sep=""),add.legend=TRUE))
  
  #save(result,samplelabels,col_per_group,col_vec,main_text,col,cex,pch,pls.ellipse,r1,file="plsdebug.Rda")
  if(result$ncomp>1){
    
   # w <- 0.1
    #par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
    
   # print(plotIndiv(result, comp = c(1,2),ind.names = FALSE, group=samplelabels, cex = cex[1], pch = pch, ellipse=pls.ellipse, style="lattice",col.per.group=col_per_group,
    #                ellipse.level = 0.95, X.label=paste("PLS1 (",r1[1],"% variation)",sep=""),Y.label=paste("PLS2 (",r1[2],"% variation)",sep=""),legend=TRUE,title=main_text))
    plotIndiv(result,comp=c(1,2),group=as.factor(samplelabels),legend = TRUE,
              ellipse=pls.ellipse,style="lattice",
              title = main_text,col.per.group=col_per_group,
              X.label=paste("PLS1 (",r1[1],"% variation)",sep=""),Y.label=paste("PLS2 (",r1[2],"% variation)",sep=""))
    
   
  }
  if(result$ncomp>2){
    
   # w <- 0.1
    #par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
   # print(plotIndiv(result, comp = c(1,3),ind.names = FALSE, group=samplelabels, cex = cex[1], pch = pch, ellipse=pls.ellipse, style="lattice",col.per.group=col_per_group,
    #                ellipse.level = 0.95, X.label=paste("PLS1 (",r1[1],"% variation)",sep=""),Y.label=paste("PLS3 (",r1[3],"% variation)",sep=""),legend=TRUE,title=main_text))
    plotIndiv(result,comp=c(1,3),group=as.factor(samplelabels),legend = TRUE,
              ellipse=pls.ellipse,style="lattice",
              title = main_text,col.per.group=col_per_group,
              X.label=paste("PLS1 (",r1[1],"% variation)",sep=""),Y.label=paste("PLS3 (",r1[3],"% variation)",sep=""))
    
   
   # w <- 0.1
    #par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
   
   # print(plotIndiv(result, comp = c(2,3),ind.names = FALSE, group=samplelabels, cex = cex[1], pch = pch, ellipse=pls.ellipse, style="lattice",col.per.group=col_per_group,
    #                ellipse.level = 0.95, X.label=paste("PLS2 (",r1[2],"% variation)",sep=""),Y.label=paste("PLS3 (",r1[3],"% variation)",sep=""),legend=TRUE,title=main_text))
    
    plotIndiv(result,comp=c(2,3),group=as.factor(samplelabels),legend = TRUE,
              ellipse=pls.ellipse,style="lattice",
              title = main_text,col.per.group=col_per_group,
              X.label=paste("PLS2 (",r1[2],"% variation)",sep=""),Y.label=paste("PLS3 (",r1[3],"% variation)",sep=""))
    
  }
  
  
  
}


get_barplots<-function(feature_table_file,class_labels_file,X=NA,Y=NA,parentoutput_dir,newdevice=FALSE,
                       ylabel="Intensity",bar.colors=NA,cex.plots=0.6,barplot.col.opt="journal",
                       error.bar=TRUE,barplot.xaxis="Factor2",alphabetical.order=FALSE,name=NA,study.design="oneway",alphacol=1){
  
  analysistype=study.design
  cex.val=cex.plots
  xaxis=barplot.xaxis
  
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }else{
    data_matrix<-X
    rm(X)
    
  }
  
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  
  mzlabels<-data_matrix[,1]
  
  timelabels<-data_matrix[,2]
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  col_samples<-TRUE
  
  
  
  if(typeof(Y)=="logical"){
    if(is.na(class_labels_file)==FALSE){
      classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    }else{
      
      classlabels<-rep("classA",dim(data_m)[2])
      classlabels<-cbind(classlabels,classlabels)
      
      col_samples<-FALSE
      
    }
  }else{
    classlabels<-Y
    
  }
  
  
  
  classlabels<-as.data.frame(classlabels)
  
  pairedanalysis=FALSE
  if(analysistype=="twowayrepeat" | analysistype=="2wayrepeat" | analysistype=="onewayrepeat" | analysistype=="1wayrepeat"){
    
    pairedanalysis=TRUE
  }
  
  
  if(dim(classlabels)[2]>2){
    if(pairedanalysis==TRUE){
      
      #    paireddesign=classlabels[,2]
      
      #classlabels_orig<-classlabels_orig[,-c(2)]
    }
    
    if(analysistype=="twowayrepeat" | analysistype=="2wayrepeat" | analysistype=="twoway" | analysistype=="2way"){
      Class<-paste(classlabels[,2],":",classlabels[,3],sep="") #classlabels[,2]:classlabels[,3]
      
      tabbed_groups<-TRUE
    }else{
      Class<-classlabels[,2]
      
      tabbed_groups=FALSE
    }
    
  }else{
    
    Class<-classlabels[,2]
    
    tabbed_groups=FALSE
  }
  
  if(alphabetical.order==FALSE){
    Class <- factor(Class, levels=unique(Class))
  }
  
  
  class_labels_levels<-levels(as.factor(Class))
  
  barplot.col.opt<-barplot.col.opt[1]
  
  if(is.na(barplot.col.opt)==FALSE)
  {
    if(barplot.col.opt=="default"){
      
      col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
                 "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
                 "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
                 "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
      
    }else{
      if(barplot.col.opt=="topo"){
        #col_vec<-topo.colors(256) #length(class_labels_levels))
        
        #col_vec<-col_vec[seq(1,length(col_vec),)]
        
        col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(barplot.col.opt=="heat"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          
          col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          if(barplot.col.opt=="rainbow"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(barplot.col.opt=="terrain"){
              
              col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
            }else{
              if(is.na(barplot.col.opt)==TRUE){
                col_vec<-c("black")
              }else{
                
                if(barplot.col.opt=="colorblind"){
                  #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                  # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                  
                  if(length(class_labels_levels)<9){
                    
                    col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                    
                  }else{
                    
                    #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                               "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                    
                  }
                  
                  
                }else{
                  
                  check_brewer<-grep(pattern="brewer",x=barplot.col.opt)
                  
                  if(length(check_brewer)>0){
                    barplot.col.opt=gsub(x=barplot.col.opt,pattern="brewer.",replacement="")
                    col_vec <- colorRampPalette(brewer.pal(10, barplot.col.opt))(length(class_labels_levels))
                    
                  }else{
                    
                    if(barplot.col.opt=="journal"){
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                 "#E64B3519","#4DBBD519","#631879E5","grey75")
                      if(length(class_labels_levels)<8){
                        col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                        
                        #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                        
                      }else{
                        if(length(class_labels_levels)<=28){
                          # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                          
                          col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                     "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                     "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                     
                                     "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                     "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                          
                        }else{
                          
                          
                          
                          
                          colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                          
                          col_vec<-col_vec[sample(col_vec)]
                          
                          
                        }
                      }
                      
                    }else{
                      col_vec <-barplot.col.opt
                    }
                    
                  }
                  
                }
              }
            }
            
            
          }
          
        }
        
      }
    }
  }else{
    
    col_vec<-c("grey57")
    
  }
  
  
  mtcars<-t(data_m)
  Class<-as.character(Class)
  
  
  col_vec=alpha(col_vec,alphacol)
  
  
  if(newdevice==TRUE){
    
    pdf("barplots.pdf")
    
    plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
    
    
    text(5, 8, "Barplots using the\n normalized intensities/adundance levels")
    
    
  }
  
  #par(mfrow=c(2,2),family="sans",cex=cex.plots)
  #par(mfrow=c(2,2),family="sans",cex=cex.plots,pty="s")
  # par(mfrow=c(par_rows,max_per_row))
  
  myData_list<-new("list")
  
  
  
  time_start<-Sys.time()
  ##savelist=ls(),file="debugbarplot.Rda")
  if(tabbed_groups==FALSE){
    
    mtcars<-cbind(Class,mtcars)
    mtcars<-as.data.frame(mtcars)
    mtcars <- do.call(data.frame, mtcars)
    
    if(alphabetical.order==FALSE){
      mtcars$Class<- factor(mtcars$Class, levels=unique(mtcars$Class))
      
      
    }
    
    mtcars_sum<-do.call(data.frame,aggregate(list(mtcars[-c(1)]),by=list(mtcars$Class),FUN = function(x) {x<-as.numeric(as.character(x));c(mean = mean(x), sd = sd(x),n = length(x),se=sd(x)/sqrt(length(x)))}))
    
    label_inc_list<-seq(2,dim(mtcars_sum)[2],4) #seq(1,dim(mtcars_sum)[2],3)
    # ##save(list=ls(),file="debugbarplot.Rda")
    #  for(i in 2:dim(mtcars)[2]){
    myData_list<-lapply(seq(2,dim(mtcars_sum)[2],4),function(i){
      
      myData<-mtcars_sum[,c(1,i:(i+3))]
      colnames(myData) <- c("Class", "Intensity", "sd", "n", "se")
      
      get_label_ind<-which(label_inc_list==i)
   #   round_mzval<-sprintf("%.4f",mzlabels[get_label_ind])
    #  round_timeval<-sprintf("%.1f",timelabels[get_label_ind])
      
      round_mzval<-mzlabels[get_label_ind]
      round_timeval<-timelabels[get_label_ind]
      
      
      if(is.na(name[1])==TRUE){
        
        mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
      }else{
        
        mzlabel_cur<-name[get_label_ind]
        
      }
      
      
      ymax = myData$Intensity + 1.96*myData$se
      
      ymin = myData$Intensity - 1.96*myData$se
      
      max_yval<-ceiling(max((myData$Intensity + (3*myData$se)),na.rm=TRUE)) #round(max(myData$Intensity+(4*myData$se),na.rm=TRUE))
      
      
      min_yval<-max(0,floor(min((myData$Intensity - (3*myData$se)),na.rm=TRUE)))
      
      below_zero_check<-which(ymin<0)
      if(length(below_zero_check)>0){
        
        ymin[below_zero_check]<-0
      }
      
      
      
      myData$Class<-as.factor(myData$Class)
      
      colnames(myData) <- c("Class", "Intensity", "sd", "n", "se")
      
      t1<-table(myData$Class)
      
      barplot.col.opt1=rep(col_vec[1:length(t1)],t1)
      
      
      
      w <- 0.1
      par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
      ylim=range(pretty(c(min_yval,ymax)))
      rnum=length(unique(myData$Class))
      if(rnum<7)
      {
        
        space_vec=c(2,2,1.5,1,0.5,0.25)
        name_vec=unique(myData$Class)
        # barCenters=barplot(myData$Intensity,ylab=ylabel,xlab="",main=mzlabel_cur,col=barplot.col.opt1,width=0.125,xlim=c(0,1),names.arg=name_vec[1:rnum],xpd=FALSE,ylim=ylim,space=space_vec[rnum])
        barCenters=barplot(myData$Intensity,ylab=ylabel,xlab="",main=mzlabel_cur,col=barplot.col.opt1,width=0.125,xlim=c(0,1),names.arg=NULL,xpd=FALSE,space=space_vec[rnum], ylim=ylim)
        
      }else{
        #   barCenters=barplot(myData$Intensity,ylab=ylabel,xlab="",main=mzlabel_cur,col=barplot.col.opt1,space=0.1,names.arg=unique(myData$Class),xpd=FALSE,ylim=ylim)
        barCenters=barplot(myData$Intensity,ylab=ylabel,xlab="",main=mzlabel_cur,col=barplot.col.opt1,space=0.1,names.arg=NULL,xpd=FALSE,ylim=ylim)
      }
      
      if(error.bar==TRUE){
        arrows(barCenters, ymin,barCenters, ymax,angle=90,code=3,lty=1,lwd=1.25,length=0.05)
      }
      
      
      
      legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,unique(myData$Class), col = col_vec[1:length(t1)],pch = rep(19,length(col_vec[1:length(t1)])), pt.cex = 0.6, title = "Class",cex=0.8)
      
      return(myData)
      
    })
    
  }else{
    save(data_m,mtcars,classlabels,file="barplots.Rda")
    mtcars<-cbind(classlabels[,2:3],mtcars[which(rownames(mtcars)%in%classlabels[,1]),])
    mtcars<-as.data.frame(mtcars)
    cnames_mtcars<-colnames(mtcars)
    cnames_mtcars[1:2]<-c("Factor1","Factor2")
    colnames(mtcars)<-cnames_mtcars
    mtcars <- do.call(data.frame, mtcars)
    
    
    if(alphabetical.order==FALSE){
      mtcars$Factor1<- factor(mtcars$Factor1, levels=unique(mtcars$Factor1))
      mtcars$Factor2<- factor(mtcars$Factor2, levels=unique(mtcars$Factor2))
      
    }
    
    mtcars_sum<-do.call(data.frame,aggregate(list(mtcars[-c(1:2)]),by=list(Factor1=mtcars$Factor1,Factor2=mtcars$Factor2),FUN = function(x) {x<-as.numeric(as.character(x));c(mean = mean(x), sd = sd(x),n = length(x),se=sd(x)/sqrt(length(x)))}))
    
    
    
    
    label_inc_list<-seq(3,dim(mtcars_sum)[2],4) #seq(1,dim(mtcars_sum)[2],3)
    ####savelist=ls(),file="debugbarplot.Rda")
    #  for(i in 2:dim(mtcars)[2]){
    myData_list<-lapply(seq(3,dim(mtcars_sum)[2],4),function(i){
      
      myData<-mtcars_sum[,c(1:2,i:(i+3))]
      colnames(myData) <- c("Factor1", "Factor2", "Intensity", "sd", "n", "se")
      
      if(xaxis=="Factor1"){
        tabbedMeans <- tapply(myData$Intensity, list(myData$Factor2,myData$Factor1),
                              function(x) c(x = x))
        
        tabbedSE <- tapply(myData$se, list(myData$Factor2,myData$Factor1),
                           function(x) c(x = x))
        
      }else{
        
        if(xaxis=="Factor2"){
          tabbedMeans <- tapply(myData$Intensity, list(myData$Factor1,myData$Factor2),
                                function(x) c(x = x))
          
          tabbedSE <- tapply(myData$se, list(myData$Factor1,myData$Factor2),
                             function(x) c(x = x))
        }
        
        
      }
      get_label_ind<-which(label_inc_list==i)
      round_mzval<-mzlabels[get_label_ind] #sprintf("%.4f",mzlabels[get_label_ind])
      round_timeval<-timelabels[get_label_ind] #sprintf("%.1f",timelabels[get_label_ind])
      
      # mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
      
      if(is.na(name[1])==TRUE){
        
        mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
      }else{
        
        mzlabel_cur<-name[get_label_ind]
        
      }
      
      
      ymax = tabbedMeans + 1.96*tabbedSE
      
      ymin = tabbedMeans - 1.96*tabbedSE
      
      max_yval<-ceiling(max((tabbedMeans + (3*tabbedSE)),na.rm=TRUE)) #round(max(myData$Intensity+(4*myData$se),na.rm=TRUE))
      
      min_yval<-max(0,floor(min((tabbedMeans - (3*tabbedSE)),na.rm=TRUE)))
      
      below_zero_check<-which(ymin<0)
      
      if(length(below_zero_check)>0){
        
        ymin[below_zero_check]<-0
      }
      
      if(xaxis=="Factor2"){
        
        t1<-table(factor(myData$Factor1))
        t2<-table(factor(myData$Factor2))
      }else{
        t1<-table(factor(myData$Factor2))
        t2<-table(factor(myData$Factor1))
      }
      
      barplot.col.opt1=rep(col_vec[1:length(t1)],length(t2))
      
      w <- 0.1
      par(omd=c(0, 1-w, 0, 1),cex.main=1)
      ylim=range(pretty(c(min_yval,ymax)))
      
      
      barCenters=barplot(tabbedMeans,beside=TRUE, ylab=ylabel,xlab="",main=mzlabel_cur,col=barplot.col.opt1,las=1,names.arg=unique(myData$Class),xpd=FALSE,border = "black",ylim=ylim)
      
      segments(barCenters, ymin, barCenters,ymax, lwd = 1.25)
      
      if(error.bar==TRUE){
        # arrows(barCenters, ymin,barCenters, ymax,angle=90,code=3,lty=1,lwd=1.25,length=0.05)
        arrows(barCenters, ymin, barCenters, ymax, lwd = 1.25, angle = 90, code = 3, length = 0.05)
      }
      
      if(xaxis=="Factor1"){
        legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,unique(myData$Factor2), col = col_vec[1:length(t1)],pch = rep(19,length(col_vec[1:length(t1)])), pt.cex = 0.6, title = "",cex=0.8)
      }else{
        legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,unique(myData$Factor1), col = col_vec[1:length(t1)],pch = rep(19,length(col_vec[1:length(t1)])), pt.cex = 0.6, title = "",cex=0.8)
        
      }
      return(myData)
      
    })
    
    
    
    
    
    
  }
  
  
  
  if(newdevice==TRUE){
    try(dev.off(),silent=TRUE)
  }
  
  # suppressWarnings(dir.create("Tables"))
  
  ###savemyData_list,file="Tables/barplots_data.Rda")
  
  
}



get_individualsampleplots<-function(feature_table_file,class_labels_file,X=NA,Y=NA,parentoutput_dir,newdevice=FALSE,
                                    ylabel="Intensity",bar.colors=NA,cex.plots=0.75,sample.col.opt=c("grey57"),alphabetical.order=FALSE,name=NA){
  
  cex.val=cex.plots
  
  plottype="barplot"
  
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }else{
    data_matrix<-X
    rm(X)
    
  }
  
  par(mfrow=c(1,1),family="sans",cex=cex.val)
  alphacol=0.3
  
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  mzlabels<-data_matrix[,1]
  
  timelabels<-data_matrix[,2]
  
  
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  col_samples<-TRUE
  
  
  if(typeof(Y)=="logical"){
    if(is.na(class_labels_file)==FALSE){
      classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    }else{
      
      classlabels<-rep("classA",dim(data_m)[2])
      classlabels<-cbind(classlabels,classlabels)
      
      col_samples<-FALSE
      
    }
  }else{
    classlabels<-Y
    
  }
  
  
  
  classlabels<-as.data.frame(classlabels)
  
  
  
  
  if(dim(classlabels)[2]>2){
    
    Class<-paste(classlabels[,2],":",classlabels[,3],sep="") #classlabels[,2]:classlabels[,3]
  }else{
    
    Class<-classlabels[,2]
  }
  
  #keeps the class order same as in the input file; avoids arrangement by alphabetical order
  if(alphabetical.order==FALSE){
    Class <- factor(Class, levels=unique(Class))
  }
  
  class_labels_levels<-levels(as.factor(Class))
  
  
  if(sample.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{
    if(sample.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels))
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(sample.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(sample.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=sample.col.opt)
              
              if(length(check_brewer)>0){
                
                sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                
              }else{
                
                if(sample.col.opt=="journal"){
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                }else{
                  #col_vec <-rep(sample.col.opt,length(class_labels_levels))
                #  if(length(sample.col.opt)==1){
                 #   col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  #}else{
                    
                   # colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    
                  #}
                  
                  if(length(sample.col.opt)==1){
                    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  }else{
                    
                    if(length(sample.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-sample.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                      
                      
                    }else{
                      colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    }
                    
                  }
                  
                }
                
              }
              
            }
          }
          
          
        }
        
      }
      
    }
  }
  
  mtcars<-t(data_m)
  Class<-as.character(Class)
  
  barplot.col.opt=col_vec
  
  mtcars<-cbind(Class,mtcars)
  mtcars<-as.data.frame(mtcars)
  
  mtcars<-mtcars[order(mtcars$Class),]
  
  if(newdevice==TRUE){
    
    pdf("individual.sample.plots.pdf")
    
  }
  
  col_per_group<-{}
  pch_per_group<-{}
  
  l2<-levels(as.factor(Class))
  col1<-rep("red",length(Class))
  
  
  
  par_rows=2
  max_per_row=2
  
  # par(mfrow=c(par_rows,max_per_row))
  
  myData_list<-new("list")
  
  mtcars <- do.call(data.frame, mtcars)
  
  ####savemtcars,file="mtcars.Rda")
  
  
  
  #for(i in 2:dim(mtcars)[2]){
  lapply(2:dim(mtcars)[2],function(i){
    x<-as.numeric(as.character(mtcars[,i]))
    
    myData <- x
    
    myData<-cbind(mtcars$Class,myData)
    colnames(myData)<-c("Class","Intensity")
    #myData<-myData[c(2:3,1,4:5),]
    
    myData <- as.data.frame(myData)
    myData<-myData[order(myData$Class),]
    
    
    
    round_mzval<-mzlabels[(i-1)] #sprintf("%.4f",mzlabels[(i-1)])
    round_timeval<-timelabels[(i-1)] #sprintf("%.1f",timelabels[(i-1)])
    
    #mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
    
    if(is.na(name[1])==TRUE){
      
      mzlabel_cur<-paste("mz_time: ",round_mzval,"_",round_timeval,sep="")
    }else{
      
      mzlabel_cur<-name[i-1]
    }
    
    t1<-table(myData$Class)
    if(length(barplot.col.opt)<2){
      
      barplot.col.opt1=rep(barplot.col.opt,length(myData$Class))
    }else{
      
      
      if(length(barplot.col.opt)==length(levels(factor(myData$Class)))){
        
        #barplot.col.opt1=rep(barplot.col.opt,t1)
        
        barplot.col.opt1=rep(barplot.col.opt[1:length(t1)],t1)
        
        
      }else{
        
        # print("Number of classes is greater than the length of the color vector. Using default colors.")
        #col_clust<-topo.colors(length(t1))
        #barplot.col.opt1=col1
        #t1<-table(mtcars$Class)
        #barplot.col.opt1=rep(barplot.col.opt,t1)
        barplot.col.opt1=rep(barplot.col.opt[1:length(t1)],t1)
      }
      
      
    }
    
    #print(barplot.col.opt1)
    #barplot.col.opt1=barplot.col.opt
    
    # print(barplot.col.opt1)
    
    if(alphabetical.order==FALSE){
      myData$Class<-factor(myData$Class,levels=unique(myData$Class))
      
    }else{
      myData$Class<-factor(myData$Class)
    }
    Samples<-seq(1,nrow(myData))
    Var2<-rep(1,nrow(myData))
    myData<-cbind(myData,Samples,Var2)
    
    
  #  save(myData,file="myData.Rda")
    # ###savelist=ls(),file="barplotdebug.Rda")
    
    if(plottype=="barplot"){
      #barplot(as.vector(myData[,2]),col=c(barplot.col.opt1),main=mzlabel_cur, ylab="Intensity",xlab="Sample") #,ylim=c(min(myData[,2])-1,max(myData[,2])+1),xpd=FALSE)
      
      
      w <- 0.1
      par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
      
      min_yval=min(myData[,2],na.rm=TRUE)
      ymax=max(myData[,2],na.rm=TRUE)
      ylim=range(pretty(c(min_yval,ymax)))
      
      plot(as.vector(myData[,2]),col=c(barplot.col.opt1),main=mzlabel_cur, ylab=ylabel,xlab="Sample",type="h",lwd=2,ylim=ylim)
      
      
      
      legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,levels(as.factor(mtcars$Class)), col = col_vec[1:length(t1)],pch = rep(19,length(col_vec[1:length(t1)])), pt.cex = 0.6, title = "Class",cex=0.8)
      
      
      if(FALSE){
        barplot1 <- ggplot(data=myData) + geom_bar(aes(x=Samples, y=Intensity, fill=Class), stat="identity") + facet_wrap(~Var2) + scale_fill_manual(values=unique(barplot.col.opt1)) + ggtitle(mzlabel_cur) + ylab(ylabel) + xlab("Samples") + theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
                                                                                                                                                                                                                                                                   panel.grid.minor = element_blank(), axis.line = element_line(colour = "black",size=sizeval), plot.margin=unit(c(10,5,5,5),"mm"),
                                                                                                                                                                                                                                                                   strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
                                                                                                                                                                                                                                                                   strip.text = element_text(face="bold"))
      }
      
      #print(barplot1)
      
    }else{
      if(plottype=="point"){
        plot(as.vector(myData[,2]),col=c(barplot.col.opt1),main=mzlabel_cur, ylab=ylab,xlab="Samples",type="p",ylim=range(pretty(c(0,max(myData[,2],na.rm=TRUE)))))
      }else{
        
        if(plottype=="ggplot"){
          p <- ggplot(data = myData, aes(x = Class, y = Intensity,fill=Class)) + scale_fill_manual(values = c(barplot.col.opt1)) + ylab(ylabel)
          p=p+geom_point(size=cex.plots)+ggtitle(mzlabel_cur) #,aes(colour=barplot.col.opt))
          print(p)
        }
      }
    }
    
    
  })
  if(newdevice==TRUE){
    try(dev.off(),silent=TRUE)
  }
  
  
  
  
}

#W.k for gap statistic
W.k <- function(x, clus,d.power=1) {
  n <- nrow(x);ii <- seq_len(n)
  res<-suppressWarnings(0.5 * sum(vapply(split(ii, clus), function(I) {
    xs <- x[I, , drop = FALSE]
    sum(dist(xs)^d.power/nrow(xs))
  }, 0)))
  
 print(res)
  logW.k<-log(res+0.001)
  return(logW.k)
}

E.W.k<-function(x, d.power=1,B=100) {
  
 
  rng.x1 <- apply(x, 2L, range)
  logWks <- matrix(0, B, 1)
 
  xs <- scale(x, center = TRUE, scale = FALSE)
  m.x <- rep(attr(xs, "scaled:center"), each = n)
  z1 <- apply(rng.x1, 2, function(M, nn) runif(nn, min = M[1], 
                                               max = M[2]), nn = n)
  
  cl <- parallel::makeCluster(getOption("cl.cores", 0.5*detectCores()))
  clusterEvalQ(cl,library(WGCNA))
  clusterEvalQ(cl,library(fastcluster))
  clusterEvalQ(cl,library(dynamicTreeCut))
  clusterExport(cl,"W.k",envir = .GlobalEnv)
  res<-parLapply(cl,1:B,function(b){
    z <-x[sample(1:nrow(x)),sample(1:ncol(x))]#z1 + m.x
    
   
    dist2<-as.dist(1-WGCNA::cor(z))
    f2=fastcluster::hclust(d=dist2,method = "complete")
    
    mycl_metabs2 <-suppressWarnings(cutreeDynamic(f2,distM=as.matrix((dist2)),cutHeight = 0.95,verbose = FALSE,
                                                  ,deepSplit = 4,minClusterSize = 2,pamStage = FALSE,pamRespectsDendro = FALSE))
    names(mycl_metabs2)<-f2$labels
    
    wk<-W.k(x=t(z),clus=mycl_metabs2)
    #if(wk>0){
    cval1<- wk
    #}else{
      
     # cval1<- log(0.001)
    #}
    return(cval1)
  })
  stopCluster(cl)
  res<-unlist(res)
  print(summary(res,na.rm=TRUE))
  E.logW<-(mean(res,na.rm=TRUE))
  return(E.logW)
}


get_hca<-function(feature_table_file=NA,parentoutput_dir,class_labels_file=NA,X=NA,Y=NA,heatmap.col.opt="RdBu",cor.method="spearman",
                  is.data.znorm=FALSE,analysismode="classification",
                  sample.col.opt=c("journal", "npg", "nejm", "jco", "lancet", "custom1", "brewer.RdYlBu", "brewer.RdBu", "brewer.PuOr", 
                                   "brewer.PRGn", "brewer.PiYG", "brewer.BrBG", "brewer.Set2", "brewer.Paired", "brewer.Dark2", "brewer.YlGnBu", "brewer.YlGn",
                                   "brewer.YlOrRd", "brewer.YlOrBr", "brewer.PuBuGn", "brewer.PuRd", "brewer.PuBu", "brewer.OrRd", "brewer.GnBu", "brewer.BuPu",
                                   "brewer.BuGn", "brewer.blues", "black", "grey65", "terrain", "rainbow", "heat", "topo"),
                  plots.width=8,plots.height=8,plots.res=600, plots.type="cairo", alphacol=1, hca_type="two-way",
                  newdevice=FALSE,input.type="intensity",mainlab="",cexRow=0.5, cexCol=0.5,plot.bycluster=FALSE,color.rows=TRUE,
                  similarity.matrix="correlation",deepsplit=4,minclustsize=2,mergeCutHeight=0.05,num_nodes=2,alphabetical.order=FALSE,
                  pairedanalysis=FALSE,cutree.method=c("dynamic","default"),study.design=c("multiclass","onewayanova","twowayanova","onewayanovarepeat",
                                                                                 "twowayanovarepeat"),labRow.value = FALSE,
                  labCol.value = FALSE,power_val=6,row.col.opt="journal",show.silhouette=FALSE,cexLegend=0.7,ylab_text="",xlab_text="",heatmap_file="heatmap")
{
  match_col.opt=match(sample.col.opt,c("journal","npg","nejm","jco","lancet","custom1","brewer.RdYlBu","brewer.RdBu","brewer.PuOr","brewer.PRGn","brewer.PiYG","brewer.BrBG",
                                       "brewer.Set2","brewer.Paired","brewer.Dark2","brewer.YlGnBu","brewer.YlGn","brewer.YlOrRd","brewer.YlOrBr","brewer.PuBuGn",
                                       "brewer.PuRd","brewer.PuBu",
                                       "brewer.OrRd","brewer.GnBu","brewer.BuPu","brewer.BuGn","brewer.blues","black","grey65","terrain","rainbow","heat","topo"))
  
  match_col.opt=length(which(is.na(match_col.opt)==TRUE))
  
  cutree.method=cutree.method[1]
  
  if(length(match_col.opt)<1){
    
    sample.col.opt=sample.col.opt[1]
  }else{
    
    if(length(grep(sample.col.opt,pattern="brewer."))>1){
      
      sample.col.opt=sample.col.opt[1]
    }
  }
  if(length(sample.col.opt)==1){
    
    check_brewer<-grep(pattern="brewer",x=sample.col.opt)
       
       if(length(check_brewer)<1){
         
        
    sample.col.opt=tolower(sample.col.opt)
    sample.col.opt=get_hexcolors_for_palettes(color.palette=sample.col.opt[1],alpha.col=alphacol[1])
       }
  }
  
  print(study.design)
  
  h73<-get_hca_child(X=X,Y=Y,feature_table_file=feature_table_file,parentoutput_dir=parentoutput_dir,class_labels_file=class_labels_file,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,
                     is.data.znorm=is.data.znorm,analysismode=analysismode,
                     sample.col.opt=sample.col.opt,plots.width=plots.width,plots.height=plots.height,plots.res=plots.res, plots.type=plots.type, 
                     alphacol=alphacol, hca_type=hca_type,newdevice=newdevice,input.type=input.type,mainlab=mainlab,cexRow=cexRow, 
                     cexCol=cexCol,plot.bycluster=plot.bycluster,color.rows=color.rows,similarity.matrix=similarity.matrix,deepsplit=deepsplit,minclustsize=minclustsize,
                     mergeCutHeight=mergeCutHeight,num_nodes=num_nodes,alphabetical.order=alphabetical.order,
                     pairedanalysis=pairedanalysis,cutree.method=cutree.method,study.design=study.design,labRow.value=labRow.value,labCol.value=labCol.value,power_val=power_val,row.col.opt=row.col.opt,
                     show.silhouette=show.silhouette,cexLegend=cexLegend,ylab_text=ylab_text,xlab_text=xlab_text,heatmap_file=heatmap_file)
  return(h73)
}

get_hca_child<-function(feature_table_file,parentoutput_dir,class_labels_file,X=NA,Y=NA,heatmap.col.opt="RdBu",cor.method="spearman",is.data.znorm=FALSE,analysismode="classification",
                        sample.col.opt="rainbow",plots.width=8,plots.height=8,plots.res=600, plots.type="cairo", alphacol=0.3, 
                        hca_type,newdevice=FALSE,input.type="intensity",mainlab="",cexRow=0.5, cexCol=0.5,
                        plot.bycluster=FALSE,color.rows=FALSE,similarity.matrix="correlation",deepsplit=2,minclustsize=10,mergeCutHeight=0.1,
                        num_nodes=2,alphabetical.order=FALSE,pairedanalysis=FALSE,cutree.method="halfheight",study.design="multiclass",labRow.value = FALSE,
                        labCol.value = FALSE,power_val=6,row.col.opt="journal",show.silhouette=FALSE,cexLegend=0.7,ylab_text="",xlab_text="",heatmap_file="heatmap")
{
  
  
  print(study.design)
  suppressMessages(library(WGCNA))
  suppressMessages(library(flashClust))
  suppressMessages(library(gplots))
  suppressMessages(library(cluster))
  suppressMessages(library(mclust))
  
  suppressMessages(library(RColorBrewer))
  
  analysistype=study.design
  
 
  
  if(typeof(X)=="logical"){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
 
    
   }else{
    data_matrix<-X
    rm(X)
    
  }
  
  
  mycl_metabs={}
  mycl_samples={}    
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(data_matrix)+1,1)
        time<-seq(1.01,nrow(data_matrix)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        data_matrix<-as.data.frame(data_matrix)
        
        Name<-as.character(data_matrix[,check_ind])
        
        data_matrix<-cbind(mz,time,data_matrix[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        data_matrix<-as.data.frame(data_matrix)
        
        #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
        rownames(data_matrix)<-as.character(Name)
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(data_matrix[,check_ind])
          data_matrix<-data_matrix[,-check_ind]
          names_with_mz_time=cbind(Name,data_matrix$mz,data_matrix$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          data_matrix<-as.data.frame
          rownames(data_matrix)<-as.character(Name)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  col_metabs=color.rows
  
  data_m<-data_matrix[,-c(1:2)]
  
  data_m<-as.matrix(data_m)
  
  rownames(data_m)<-rownames(data_matrix)
  col_samples<-TRUE
  
  suppressWarnings(dir.create("Tables",showWarnings = FALSE))
  
  
  if(labRow.value==TRUE){
    
    labRow.value=rownames(data_m)
  }else{
    
    labRow.value=NA
    
  }
  
  if(labCol.value==TRUE){
    
    labCol.value=colnames(data_m)
  }else{
    
    labCol.value=NA
  }
  
  if(is.na(cexLegend)==TRUE){
    
    hca.show.legend=FALSE
  }else{
    hca.show.legend=TRUE
    
  }
  
  
  if(plot.bycluster==TRUE){
    
    hca.show.legend=FALSE
  }
  
  
  if(typeof(Y)=="logical"){
    if(is.na(class_labels_file)==FALSE){
      classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    }else{
      
      classlabels<-rep("classA",dim(data_m)[2])
      classlabels<-cbind(classlabels,classlabels)
      
      col_samples<-FALSE
      
    }
  }else{
    classlabels<-Y
    
  }
  
  
  classlabels_orig<-classlabels
  
  if(analysistype=="twowayrepeat" | analysistype=="2wayrepeat" | analysistype=="onewayrepeat" | analysistype=="1wayrepeat"){
    
    pairedanalysis=TRUE
  }
  
  print("hca classlabels")
  print(pairedanalysis)
  print(analysistype)
  print(study.design)
  print(dim(classlabels))
  
  if(dim(classlabels)[2]>2){
    
    if(pairedanalysis==TRUE){
      
      paireddesign=classlabels_orig[,2]
      
      classlabels_orig<-classlabels_orig[,-c(2)]
      
      classlabels<-classlabels[,-c(2)]
    }
    
    if(dim(classlabels_orig)[2]>2){
      
      if(analysistype=="twowayrepeat" | analysistype=="2wayrepeat" | analysistype=="twoway" | analysistype=="2way" | analysistype=="twowayanova" | analysistype=="twowayanovarepeat"){
        
        classgroup<-paste(classlabels_orig[,2],":",classlabels_orig[,3],sep="")
        
      }else{
        
        classgroup<-classlabels_orig[,2]
      }
      
    }else{
      
      classgroup<-classlabels_orig[,2]
    }
    
  }else{
    
    classgroup<-classlabels_orig[,2]
    
    
  }
  classlabels[,2]<-classgroup

  
  names(classgroup)<-classlabels[,1]
  
  #patientcolors<-rep("green",dim(data_m)[2])
  
  #keeps the class order same as in the input file; avoids arrangement by alphabetical order
  if(alphabetical.order==FALSE){
    classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
  }
  
  
  class_labels_levels<-levels(as.factor(classlabels[,2]))
  ordered_labels<-classlabels[,2]
  
  #class_label_alphabets<-c("A","B","C","D","E","F","G","H","I","J","K","L","M")
  class_label_alphabets<-class_labels_levels #paste("C",1:length(class_labels_levels),sep="")
  
  if(sample.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{
    if(sample.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels))
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(sample.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(sample.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            if(sample.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                # col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              
              check_brewer<-grep(pattern="brewer",x=sample.col.opt)
              
              if(length(check_brewer)>0){
                
                sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                
              }else{
                
                if(sample.col.opt=="journal"){
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                  
                }else{
                  #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                  
                 # if(length(sample.col.opt)==1){
                  #  col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  #}else{
                    
                   # colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    
                   # col_vec <-sample.col.opt
                    #col_vec <- rep(col_vec,length(class_labels_levels))
                    
                  #}
                  
                  if(length(sample.col.opt)==1){
                    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  }else{
                    
                    if(length(sample.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-sample.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                      
                      
                    }else{
                      colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    }
                    
                  }
                  
                }
                
              }
              
            }
          }
          
          
        }
        
      }
      
    }
  }
  col_samples=FALSE
  
  
  if(analysismode=="classification")
  {
    #save(classlabels,class_labels_levels,class_label_alphabets,ordered_labels,file="hca2.Rda")
    
    sampleclass<-{}
    patientcolors<-rep("green",nrow(classlabels))
    #print(classlabels)
    classlabels<-as.data.frame(classlabels)
    f<-factor(classlabels[,1])
    
    col_samples=TRUE
    for(c in 1:length(class_labels_levels)){
      
      num_samps_group_cur=length(which(ordered_labels==class_labels_levels[c]))
      
      #classlabels<-c(classlabels,rep(paste("Class",class_label_alphabets,sep=""),num_samps_group_cur))
      #,rep("ClassB",num_samps_group[[2]]),rep("ClassC",num_samps_group[[3]]))
      sampleclass<-c(sampleclass,rep(paste("Class",class_label_alphabets[c],sep=""),num_samps_group_cur))
      
      #patientcolors <-c(patientcolors,rep(col_vec[c],num_samps_group_cur))
      patientcolors[which(ordered_labels==class_labels_levels[c])]<-col_vec[c]
      
    }
    
    
    
  }
  
  if(heatmap.col.opt=="RdBu"){
    
    heatmap.col.opt="redblue"
  }
  
  heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
  heatmap_cols<-rev(heatmap_cols)
  
  if(heatmap.col.opt=="topo"){
    heatmap_cols<-topo.colors(256)
    heatmap_cols<-rev(heatmap_cols)
  }else{
    if(heatmap.col.opt=="heat"){
      heatmap_cols<-heat.colors(256)
      heatmap_cols<-rev(heatmap_cols)
    }else{
      
      if(heatmap.col.opt=="yellowblue"){
        
        heatmap_cols<-colorRampPalette(c("yellow","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
        #heatmap_cols<-blue2yellow(256) #colorRampPalette(c("yellow","blue"))(256)
        heatmap_cols<-rev(heatmap_cols)
      }else{
        
        if(heatmap.col.opt=="redblue"){
          
          heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
          heatmap_cols<-rev(heatmap_cols)
        }else{
          
          #my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
          if(heatmap.col.opt=="redyellowgreen"){
            
            heatmap_cols <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
            heatmap_cols<-rev(heatmap_cols)
          }else{
            if(heatmap.col.opt=="yellowwhiteblue"){
              
              heatmap_cols<-colorRampPalette(c("yellow2","white","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
              heatmap_cols<-rev(heatmap_cols)
            }else{
              
              if(heatmap.col.opt=="redwhiteblue"){
                
                heatmap_cols<-colorRampPalette(c("red","white","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
                heatmap_cols<-rev(heatmap_cols)
              }else{
                
                
                if(length(grep(heatmap.col.opt,pattern = "brewer."))>0){
                 
                  heatmap.col.opt<-gsub(heatmap.col.opt,pattern="brewer.",replacement="")
                
                heatmap_cols <- colorRampPalette(brewer.pal(10, heatmap.col.opt))(256)
                heatmap_cols<-rev(heatmap_cols)
                }else{
                  
                  if(heatmap.col.opt=="bluered"){
                    
                    heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
                   # heatmap_cols<-rev(heatmap_cols)
                  }else{
                    
                    if(heatmap.col.opt=="blueorange"){
                      
                      heatmap_cols <- colorRampPalette(c("orange","blue"))(256)
                      # heatmap_cols<-rev(heatmap_cols)
                    }else{
                      
                      if(heatmap.col.opt=="orangeblue"){
                        
                        heatmap_cols <- colorRampPalette(c("orange","blue"))(256)
                        heatmap_cols<-rev(heatmap_cols)
                      }
                    }
                  }
                  
                }
              }
              
            }
            
          }
          
        }
        
      }
    }
    
  }
  
  # print(classlabels)
  #print(patientcolors)
  col_vec2 <- topo.colors(255, alpha=alphacol)
  
  mergeCutheight=mergeCutHeight 
  
  
#  save(data_m,heatmap_cols,patientcolors,file="hcaDfalse.Rda")
  
  if(input.type=="intensity"){
    
    
    if(similarity.matrix=="TOM"){
      ##save(data_m,cor.method,num_nodes,file="debugcorselfeats.Rda")
      simmat<-WGCNA::cor(t(data_m),nThreads=num_nodes,method=cor.method,use = 'p')
      write.table(simmat,file="Tables/pairwisecorrelation_selectedfeatures.txt",sep="\t",row.names=TRUE)
      
      if(is.na(power_val)==TRUE){
              #data_m<-log2(data_m+1)
              powers = c(c(1:10), seq(from = 12, to=20, by=2))
              
              
              sft = try(pickSoftThreshold.fromSimilarity(similarity=simmat, powerVector = powers, verbose = 0),silent=TRUE)
              #power_val=sft$powerEstimate
              
              if(is(sft,"try-error")){
                power_val=6
              }else{
                power_val=sft$powerEstimate
              }
              if(is.na(power_val)==TRUE){
                power_val=6 
              }

      }else{
        if(is.na(power_val)==TRUE){
          power_val=6 
        }
        
      }
      
      
      ADJdataOne<-adjacency.fromSimilarity(similarity=simmat,power=power_val)
      
      TOM = TOMsimilarity(ADJdataOne, TOMType="signed") # specify network type
      #dissTOMCormat = 1-TOM
      dissTOMCormat=TOMdist(ADJdataOne) #(1-global_cor)
      hr = fastcluster::hclust(as.dist(dissTOMCormat),method="complete");
      
      
      
      pdf("metabplot.pdf")
      plot(hr,labels=F,main="Dendrogram")
      dev.off()
      
      mycl_metabs <-cutreeDynamic(hr,distM= dissTOMCormat,deepSplit=deepsplit, minClusterSize=minclustsize, pamRespectsDendro = FALSE, pamStage=TRUE,verbose=0)
      
      m2=try(mergeCloseModules(t(data_m),colors=mycl_metabs,cutHeight=mergeCutheight),silent=TRUE)
      
     # save(mycl_metabs,m2,data_m,mergeCutheight,file="d1.Rda")
      
      if(is(m2,"try-error")){
        
        mod_list<-mycl_metabs
      }else{
        
        mod_list<-as.numeric(m2$colors)
      }
      
      mycl_metabs<-mod_list
      
      s2.metab<- silhouette(mycl_metabs,dmatrix=dissTOMCormat)
      
      
      ###samples
      simmat<-WGCNA::cor((data_m),nThreads=num_nodes,method=cor.method,use = 'p')
      
      write.table(simmat,file="Tables/pairwisecorrelation_samples.txt",sep="\t",row.names=TRUE)
      
      
      if(is.na(power_val)==TRUE){
        #data_m<-log2(data_m+1)
        powers = c(c(1:10), seq(from = 12, to=20, by=2))
        
        
        sft = try(pickSoftThreshold.fromSimilarity(similarity=simmat, powerVector = powers, verbose = 0),silent=TRUE)
        #power_val=sft$powerEstimate
        
        if(is(sft,"try-error")){
          power_val=6
        }else{
          power_val=sft$powerEstimate
        }
        if(is.na(power_val)==TRUE){
          power_val=6 
        }
        
      }else{
        if(is.na(power_val)==TRUE){
          power_val=6 
        }
        
      }
      
      
      ADJdataOne<-adjacency.fromSimilarity(similarity=simmat,power=power_val)
      
      TOM = TOMsimilarity(ADJdataOne, TOMType="signed") # specify network type
      #dissTOMCormat = 1-TOM
      dissTOMCormat=TOMdist(ADJdataOne) #(1-global_cor)
      hc = fastcluster::hclust(as.dist(dissTOMCormat),method="complete");
      
      pdf("sampleplot.pdf")
      plot(hc,labels=F,main="Dendrogram")
      dev.off()
      
      
      mycl_samples <-cutreeDynamic(hc,distM= dissTOMCormat,deepSplit=deepsplit, minClusterSize=minclustsize, pamRespectsDendro = FALSE, pamStage=FALSE,verbose=0)
      
      m3=try(mergeCloseModules((data_m),colors=mycl_samples,cutHeight=mergeCutheight),silent=TRUE)
      
      if(is(m3,"try-error")){
        
        mod_list2<-mycl_samples
      }else{
        
        mod_list2<-as.numeric(m3$colors)
      }
      
      mycl_samples<-mod_list2
      
      
      if(min(mycl_metabs)==0){
        mycl_metabs<-mycl_metabs+1
      }
      
      if(min(mycl_samples)==0){
        mycl_samples<-mycl_samples+1
      }
      
      s1.samp<- silhouette(mycl_samples,dmatrix=dissTOMCormat)
      
      
      
      
    }else{
      
      
      simmat=WGCNA::cor(data_m,method=cor.method,use="pairwise.complete.obs")
      distc_m<-1-simmat
      
      write.table(simmat,file="Tables/pairwisecorrelation_samples.txt",sep="\t",row.names=TRUE)
      
      #save(data_m,file="data_m.Rda")
      simmat=WGCNA::cor(t(data_m),method=cor.method,use="pairwise.complete.obs")
      distr_m<-1-simmat
      write.table(simmat,file="Tables/pairwisecorrelation_selectedfeatures.txt",sep="\t",row.names=TRUE)
      
      
      
      distc<-as.dist(distc_m)
      distr<-as.dist(distr_m)
      
      
      
      if(cutree.method=="dynamic"){
        
       save(distc,distc_m,deepsplit,minclustsize,mergeCutHeight,data_m,file="debugdynamic.Rda")
        hc = fastcluster::hclust(distc,method="complete")
        
        mycl_samples <-cutreeDynamic(hc,distM= distc_m,deepSplit=deepsplit, method="hybrid",minClusterSize=minclustsize, pamRespectsDendro = FALSE, pamStage=FALSE,verbose=0)
        
        m3=try(mergeCloseModules((data_m),colors=mycl_samples,cutHeight=mergeCutHeight,verbose = 0),silent=TRUE)
        
        if(is(m3,"try-error")){
          
          mod_list2<-mycl_samples
        }else{
          
          mod_list2<-as.numeric(m3$colors)
        }
        
        mycl_samples<-mod_list2
        names(mycl_samples)<-hc$labels
        hr = fastcluster::hclust(distr,method="complete")
        
        mycl_metabs <-cutreeDynamic(hr,distM=distr_m,deepSplit=deepsplit, method="hybrid",minClusterSize=minclustsize, pamRespectsDendro = FALSE, pamStage=FALSE,verbose=0)
        
        m3=try(mergeCloseModules(t(data_m),colors=mycl_metabs,cutHeight=mergeCutHeight,verbose = 0),silent=TRUE)
        
        if(is(m3,"try-error")){
          
          mod_list2<-mycl_metabs
        }else{
          
          mod_list2<-as.numeric(m3$colors)
        }
        
        mycl_metabs<-mod_list2
        
        names(mycl_metabs)<-hr$labels
        
        if(min(mycl_metabs)==0){
          mycl_metabs<-mycl_metabs+1
        }
        
        if(min(mycl_samples)==0){
          mycl_samples<-mycl_samples+1
        }
        
      }else{
        
        hc <- try(hclust(distc),silent=TRUE) #samples
        hr <- try(hclust(distr),silent=TRUE) #metabolites
        
        mycl_samples <- cutree(hc, h=max(hc$height)/2)
        mycl_metabs <- cutree(hr, h=max(hr$height)/2)
        
      }
      
    save(hr,hc,deepsplit,minclustsize,mergeCutheight,mycl_metabs,mycl_samples,distc,distr,distc_m,distr_m,data_m,distr,patientcolors,file="hr_hcC.Rda")
      
      s1.samp<- silhouette(mycl_samples,distc)
      s2.metab<- silhouette(mycl_metabs,distr)
      
    }
    
    
  }else{
    
    
  }
  

  #if(FALSE)
  {
    save(hc,file="hc.Rda")
    save(hr,file="hr.Rda")
    save(distc,file="distc.Rda")
    save(distr,file="distr.Rda")
    save(s1.samp,file="s1samp.Rda")
    save(s2.metab,file="s2metab.Rda")
  }
  
  if(is.na(s1.samp)[1]==FALSE){
    s1.samp=round(mean(s1.samp[,3],na.rm=TRUE),2)
  }
  if(is.na(s2.metab)[1]==FALSE){
    s2.metab=try(round(mean(s2.metab[,3],na.rm=TRUE),2),silent=TRUE)
  }
  
  classgroup_levels<-levels(as.factor(classgroup))
  
  classgroup<-as.data.frame(classgroup)
  colnames(classgroup)<-"factor_levels"
  
  class_df <- data.frame(factor_levels = classgroup_levels,
                         Class = seq(1,length(classgroup_levels)),
                         stringsAsFactors = FALSE)
  
  
  dt3 <- merge(classgroup, class_df, by = "factor_levels", all.x = TRUE)
  
  #save(classgroup,mycl_samples,file="hcad.Rda")
  ari_val<-try(round(adjustedRandIndex(x=classgroup[,1], y=mycl_samples),2),silent=TRUE)
  
  
  if(show.silhouette==FALSE){
  
  mainlab1<-"" #paste("HCA using ",mainlab," selected features",sep="")
  }else{
  mainlab1<-"" #paste("Average  width samples: ",s1.samp,"\n ","Average Silhouette width features: ", s2.metab," \n ", "Adjusted Rand index (comparison with true class labels): ",ari_val,sep="")
  }
  
  #rownames(data_m)<-NULL
  #colnames(data_m)<-NULL
  
  
  sample.col.opt=row.col.opt
  
  if(is(hr,"try-error") || is(hc,"try-error")){
    
    print("Hierarchical clustering can not be performed. ")
  }else{
    heatmap_file<-paste(heatmap_file,".png",sep="")
    
    if(newdevice==TRUE){
      png(heatmap_file,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      #png("test_png.png",res=600,width=8,height=8,units="in",type="cairo")
    }
    
    if(hca_type=="two-way"){
      
      
      
      
      if(col_metabs==TRUE){
        
        col_vec2 <- rainbow(length(unique(mycl_metabs)), alpha=alphacol)
        
        
        if(sample.col.opt=="topo"){
          
          col_vec2 <- topo.colors(length(unique(mycl_metabs)), alpha=alphacol)
        }else{
          if(sample.col.opt=="heat"){
            
            col_vec2 <- heat.colors(length(unique(mycl_metabs)), alpha=alphacol)
          }else{
            if(sample.col.opt=="rainbow"){
              col_vec2<-rainbow(length(unique(mycl_metabs)), start = 0, end = alphacol)
              
              
            }else{
              
              if(sample.col.opt=="terrain"){
                
                col_vec2 <- cm.colors(length(unique(mycl_metabs)), alpha=alphacol)
              }else{
                
                if(sample.col.opt=="colorblind"){
                  #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                  # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                  
                  if(length(unique(mycl_metabs))<9){
                    
                    col_vec2 <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35B2", "grey57")
                    
                  }else{
                    
                    #col_vec2<-colorRampPalette(brewer.pal(10, "RdBu"))(length(unique(mycl_metabs)))
                    col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                                "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                    
                  }
                  
                  
                }else{
                  
                  check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                  
                  if(length(check_brewer)>0){
                    
                    sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                    col_vec2 <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(unique(mycl_metabs)))
                    
                  }else{
                    
                    if(sample.col.opt=="journal"){
                      
                      col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                 "#E64B3519","#4DBBD519","#631879E5","grey75")
                      if(length(class_labels_levels)<8){
                        col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                        
                        #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                        
                      }else{
                        if(length(class_labels_levels)<=28){
                          # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                          
                          col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                     "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                     "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                     
                                     "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                     "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                          
                        }else{
                          
                          
                          
                          
                          colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                          
                          col_vec2<-col_vec[sample(col_vec)]
                          
                          
                        }
                      }
                    }else{
                      col_vec2 <-sample.col.opt
                    }
                    
                  }
                  
                }
              }
              
              
            }
            
          }
          
        }
        
      #  col_vec2 <- topo.colors(length(unique(mycl_metabs)), alpha=alphacol)
       if(FALSE)
         { 
        col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                    "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                    "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                    
                    "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                    "#E64B3519","#4DBBD519","#631879E5","grey75")
       }
       # col_vec2<-brewer.pal(10,"Dark2")
        #colfunc <-colorRampPalette(c(col_vec2))
        
        #col_vec2<-colfunc(length(unique(mycl_metabs)))
       # col_vec2<-standardColors() #length(mycl_metabs))
        #colfunc <-colorRampPalette(c(col_vec2))
        #col_vec2<-colfunc(length(unique(mycl_metabs)))
        
        if(length(unique(mycl_metabs))<100){
          
          
               col_vec2<-standardColors(length(mycl_metabs))
               
               if(length(grep(col_vec2,pattern="white$"))>0){
                 col_vec2<-col_vec2[-grep(col_vec2,pattern="white$")]
               }
               
               if(length(grep(col_vec2,pattern="^ivory"))>0){
                 col_vec2<-col_vec2[-grep(col_vec2,pattern="^ivory")]
               }
               
               if(length(grep(col_vec2,pattern="^black"))>0){
                 col_vec2<-col_vec2[-grep(col_vec2,pattern="^black")]
               }
               
               
               if(min(as.numeric(mycl_metabs),na.rm=TRUE)==0){
                 
                 rowcolors=col_vec2[as.numeric(mycl_metabs)+1] #+1]
               }else{
                 rowcolors=col_vec2[as.numeric(mycl_metabs)] #+1]
               }
        }else{
          
                rowcolors=NA
        }
        
       
        
        
      }else{
        rowcolors=NA #rep("",length(mycl_metabs))
      }
      
      #save(mycl_metabs,rowcolors,file="d2.Rda")
      if(plot.bycluster==TRUE){
        
        #col_vec2 <- rainbow(length(unique(mycl_samples)), alpha=alphacol)
        if(sample.col.opt=="topo"){
          
          col_vec2 <- topo.colors(length(unique(mycl_samples)), alpha=alphacol)
        }else{
          if(sample.col.opt=="heat"){
            
            col_vec2 <- heat.colors(length(unique(mycl_samples)), alpha=alphacol)
          }else{
            if(sample.col.opt=="rainbow"){
              col_vec2<-rainbow(length(unique(mycl_samples)), start = 0, end = alphacol)
              
              
            }else{
              
              if(sample.col.opt=="terrain"){
                
                col_vec2 <- cm.colors(length(unique(mycl_samples)), alpha=alphacol)
              }else{
                
                if(sample.col.opt=="colorblind"){
                  #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                  # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                  
                  if(length(unique(mycl_samples))<9){
                    
                    col_vec2 <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35B2", "grey57")
                    
                  }else{
                    
                    # col_vec2<-colorRampPalette(brewer.pal(10, "RdBu"))(length(unique(mycl_samples)))
                    col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                                "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                    
                  }
                  
                  
                }else{
                  
                  check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                  
                  if(length(check_brewer)>0){
                    
                    sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                    
                    col_vec2 <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(unique(mycl_samples)))
                    
                  }else{
                    
                    if(sample.col.opt=="journal"){
                      
                      col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                  "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                  "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                  
                                  "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                  "#E64B3519","#4DBBD519","#631879E5","grey75")
                      if(length(class_labels_levels)<8){
                        col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                        
                        #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                        
                      }else{
                        if(length(class_labels_levels)<=28){
                          # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                          
                          col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                      "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                      "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                      
                                      "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                      "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                          
                        }else{
                          
                          
                          
                          
                          colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec2<-colfunc(length(class_labels_levels))
                          
                          col_vec2<-col_vec2[sample(col_vec2)]
                          
                          
                        }
                      }
                      
                    }else{
                      col_vec2 <-sample.col.opt
                    }
                    
                  }
                  
                }
              }
              
              
            }
            
          }
          
        }
        
        patientcolors<-col_vec2[as.numeric(mycl_samples)]
        
      }
      
 # save(list=c("data_m","hr","labRow.value","labCol.value","cexLegend","hc","heatmap_cols","mainlab1","rowcolors","patientcolors","cexRow","cexCol","col_vec","class_labels_levels","labRow.value","labCol.value"),file="hcadebug.Rda")

 # save(rowcolors,hr,hc,file="rowcolors.Rda")
      if(col_samples==FALSE){
        if(is.data.znorm==FALSE){
          
          if(is.na(rowcolors)[1][1]==FALSE){
            
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            
            
            
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="row",key=TRUE, 
                           symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,xlab=xlab_text,ylab=ylab_text,
                           main=mainlab1,RowSideColors=rowcolors,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
            
            
            if(hca.show.legend==TRUE){
            le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend))
            }
            
            
          }else{
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            
            
            
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="row",
                           key=TRUE, symkey=FALSE, density.info="none", trace="none", 
                           cexRow=cexRow, cexCol=cexCol,xlab=xlab_text,ylab=ylab_text, main=mainlab1,
                           labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
            
            if(hca.show.legend==TRUE){
              le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend))
            }
            
          }
          
        }else{
          
          if(is.na(rowcolors)[1][1]==FALSE){
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            
            
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols,
                           scale="none",key=TRUE, symkey=FALSE, density.info="none", trace="none",
                           cexRow=cexRow, cexCol=cexCol,xlab=xlab_text,ylab=ylab_text, main=mainlab1,
                           RowSideColors=rowcolors,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
            
           
            if(hca.show.legend==TRUE){
             le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend))
            }
            
          }else{
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            
            
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="none",
                           key=TRUE, symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                           xlab=xlab_text,ylab=ylab_text, main=mainlab1,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
            
            if(hca.show.legend==TRUE){
              le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend))
            }
            
          }
        }
        
      }else{
        
        
        if(is.data.znorm==FALSE){
          
          if(is.na(rowcolors)[1]==FALSE){
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            #print(rowcolors)
            
            print(length(patientcolors))
            print(length(unique(patientcolors)))
            print(dim(data_m))
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="row",key=TRUE, 
                           symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol, xlab=xlab_text,ylab=ylab_text,
                           main=mainlab1, ColSideColors=patientcolors,RowSideColors=rowcolors,labRow = labRow.value, labCol = labCol.value,
                           cex.main=0.8)
            
            if(hca.show.legend==TRUE){
            (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
            }
            
          }else{
            
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            
           #print("DOING THIS HCA")
            
          #  save(data_m,hr,hc,heatmap_cols,cexRow,cexCol,mainlab1,patientcolors,labRow.value,labCol.value,file="thishca.Rda")
            
            
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="row",key=TRUE, symkey=FALSE, 
                           density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol, xlab=xlab_text,ylab=ylab_text,
                           main=mainlab1, ColSideColors=patientcolors,labRow = labRow.value, labCol = labCol.value)
            
            # h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc), scale="row",key=TRUE, symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol, xlab="Samples",ylab="", main=mainlab1, ColSideColors=patientcolors) #,labRow = FALSE, labCol = FALSE)
            
            if(hca.show.legend==TRUE){
            (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
            }
            
          }
          
        }else{
          
          if(is.na(rowcolors)[1]==FALSE){
            
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="none",
                           key=TRUE, symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                           xlab=xlab_text,ylab=ylab_text, main=mainlab1, ColSideColors=patientcolors,
                           RowSideColors=rowcolors,labRow = labRow.value, labCol = labCol.value)
            
            if(hca.show.legend==TRUE){
            (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
            }
            
          }else{
            
            w <- 0.1
            par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
            
            h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="none",
                           key=TRUE, symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                           xlab=xlab_text,ylab=ylab_text, main=mainlab1, ColSideColors=patientcolors,
                           labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
            
            if(hca.show.legend==TRUE){
            (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
            }
            
          }
        }
      }
      
      
      if(newdevice==TRUE){
        try(dev.off(),silent=TRUE)
      }
      
      
      
      ord_data<-cbind(mycl_metabs[rev(h73$rowInd)],data_matrix[rev(h73$rowInd),c(1:2)],data_m[rev(h73$rowInd),h73$colInd])
    }
    else{
      if(hca_type=="one-way" | hca_type=="oneway_features" | hca_type=="features"){
        hc<-seq(1,dim(data_m)[2])
        
        
        # mycl_metabs <- cutree(hr, h=max(hr$height)/2)
        
        if(col_metabs==TRUE){
          
          #col_vec2 <- rainbow(length(unique(mycl_metabs)), alpha=alphacol)
          
          if(sample.col.opt=="topo"){
            
            col_vec2 <- topo.colors(length(unique(mycl_metabs)), alpha=alphacol)
          }else{
            if(sample.col.opt=="heat"){
              
              col_vec2 <- heat.colors(length(unique(mycl_metabs)), alpha=alphacol)
            }else{
              if(sample.col.opt=="rainbow"){
                col_vec2<-rainbow(length(unique(mycl_metabs)), start = 0, end = alphacol)
                
                
              }else{
                
                if(sample.col.opt=="terrain"){
                  
                  col_vec2 <- cm.colors(length(unique(mycl_metabs)), alpha=alphacol)
                }else{
                  
                  if(sample.col.opt=="colorblind"){
                    #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                    # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                    
                    if(length(unique(mycl_metabs))<9){
                      
                      col_vec2 <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35B2", "grey57")
                      
                    }else{
                      
                      #col_vec2<-colorRampPalette(brewer.pal(10, "RdBu"))(length(unique(mycl_metabs)))
                      col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                                  "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                      
                    }
                    
                    
                  }else{
                    
                    check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                    
                    if(length(check_brewer)>0){
                      
                      sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                      col_vec2 <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(unique(mycl_metabs)))
                      
                    }else{
                      
                      if(sample.col.opt=="journal"){
                        
                        col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                    "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                    "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                    
                                    "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                    "#E64B3519","#4DBBD519","#631879E5","grey75")
                        if(length(class_labels_levels)<8){
                          col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                          
                          #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                          
                        }else{
                          if(length(class_labels_levels)<=28){
                            # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                            
                            col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                        "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                        "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                        
                                        "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                        "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                            
                          }else{
                            
                            
                            
                            
                            colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec2<-colfunc(length(class_labels_levels))
                            
                            col_vec2<-col_vec2[sample(col_vec2)]
                            
                            
                          }
                        }
                        
                      }else{
                        col_vec2 <-sample.col.opt
                      }
                      
                    }
                    
                  }
                }
                
                
              }
              
            }
            
          }
          
          
          #rowcolors=col_vec2[as.numeric(mycl_metabs)+1]
          
          if(length(unique(mycl_metabs))<100){
            
            
            col_vec2<-standardColors(length(mycl_metabs))
            
            if(length(grep(col_vec2,pattern="white$"))>0){
              col_vec2<-col_vec2[-grep(col_vec2,pattern="white$")]
            }
            
            if(length(grep(col_vec2,pattern="^ivory"))>0){
              col_vec2<-col_vec2[-grep(col_vec2,pattern="^ivory")]
            }
            
            if(length(grep(col_vec2,pattern="^black"))>0){
              col_vec2<-col_vec2[-grep(col_vec2,pattern="^black")]
            }
            
            
            if(min(as.numeric(mycl_metabs),na.rm=TRUE)==0){
              
              rowcolors=col_vec2[as.numeric(mycl_metabs)+1] #+1]
            }else{
              rowcolors=col_vec2[as.numeric(mycl_metabs)] #+1]
            }
          }else{
            
            rowcolors=NA
          }
        }else{
          rowcolors=NA
        }
        
        
        
        if(col_samples==FALSE){
          if(is.data.znorm==FALSE){
            
            if(is.na(rowcolors)[1]==FALSE){
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="row",key=TRUE, 
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,RowSideColors=rowcolors,
                             labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }else{
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="row",key=TRUE,
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }
          }else{
            
            if(is.na(rowcolors)[1]==FALSE){
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="none",
                             key=TRUE, symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, 
                             cexCol=cexCol,xlab=xlab_text,ylab=ylab_text, main=mainlab1,RowSideColors=rowcolors,
                             labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }else{
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="none",key=TRUE,
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }
          }
          
        }else{
          if(is.data.znorm==FALSE){
            
            if(is.na(rowcolors)[1]==FALSE){
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="row",key=TRUE,
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("row"),
                             ColSideColors=patientcolors,RowSideColors=rowcolors,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }else{
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="row",key=TRUE, 
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("row"),
                             ColSideColors=patientcolors,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }
          }else{
            
            if(is.na(rowcolors)[1]==FALSE){
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="none",key=TRUE, 
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("row"),
                             ColSideColors=patientcolors,RowSideColors=rowcolors,labRow = labRow.value, labCol = labCol.value,
                             cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }else{
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=NULL,  col=heatmap_cols, scale="none",key=TRUE,
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("row"),
                             ColSideColors=patientcolors,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }
          }
        }
        
        if(newdevice==TRUE){
          try(dev.off(),silent=TRUE)
        }
        
        mycl_samples<-seq(1,dim(data_m)[2])
        #mycl_samples <- cutree(hc, h=max(hc$height)/2)
        #mycl_metabs <- cutree(hr, h=max(hr$height)/2)
        
        ord_data<-cbind(mycl_metabs[rev(h73$rowInd)],data_matrix[rev(h73$rowInd),c(1:2)],data_m[rev(h73$rowInd),h73$colInd])
        
      }else{
        if(hca_type=="samples" | hca_type=="oneway_samples"){
          hr<-seq(1,dim(data_m)[1])
          
          
          
          
          if(col_samples==FALSE){
            if(is.data.znorm==FALSE){
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=as.dendrogram(hc),  col=heatmap_cols, scale="row",
                             key=TRUE, symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, 
                             cexCol=cexCol,xlab=xlab_text,ylab=ylab_text, main=mainlab1,
                             labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
              
            }else{
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=as.dendrogram(hc),  col=heatmap_cols, scale="none",key=TRUE,
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol, 
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }
            
          }else{
            if(is.data.znorm==FALSE){
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=as.dendrogram(hc),  col=heatmap_cols, scale="row",key=TRUE,
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,xlab=xlab_text,ylab=ylab_text,
                             main=mainlab1,dendrogram = c("col"),ColSideColors=patientcolors,
                             labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
            }else{
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=as.dendrogram(hc),  col=heatmap_cols, scale="none",key=TRUE,
                             symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("col"),
                             ColSideColors=patientcolors,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }
          }
          
          
          
          if(newdevice==TRUE){
            try(dev.off(),silent=TRUE)
          }
          
          #mycl_samples<-seq(1,dim(data_m)[2])
          # mycl_samples <- cutree(hc, h=max(hc$height)/2)
          mycl_metabs <- seq(1,dim(data_m)[1]) #cutree(hr, h=max(hr$height)/2)
          
          ord_data<-cbind(mycl_metabs[rev(h73$rowInd)],data_matrix[rev(h73$rowInd),c(1:2)],data_m[rev(h73$rowInd),h73$colInd])
          
        }
        else{
          
         if(hca_type=="heatmap"){ 
          #only plot heatmap; no clustering
          hr<-seq(1,dim(data_m)[1])
          hc<-seq(1,dim(data_m)[2])
          
          
          if(col_samples==FALSE){
            if(is.data.znorm==FALSE){
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=NULL,  col=heatmap_cols, scale="row",key=TRUE, symkey=FALSE, 
                             density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,xlab=xlab_text,ylab=ylab_text,
                             main=mainlab1,dendrogram = c("none"),labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }else{
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=NULL,  col=heatmap_cols, scale="none",key=TRUE, symkey=FALSE,
                             density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                             xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("none"),
                             labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }
            
          }else{
            if(is.data.znorm==FALSE){
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=NULL,  col=heatmap_cols, scale="row",key=TRUE, symkey=FALSE, 
                             density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,xlab=xlab_text,ylab=ylab_text,
                             main=mainlab1,ColSideColors=patientcolors,dendrogram = c("none"),
                             labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
              
            }else{
              
              w <- 0.1
              par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
              
              h73<-heatmap.2(data_m, Rowv=NULL, Colv=NULL,  col=heatmap_cols, scale="none",key=TRUE, symkey=FALSE,
                             density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,xlab=xlab_text,ylab=ylab_text,main=mainlab1,ColSideColors=patientcolors,dendrogram = c("none"),
                             labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
              if(hca.show.legend==TRUE){
              (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
              }
            }
          }
          
          #  par(xpd=TRUE)
          #legend("bottomleft",legend=levels(ordered_labels),text.col=unique(patientcolors),pch=13,cex=0.4)
          #par(xpd=FALSE)
          
          if(newdevice==TRUE){
            try(dev.off(),silent=TRUE)
          }
          
          mycl_samples<-seq(1,dim(data_m)[2])
          #mycl_samples <- cutree(hc, h=max(hc$height)/2)
          mycl_metabs <- seq(1,dim(data_m)[1]) #cutree(hr, h=max(hr$height)/2)
          
          ord_data<-cbind(mycl_metabs[rev(h73$rowInd)],data_matrix[rev(h73$rowInd),c(1:2)],data_m[rev(h73$rowInd),h73$colInd])
         }else{
          
           if(hca_type=="feature_by_feature"){
             hc<-seq(1,dim(data_m)[2])
             
             
             # mycl_metabs <- cutree(hr, h=max(hr$height)/2)
             
             if(col_metabs==TRUE){
               
               #col_vec2 <- rainbow(length(unique(mycl_metabs)), alpha=alphacol)
               
               if(sample.col.opt=="topo"){
                 
                 col_vec2 <- topo.colors(length(unique(mycl_metabs)), alpha=alphacol)
               }else{
                 if(sample.col.opt=="heat"){
                   
                   col_vec2 <- heat.colors(length(unique(mycl_metabs)), alpha=alphacol)
                 }else{
                   if(sample.col.opt=="rainbow"){
                     col_vec2<-rainbow(length(unique(mycl_metabs)), start = 0, end = alphacol)
                     
                     
                   }else{
                     
                     if(sample.col.opt=="terrain"){
                       
                       col_vec2 <- cm.colors(length(unique(mycl_metabs)), alpha=alphacol)
                     }else{
                       
                       if(sample.col.opt=="colorblind"){
                         #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
                         # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
                         
                         if(length(unique(mycl_metabs))<9){
                           
                           col_vec2 <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35B2", "grey57")
                           
                         }else{
                           
                           #col_vec2<-colorRampPalette(brewer.pal(10, "RdBu"))(length(unique(mycl_metabs)))
                           col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                                       "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                           
                         }
                         
                         
                       }else{
                         
                         check_brewer<-grep(pattern="brewer",x=sample.col.opt)
                         
                         if(length(check_brewer)>0){
                           
                           sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                           col_vec2 <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(unique(mycl_metabs)))
                           
                         }else{
                           
                           if(sample.col.opt=="journal"){
                             
                             col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                         "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                         "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                         
                                         "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                                         "#E64B3519","#4DBBD519","#631879E5","grey75")
                             if(length(class_labels_levels)<8){
                               col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                               
                               #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                               
                             }else{
                               if(length(class_labels_levels)<=28){
                                 # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                                 
                                 col_vec2<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                             
                                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                             "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                                 
                               }else{
                                 
                                 
                                 
                                 
                                 colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec2<-colfunc(length(class_labels_levels))
                                 
                                 col_vec2<-col_vec2[sample(col_vec2)]
                                 
                                 
                               }
                             }
                             
                           }else{
                             col_vec2 <-sample.col.opt
                           }
                           
                         }
                         
                       }
                     }
                     
                     
                   }
                   
                 }
                 
               }
               
               
               #rowcolors=col_vec2[as.numeric(mycl_metabs)+1]
               
               if(length(unique(mycl_metabs))<100){
                 
                 
                 col_vec2<-standardColors(length(mycl_metabs))
                 
                 if(length(grep(col_vec2,pattern="white$"))>0){
                   col_vec2<-col_vec2[-grep(col_vec2,pattern="white$")]
                 }
                 
                 if(length(grep(col_vec2,pattern="^ivory"))>0){
                   col_vec2<-col_vec2[-grep(col_vec2,pattern="^ivory")]
                 }
                 
                 if(length(grep(col_vec2,pattern="^black"))>0){
                   col_vec2<-col_vec2[-grep(col_vec2,pattern="^black")]
                 }
                 
                 
                 if(min(as.numeric(mycl_metabs),na.rm=TRUE)==0){
                   
                   rowcolors=col_vec2[as.numeric(mycl_metabs)+1] #+1]
                 }else{
                   rowcolors=col_vec2[as.numeric(mycl_metabs)] #+1]
                 }
               }else{
                 
                 rowcolors=NA
               }
             }else{
               rowcolors=NA
             }
             
             cor_m<-read.table("Tables/pairwisecorrelation_selectedfeatures.txt",sep="\t",header=TRUE,row.names = 1) #1+distr_m
             hca.show.legend=FALSE
             #print(head(cor_m))
             cor_m<-as.matrix(cor_m)
             print(ylab_text)
             colnames(cor_m)<-rownames(cor_m)
             
             save(cor_m,distr_m,hr,heatmap_cols,xlab_text,ylab_text,mainlab1,labRow.value,labCol.value,file="test.Rda")
             if(col_samples==FALSE){
               if(is.data.znorm==FALSE){
                 
                 if(is.na(rowcolors)[1]==FALSE){
                   
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="row",key=TRUE, 
                                  symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                                  xlab=xlab_text,ylab=ylab_text, main=mainlab1,RowSideColors=rowcolors,
                                  labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }else{
                   
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="row",key=TRUE,
                                  symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                                  xlab=xlab_text,ylab=ylab_text, main=mainlab1,labRow = labRow.value, labCol = labCol.value,cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }
               }else{
                 
                 if(is.na(rowcolors)[1]==FALSE){
                   
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="none",
                                  key=TRUE, symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, 
                                  cexCol=cexCol,xlab=xlab_text,ylab=ylab_text, main=mainlab1,RowSideColors=rowcolors,
                                  labRow = labRow.value, labCol = labRow.value,cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }else{
                   
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="none",key=TRUE,
                                  symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                                  xlab=xlab_text,ylab=ylab_text, main=mainlab1,labRow = labRow.value, labCol = labRow.value,cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }
               }
               
             }else{
               if(is.data.znorm==FALSE){
                 
                 if(is.na(rowcolors)[1]==FALSE){
                   
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="none",key=TRUE,
                                  symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                                  xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("both"),
                                  ColSideColors=rowcolors,RowSideColors=rowcolors,labRow = labRow.value, labCol = labRow.value,cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }else{
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="none",key=TRUE, 
                                  symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                                  xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("both"),
                                  ColSideColors=rowcolors,labRow = labRow.value, labCol = labRow.value,cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }
               }else{
                 
                 if(is.na(rowcolors)[1]==FALSE){
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="none",key=TRUE, 
                                  symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                                  xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("both"),
                                  ColSideColors=rowcolors,RowSideColors=rowcolors,labRow = labRow.value, labCol = labRow.value,
                                  cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }else{
                   w <- 0.1
                   par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
                   
                   h73<-heatmap.2(cor_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hr),  col=heatmap_cols, scale="none",key=TRUE,
                                  symkey=FALSE, density.info="none", trace="none", cexRow=cexRow, cexCol=cexCol,
                                  xlab=xlab_text,ylab=ylab_text, main=mainlab1,dendrogram = c("both"),
                                  ColSideColors=rowcolors,labRow = labRow.value, labCol = labRow.value,cex.main=0.8)
                   
                   if(hca.show.legend==TRUE){
                     (le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,class_labels_levels, col = col_vec,pch = rep(19,length(col_vec)), pt.cex = 0.8, title = "Class",cex=cexLegend)))
                   }
                   
                 }
               }
             }
             
             if(newdevice==TRUE){
               try(dev.off(),silent=TRUE)
             }
             
             mycl_samples<-seq(1,dim(data_m)[2])
             #mycl_samples <- cutree(hc, h=max(hc$height)/2)
             #mycl_metabs <- cutree(hr, h=max(hr$height)/2)
             
             ord_data<-cbind(mycl_metabs[rev(h73$rowInd)],data_matrix[rev(h73$rowInd),c(1:2)],data_m[rev(h73$rowInd),h73$colInd])
             
           } 
           
          }
          
        }
      }
    }
    
    cnames1<-colnames(ord_data)
    cnames1[1]<-"mz_cluster_label"
    colnames(ord_data)<-cnames1
    fname1<-paste("Tables/Clustering_based_sorted_intensity_using_",mainlab,"features.txt",sep="")
    write.table(ord_data,file=fname1,sep="\t",row.names=FALSE)
    
    fname2<-paste("Tables/Sample_clusterlabels_using_",mainlab,"features.txt",sep="")
    
    sample_clust_num<-mycl_samples[h73$colInd]
    temp1<-classlabels[h73$colInd,1]
    temp2<-classlabels
    
    #print(head(temp2))
    #temp1<-as.data.frame(temp1)
    
    #print(dim(temp1))
    match_ind<-match(temp1,temp2[,1])
    
    temp3<-temp2[match_ind,]
    
    #print(head(temp3))
    temp4<-cbind(temp1,temp3,sample_clust_num)
    
    #write.table(temp4,file="s1.txt",sep="\t",row.names=FALSE)
    #   print(head(temp1))
    
    rnames1<-rownames(temp4)
    #temp4<-cbind(rnames1,temp4)
    temp4<-as.data.frame(temp4)
    temp4<-temp4[,-c(1)]
    # print(temp4[,1:4])
    
    
    
    
    if(analysismode=="regression"){
      
      
      
      temp3<-temp4 #[,-c(1)]
      temp3<-as.data.frame(temp3)
      temp3<-apply(temp3,2,as.numeric)
      
      
      temp_vec<-as.vector(temp3[,2])
      
      
      
      names(temp_vec)<-as.character(temp4[,1])
      
      
      # if(output.device.type!="pdf"){
      
      if(newdevice==TRUE){
        
        temp_filename_1<-"Figures/Barplot_dependent_variable_ordered_by_HCA.png"
        
        png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      }
      
      
      #print(temp_vec)
      #tiff("Barplot_sample_cluster_ymat.tiff", width=plots.width,height=plots.height,res=plots.res, compression="lzw")
      barplot(temp_vec,col="brown",ylab="Y",cex.axis=0.5,cex.names=0.5,main="Dependent variable levels in samples; \n ordered based on hierarchical clustering")
      #dev.off()
      
      
      
      if(newdevice==TRUE){
        try(dev.off(),silent=TRUE)
      }
      
    }
    
    write.table(temp4,file=fname2,sep="\t",row.names=FALSE)
    
    
    
    fname3<-paste("Tables/Metabolite_clusterlabels_for_",mainlab,"features.txt",sep="")
    
    mycl_metabs_ord<-mycl_metabs[rev(h73$rowInd)]
    write.table(mycl_metabs_ord,file=fname3,sep="\t",row.names=TRUE)
    
  }
  return(list("h73"=h73,"classgroup"=classgroup,"Silhouette.sample"=s1.samp,"Silhouette.feature"=s2.metab,"adj.rand.index"=ari_val,"metab.clusters"=mycl_metabs,"metab.samples"=mycl_samples))
}

# plot top 3 eigentrends with a line at 0.
# in cse of a single treatment group u and v matrices are switched..
plot.eigentrends = function(svdr, title1){
  v = svdr$v
  d = svdr$d
  ss = d^2
  Tk = signif(ss/sum(ss)* 100, 2)
  
  titles = paste("Trend ", 1:3, " (", Tk[1:3], "%)", sep = "")
  do.text = function(j) mtext(titles[j], cex=0.7, padj=-0.7, adj=1)
  range.y = range(as.numeric(v[,1:3]), na.rm=T)
  
  toplot1_1 = as.numeric(v[,1])
  toplot1_2 = as.numeric(v[,2])
  toplot1_3 = as.numeric(v[,3])
  
  plot(c(1:length(toplot1_1)), toplot1_1, type='b', ann=F, ylim=range.y)
  do.text(1)
  abline(h=0, lty=3)
  title(title1, cex.main = 1.2, font.main= 1, col.main= "purple", ylab=NULL)
  plot(c(1:length(toplot1_2)), toplot1_2, type='b', ann=F, ylim=range.y)
  do.text(2)
  abline(h=0, lty=3)
  plot(c(1:length(toplot1_3)), toplot1_3, type='b', ann=F, ylim=range.y)
  do.text(3)
  abline(h=0, lty=3)
  return(Tk)
}

# plot any 3 eigentrends with a line at 0. Strting at the trend number passed in
# pos1 parameter provide the starting index for teh 3 trends
# in cse of a single treatment group u and v matrices are switched..
plot.eigentrends.start = function(svdr, title1, pos1=1){
  # No check for valid range of pos1 is performed!!!
  v = svdr$v
  d = svdr$d
  ss = d^2
  Tk = signif(ss/sum(ss)* 100, 2)
  #  pe = signif(d/sum(d, na.rm=T)*100, 2)
  titles = paste("Trend ", pos1:(pos1+3), " (", Tk[pos1:(pos1+3)], "%)", sep = "")
  do.text = function(j) mtext(titles[j], cex=0.7, padj=-0.7, adj=1)
  range.y = range(as.numeric(v[,pos1:(pos1+3)]), na.rm=T)
  
  toplot1_1 = as.numeric(v[,pos1])
  toplot1_2 = as.numeric(v[,(pos1+1)])
  toplot1_3 = as.numeric(v[,(pos1+2)])
  
  plot(c(1:length(toplot1_1)), toplot1_1, type='b', ann=F, ylim=range.y)
  do.text(1)
  abline(h=0, lty=3)
  title(title1, cex.main = 1.2, font.main= 1, col.main= "purple", ylab=NULL)
  plot(c(1:length(toplot1_2)), toplot1_2, type='b', ann=F, ylim=range.y)
  do.text(2)
  abline(h=0, lty=3)
  plot(c(1:length(toplot1_3)), toplot1_3, type='b', ann=F, ylim=range.y)
  do.text(3)
  abline(h=0, lty=3)
  return(Tk)
}

# not used in EigenMS
make.formula.string = function(factors, do.interactions=FALSE){
  fs = "1"
  if(length(factors)){
    fs = paste(factors, collapse=" + ")
    if(do.interactions && length(factors) > 1)
      fs = paste(unlist(lapply(as.data.frame(t(combinations(length(factors), 2, factors)), stringsAsFactors=F), paste, collapse="*")), collapse = " + ")
  }
  return(fs)
}


# make a string formula to use in 'lm' call when computing grp differences to preserve
makeLMFormula = function(eff, var_name='') {
  # eff - effects used in contrasts
  # var_name - for singe factor use var-name that is passed in as variable names, otherwise it has no colnmae
  #           only used for a single factor
  if(is.factor(eff))
  {
    ndims = 1
    cols1 = var_name # ftemp in EigenMS
  }
  else
  {
    ndims = dim(eff)[2]
    cols1 = colnames(eff)
  }
  lhs = cols1[1]
  lm.fm = NULL
  # check if can have a list if only have 1 factor...
  
  params = paste('contrasts=list(', cols1[1], '=contr.sum', sep=)
  
  if (ndims > 1) { # removed ndims[2] here, now ndims holds only 1 dimention...
    for (ii in 2:length(cols1))
    {
      lhs = paste(lhs, "+", cols1[ii])  # bl="contr.sum",
      params = paste(params, ',', cols1[ii], '=contr.sum', sep='')
    }
  }
  params = paste(params,")")
  lm.formula = as.formula(paste('~', lhs))
  lm.fm$lm.formula = lm.formula
  lm.fm$lm.params = params
  return(lm.fm)
}


eig_norm1<-function (m, treatment, prot.info, write_to_file = "",plot.trend=FALSE)
{
  
  if (is.factor(treatment)) {
    n.treatment = 1
    n.u.treatment = length(unique(treatment))[1]
  }
  else {
    n.treatment = dim(treatment)[2]
    n.u.treatment = dim(unique(treatment))[1]
  }
 # print(n.u.treatment)
  
  m = as.matrix(m)
  grpFactors = treatment
  nGrpFactors = n.treatment
  if (nGrpFactors > 1) {
    ugrps = unique(grpFactors)
    udims = dim(ugrps)
    grp = NULL
    for (ii in seq_len(udims[1])) {
      pos = grpFactors[, 1] == ugrps[ii, 1]
      for (jj in seq(2, udims[2])) {
        pos = pos & grpFactors[, jj] == ugrps[ii, jj]
      }
      grp[pos] = rep(ii, sum(pos))
    }
    grp = as.factor(grp)
  }
  else {
    grp = treatment
  }
  nobs = array(NA, c(nrow(m), length(unique(grp))))
  message("Treatment groups: ", grp)
  
  for (ii in seq_len(nrow(m))) {
    for (jj in seq_len(length(unique(grp)))) {
      nobs[ii, jj] = sum(!is.na(m[ii, grp == unique(grp)[jj]]))
    }
  }
  present.min = matrixStats::rowMins(nobs)
  ii = present.min == 0
  pmiss = rbind(m[ii, ])
  rownames(pmiss) = prot.info[ii, 1]
  present = prot.info[!(prot.info[, 1] %in% rownames(pmiss)),
  ]
  pres = m[!(prot.info[, 1] %in% rownames(pmiss)), ]
  rownames(pres) = prot.info[!(prot.info[, 1] %in% rownames(pmiss)),
                             1]
  #   message("Selecting complete data")
  nobs = array(NA, nrow(pres))
  numiter = nrow(pres)
  nobs = matrixStats::rowSums2(!is.na(pres))
  iii = nobs == ncol(pres)
  complete = rbind(pres[iii, ])
  if (write_to_file != "") {
    utils::write.table(complete, file = write_to_file, append = FALSE,
                       quote = FALSE, sep = "\t", eol = "\n", na = "NaN",
                       dec = ".", row.names = TRUE, col.names = TRUE, qmethod = c("escape",
                                                                                  "double"))
  }
  if (n.u.treatment > 1) {
    #   message("Got 2+ treatment grps")
    lm.fm = makeLMFormula(treatment, "TREATS")
    TREATS = treatment
    TREATS = data.frame(treatment)
    if (is.factor(treatment)) {
      colnames(TREATS) = "TREATS"
    }
    else {
      colnames(TREATS) = colnames(treatment)
    }
    attach(TREATS)
    mod.c = stats::model.matrix(lm.fm$lm.formula, data = TREATS,
                                eval(parse(text = lm.fm$lm.params)))
    Y.c = as.matrix(complete)
    formula1 = paste("t(Y.c)~", as.character(lm.fm$lm.formula)[2],
                     sep = "")
    TREATS = treatment
    fit_lmAll = stats::lm(eval(parse(text = formula1)))
    R.c = stats::residuals(fit_lmAll)
  }
  else {
    message("Got 1 treatment grp")
    mod.c = as.numeric(t(treatment))
    R.c = t(as.matrix(complete))
    TREATS = treatment
  }
  #    message("Computing SVD, estimating Eigentrends...")
  R.c_center = scale(R.c, center = TRUE, scale = FALSE)
  my.svd = svd(R.c_center)
  temp = my.svd$u
  my.svd$u = my.svd$v
  my.svd$v = temp
  numcompletepep = dim(complete)[1]
  #   message("Number of treatments: ", n.u.treatment)
  
  set.seed(123)
  h.c = sva.id(complete, n.u.treatment, lm.fm = lm.fm)$n.sv
  message("Number of bias trends automatically detected ",h.c)
  complete_center = scale(t(complete), center = TRUE, scale = FALSE)
  
  
  # n.u.treatment
  toplot1 = svd(complete_center)
  temp = toplot1$u
  toplot1$u = toplot1$v
  toplot1$v = temp
  if(plot.trend==TRUE){
    message("Preparing to plot...")
    graphics::par(mfcol = c(3, 2))
    graphics::par(mar = c(2, 2, 2, 2))
    plot.eigentrends(toplot1, "Raw Data")
    plot.eigentrends(my.svd, "Residual Data")
  }
  d = my.svd$d
  ss = d^2
  Tk = signif(ss/sum(ss) * 100, 2)
  retval = list(m = m, treatment = treatment, my.svd = my.svd,
                pres = pres, n.treatment = n.treatment, n.u.treatment = n.u.treatment,
                h.c = h.c, present = present, prot.info = prot.info,
                complete = complete, toplot1 = toplot1, Tk = Tk, ncompl = numcompletepep,
                grp = grp)
  return(retval)
}



# Second portion of EigenMS: remove effects of bias
# split into 2 functions to allo the user to examine the bias trends and be able to change the number
# by resetting h.c returned by eig_norm1(return_value_from_eig_norm1)
eig_norm2 = function(rv,plot.trend=FALSE) {
  # UNPUT:
  #   rv - return value from the eig_norm1
  #   if user wants to change the number of bias trends that will be eliminated h.c in rv should
  #   be updates to the desired number
  #
  # OUTPUT:
  #   normalized - matrix of normalized abundances with 2 columns of protein and peptdie names
  #   norm_m - matrix of normalized abundances, no extra columns
  #   eigentrends - found in raw data, bias trendsup to h.c
  #   rescrange - rescaling range for the addition of the while noise to avoid overfitting
  #   norm.svd - trends in normalized data, if one wanted to plot at later time.
  #   exPeps - excluded variables - excluded due to exception in fitting a linear model
  
  m = rv$pres # yuliya: use pres matrix, as we cannot deal with m anyways, need to narrow it down to 'complete' variables
  treatment = rv$treatment
  my.svd = rv$my.svd
  pres = rv$pres
  n.treatment = rv$n.treatment
  n.u.treatment = rv$n.u.treatment
  numFact = dim(rv$treatment)[2]
  print(paste('Unique number of treatment combinations:', n.u.treatment) )
  h.c = rv$h.c
  present = rv$present
  toplot1 = rv$toplot1
  # vector of indicators of variables that threw exeptions
  exPeps = vector(mode = "numeric", length = nrow(pres))
  
  print("Normalizing...")
  treatment = data.frame(treatment) # does this need to be done?
  if(n.u.treatment > 1) {
    lm.fm = makeLMFormula(treatment, 'ftemp')
    mtmp = model.matrix(lm.fm$lm.formula, data=treatment, eval(parse(text=lm.fm$lm.params)))  #contrasts=list(bl="contr.sum", it="contr.sum",Pi="contr.sum", tp="contr.sum"))
  } else {  # have 1 treatment group
    mtmp = treatment # as.numeric(t(treatment))
  }
  
  
  # above needed to know how many values will get back for some matrices
  # create some variables:
  betahat = matrix(NA,nrow=dim(mtmp)[2],ncol=nrow(pres))
  newR = array(NA, c(nrow(pres), ncol(pres))) #, n.treatment))
  norm_m = array(NA, c(nrow(pres), ncol(pres))) # , n.treatment))
  numsamp = dim(pres)[2]
  numpep = dim(pres)[1]
  betahat_n = matrix(NA,nrow=dim(mtmp)[2],ncol=nrow(pres))
  rm(mtmp)
  
  
  V0 = my.svd$v[,1:h.c,drop=F]   # residual eigenvariables
  
  
  if(n.u.treatment == 1) { # got 1 treatment group
    for (ii in 1:nrow(pres)) {
      if(ii%%250 == 0) { print(paste('Processing variable ',ii))  }
      pep = pres[ii, ]
      pos = !is.na(pep)
      peptemp = as.matrix(pep[pos]) # take only the observed values
      resm = rep(NA, numsamp)
      resm[pos] = as.numeric(pep[pos])
      bias = array(NA, numsamp)
      bias[pos] = resm[pos] %*% V0[pos,] %*% t(V0[pos,])
      norm_m[ii, ] = as.numeric(pep - bias)
    }
    
  } else { # got 2+ treatment groups
    for (ii in 1:nrow(pres)) {
      if(ii %% 100 == 0) { print(paste('Processing variable ',ii))  }
      pep = pres[ii, ]
      
      pos = !is.na(pep)
      peptemp = as.matrix(pep[pos]) # take only the observed values, may not be needed in R? but this works
      
      
      ftemp = treatment[pos,]
      ftemp = data.frame(ftemp)
      #### use try, not entirely sure if need for modt, need it for solve lm?!
      options(warn = -1)
      lm.fm = makeLMFormula(ftemp, 'ftemp') # using general function that can accomodate for 1+ number of factors
      modt = try(model.matrix(lm.fm$lm.formula, data=ftemp, eval(parse(text=lm.fm$lm.params))), silent=TRUE)
      options(warn = 0)
      
      if(!inherits(modt, "try-error")) { # do nothing if could not make model matrix
        options(warn = -1)
        # if we are able to solve this, we are able to estimate bias
        bhat =  try(solve(t(modt) %*% modt) %*% t(modt) %*% peptemp)
        options(warn = 0)
        if(!inherits(bhat, "try-error")) {
          betahat[,ii] = bhat
          ceffects = modt %*% bhat  # these are the group effects, from estimated coefficients betahat
          
          resm = rep(NA, numsamp) # really a vector only, not m
          resm[pos] = as.numeric(pep[pos] - ceffects)
          bias = array(NA, numsamp)
          bias[pos] = resm[pos] %*% V0[pos,] %*% t(V0[pos,])
          norm_m[ii, ] = as.numeric(pep - bias)
          
          # yuliya:  but newR should be computed on Normalized data
          resm_n = rep(NA, numsamp)
          bhat_n =  solve(t(modt) %*% modt) %*% t(modt) %*% norm_m[ii, pos]
          betahat_n[,ii] = bhat_n
          ceffects_n = modt %*% bhat_n
          resm_n[pos] = norm_m[ii,pos] - ceffects
          newR[ii, ] = resm_n
        } else {
          print(paste('got exception 2 at variable:', ii, 'should not get here...'))
          exPeps[ii] = 2 # should not get 2 here ever...
        }
      } else {
        print(paste('got exception at variable:', ii))
        exPeps[ii] = 1 # keep track of variables that threw exeptions, check why...
      }
    }
  } # end else - got 2+ treatment groups
  
  
  #####################################################################################
  # rescaling has been eliminated form the code after discussion that bias
  # adds variation and we remove it, so no need to rescale after as we removed what was introduced
  y_rescaled = norm_m # for 1 group normalization only, we do not rescale
  # add column names to y-rescaled, now X1, X2,...
  colnames(y_rescaled) = colnames(pres) # these have same number of cols
  rownames(y_rescaled) = rownames(pres)
  y_resc = data.frame(present, y_rescaled)
  rownames(y_resc) = rownames(pres)  # rownames(rv$normalized)
  final = y_resc # row names are assumed to be UNIQUE, variable IDs are unique
  
  # rows with all observations present
  complete_all = y_rescaled[rowSums(is.na(y_rescaled))==0,,drop=F]
  
  #  x11() # make R open new figure window
  par(mfcol=c(3,2))
  par(mar = c(2,2,2,2))
  # center each variable around zero (subtract its mean across samples)
  # note: we are not changing matrix itself, only centerig what we pass to svd
  complete_all_center = t(scale(t(complete_all), center = TRUE, scale = FALSE))
  toplot3 = svd(complete_all_center)
  
  if(plot.trend==TRUE){
    plot.eigentrends(toplot1, "Raw Data")
    plot.eigentrends(toplot3, "Normalized Data")
  }
  # print("Done with normalization!!!")
  colnames(V0) =  paste("Trend", 1:ncol(V0), sep="_")
  
  maxrange = NULL # no rescaling # data.matrix(maxrange)
  return(list(normalized=final, norm_m=y_rescaled, eigentrends=V0, rescrange=maxrange,
              norm.svd=toplot3, exPeps=exPeps))
} # end function eig_norm2


eig_norm2test = function(rv,Xtest=NA) {
  # UNPUT:
  #   rv - return value from the eig_norm1
  #   if user wants to change the number of bias trends that will be eliminated h.c in rv should
  #   be updates to the desired number
  #
  # OUTPUT:
  #   normalized - matrix of normalized abundances with 2 columns of protein and peptdie names
  #   norm_m - matrix of normalized abundances, no extra columns
  #   eigentrends - found in raw data, bias trendsup to h.c
  #   rescrange - rescaling range for the addition of the while noise to avoid overfitting
  #   norm.svd - trends in normalized data, if one wanted to plot at later time.
  #   exPeps - excluded variables - excluded due to exception in fitting a linear model
  
  m = rv$pres # yuliya: use pres matrix, as we cannot deal with m anyways, need to narrow it down to 'complete' variables
  treatment = rv$treatment
  my.svd = rv$my.svd
  pres = rv$pres
  n.treatment = rv$n.treatment
  n.u.treatment = rv$n.u.treatment
  numFact = dim(rv$treatment)[2]
  print(paste('Unique number of treatment combinations:', n.u.treatment) )
  h.c = rv$h.c
  present = rv$present
  toplot1 = rv$toplot1
  # vector of indicators of variables that threw exeptions
  exPeps = vector(mode = "numeric", length = nrow(pres))
  
  print("Normalizing...")
  treatment = data.frame(treatment) # does this need to be done?
  if(n.u.treatment > 1) {
    lm.fm = makeLMFormula(treatment, 'ftemp')
    mtmp = model.matrix(lm.fm$lm.formula, data=treatment, eval(parse(text=lm.fm$lm.params)))  #contrasts=list(bl="contr.sum", it="contr.sum",Pi="contr.sum", tp="contr.sum"))
  } else {  # have 1 treatment group
    mtmp = treatment # as.numeric(t(treatment))
  }
  
  
  
  # above needed to know how many values will get back for some matrices
  # create some variables:
  betahat = matrix(NA,nrow=dim(mtmp)[2],ncol=nrow(pres))
  newR = array(NA, c(nrow(pres), ncol(pres))) #, n.treatment))
  norm_m = array(NA, c(nrow(pres), ncol(pres))) # , n.treatment))
  numsamp = dim(pres)[2]
  numpep = dim(pres)[1]
  betahat_n = matrix(NA,nrow=dim(mtmp)[2],ncol=nrow(pres))
  
  norm_mtest = array(NA, c(nrow(Xtest), ncol(Xtest)))
  
  rm(mtmp)
  
  
  V0 = my.svd$v[,1:h.c,drop=F]   # residual eigenvariables
  
  
  if(n.u.treatment == 1) { # got 1 treatment group
    for (ii in 1:nrow(pres)) {
      if(ii%%250 == 0) { print(paste('Processing variable ',ii))  }
      pep = pres[ii, ]
      pos = !is.na(pep)
      peptemp = as.matrix(pep[pos]) # take only the observed values
      resm = rep(NA, numsamp)
      resm[pos] = as.numeric(pep[pos])
      bias = array(NA, numsamp)
      bias[pos] = resm[pos] %*% V0[pos,] %*% t(V0[pos,])
      norm_m[ii, ] = as.numeric(pep - bias)
      norm_mtest[ii, ] = as.numeric(Xtest - bias)
    }
    
  } else { # got 2+ treatment groups
    for (ii in 1:nrow(pres)) {
      if(ii %% 100 == 0) { print(paste('Processing variable ',ii))  }
      pep = pres[ii, ]
      pos = !is.na(pep)
      peptemp = as.matrix(pep[pos]) # take only the observed values, may not be needed in R? but this works
      ftemp = treatment[pos,]
      ftemp = data.frame(ftemp)
      #### use try, not entirely sure if need for modt, need it for solve lm?!
      options(warn = -1)
      lm.fm = makeLMFormula(ftemp, 'ftemp') # using general function that can accomodate for 1+ number of factors
      modt = try(model.matrix(lm.fm$lm.formula, data=ftemp, eval(parse(text=lm.fm$lm.params))), silent=TRUE)
      options(warn = 0)
      
      if(!inherits(modt, "try-error")) { # do nothing if could not make model matrix
        options(warn = -1)
        # if we are able to solve this, we are able to estimate bias
        bhat =  try(solve(t(modt) %*% modt) %*% t(modt) %*% peptemp)
        options(warn = 0)
        if(!inherits(bhat, "try-error")) {
          betahat[,ii] = bhat
          ceffects = modt %*% bhat  # these are the group effects, from estimated coefficients betahat
          
          resm = rep(NA, numsamp) # really a vector only, not m
          resm[pos] = as.numeric(pep[pos] - ceffects)
          bias = array(NA, numsamp)
          bias[pos] = resm[pos] %*% V0[pos,] %*% t(V0[pos,])
          norm_m[ii, ] = as.numeric(pep - bias)
          
        
          bias2 = array(NA, ncol(Xtest))
          bias2[pos] = Xtest[pos] %*% V0[pos,] %*% t(V0[pos,])
          
          norm_mtest[ii, ] = as.numeric(Xtest - bias2)
          
          # yuliya:  but newR should be computed on Normalized data
          resm_n = rep(NA, numsamp)
          bhat_n =  solve(t(modt) %*% modt) %*% t(modt) %*% norm_m[ii, pos]
          betahat_n[,ii] = bhat_n
          ceffects_n = modt %*% bhat_n
          resm_n[pos] = norm_m[ii,pos] - ceffects
          newR[ii, ] = resm_n
        } else {
          print(paste('got exception 2 at variable:', ii, 'should not get here...'))
          exPeps[ii] = 2 # should not get 2 here ever...
        }
      } else {
        print(paste('got exception at variable:', ii))
        exPeps[ii] = 1 # keep track of variables that threw exeptions, check why...
      }
    }
  } # end else - got 2+ treatment groups
  
  #####################################################################################
  # rescaling has been eliminated form the code after discussion that bias
  # adds variation and we remove it, so no need to rescale after as we removed what was introduced
  y_rescaled = norm_m # for 1 group normalization only, we do not rescale
  # add column names to y-rescaled, now X1, X2,...
  colnames(y_rescaled) = colnames(pres) # these have same number of cols
  rownames(y_rescaled) = rownames(pres)
  y_resc = data.frame(present, y_rescaled)
  rownames(y_resc) = rownames(pres)  # rownames(rv$normalized)
  final = y_resc # row names are assumed to be UNIQUE, variable IDs are unique
  
  # rows with all observations present
  complete_all = y_rescaled[rowSums(is.na(y_rescaled))==0,,drop=F]
  
  #  x11() # make R open new figure window
  par(mfcol=c(3,2))
  par(mar = c(2,2,2,2))
  # center each variable around zero (subtract its mean across samples)
  # note: we are not changing matrix itself, only centerig what we pass to svd
  complete_all_center = t(scale(t(complete_all), center = TRUE, scale = FALSE))
  toplot3 = svd(complete_all_center)
  plot.eigentrends(toplot1, "Raw Data")
  plot.eigentrends(toplot3, "Normalized Data")
  
  print("Done with normalization!!!")
  colnames(V0) =  paste("Trend", 1:ncol(V0), sep="_")
  
  maxrange = NULL # no rescaling # data.matrix(maxrange)
  return(list(normalized=final, norm_m=y_rescaled, eigentrends=V0, rescrange=maxrange,
              norm.svd=toplot3, exPeps=exPeps))
} # end function eig_norm2


sva.id = function(dat, n.u.treatment, lm.fm, B = 500, sv.sig = 0.05)
{
  #message("Number of complete variables (and samples) used in SVD")
  #message(dim(dat))
  n = ncol(dat)
  ncomp = n.u.treatment
  # message("Number of treatment groups (in svd.id): ", ncomp)
  # should be true for either case and can be used later
  
  if (ncomp > 1) {
    formula1 = paste('t(dat)~', as.character(lm.fm$lm.formula)[2], sep = '')
    fit_lmAll = stats::lm(eval(parse(text = formula1)))
    res = t(stats::residuals(fit_lmAll))
  } else {
    res = dat
  }
  # center each peptide around zero (subtract its mean across samples)
  res_center = t(scale(t(res), center = TRUE, scale = FALSE))
  
  uu = svd(t(res_center)) # NEED a WRAPPER for t(). the diag is min(n, m)
  temp = uu$u
  uu$u = uu$v
  uu$v = temp
  
  s0 = uu$d
  s0 = s0 ^ 2
  dstat = s0 / sum(s0)
  ndf = length(dstat)
  dstat0 = matrix(0, nrow = B, ncol = ndf) # num samples
  
  #  message("Starting Bootstrap.....")
  # Bootstrap procedure determines the number of significant eigertrends...
  for (ii in seq_len(B)) {
    if (ii %% 50 == 0) {
      #  message('Iteration ', ii)
    }
    res0 = t(apply(res, 1, sample, replace = FALSE)) # regression
    # center each peptide around zero (subtract its mean across samples)
    # note: not changing matrix itself, only centerig what we pass to svd
    res0_center = t(scale(t(res0), center = TRUE, scale = FALSE))
    uu0 = svd(res0_center)
    temp = uu0$u  # why did tom do this??
    uu0$u = uu0$v
    uu0$v = temp
    
    ss0 = uu0$d  # no need for diag....
    ss0 = ss0 ^ 2
    dstat0[ii, ] = ss0 / sum(ss0) # Tk0 in Matlab
  }
  
  # yuliya: check p-values here, Tom had mean value...
  psv = rep(1, n)
  for (ii in seq_len(ndf)) {
    # should this be compared to a mean? ie dstat0[ii,] ?
    posGreater = dstat0[, ii] > dstat[ii]
    psv[ii] = sum(posGreater) / B
  }
  
  # p-values for trends have to be in the monotonically increasing order,
  # set equal to previous one if not the case
  for (ii in 2:ndf) {
    if (psv[(ii - 1)] > psv[ii]) {
      psv[ii] = psv[(ii - 1)]
    }
  }
  nsv = sum(psv <= sv.sig)
  return(list(n.sv = nsv, p.sv = psv))
}
# end sva.id


### EigenMS helper functions, a few more...
# Tom had Sig set to 0.1, I and Storey's paper has 0.05
# sva.id = function(dat, mod, n.u.treatment, B=500, sv.sig=0.05, seed=NULL) {



mmul = function(A, B){
  # multiply square matrix by rectangle with NA's (???)
  X = A
  Y = B
  X[is.na(A)] = Y[is.na(B)] = 0
  R = X %*% Y
  R[is.na(B)] = NA
  R
}
# end mmul



#####    Not used in EigenMS, but a solution to imputing variables with 1+ group missing completely.
#######################################################################
imp_elim_proteins= function(nosib.miss, treatment){
  # Impute 1 variable proteins with 1 grp completely missing
  #
  # INPUT: proteins - 1 variable proteins with 1 grp missing completely (NaNs)
  #        grps - grouping information for observations, can be 2+ grps here,
  #               but not sure what to do with more then 2 groups if 2+ gs are
  #               missing completely. So only 1 grp is completely missing.
  # OUTPUT: prs - imputed proteins, same size as proteins parameter
  #nosib.miss <= nosib.miss
  #treatment <= treatment
  tlvls = unique(treatment)
  proteins = nosib.miss
  ng = length(unique(treatment))
  for (i in 1:nrow(proteins)) {
    pr = as.vector(proteins[i,])
    #% find number of missing values in ALL groups
    miss = array(NA, c(1, ng))
    for (j in 1:ng) miss[j] = sum(is.na(pr[treatment==unique(treatment)[j]]))
    #    pos = miss==0
    pos = miss==min(miss)  # Tom 092510
    present_groups = pr[treatment==unique(treatment)[pos]]
    
    # compute mean and stdev from one of the present groups, make sure no NaNs are used
    pospres = !is.na(present_groups)
    presvals = present_groups[pospres]
    pepmean = mean(presvals)
    pepstd =  sd(presvals)
    if(is.na(pepstd)) next;
    
    #% imputing only COMPLETELY missing variables here
    for (j in 1:ng) {
      if   (!pos[j]) { #% imute only the ones not at pos complete
        imppos = is.na(pr[treatment==tlvls[j]])  #% should be all in this group, but double check
        imppepmean = pepmean - 6* pepstd
        imppepstd = pepstd
        tt = imppepmean - 3 * imppepstd
        kk = 0
        while (tt < 0 && kk < 10){  # added kk counter - tom 092510
          offset = .25
          gap = imppepstd * offset
          imppepstd = imppepstd * (1- offset)
          imppepmean = imppepmean + 3 * gap
          tt = imppepmean - 3 * imppepstd
          kk = kk + 1
        }
        imp_tmp = rnorm(length(imppos), imppepmean, pepstd)
        pr[treatment==tlvls[j]] = imp_tmp
      }
    }
    proteins[i,] = pr
  }
  
  # tom - this routine gives some nearly-blank rows
  # to avoid singularities, i'm going to scan this to see which protein rows
  # have all blanks in one row and remove them
  #  proteins <= proteins
  xx = (!is.na(proteins)) %*% model.matrix(~treatment-1)
  notblank.idx = rep(TRUE, nrow(xx))
  for(jj in 1:ncol(xx)) notblank.idx = notblank.idx & xx[,jj]
  #  proteins = proteins[blank.idx,,drop=FALSE]
  
  return(list(proteins=proteins, notblank.idx=notblank.idx))
}


# generic star vertex shape, with a parameter for number of rays
mystar <- function(coords, v=NULL, params) {
  vertex.color <- params("vertex", "color")
  if (length(vertex.color) != 1 && !is.null(v)) {
    vertex.color <- vertex.color[v]
  }
  vertex.size  <- 1/200 * params("vertex", "size")
  if (length(vertex.size) != 1 && !is.null(v)) {
    vertex.size <- vertex.size[v]
  }
  norays <- params("vertex", "norays")
  if (length(norays) != 1 && !is.null(v)) {
    norays <- norays[v]
  }
  
  mapply(coords[,1], coords[,2], vertex.color, vertex.size, norays,
         FUN=function(x, y, bg, size, nor) {
           symbols(x=x, y=y, bg=bg,
                   stars=matrix(c(size,size/2), nrow=1, ncol=nor*2),
                   add=TRUE, inches=FALSE)
         })
}

#######################################################################
#######################################################################
my.Psi = function(x, my.pi){
  # calculates Psi
  exp(log(1-my.pi)  + dnorm(x, 0, 1, log=T) - log(my.pi + (1 - my.pi) * pnorm(x, 0, 1) ))
}
# end my.Psi

my.Psi.dash = function(x, my.pi){
  # calculates the derivative of Psi
  -my.Psi(x, my.pi) * (x + my.Psi(x, my.pi))
}
# end my.Psi.dash

phi = function(x){dnorm(x)}

rnorm.trunc = function (n, mu, sigma, lo=-Inf, hi=Inf){
  # Calculates truncated noraml
  p.lo = pnorm (lo, mu, sigma)
  p.hi = pnorm (hi, mu, sigma)
  u = runif (n, p.lo, p.hi)
  return (qnorm (u, mu, sigma))
}
# end rnorm.truncf

#data_matrix: rows: features; columns: samples (column A: sample1, column B: sample2)
outlier_detect<-function(data_matrix,ncomp=2,pthresh=0.005,outlier.method=c("pcout","sumtukey","pcatukey","MDchisq"),column.rm.index=NA,iqr.multiplier=1.5){
  
  
  cnames<-{}
  if(outlier.method=="sumtukey"){
    
    
    if(is.na(column.rm.index)[1]==FALSE){
      s2=apply(data_matrix[,-c(column.rm.index)],2,function(x){sum(x,na.rm=TRUE)})
      cnames<-colnames(data_matrix[,-c(column.rm.index)])
    }else{
      s2=apply(data_matrix,2,function(x){sum(x,na.rm=TRUE)})
      cnames<-colnames(data_matrix)
    }
    
    iqr_val<-quantile(s2,0.75)-quantile(s2,0.25)
    upper_limit=quantile(s2,0.75)+iqr.multiplier*(iqr_val)
    lower_limit=quantile(s2,0.25)-iqr.multiplier*(iqr_val)
    cnames<-cnames[which(s2>upper_limit | s2<lower_limit)]
    
    
  }
  else{
  if(is.na(column.rm.index)[1]==FALSE){
  p1<-mixOmics::pca(t(data_matrix[,-c(column.rm.index)]),center=TRUE,scale=TRUE,ncomp=ncomp)
  cnames<-colnames(data_matrix[,-c(column.rm.index)])
  }else{
    p1<-mixOmics::pca(t(data_matrix),center=TRUE,scale=TRUE,ncomp=ncomp)
    cnames<-colnames(data_matrix)
    
  }
  U3=p1$variates$X
  
  ##save(p1,U3,file="pcaoutlier.Rda")
  
  if(outlier.method=="MDchisq"){
    suppressMessages(library(robust))
    dist2=covRob(p1$variates$X,estim="pairwiseGK")$dist
    pval <- pchisq(dist2, df = ncomp, lower.tail = FALSE)
    is.out <- (pval < (pthresh)) # / length(dist2)))
    #qplot(U3[, 1], U3[, 2], color =is.out,size = I(2),main="Outlier (green dots) detection using PCA and ChiSq test (p<0.005) ") + coord_equal()
    col=rep("blue",length(is.out))
    col[is.out==TRUE]<-"brown"
    plotIndiv(p1,col=col,cex=2,title=paste("Outlier (brown dots) detection using PCA and ChiSq test (p<",pthresh,")",sep=""),size.title=8) #0.005) )
    cnames<-cnames[which(is.out==TRUE)]
  }else{
    if(outlier.method=="pcout"){
      suppressMessages(library(mvoutlier))
      res<-pcout(U3,makeplot=TRUE)
      cnames<-names(res$wfinal01[which(res$wfinal01==0)])
    }else{
      
      if(outlier.method=="pcatukey"){
        #s2=apply(data_matrix[,-c(1:2)],2,sum)
        s2=U3[,1]
        iqr_val<-quantile(s2,0.75)-quantile(s2,0.25)
        upper_limit=quantile(s2,0.75)+iqr.multiplier*(iqr_val)
        lower_limit=quantile(s2,0.25)-iqr.multiplier*(iqr_val)
        cnames1<-cnames[which(s2>upper_limit | s2<lower_limit)]
        
       # s2=U3[,2]
       # iqr_val<-quantile(s2,0.75)-quantile(s2,0.25)
      #  upper_limit=quantile(s2,0.75)+iqr.multiplier*(iqr_val)
      #  lower_limit=quantile(s2,0.25)-iqr.multiplier*(iqr_val)
       # cnames1<-c(cnames1,cnames[which(s2>upper_limit | s2<lower_limit)])
        
        cnames=cnames1
      }else{
        
       
        
      }
    }
  }
  
  }
  if(length(cnames)>0){
  #  print(paste("Potential outliers: ",paste(cnames,sep="",collapse=";"),sep=""))
  }else{
    
  #  print("No outliers detected.")
  }
  
  if(dir.exists("Tables")){
  write.table(cnames,file="Tables/Potential.Outliers.txt",sep="\t",row.names=FALSE)
  }else{
    
    write.table(cnames,file="Potential.Outliers.txt",sep="\t",row.names=FALSE)
  }
  return(cnames)
}


#Compare normalization methods
compare.normalization<-function(Xmat=NA,Ymat=NA,Zmat=NA,feature_table_file=NA,parentoutput_dir,class_labels_file=NA,num_replicates=3,feat.filt.thresh=NA,summarize.replicates=TRUE,summary.method="mean",
                                all.missing.thresh=0.5,group.missing.thresh=0.7,
                                missing.val=0,samplermindex=NA, rep.max.missing.thresh=0.5,summary.na.replacement="zeros",pairedanalysis=FALSE,
                                normalization.method=c("all","log2quantilenorm","log2transform","znormtransform","lowess_norm","quantile_norm","rangescaling",
                                                       "paretoscaling","mstus","eigenms_norm","vsn_norm","sva_norm","tic_norm","cubicspline_norm","mad_norm"),input.intensity.scale="raw",
                                abs.cor.thresh=0.4,pvalue.thresh=0.05,cor.fdrthresh=0.2,cex.plots=0.7,plots.width=8,plots.height=8,plots.res=600,
                                plots.type="cairo",heatmap.col.opt="RdBu",cor.method="pearson",pca.ellipse=FALSE,ground_truth_file=NA,cutree.method="dynamic",rsd.filt.thresh=1,alphabetical.order=TRUE,analysistype="classification",lme.modeltype="RI",
                                study.design=c("multiclass","onewayanova","twowayanova","onewayanovarepeat","twowayanovarepeat"),log2.transform.constant=1,
                                featselmethod="limma",similarity.matrix="correlation",...){
  
  #featselmethod=NA
  suppressMessages(require(dynamicTreeCut))
  suppressMessages(require(mclust))
  suppressMessages(require(cluster))
  suppressMessages(require(WGCNA))
  
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  if(is.na(Xmat)[1]==TRUE){
    Xmat<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }
  
  if(is.na(Ymat)[1]==TRUE){
    Ymat<-read.table(class_labels_file,sep="\t",header=TRUE)
  }
  
  if(is.na(ground_truth_file)==FALSE){
    
    Zmat<-read.table(ground_truth_file,sep="\t",header=TRUE)
  }
  
  
  if(study.design=="multiclass" | study.design=="onewayanova"){
    
    
    print("Treating column B as class labels")
    cnames<-colnames(Ymat)
    cnames[2]<-c("Class")
    colnames(Ymat)<-cnames
  }else{
    if(study.design=="onewayanovarepeat"){
      
      
      print("Treating column B as subject IDs, column C as class labels")
      Ymat<-Ymat[,-c(2)]
      cnames<-colnames(Ymat)
      cnames[2]<-c("Class")
      colnames(Ymat)<-cnames
    }else{
      if(study.design=="twowayanovarepeat"){
        
        
        print("Treating column B as subject IDs, column C as factor 1, and column D as factor 2")
        Ymat<-Ymat[,-c(2)]
        Ymat[,2]<-as.factor(Ymat[,2]):as.factor(Ymat[,3])
        Ymat<-Ymat[,-3]
        cnames<-colnames(Ymat)
        cnames[2]<-c("Class")
        colnames(Ymat)<-cnames
      }else{
        
        if(study.design=="twowayanova"){
          
          
          print("Treating column B as factor 1 and column C as factor 2")
          
          Ymat[,2]<-as.factor(Ymat[,2]):as.factor(Ymat[,3])
          Ymat<-Ymat[,-3]
          cnames<-colnames(Ymat)
          cnames[2]<-c("Class")
          colnames(Ymat)<-cnames
        }
        
        
      }
      
    }
    
    
    
  }
  
  normalization.method=tolower(normalization.method)
  
  
  if(normalization.method[1]==c("all")){
    
    normalization.method=c("log2quantilenorm","log2transform","znormtransform","lowess_norm","quantile_norm","rangescaling","paretoscaling","mstus","eigenms_norm","vsn_norm","sva_norm","tic_norm","cubicspline_norm","mad_norm")
    
  }
  
  if(normalization.method[1]==c("none")){
    print("Using raw data")
  }
  valid_norm_options<-c("log2quantilenorm","log2transform","znormtransform","lowess_norm","quantile_norm","rangescaling","paretoscaling","mstus",
                        "eigenms_norm","vsn_norm","sva_norm","none","tic_norm","cubicspline_norm","mad_norm")
  
  data_matrix_list<-new("list")
  
  rnames_xmat<-colnames(Xmat)
  rnames_xmat<-tolower(rnames_xmat)
  #colnames(Xmat)<-rnames_xmat
  
  rnames_ymat<-colnames(Ymat)
  rnames_ymat<-tolower(rnames_ymat)
  
  check_ylabel<-regexpr(rnames_ymat,pattern="^((class)|(factor))",perl=TRUE)
  
  
  if(length(which(check_ylabel>0))<1){
    
    stop("No column named Class found in the class labels file. Please use the name Class for the column with the main outcome.")
  }
  
  
  colnames(Ymat)<-rnames_ymat
  
  #Xmat1<-Xmat[,c(1,order(rnames_xmat)+1)]
  
  
  
  check_xlabel<-regexpr(rnames_xmat[1],pattern="^(name|Name)",perl=TRUE)
  if(check_xlabel>0){
    
    
    # Xmat<-cbind(Xmat[,c(1)],Xmat[,c(order(Ymat$class)+1)])
    
    cnames1<-colnames(Xmat)
    cnames1[1]<-"Name"
    
    colnames(Xmat)<-cnames1
    
    #    Ymat<-Ymat[order(Ymat$class),]
    
    rnames_xmat<-colnames(Xmat[,-c(1)])
    rnames_ymat<-Ymat[,1]
    
    # rnames_ymat<-tolower(rnames_ymat)
    
  }else{
    
    
    
    
    #Xmat<-cbind(Xmat[,c(1:2)],Xmat[,c(order(Ymat$class)+2)])
    
    
    # Ymat<-Ymat[order(Ymat$class),]
    
    
    rnames_xmat<-colnames(Xmat[,-c(1:2)])
    rnames_ymat<-Ymat[,1]
    # rnames_ymat<-tolower(rnames_ymat)
  }
  
  
  data_matrix_list<-lapply(1:length(normalization.method),function(i)
  {
    
    if(normalization.method[i]%in%valid_norm_options){
      
      print("###################")
      
      print("          ")
      
      dir.create(parentoutput_dir,showWarnings = FALSE)
      setwd(parentoutput_dir)
      dir.create(normalization.method[i],showWarnings = FALSE)
      setwd(normalization.method[i])
      outloc=paste(parentoutput_dir,"/",normalization.method[i],sep="")
      
      print(outloc)
      fname1<-paste(normalization.method[i],".pdf",sep="")
      
      
      pdf(fname1)
      par(mfrow=c(1,1),family="sans",cex=cex.plots)
      
      ######
      
      if(is.na(featselmethod)==FALSE){
        
        if(featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="poissonreg" | featselmethod=="lmregrobust" | featselmethod=="logitregrobust" | featselmethod=="poissonregrobust" | featselmethod=="limma" | featselmethod=="limma1way" | featselmethod=="MARS" | featselmethod=="RF" | featselmethod=="pls" | featselmethod=="o1pls" | featselmethod=="o2pls" | featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="spls" | featselmethod=="o1spls" | featselmethod=="o2spls" | featselmethod=="rfesvm" | featselmethod=="pamr" | featselmethod=="poissonreg" | featselmethod=="ttest" | featselmethod=="wilcox" | featselmethod=="lm1wayanova"){
          
          
          Ymat<-Ymat[,c(1:2)]
          
        }
        
      }else{
        
        print("Treating the second column as the class label.")
        Ymat<-Ymat[,c(1:2)]
        
      }
      
      
      
      
      #rnames_ymat[match(rnames_xmat,rnames_ymat)]
      
      if(length(which(duplicated(rnames_ymat)==TRUE))>0){
        
        stop("Duplicate sample IDs are not allowed. Please represent replicates by _1,_2,_3.")
      }
      
      check_ylabel<-regexpr(rnames_ymat[1],pattern="^[0-9]*",perl=TRUE)
      check_xlabel<-regexpr(rnames_xmat[1],pattern="^X[0-9]*",perl=TRUE)
      
      check_ylabel<-regexpr(rnames_ymat[1],pattern="^ ",perl=TRUE)
      check_xlabel<-regexpr(rnames_xmat[1],pattern="^ ",perl=TRUE)
      if(length(check_ylabel)>0 && length(check_xlabel)>0){
        if(attr(check_ylabel,"match.length")>0 && attr(check_xlabel,"match.length")>0){
          
          rnames_ymat<-paste("X",rnames_ymat,sep="")
        }
      }
      
      match_names<-match(rnames_xmat,rnames_ymat)
      
      bad_colnames<-length(which(is.na(match_names)==TRUE))
      
      if(bad_colnames>0){
        print("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names.")
        print("Sample names in feature table")
        print(head(rnames_xmat))
        print("Sample names in classlabels file")
        
        print(head(rnames_ymat))
        #stop("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names. Please try again.")
      }
      
      
      if(is.na(all(diff(match(rnames_xmat,rnames_ymat))))==FALSE){
        if(all(diff(match(rnames_xmat,rnames_ymat)) > 0)==FALSE){
         
          print(head(rnames_xmat))
          print("Sample names in classlabels file")
          
          print(head(rnames_ymat))
          
           stop("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names. Please try again.")
        }
      }else{
        print(head(rnames_xmat))
        print("Sample names in classlabels file")
        
        print(head(rnames_ymat))
        stop("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names. Please try again.")
      }
      
      data_matrix_list<-data_preprocess(Xmat=Xmat,Ymat=Ymat,feature_table_file=feature_table_file,parentoutput_dir=outloc,class_labels_file=class_labels_file,num_replicates=num_replicates,feat.filt.thresh=NA,summarize.replicates=summarize.replicates,
                                        summary.method=summary.method,
                                        all.missing.thresh=all.missing.thresh,group.missing.thresh=group.missing.thresh,log2transform=FALSE,quantile_norm=FALSE,missing.val=missing.val,samplermindex=samplermindex, rep.max.missing.thresh=rep.max.missing.thresh,
                                        summary.na.replacement=summary.na.replacement,
                                        featselmethod=featselmethod,pairedanalysis=pairedanalysis,normalization.method=normalization.method[i],input.intensity.scale=input.intensity.scale,log2.transform.constant=log2.transform.constant) #,silent=TRUE)
      
      if(is(data_matrix_list,"try-error")){
        
        return(list("data_matrix_list"=NA,"Silhouette.sample"=NA,"Silhouette.feature"=NA,"ari_val"=NA,"feat.cor.mat"=NA))
      }else{
        
        
        feature_names<-data_matrix_list$names_with_mz_time
        
        X<-data_matrix_list$data_matrix_afternorm_scaling
        
        sd_check<-apply(X[,-c(1:2)],1,sd)
        
        if(length(which(sd_check==0))>0){
          
          X<-X[-which(sd_check==0),]
        }
        
        feat_rsds<-apply(X[,-c(1:2)],1,do_rsd)
        
        sum_rsd<-summary(feat_rsds,na.rm=TRUE)
        max_rsd<-max(feat_rsds,na.rm=TRUE)
        max_rsd<-round(max_rsd,2)
        
       # print("Summary of RSD across all features:")
        #print(sum_rsd)
        
        abs_feat_rsds<-abs(feat_rsds)
        
        good_metabs<-which(abs_feat_rsds>rsd.filt.thresh)
        
        if(length(good_metabs)>0){
          
          X<-X[good_metabs,]
          
        }else{
          
          
          stop(paste("Please decrease the maximum relative standard deviation (rsd.filt.thresh) threshold to ",max_rsd,sep=""))
          
        }
        
      
        setwd(parentoutput_dir)
        
        setwd(normalization.method[i])
        
        if(is.na(feature_names)==FALSE){
          
          feature_names<-merge(feature_names,X[,c(1:2)],by=c("mz","time"))
          feature_names<-feature_names[order(as.numeric(as.character(feature_names$mz)),feature_names$time),]
          
          dup_name_check<-which(duplicated(feature_names$Name)==TRUE)
          if(length(dup_name_check)>0){
            feature_names<-feature_names[-dup_name_check,]
            
            X<-X[-dup_name_check,]
          }
          rownames(X)<-feature_names$Name
          
        }
        Y<-data_matrix_list$classlabels
        
        size_num<-min(100,dim(X[,-c(1:2)])[2])
        
        data_m_fc<-X[,-c(1:2)]
        
        par(mfrow=c(1,1),family="sans",cex=cex.plots)
        samp_index<-sample(x=1:dim(data_m_fc)[2],size=size_num)
        samp_index<-samp_index[order(samp_index)]
        
        if(normalization.method[i]=="none"){
          
          boxplot(data_m_fc[,samp_index],main=paste("Intensity distribution across samples after no normalization",sep=""),xlab="Samples",ylab="Intensity",col="white",cex=0.8)
          
        }else{
          boxplot(data_m_fc[,samp_index],main=paste("Intensity distribution across samples after ", normalization.method[i],sep=""),xlab="Samples",ylab="Intensity",col="white",cex=0.8)
        }
        
        ##save(Y,file="Y.Rda")
        if(pairedanalysis==TRUE){
          
          Y1=Y[,-c(2)]
        }
        
       # print("Starting PCA")
        
        #  get_pcascoredistplots(X=X,Y=Y,feature_table_file=NA,parentoutput_dir=outloc,class_labels_file=NA,sample.col.opt="journal",plots.width=plots.width,plots.height=plots.height,plots.res=plots.res, alphacol=0.3,col_vec=NA,pairedanalysis=pairedanalysis,
        #pca.cex.val=2,legendlocation="topright",pca.ellipse=pca.ellipse,ellipse.conf.level=0.95,filename=paste(normalization.method[i], " data ",sep=""),paireddesign=NA,error.bar=TRUE,
        #lineplot.col.opt="black",lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),newdevice=FALSE,timeseries.lineplots=FALSE,pcascale=TRUE,pcacenter=TRUE)
        
        
        #print(X[1:3,1:5])
        #print(head(Y))
       # save(X,Y,pairedanalysis,pca.ellipse,normalization.method,i,alphabetical.order,analysistype,lme.modeltype,file="pcad1.Rda")
      
        cat("Starting PCA",sep="\n")  
        pcares<-get_pcascoredistplots(X=X,Y=Y,feature_table_file=NA,parentoutput_dir=outloc,class_labels_file=NA,sample.col.opt="journal",
                                      plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3,col_vec=NA,pairedanalysis=pairedanalysis,pca.cex.val=2,legendlocation="topright",
                                      pca.ellipse=pca.ellipse,ellipse.conf.level=0.95,filename=paste(normalization.method[i], "data ",sep=""),paireddesign=NA,
                                      lineplot.col.opt="black",lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),timeseries.lineplots=FALSE,pcacenter=TRUE,pcascale=TRUE,alphabetical.order=alphabetical.order,study.design=analysistype,lme.modeltype=lme.modeltype) #,silent=TRUE)
        
       #save(pcares,file="pcares.Rda")
      
        setwd(parentoutput_dir)
        
        classgroup=Y[,2]
        classgroup=as.data.frame(classgroup)
        
        
        setwd(normalization.method[i])
        cat("Starting HCA")
        st1=Sys.time()
        
        #cluster features
        x=pcares$X
        #row samples; column: features
        dist1<-as.dist(1-WGCNA::cor(x))
        f1=fastcluster::hclust(d=dist1,method = "complete")
        
        mycl_metabs <-cutreeDynamic(f1,distM=as.matrix((1-WGCNA::cor(x))),method="hybrid",cutHeight = 0.95,
                                    deepSplit = 4,minClusterSize = 2,verbose = FALSE)
        names(mycl_metabs)<-f1$labels
        
        Silhouette.features<- silhouette(mycl_metabs,dmatrix=as.matrix(dist1))
        
        Silhouette.features<-round(mean(Silhouette.features[,3]),3)
        
        #transpose for W.k: row: features; col: samples
        #gap.stat.features<-E.W.k(x=(x), d.power=1,B=100)-W.k(x=t(x), clus=mycl_metabs,d.power=1)
        
        
        #cluster samples
        x=t(pcares$X)
        #row samples; column: features
        dist1<-as.dist(1-WGCNA::cor(x))
        f1=fastcluster::hclust(d=dist1,method = "complete")
        
        mycl_samples <-cutreeDynamic(f1,distM=as.matrix((1-WGCNA::cor(x))),method="hybrid",cutHeight = 0.95,
                                    deepSplit = 2,minClusterSize =2,verbose = FALSE)
        names(mycl_samples)<-f1$labels
        
        Silhouette.samples<- silhouette(mycl_samples,dmatrix=as.matrix(dist1))
        Silhouette.samples<-round(mean(Silhouette.samples[,3]),3)
        
        ari_val<-try(round(adjustedRandIndex(x=classgroup[,1], y=mycl_samples),2),silent=TRUE)
        
       # save(f1,mycl_samples,classgroup,file="hcasamples.Rda")
        
        plotDendroAndColors(f1,mycl_samples,rowText = mycl_samples,groupLabels = c("Cluster"),
                            rowTextAlignment = "center",
                            dendroLabels = rownames(f1),
                            main=paste("Cluster dendrogram for samples\n Adjusted Rand Index:",ari_val,sep=""))
        
        
       
        #transpose for W.k: row: features; col: samples
    #    gap.stat.samples<-E.W.k(x=(x), d.power=1,B=100)-W.k(x=t(x), clus=mycl_samples,d.power=1)
        
        
        #W.k <- function(x, kk,clus,d.power=1) {
      if(FALSE)
      {
        hca_res<-get_hca(parentoutput_dir=outloc,X=X,Y=Y,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                         sample.col.opt="journal",plots.width=plots.width,plots.height=plots.height,plots.res=plots.res, plots.type=plots.type, 
                         alphacol=0.3, hca_type="two-way",newdevice=FALSE,input.type="intensity",mainlab="",
                         plot.bycluster=FALSE,color.rows=FALSE,deepsplit=2,minclustsize=1,mergeCutHeight=0.1,
                         num_nodes=2,alphabetical.order=alphabetical.order,pairedanalysis=pairedanalysis,cutree.method=cutree.method,
                         study.design=analysistype,similarity.matrix=similarity.matrix,cexRow=cex.plots,cexCol=cex.plots)
        
        classlabels_response_mat=Y[,2]
        st2=Sys.time()
        cat("Done with HCA",sep="\n")
        print(st2-st1)
      }
        
        
        if(FALSE){ 
        if(analysistype=="classification"){
          
          #print("Performing one-way ANOVA analysis")
          
          #numcores<-round(detectCores()*0.6)
          cl <- parallel::makeCluster(getOption("cl.cores", 2))
          clusterExport(cl,"diffexponewayanova",envir = .GlobalEnv)
          clusterExport(cl,"anova",envir = .GlobalEnv)
          clusterExport(cl,"TukeyHSD",envir = .GlobalEnv)
          clusterExport(cl,"aov",envir = .GlobalEnv)
          res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat){
            #res1<-apply(data_m_fc,1,function(x,classlabels_response_mat){
            xvec<-x
            data_mat_anova<-cbind(xvec,classlabels_response_mat)
            data_mat_anova<-as.data.frame(data_mat_anova)
            cnames<-colnames(data_mat_anova)
            cnames[1]<-"Response"
            colnames(data_mat_anova)<-c("Response","Factor1")
            data_mat_anova$Factor1<-as.factor(data_mat_anova$Factor1)
            #anova_res<-diffexponewayanova(dataA=data_mat_anova)
            data_mat_anova<-as.data.frame(data_mat_anova)
            
            ##save(data_mat_anova,file="data_mat_anova.Rda")
            a1 <- aov(as.numeric(data_mat_anova$Response) ~ .,data=data_mat_anova) # + chocolate$Factor1*chocolate$Factor2)
            
            # posthoc <- TukeyHSD(x=a1, conf.level=0.95,test=univariate())
            anova_res<-anova(a1)
            
            num_rows<-dim(anova_res)
            pvalues_factors<-data.frame(t(anova_res["Pr(>F)"][-c(num_rows),]))
            
            
            
            return(pvalues_factors)
          },classlabels_response_mat)
          
          stopCluster(cl)
          
          pvalues<-{}
          
          
          pvalues<-unlist(res1)
          
        }
        else{
          
          # numcores<-num_nodes #round(detectCores()*0.5)
          
          cl <- parallel::makeCluster(getOption("cl.cores", 2))
          
          clusterExport(cl,"diffexplmreg",envir = .GlobalEnv)
          clusterExport(cl,"lm",envir = .GlobalEnv)
          clusterExport(cl,"glm",envir = .GlobalEnv)
          clusterExport(cl,"summary",envir = .GlobalEnv)
          clusterExport(cl,"anova",envir = .GlobalEnv)
          clusterEvalQ(cl,library(sandwich))
          
          
          #data_mat_anova<-cbind(t(data_m_fc),classlabels_response_mat)
          res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat,logistic_reg,poisson_reg,robust.estimate){
            
            xvec<-x
            
            
            
            data_mat_anova<-cbind(xvec,classlabels_response_mat)
            
            cnames<-colnames(data_mat_anova)
            cnames[1]<-"Response"
            
            colnames(data_mat_anova)<-cnames
            
            
            anova_res<-diffexplmreg(dataA=data_mat_anova,logistic_reg,poisson_reg,robust.estimate)
            
            return(anova_res)
          },classlabels_response_mat,FALSE,FALSE,TRUE)
          
          stopCluster(cl)
          main_pval_mat<-{}
          
          posthoc_pval_mat<-{}
          pvalues<-{}
          
          all_inf_mat<-{}
          
          for(i in 1:length(res1)){
            
            main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
            pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
          }
          pvalues<-unlist(pvalues)
          
          #posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthocfactor1)
          
          
        }
        
        
        kstest_res<-ks.test(pvalues,"punif",0,1)
        kstest_res<-round(kstest_res$p.value,3)
        
        hist(as.numeric(pvalues),main=paste("Distribution of pvalues\n","Kolmogorov-Smirnov test for uniform distribution, p=",kstest_res,sep=""),cex.main=0.75,xlab="pvalues")
        #if(FALSE)
        {
          simpleQQPlot = function (observedPValues,mainlab) {
            plot(-log10(1:length(observedPValues)/length(observedPValues)),
                 -log10(sort(observedPValues)),main=mainlab,xlab=paste("Expected -log10pvalue",sep=""),ylab=paste("Observed -logpvalue",sep=""),cex.main=0.75)
            abline(0, 1, col = "brown")
          }
          
          inflation <- function(pvalue) {
            chisq <- qchisq(1 - pvalue, 1)
            lambda <- median(chisq) / qchisq(0.5, 1)
            lambda
          }
          inflation_res<-round(inflation(pvalues),2)
          
          simpleQQPlot(pvalues,mainlab=paste("QQplot pvalues","\np-value inflation factor: ",inflation_res," (no inflation: close to 1; bias: greater than 1)",sep=""))
          
        }
        
        }
        
        
        
        if(FALSE){
        
        Silhouette.sample=hca_res$Silhouette.sample
        
        Silhouette.feature=hca_res$Silhouette.feature
        
        ari_val=hca_res$adj.rand.index
        
        ##save(hca_res,file="hca_res.Rda")
        
        classgroup=hca_res$classgroup[,1]
      }
        #rownames(X)<-NULL
        
        setwd(outloc)
        
        feat.cor.mat=NA
        
        if(is.na(abs.cor.thresh)==FALSE){
          
          
        #  print("Starting pairwise correlation analysis")
          feat.cor.mat=plot.pairwise.correlation(data_matrix=X,newdevice=FALSE,abs.cor.thresh=abs.cor.thresh,pvalue.thresh=pvalue.thresh,cor.fdrthresh=cor.fdrthresh,cex.plots=cex.plots,plots.width=plots.width,plots.height=plots.height,plots.res=plots.res, plots.type=plots.type,Y=classgroup,cor.method=cor.method)
          
          
          if(is.na(Zmat)==FALSE){
            
            
            plot.pairwise.correlation.bipartite(data_matrix=X,newdevice=FALSE,abs.cor.thresh=abs.cor.thresh,pvalue.thresh=pvalue.thresh,cor.fdrthresh=cor.fdrthresh,cex.plots=cex.plots,plots.width=plots.width,plots.height=plots.height,plots.res=plots.res, plots.type=plots.type,data_matrixB=Zmat,cor.method=cor.method)
          }
        }
        
        dev.off()
        
        
        
        
        return(list("data_matrix_list"=data_matrix_list,"Silhouette.sample"=Silhouette.samples,
                    "Silhouette.feature"=Silhouette.features,"ari_val"=ari_val,
                   #"Gap.feature"=gap.stat.features,
                    #"Gap.sample"=gap.stat.samples,
                    "feat.cor.mat"=feat.cor.mat))
        
      }
      
    }else{
      
      print(paste("Invalid option: ",normalization.method[i],sep=""))
    }
    
    
  })
  
  #   ##save(data_matrix_list,file="data_matrix_list1.Rda")
  if(FALSE){   
  Gap.sample=lapply(1:length(data_matrix_list),function(j){
    
    return(data_matrix_list[[j]]$Gap.sample)
  })
  
  Gap.feature=lapply(1:length(data_matrix_list),function(j){
    
    return(data_matrix_list[[j]]$Gap.feature)
  })
}
  Silhouette.sample=lapply(1:length(data_matrix_list),function(j){
    
    return(data_matrix_list[[j]]$Silhouette.sample)
  })
  
  #Silhouette.feature=data_matrix_list$Silhouette.feature
  Silhouette.feature=lapply(1:length(data_matrix_list),function(j){
    
    return(data_matrix_list[[j]]$Silhouette.feature)
  })
  
  # ari_val=data_matrix_list$ari_val
  
  ari_val=lapply(1:length(data_matrix_list),function(j){
    
    return(data_matrix_list[[j]]$ari_val)
  })
  
  #feat.cor.mat=data_matrix_list$feat.cor.mat
  feat.cor.mat=lapply(1:length(data_matrix_list),function(j){
    
    return(data_matrix_list[[j]]$feat.cor.mat)
  })
  
  # data_matrix_list=data_matrix_list$data_matrix_list
  data_matrix_list=lapply(1:length(data_matrix_list),function(j){
    
    return(data_matrix_list[[j]]$data_matrix_list)
  })
  
  norm_method_names<-(normalization.method)
  norm_method_names<-gsub(norm_method_names,pattern="_norm|norm",replacement="")
  
  setwd(parentoutput_dir)
  
  #save(norm_method_names,Silhouette.feature,Silhouette.sample,ari_val,file="hcaplotdebug.Rda")
  
  pdf("Compare.HCA.performance.pdf",height=8,width=12)
  
  par(mfrow=c(1,3))
  par(mar=c(10,3,4,3))
  #    ##save(varimp_res2,data_m_fc,rf_classlabels,sorted_varimp_res,file="test_rf.Rda")
  #xaxt="n",

  cval1<-unlist(Silhouette.feature)
  names(cval1)<-norm_method_names
  x=barplot(cval1,ylab="",main="mean Silhouette coefficient \n for clustering of features",cex.axis=0.9,cex.names=0.9, xlab="",las=2,ylim=c(0,1))
 # title(ylab = "mean Silhouette coefficient \n for clustering of features", cex.lab = 1.5,line = 4.5)
            
  cval1<-unlist(Silhouette.sample)
  names(cval1)<-norm_method_names
  x=barplot(cval1,ylab="",main="mean Silhouette coefficient \n for clustering of samples",cex.axis=0.9,cex.names=0.9, xlab="",las=2,ylim=c(0,1))
 # title(ylab = "mean Silhouette coefficient \n for clustering of samples", cex.lab = 1.5,line = 4.5)
 if(FALSE){ 
  cval1<-unlist(Gap.feature)
  x=barplot(cval1,xlab="",main="",cex.axis=0.9,cex.names=0.9, ylab="",las=2,ylim=range(pretty(c(min(cval1,na.rm=TRUE),max(cval1,na.rm=TRUE)))))
  title(ylab = "mean Gap statistic \n for clustering of features", cex.lab = 1.5,line = 4.5)
  
  cval1<-unlist(Gap.sample)
  x=barplot(cval1,xlab="",main="",cex.axis=0.9,cex.names=0.9, ylab="",las=2,ylim=range(pretty(c(min(cval1,na.rm=TRUE),max(cval1,na.rm=TRUE)))))
  title(ylab = "mean Gap statistic \n for clustering of samples", cex.lab = 1.5,line = 4.5)
 }  
  
  cval1<-unlist(ari_val)
  print(cval1)
  names(cval1)<-norm_method_names
  x=barplot(cval1,ylab="",main="Adjusted rand index \n for comparing sample clustering \nwith the ground truth (class labels)",cex.axis=0.9,
            cex.names=0.9, xlab="",las=2,ylim=c(0,1))
 # title(ylab = "Adjusted rand index \n for comparing sample clustering \nwith the ground truth (class labels)", cex.lab = 1.5,line = 4.5)
  
  #par(mar=c(1,1))
  
  if(FALSE){
    plot(unlist(Silhouette.feature),type="o",ylim=c(0,1),col="#0072B2",lwd=2,xaxt="n",xlab="",ylab="Value",
       main="Comparison of clustering quality evaluation \n (silhouette, gap, and adjusted rand index) metrics",cex.main=0.8)
  lines(unlist(Silhouette.sample),type="o",lty=2,col="#E69F00",lwd=2)
  lines(unlist(Gap.feature),type="o",lty=5,col="#009E73",lwd=2)
  lines(unlist(Gap.sample),type="o",lty=3,col="#56B4E9",lwd=2)
  lines(unlist(ari_val),type="o",lty=4,col="#D55E00",lwd=2)
  axis(labels=norm_method_names,at=seq(1,length(norm_method_names)),side=1,las=2,cex.axis=0.65)
  legend("topright",legend=c("Silhouette.features","Silhouette.samples","Gap.feautres","Gap.samples","Adjusted Rand Index"),
         lty=c(1,2,5,3,4),col=c("#0072B2","#E69F00",
                                                                                                                      "#009E73","#56B4E9",
                                                                                                                      "#D55E00"))
  }
  
  dev.off()  
  #unlist(Gap.feature),unlist(Gap.sample),
  resmat<-cbind(normalization.method,unlist(Silhouette.feature),unlist(Silhouette.sample),unlist(ari_val))
  colnames(resmat)<-c("Normalization.method","Silhouette.feature","Silhouette.sample","Adjusted_Rand_Index")
  write.csv(resmat,file="comparison.HCA.performance.csv",row.names=FALSE)
  return(list(data_matrix_list=data_matrix_list,normalization.methods=normalization.method,
              Silhouette.sample=Silhouette.sample,Silhouette.feature=Silhouette.feature,
              #Gap.sample=Gap.sample,
              #Gap.feature=Gap.feature,
              ari_val=ari_val,feat.cor.mat=feat.cor.mat))
  
  
  
}

plot.pairwise.correlation.bipartite<-function(data_matrix,data_matrixB,newdevice=TRUE,abs.cor.thresh=0.4,pvalue.thresh=0.05,
                                              cor.fdrthresh=0.2,cex.plots=0.7,output.device.type="pdf",plots.width=8,
                                              plots.height=8,plots.res=600, plots.type="cairo",cor.method="spearman",
                                              do.clustering=TRUE){
  
 
  cnames<-colnames(data_matrixB)
  cnames<-tolower(cnames)
  
  check_names<-grep(cnames,pattern="^name$")
  
  names_with_mz_time<-NA
  
  X<-data_matrixB
  if(length(check_names)>0){
    
    if(check_names==1){
      
      rownames(data_matrix)<-data_matrix$Name
      rownames(data_matrixB)<-data_matrixB$Name
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        col_ind_rm<-c(check_ind)
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
        
          
          check_ind1<-gregexpr(cnames,pattern="^mz$")
          check_ind1<-which(check_ind1>0)
          
          check_ind2<-gregexpr(cnames,pattern="^time$")
          check_ind2<-which(check_ind2>0)
          
          col_ind_rm<-c(check_ind,check_ind1,check_ind2)
          
          #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
    if(length(check_names1)>0 & length(check_names2)>0){
      
      
      
      check_ind1<-gregexpr(cnames,pattern="^mz$")
      check_ind1<-which(check_ind1>0)
      
      check_ind2<-gregexpr(cnames,pattern="^time$")
      check_ind2<-which(check_ind2>0)
      
      col_ind_rm<-c(check_ind1,check_ind2)
      
      #write.table(names_with_mz_time,file="Stage1/Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
    }
  }
  
 # data_matrixB<-X
  
  
  goodfeats_temp=rbind(data_matrix,data_matrixB)
  print(newdevice)
  print(output.device.type)
  
  if(newdevice==TRUE){
    if(output.device.type=="pdf"){
      
      try(dev.off(),silent=TRUE)
      temp_filename_1<-"Pairwise.correlation.plots.pdf"
      
      #pdf(temp_filename_1)
      pdf(temp_filename_1,width=plots.width,height=plots.height)
      
    }else{
      
      temp_filename_1<-"Pairwise.correlation.plots.png"
      
      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      
    }
  }
  
  par(mfrow=c(1,1),family="sans",cex=cex.plots,cex.main=0.7)
  
  #save(goodfeats_temp,data_matrix,file="pcormat.Rda")
  
  cor1<-WGCNA::cor(t(goodfeats_temp[,-c(col_ind_rm)]),method=cor.method)
  
  cor1<-cor1[1:nrow(data_matrix),(nrow(data_matrix)+1):(nrow(data_matrix)+nrow(data_matrixB))]
  
  corpval1=apply(cor1,2,function(x){corPvalueStudent(x,n=ncol(goodfeats_temp[,-c(col_ind_rm)]))})
  
  #save(cor1,goodfeats_temp,corpval1,file="cor2.Rda")
 
  cor1[(abs(cor1)<abs.cor.thresh)]<-0
  newnet <- cor1
  

  #upperTriangle<-upper.tri(cor1, diag=F)
  #lowerTriangle<-lower.tri(cor1, diag=F)
  
  if(is.na(cor.fdrthresh)==FALSE){
  fdr_adjust_pvalue<-try(suppressWarnings(fdrtool(as.vector(cor1),statistic="correlation",verbose=FALSE,plot=FALSE)),silent=TRUE)
  #corqval1[upperTriangle]<-fdr_adjust_pvalue$qval
  #
  newnet[fdr_adjust_pvalue$qval > cor.fdrthresh] <- 0
  newnet[as.vector(corpval1) > pvalue.thresh] <- 0
  
 # newnet[lower.tri(newnet)] <- t(newnet)[lower.tri(newnet)]
  newnet <- as.matrix(newnet)
  
  cor1=newnet
  }
  
  correlations_melted<-na.omit(melt(cor1, value.name ="correlationCoef"))
 # correlations_melted<-na.omit(melt(newnet[upper.tri(newnet)], value.name ="correlationCoef")) #use melt to reshape the matrix into triplets, na.omit to get rid of the NA rows
  
  colnames(correlations_melted)<-c("from", "to", "weight")

  #corqval1[lowerTriangle]<-corqval1[upperTriangle]
  
  #cor1=newnet
  rm(newnet)
  
  # rownames(cor1)<-paste(goodfeats_temp[,c(1)],goodfeats_temp[,c(2)],sep="_")
  #  colnames(cor1)<-rownames(cor1)
  
  cor_range<-round(range(cor1,na.rm=TRUE),2)
  
  mainlab1<-paste("Pairwise correlation of variables \n correlation range: ",cor_range[1]," to ",cor_range[2],sep="")
  
  # print(mainlab1)
  #xlab="Samples",ylab=""
  
  #dendrogram="none",
  if(do.clustering==TRUE){
  h1<-heatmap.2(cor1,col=rev(brewer.pal(11,"RdBu")),Rowv=TRUE,Colv=TRUE,scale="none",key=TRUE, symkey=FALSE, 
                density.info="none", trace="none",main=mainlab1,cexRow = 0.5,cexCol = 0.5,cex.main=0.7,
                xlab="Dataset B",ylab="Dataset A")
  }else{
    h1<-heatmap.2(cor1,col=rev(brewer.pal(11,"RdBu")),Rowv=FALSE,Colv=FALSE,scale="none",key=TRUE, symkey=FALSE, 
                  density.info="none", trace="none",main=mainlab1,cexRow = 0.5,cexCol = 0.5,cex.main=0.7,
                  xlab="Dataset B",ylab="Dataset A",dendrogram="none")
    
  }
  correlations_melted$from<-factor(correlations_melted$from,levels=unique(correlations_melted$from))
  correlations_melted$to<-factor(correlations_melted$to,levels=unique(correlations_melted$to))
  p<-get_bubbleplot(correlations_melted[,c(2,1,3)],statistic.type = "correlation",newdevice = FALSE,reverse.yaxis = TRUE)
  print(p)
  if(newdevice==TRUE){
    
      
      try(dev.off(),silent=TRUE)
  }
  return(list("cor.matrix"=cor1,"link.matrix"=correlations_melted))
  
}


plot.pairwise.correlation<-function(data_matrix,newdevice=FALSE,abs.cor.thresh=0.4,pvalue.thresh=0.05,cor.fdrthresh=0.2,cex.plots=0.7,output.device.type="pdf",plots.width=8,plots.height=8,
                                    plots.res=600, plots.type="cairo",Y=NA,cor.method="spearman",show.dendrogram=FALSE){
  
  goodfeats_temp=data_matrix
  
  suppressMessages(library(WGCNA))
  
  if(newdevice==TRUE){
    if(output.device.type!="pdf"){
      
      try(dev.off(),silent=TRUE)
      temp_filename_1<-"Pairwise.correlation.plots.pdf"
      #pdf(temp_filename_1)
      
      pdf(temp_filename_1,width=plots.width,height=plots.height)
    }else{
      
      temp_filename_1<-"Pairwise.correlation.plots.png"
      
      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      
    }
  }
  
  par(mfrow=c(1,1),family="sans",cex=cex.plots,cex.main=0.7)
  
  cor1<-WGCNA::cor(t(goodfeats_temp[,-c(1:2)]),method=cor.method)
  
  save(cor1,abs.cor.thresh,pvalue.thresh,cor.fdrthresh,file="corres.Rda")
  
  if(is.na(abs.cor.thresh)==FALSE){
    cor1[(abs(cor1)<abs.cor.thresh)]<-0
  }
  newnet <- cor1
  
  if(is.na(pvalue.thresh)==FALSE){
    
    corpval1=apply(cor1,2,function(x,goodfeats_temp){
      corPvalueStudent(x,n=ncol(goodfeats_temp[,-c(1:2)]))
      
    },goodfeats_temp=goodfeats_temp)
    
    
    if(is.na(cor.fdrthresh)==FALSE){
      fdr_adjust_pvalue<-try(suppressWarnings(fdrtool(as.vector(cor1[upper.tri(cor1)]),statistic="correlation",verbose=FALSE,plot=FALSE)),silent=TRUE)
      
      newnet[upper.tri(newnet)][fdr_adjust_pvalue$qval > cor.fdrthresh] <- 0
    }                
    
    
    newnet[upper.tri(newnet)][as.vector(corpval1[upper.tri(corpval1)]) > pvalue.thresh] <- 0
  }
  
  newnet[lower.tri(newnet)] <- t(newnet)[lower.tri(newnet)]
  newnet <- as.matrix(newnet)
  
  corqval1=newnet
  diag(corqval1)<-0
  upperTriangle<-upper.tri(cor1, diag=F)
  lowerTriangle<-lower.tri(cor1, diag=F)
  
  if(is.na(cor.fdrthresh)==FALSE){
    corqval1[upperTriangle]<-fdr_adjust_pvalue$qval
    corqval1[lowerTriangle]<-corqval1[upperTriangle]
  }
  
  cor1=newnet
  rm(newnet)
  
  #  rownames(cor1)<-paste(goodfeats_temp[,c(1)],goodfeats_temp[,c(2)],sep="_")
  #  colnames(cor1)<-rownames(cor1)
  
  cor_range<-round(range(cor1[upperTriangle],na.rm=TRUE),2)
  
  mainlab1<-paste("Pairwise correlations between features\n correlation range: ",cor_range[1]," to ",cor_range[2],sep="")
  
  if(show.dendrogram==FALSE){
  
      h1<-heatmap.2(cor1,col=brewer.pal(11,"RdBu"),Rowv=TRUE,Colv=TRUE,dendrogram="none",scale="none",key=TRUE, symkey=FALSE, density.info="none", trace="none",main=mainlab1,cexRow = 0.5,cexCol = 0.5,cex.main=0.7)
  }else{
    
    h1<-heatmap.2(cor1,col=brewer.pal(11,"RdBu"),Rowv=TRUE,Colv=TRUE,scale="none",key=TRUE, symkey=FALSE, density.info="none", trace="none",main=mainlab1,cexRow = 0.5,cexCol = 0.5,cex.main=0.7)
    
  }
  
  #if(FALSE)
    {
    #plot_sample_correlation_child(X=goodfeats_temp[,-c(1:2)],abs.cor.thresh=abs.cor.thresh,pvalue.thresh=pvalue.thresh,cor.fdrthresh=cor.fdrthresh,groupname="all",cor.method=cor.method)
    
    
    if(is.na(Y)==FALSE){
      
      class_levels=levels(as.factor(Y))
      
      for(i in 1:length(class_levels)){
      #  plot_sample_correlation_child(X=goodfeats_temp[,which(Y==class_levels[i])+2],abs.cor.thresh=abs.cor.thresh,pvalue.thresh=pvalue.thresh,cor.fdrthresh=cor.fdrthresh,groupname=class_levels[i],cor.method=cor.method)
        
      }
    }
    
  }
  
  return(cor1)
  
}

plot_sample_correlation_child<-function(X,abs.cor.thresh=0.4,pvalue.thresh=0.05,cor.fdrthresh=0.2,groupname="",cor.method="spearman"){
  
  
  cor1<-WGCNA::cor(X,method=cor.method)
  
  
  
  
  
  
  if(is.na(abs.cor.thresh)==FALSE){
    cor1[(abs(cor1)<abs.cor.thresh)]<-0
  }
  
  newnet <- cor1
  
  if(is.na(cor.fdrthresh)==FALSE){
    fdr_adjust_pvalue<-try(suppressWarnings(fdrtool(as.vector(cor1[upper.tri(cor1)]),statistic="correlation",verbose=FALSE,plot=FALSE)),silent=TRUE)
    
    
    newnet[upper.tri(newnet)][fdr_adjust_pvalue$qval > cor.fdrthresh] <- 0
  }
  
  if(is.na(pvalue.thresh)==FALSE){
    
    corpval1=apply(cor1,2,function(x){
      corPvalueStudent(x,n=ncol(X))
      
    })
    
    newnet[upper.tri(newnet)][as.vector(corpval1[upper.tri(corpval1)]) > pvalue.thresh] <- 0
  }
  
  newnet[lower.tri(newnet)] <- t(newnet)[lower.tri(newnet)]
  newnet <- as.matrix(newnet)
  
  corqval1=newnet
  diag(corqval1)<-0
  upperTriangle<-upper.tri(cor1, diag=F)
  lowerTriangle<-lower.tri(cor1, diag=F)
  
  if(is.na(cor.fdrthresh)==FALSE){
    corqval1[upperTriangle]<-fdr_adjust_pvalue$qval
    corqval1[lowerTriangle]<-corqval1[upperTriangle]
  }
  cor1=newnet
  rm(newnet)
  
  
  cor_range<-round(range(cor1[upperTriangle],na.rm=TRUE),2)
  
  mainlab1<-paste("Pairwise correlations between ",groupname," samples\n correlation range: ",cor_range[1]," to ",cor_range[2],sep="")
  
  
  
  h1<-heatmap.2(cor1,col=brewer.pal(11,"RdBu"),Rowv=TRUE,Colv=TRUE,dendrogram="none",scale="none",key=TRUE, symkey=FALSE, density.info="none", trace="none",main=mainlab1,cexRow = 0.5,cexCol = 0.5,cex.main=0.7)
  
}

eval.class.acc1<-function(){
  
  
  #Working here: classification accuracy training and test set
  if(num_levels==2){
    if(split.train.test==TRUE){
      
      res<-get_classification.accuracy(kfold=kfold,featuretable=data_m_fc_withfeats[goodip,],classlabels=Y,classifier="logit",testfeaturetable=data_m_fc_withfeats_test[goodip,],testclasslabels=Ytest,errortype="BAR",kernelname=svm_kernel,svm.cost=svm.cost,svm.gamma=svm.gamma)
      
      
    }else{
      #get_roc(dataA=good_feats,classlabels=Y,classifier="svm",kname=svm_kernel,rocfeatlist=seq(2,10,1),rocfeatincrement=TRUE,testset=X,testclasslabels=Y,mainlabel="Using training set based on SVM")
      
      #get_roc(dataA=good_feats,classlabels=Y,classifier="svm",kname=svm_kernel,rocfeatlist=c(dim(good_feats)[2]),rocfeatincrement=FALSE,testset=good_feats_test,testclasslabels=Ytest,mainlabel="Test set")
      
      res<-get_classification.accuracy(kfold=kfold,featuretable=good_feats,classlabels=Y,classifier="logit",testfeaturetable=good_feats_test,testclasslabels=Ytest,errortype="BAR",kernelname=svm_kernel,svm.cost=svm.cost,svm.gamma=svm.gamma)
      
      
    }
  }
  
  test_acc_mat<-{}
  class_levels_vec<-levels(as.factor(Y))
  
  
  learnmatrix <- matrix(seq(1,nrow(X)), nrow = 1)
  fiveCV10iter<-new("learningsets", learnmatrix = learnmatrix, method = "none",ntrain = ncol(learnmatrix), iter = nrow(learnmatrix))
  X<-rbind(X,Xtest)
  Y<-c(Y,Ytest)
  classifier_names<-c("PLSLDA","PLSRF","SCDA","SVM","RF","NNet","pLR","PLSLR","pLRlasso","pLRelasticnet")
  
  result_cma_list<-new("list")
  
  
  ###savelist=ls(),file="debug3.Rda")
  
  confusion_matrix_list<-new("list")
  
  if(length(good_feats_index)>2)
  {
    
    if(tune_classifiers==TRUE){
      s1<-ldply(tune_plslda@tuneres,rbind)
      
      s2<-apply(s1,2,median)
      
      
      t1<-new("list")
      confusion_matrix_list<-new("list")
      t1[[1]]<-s2
      tune_plslda1<-tune_plslda
      tune_plslda1@tuneres<-t1
      
      set.seed(seedvalue)
      class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA, tuneres = tune_plslda1,trace=FALSE)
      
      b1<-best(tune_plslda1)
      
      
      
      learnmatrix<-as.numeric(learnmatrix)
      
      set.seed(seedvalue)
      class_res2<-pls_ldaCMA(X = X, y = Y, learnind = learnmatrix, comp = median(unlist(b1)))
      
      
    }else{
      
      set.seed(seedvalue)
      class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_ldaCMA, trace=FALSE)
      learnmatrix<-as.numeric(learnmatrix)
      
      set.seed(seedvalue)
      class_res2<-pls_ldaCMA(X = X, y = Y, learnind = learnmatrix)
      
      
    }
    ##saveclass_res2,file="pls_ldaCMA.Rda")
    result_cma_list[[1]]<-class_res2
    
    ###saveconfusion_matrix_1,file="confusion_matrix_plslda.Rda")
    confusion_matrix_list[[1]]<-table(class_res2@y,class_res2@yhat)
    
    if(length(class_levels_vec)==2){
      testeval_res_auc<-evaluation(class_res,measure = "auc")
      ###savetesteval_res_auc,file="testeval_res_auc.Rda")
      
      test_auc<-100*(mean(testeval_res_auc@score))
      test_acc_mat<-c(test_acc_mat,test_auc)
      
    }else{
      
      test_acc<-evaluation(class_res)
      
      test_acc<-100*(1-mean(testeval_res_auc@score))
      test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
      
      
    }
    
    
    
    #if(best_classifier_name==classifier_names[2]){
    
    if(tune_classifiers==TRUE){
      s1<-ldply(tune_plsrf@tuneres,rbind)
      s2<-apply(s1,2,median)
      t1<-new("list")
      t1[[1]]<-s2
      
      tune_plsrf1<-tune_plsrf
      tune_plsrf1@tuneres<-t1
      set.seed(seedvalue)
      class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA, tuneres = tune_plsrf1,trace=FALSE)
      
      b1<-best(tune_plsrf1)
      # ###saveb1,file="b1_pls_rfCMA.Rda")
      
      learnmatrix<-as.numeric(learnmatrix)
      
      set.seed(seedvalue)
      class_res2<-pls_rfCMA(X = X, y = Y, learnind = learnmatrix, comp = median(unlist(b1)))
    }else{
      set.seed(seedvalue)
      class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = pls_rfCMA, trace=FALSE)
      learnmatrix<-as.numeric(learnmatrix)
      
      set.seed(seedvalue)
      class_res2<-pls_rfCMA(X = X, y = Y, learnind = learnmatrix)
      
      
    }
    
    ##saveclass_res2,file="pls_rfCMA.Rda")
    result_cma_list[[2]]<-class_res2
    #confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
    ###saveconfusion_matrix_1,file="confusion_matrix_rfCMA.Rda")
    
    confusion_matrix_list[[2]]<-table(class_res2@y,class_res2@yhat)
    
    if(length(class_levels_vec)==2){
      
      testeval_res_auc<-evaluation(class_res,measure = "auc")
      ###savetesteval_res_auc,file="testeval_res_auc.Rda")
      
      test_auc<-100*(mean(testeval_res_auc@score))
      
      test_acc_mat<-c(test_acc_mat,test_auc)
      
      
      
    }else{
      
      test_acc<-evaluation(class_res)
      
      test_acc<-100*(1-mean(test_acc@score))
      test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
      
      
    }
    
    
    if(tune_classifiers==TRUE){
      
      s1<-ldply(tune_scda@tuneres,rbind)
      s2<-apply(s1,2,median)
      
      t1<-new("list")
      t1[[1]]<-s2
      
      tune_scda1<-tune_scda
      tune_scda1@tuneres<-t1
      
      #tune_scda<-new("tuningresult",tuneres=t1)
      
      set.seed(seedvalue)
      class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA, tuneres = tune_scda1,trace=FALSE)
      #scdaCMA(X, y, f, learnind, delta = 0.5, models=FALSE,...)
      
      b1<-best(tune_scda1)
      
      
      learnmatrix<-as.numeric(learnmatrix)
      set.seed(seedvalue)
      class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix, delta = median(unlist(b1)))
      
    }else{
      
      if(is.na(class_scda)==FALSE){
        set.seed(seedvalue)
        class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA,trace=FALSE)
        set.seed(seedvalue)
        class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix)
        
      }
    }
    
    if(is.na(class_scda)==FALSE){
      
      ##saveclass_res2,file="scdaCMA.Rda")
      result_cma_list[[3]]<-class_res2
      #confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_scdaCMA.Rda")
      confusion_matrix_list[[3]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ###savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
    }else{
      result_cma_list[[3]]<-NA
      confusion_matrix_list[[3]]<-NA
      test_acc_mat<-c(test_acc_mat,0)
      
    }
    
    
    
    #if(best_classifier_name==classifier_names[4])
    {
      
      if(tune_classifiers==TRUE){
        s1<-ldply(tune_svm@tuneres,rbind)
        
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        
        tune_svm1<-tune_svm
        tune_svm1@tuneres<-t1
        
        b1<-best(tune_svm1)
        
        
        #class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres=tune_svm1, kernel ="radial",trace=FALSE,probability=TRUE)
        
        
        #           ##save(X,Y,learnmatrix,seedvalue,fiveCV10iter,tune_svm1,b1,svmCMA,file="svmdebug.Rda")
        set.seed(seedvalue)
        class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres=tune_svm1, kernel ="radial",trace=FALSE,probability=TRUE)
        
        
        cost_1=b1[[1]]$cost
        gamma_1=b1[[1]]$gamma
        
        learnmatrix<-as.numeric(learnmatrix)
        
        set.seed(seedvalue)
        #class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix, cost = cost_1,gamma=gamma_1,probability=TRUE)
        class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE)
      }else{
        
        set.seed(seedvalue)
        class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, kernel ="radial",trace=FALSE,probability=TRUE)
        set.seed(seedvalue)
        class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE)
        
      }
      
      ##saveclass_res2,file="svmCMA.Rda")
      result_cma_list[[4]]<-class_res2
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_svmCMA.Rda")
      confusion_matrix_list[[4]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
    }
    
    #if(best_classifier_name==classifier_names[5])
    {
      
      if(FALSE){
        s1<-ldply(tune_rf@tuneres,rbind)
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        tune_rf1<-tune_rf
        tune_rf1@tuneres<-t1
      }
      
      set.seed(seedvalue)
      class_res <- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = rfCMA,trace=FALSE) #,tuneres=tune_rf1
      
      learnmatrix<-as.numeric(learnmatrix)
      
      
      set.seed(seedvalue)
      class_res2 <- rfCMA(X =X, y = Y, learnind=learnmatrix, varimp = FALSE) #mtry=tune_rf1$mtry,nodesize=tune_rf1$nodesize
      
      ##saveclass_res2,file="rfCMA.Rda")
      result_cma_list[[5]]<-class_res2
      
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_rfCMA.Rda")
      confusion_matrix_list[[5]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
    }
    
    #if(best_classifier_name==classifier_names[6])
    {
      
      #if(FALSE){
      
      if(tune_classifiers==TRUE){
        s1<-ldply(tune_svm@tuneres,rbind)
        
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        
        tune_svm1<-tune_svm
        tune_svm1@tuneres<-t1
        
        b1<-best(tune_svm1)
        s1<-ldply(tune_nnet@tuneres,rbind)
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        tune_nnet1<-tune_nnet
        tune_nnet1@tuneres<-t1
        
        
        b1<-best(tune_nnet1)
        #}
        
        set.seed(seedvalue)
        class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE,tuneres=tune_nnet1)
        #size=3,decay=0.1) #,
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        
        set.seed(seedvalue)
        #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
        class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix),sigma=median(unlist(best(tune_nnet))))
        #size=b1[[1]]$size,decay=b1[[1]]$decay)
        #size=3,decay=0.1)
      }else{
        
        
        set.seed(seedvalue)
        class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE)
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        
        set.seed(seedvalue)
        #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
        class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix))
        
        
        
      }
      ##saveclass_res2,file="nnetCMA.Rda")
      result_cma_list[[6]]<-class_res2
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_nnetCMA.Rda")
      confusion_matrix_list[[6]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
    }
    
    #if(best_classifier_name==classifier_names[7])
    {
      
      if(FALSE){
        s1<-ldply(tune_plr@tuneres,rbind)
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        tune_plr1<-tune_plr
        tune_plr1@tuneres<-t1
        
        
        b1<-best(tune_plr1)
      }
      
      set.seed(seedvalue)
      class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = plrCMA,trace=FALSE) #,tuneres=tune_plr
      
      set.seed(seedvalue)
      class_res2 <- plrCMA(X =X, y = Y, learnind=learnmatrix)
      
      ##saveclass_res2,file="plrCMA.Rda")
      result_cma_list[[7]]<-class_res2
      
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_plrCMA.Rda")
      confusion_matrix_list[[7]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
    }
    
    
    if(length(class_levels_vec)==2){
      
      
      
      acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
      
      
      
      if(is.na(test_data_check)==TRUE){
        
        colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Training accuracy(AUC)")
        
        print("Training set evaluation using selected features and the best classifier based on AUC measure")
      }else{
        colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Test accuracy(AUC)")
        
        print("Test set evaluation using selected features and the best classifier based on AUC measure")
      }
      
      print(acc_mat[,c(1,4)])
      ##save(acc_mat,file="acc_mat.Rda")
      #rownames(acc_mat)<-best_classifier_name[1]
      
      write.table(acc_mat,file="Classification_evaluation_results_AUC.txt",sep="\t")
      
      
    }else{
      
      acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
      
      
      if(is.na(test_data_check)==TRUE){
        
        colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Training accuracy (Misclassification)")
        print("Training set evaluation using selected features and the best classifier based on misclassification rate measure")
        
      }else{
        colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Test accuracy (Misclassification)")
        print("Test set evaluation using selected features and the best classifier based on misclassification rate measure")
      }
      
      
      #rownames(acc_mat)<-best_classifier_name[1]
      
      write.table(acc_mat,file="Classification_evaluation_results_misclassification.txt",sep="\t")
      
    }
    
    
    
    acc_mat<-acc_mat[,-c(3)]
    
    
    mainlab<-paste("Performance evaluation using classifiers and selected features",sep="")
    
    if(output.device.type!="pdf"){
      
      temp_filename_1<-"Figures/Barplot_classification_accuracy.png"
      
      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
    }
    
    
    acc_mat1<-t(acc_mat)
    #xaxt="n",
    #
    w <- 0.1
    par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
    if(length(class_levels_vec)==2){
      barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
    }else{
      
      barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
      
    }
    if(FALSE){
      if(length(class_levels_vec)==2){
        axis(side=1,at=seq(1,4),labels=c("kfold CV","Permuted kfold CV","Test set","AUC"),cex.axis=cex.plots)
      }else{
        axis(side=1,at=seq(1,3),labels=c("kfold CV","Permuted kfold CV","Test set"),cex.axis=cex.plots)
      }
    }
    
    if(is.na(test_data_check)==TRUE){
      le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("Training (kfold)","Training (overall)"), pch = rep(19,2), pt.cex = 0.6, title = "",cex=0.7,col=barplot.col.opt))
      
    }else{
      le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("Training (kfold)","Test"), pch = rep(19,2), pt.cex = 0.6, title = "",cex=0.7,col=barplot.col.opt))
    }
    
    if(output.device.type!="pdf"){
      
      try(dev.off(),silent=TRUE)
    }
    
    
    try(dev.off(),silent=TRUE)
    
  }else{
    
    test_acc_mat<-c(0,0)
    
    if(tune_classifiers==TRUE){
      
      s1<-ldply(tune_scda@tuneres,rbind)
      s2<-apply(s1,2,median)
      
      t1<-new("list")
      t1[[1]]<-s2
      
      tune_scda1<-tune_scda
      tune_scda1@tuneres<-t1
      
      #tune_scda<-new("tuningresult",tuneres=t1)
      
      set.seed(seedvalue)
      class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA, tuneres = tune_scda1,trace=FALSE)
      #scdaCMA(X, y, f, learnind, delta = 0.5, models=FALSE,...)
      
      b1<-best(tune_scda1)
      
      
      learnmatrix<-as.numeric(learnmatrix)
      set.seed(seedvalue)
      class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix, delta = median(unlist(b1)))
      
    }else{
      
      if(is.na(class_scda)==FALSE){
        set.seed(seedvalue)
        class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = scdaCMA,trace=FALSE)
        set.seed(seedvalue)
        class_res2<-scdaCMA(X = X, y = Y, learnind = learnmatrix)
        
      }
    }
    
    if(is.na(class_scda)==FALSE){
      
      ##saveclass_res2,file="scdaCMA.Rda")
      result_cma_list[[3]]<-class_res2
      #confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_scdaCMA.Rda")
      confusion_matrix_list[[3]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ###savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
    }else{
      result_cma_list[[3]]<-NA
      confusion_matrix_list[[3]]<-NA
      test_acc_mat<-c(test_acc_mat,0)
      
    }
    
    
    
    #if(best_classifier_name==classifier_names[4])
    {
      
      if(tune_classifiers==TRUE){
        s1<-ldply(tune_svm@tuneres,rbind)
        
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        
        tune_svm1<-tune_svm
        tune_svm1@tuneres<-t1
        
        b1<-best(tune_svm1)
        
        
        #class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres=tune_svm1, kernel ="radial",trace=FALSE,probability=TRUE)
        
        
        #                ##save(X,Y,learnmatrix,seedvalue,fiveCV10iter,tune_svm1,b1,svmCMA,file="svmdebug.Rda")
        set.seed(seedvalue)
        class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, tuneres=tune_svm1, kernel ="radial",trace=FALSE,probability=TRUE)
        
        
        cost_1=b1[[1]]$cost
        gamma_1=b1[[1]]$gamma
        
        learnmatrix<-as.numeric(learnmatrix)
        
        
        set.seed(seedvalue)
        #class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix, cost = cost_1,gamma=gamma_1,probability=TRUE)
        class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE)
        
      }else{
        
        set.seed(seedvalue)
        class_res <- classification(X = X, y = Y, learningsets = fiveCV10iter, classifier = svmCMA, kernel ="radial",trace=FALSE,probability=TRUE)
        set.seed(seedvalue)
        class_res2<-svmCMA(X = X, y = Y, learnind = learnmatrix,probability=TRUE)
        
      }
      
      ##saveclass_res2,file="svmCMA.Rda")
      result_cma_list[[4]]<-class_res2
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_svmCMA.Rda")
      confusion_matrix_list[[4]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
    }
    
    #if(best_classifier_name==classifier_names[5])
    {
      
      if(FALSE){
        s1<-ldply(tune_rf@tuneres,rbind)
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        tune_rf1<-tune_rf
        tune_rf1@tuneres<-t1
      }
      
      set.seed(seedvalue)
      class_res <- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = rfCMA,trace=FALSE) #,tuneres=tune_rf1
      
      learnmatrix<-as.numeric(learnmatrix)
      
      
      set.seed(seedvalue)
      class_res2 <- rfCMA(X =X, y = Y, learnind=learnmatrix, varimp = FALSE) #mtry=tune_rf1$mtry,nodesize=tune_rf1$nodesize
      
      ##saveclass_res2,file="rfCMA.Rda")
      result_cma_list[[5]]<-class_res2
      
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_rfCMA.Rda")
      confusion_matrix_list[[5]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
    }
    
    #if(best_classifier_name==classifier_names[6])
    {
      
      #if(FALSE){
      if(tune_classifiers==TRUE){
        s1<-ldply(tune_nnet@tuneres,rbind)
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        tune_nnet1<-tune_nnet
        tune_nnet1@tuneres<-t1
        
        
        b1<-best(tune_nnet1)
        
        b2=unlist(unlist(b1))
        
        
        # }
        
        set.seed(seedvalue)
        class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE,tuneres=tune_nnet) #size=3,decay=0.1) #,tuneres=tune_nnet1
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        
        set.seed(seedvalue)
        #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
        class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix),size=median(b2[seq(1,length(b2),2)]),decay=median(b2[seq(2,length(b2),2)]))
        #sigma=median(unlist(best(tune_nnet)))) #) #size=3,decay=0.1)
      }else{
        
        set.seed(seedvalue)
        class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = nnetCMA,trace=FALSE) #size=3,decay=0.1) #,tuneres=tune_nnet1
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        
        set.seed(seedvalue)
        #nnetresult <- nnetCMA(X=golubX, y=golubY, learnind=learnind, size = 3, decay = 0.01)
        class_res2 <- nnetCMA(X =X, y = Y, learnind=as.numeric(learnmatrix))
        
      }
      ##saveclass_res2,file="nnetCMA.Rda")
      result_cma_list[[6]]<-class_res2
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_nnetCMA.Rda")
      confusion_matrix_list[[6]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
      
    }
    
    
    
    
    
    
    
    
    
    
    #if(best_classifier_name==classifier_names[7])
    {
      
      if(FALSE){
        s1<-ldply(tune_plr@tuneres,rbind)
        s2<-apply(s1,2,median)
        
        t1<-new("list")
        t1[[1]]<-s2
        
        tune_plr1<-tune_plr
        tune_plr1@tuneres<-t1
        
        
        b1<-best(tune_plr1)
      }
      
      set.seed(seedvalue)
      class_res<- classification(X =X, y = Y, learningsets = fiveCV10iter, classifier = plrCMA,trace=FALSE) #,tuneres=tune_plr
      
      set.seed(seedvalue)
      class_res2 <- plrCMA(X =X, y = Y, learnind=learnmatrix)
      
      ##saveclass_res2,file="plrCMA.Rda")
      result_cma_list[[7]]<-class_res2
      
      confusion_matrix_1<-table(class_res2@y,class_res2@yhat)
      
      ###saveconfusion_matrix_1,file="confusion_matrix_plrCMA.Rda")
      confusion_matrix_list[[7]]<-table(class_res2@y,class_res2@yhat)
      
      if(length(class_levels_vec)==2){
        
        testeval_res_auc<-evaluation(class_res,measure = "auc")
        ####savetesteval_res_auc,file="testeval_res_auc.Rda")
        
        test_auc<-100*(mean(testeval_res_auc@score))
        
        test_acc_mat<-c(test_acc_mat,test_auc)
        
        
        
      }else{
        
        test_acc<-evaluation(class_res)
        
        test_acc<-100*(1-mean(test_acc@score))
        test_acc_mat<-c(test_acc_mat,test_acc) #cbind(best_kfold_acc,permkfold_acc,test_acc)
        
        
      }
      
    }
    
    
    if(length(class_levels_vec)==2){
      
      
      
      acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
      
      
      if(is.na(test_data_check)==TRUE){
        colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Training accuracy(AUC)")
        
        print("Training set evaluation using selected features and the best classifier based on AUC measure")
      }else{
        colnames(acc_mat)<-c("Training kfold CV Accuracy (AUC)","Training permuted kfold CV accuracy","Score", "Test accuracy(AUC)")
        
        print("Test set evaluation using selected features and the best classifier based on AUC measure")
        
      }
      
      print(acc_mat[,c(1,4)])
      
      #rownames(acc_mat)<-best_classifier_name[1]
      
      write.table(acc_mat,file="Classification_evaluation_results_AUC.txt",sep="\t")
      
      
    }else{
      
      acc_mat<-cbind(emat1,test_acc_mat) #cbind(best_kfold_acc,permkfold_acc,test_acc)
      
      if(is.na(test_data_check)==TRUE){
        colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Training accuracy (Misclassification)")
        
        print("Training set evaluation using selected features and the best classifier based on misclassification rate measure")
      }else{
        
        colnames(acc_mat)<-c("Training kfold CV Accuracy (Misclassification)","Training permuted kfold CV Accuracy (Misclassification)","Score", "Test accuracy (Misclassification)")
        
        print("Test set evaluation using selected features and the best classifier based on misclassification rate measure")
        
        
      }
      
#      print(acc_mat[,c(1,4)])
      
      #rownames(acc_mat)<-best_classifier_name[1]
      
      write.table(acc_mat,file="Classification_evaluation_results_misclassification.txt",sep="\t")
      
    }
    
    
    ##save(acc_mat,file="acc_mat.Rda")
    
    acc_mat<-acc_mat[,-c(3)]
    
    
    mainlab<-paste("Performance evaluation using classifiers and selected features",sep="")
    
    if(output.device.type!="pdf"){
      
      temp_filename_1<-"Figures/Barplot_classification_accuracy.png"
      
      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
    }
    
    
    acc_mat1<-t(acc_mat)
    #xaxt="n",
    #
    w <- 0.1
    par(omd=c(0, 1-w, 0, 1),cex.main=0.7)
    if(length(class_levels_vec)==2){
      barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
    }else{
      
      barplot(acc_mat1[c(1,3),],main=mainlab,ylab="Classification accuracy(%)",ylim=c(50,100),xpd=FALSE,beside=TRUE,col=barplot.col.opt,cex.axis=0.7,cex.names=0.7)
      
    }
    if(FALSE){
      if(length(class_levels_vec)==2){
        axis(side=1,at=seq(1,4),labels=c("kfold CV","Permuted kfold CV","Test set","AUC"),cex.axis=cex.plots)
      }else{
        axis(side=1,at=seq(1,3),labels=c("kfold CV","Permuted kfold CV","Test set"),cex.axis=cex.plots)
      }
    }
    #col = col_vec[1:length(t1)],
    le1<-(legend(par('usr')[2], par('usr')[4], bty='n', xpd=NA,c("Training (kfold)","Test"), pch = rep(19,2), pt.cex = 0.6, title = "",cex=0.7,col=barplot.col.opt))
    
    
    if(output.device.type!="pdf"){
      
      try(dev.off(),silent=TRUE)
    }
    
    
    try(dev.off(),silent=TRUE)
    print("number of features too small.")
  }
  
}

#,"log2quantilenorm","log2transform","znormtransform","quantile_norm","lowess_norm","rangescaling","paretoscaling","mstus"

data_preprocess<-function(Xmat=NA,Ymat=NA,feature_table_file=NA,parentoutput_dir,class_labels_file=NA,num_replicates=3,feat.filt.thresh=NA,summarize.replicates=TRUE,summary.method="mean",
                          all.missing.thresh=0.1,group.missing.thresh=0.8,normalization.method="none",
                          log2transform=FALSE,medcenter=FALSE,znormtransform=FALSE,quantile_norm=FALSE,lowess_norm=FALSE,rangescaling=FALSE,paretoscaling=FALSE,mstus=FALSE,sva_norm=FALSE,TIC_norm=FALSE,eigenms_norm=FALSE,
                          madscaling=FALSE,vsn_norm=FALSE,
                          cubicspline_norm=FALSE,
                          missing.val=0,samplermindex=NA, rep.max.missing.thresh=0.5,summary.na.replacement="zeros",featselmethod=NA,pairedanalysis=FALSE,input.intensity.scale="raw",
                          create.new.folder=TRUE,log2.transform.constant=1,alphabetical.order=FALSE){
  
  
  options(warn=-1)
  
  #read file; First row is column headers
  if(is.na(Xmat)[1]==TRUE){
    data_matrix<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
  }else{
    data_matrix<-Xmat
    #rm(Xmat)
  }
  dir.create(parentoutput_dir,showWarnings = FALSE)
  setwd(parentoutput_dir)
  
  if(create.new.folder==TRUE){
    dir.create("Stage1",showWarnings = FALSE)
    setwd("Stage1")
  }else{
    
    dir.create("Tables",showWarnings = FALSE)
    setwd("Tables")
    
    
  }
  
  normalization.method=tolower(normalization.method)
  
  if(length(normalization.method)==1){
    
    valid_norm_options<-c("log2quantilenorm","log2transform","znormtransform","lowess_norm","quantile_norm","rangescaling","paretoscaling","mstus",
                          "eigenms_norm","vsn_norm","sva_norm","none","tic_norm","cubicspline_norm","mad_norm")
    
    if(normalization.method%in%valid_norm_options){
      
     # print(paste("Performing ",normalization.method," normalization",sep=""))
      
    }else{
      
      stop(paste("Invalid normalization option. Valid options: ",paste(valid_norm_options,collapse=", "),sep=""))
    }
    
    #if(FALSE)
      {
    if(normalization.method=="log2quantilenorm" || normalization.method=="log2quantnorm"){
      #print("Performing log2 transformation and quantile normalization")
      log2transform=TRUE
      quantile_norm=TRUE
      
    }else{
      if(normalization.method=="log2transform"){
        #print("Performing log2 transformation")
        log2transform=TRUE
      }else{
        if(normalization.method=="znormtransform"){
          #print("Performing autoscaling")
          znormtransform=TRUE
          
        }else{
          if(normalization.method=="quantile_norm"){
           # print("Performing quantile normalization")
            quantile_norm=TRUE
          }else{
            if(normalization.method=="lowess_norm"){
             # print("Performing Cyclic Lowess normalization")
              lowess_norm=TRUE
            }else{
              
              if(normalization.method=="rangescaling"){
               # print("Performing Range scaling")
                rangescaling=TRUE
              }else{
                if(normalization.method=="paretoscaling"){
                 # print("Performing Pareto scaling")
                  paretoscaling=TRUE
                }else{
                  
                  if(normalization.method=="mstus"){
                    
                   # print("Performing MS Total Useful Signal (MSTUS) normalization")
                    mstus=TRUE
                  }else{
                    
                    if(normalization.method=="sva_norm"){
                      
                     # print("Performing Surrogate Variable Analysis (SVA) normalization")
                      sva_norm=TRUE
                      log2transform=TRUE
                    }else{
                      if(normalization.method=="eigenms_norm"){
                       # print("Performing EigenMS normalization")
                        eigenms_norm=TRUE
                        if(input.intensity.scale=="raw"){
                          log2transform=TRUE
                        }
                        
                      }else{
                        if(normalization.method=="vsn_norm"){
                          #print("Performing variance stabilizing normalization")
                          vsn_norm=TRUE
                          
                        }else{
                          
                          if(normalization.method=="tic_norm"){
                            
                            #print("Performing totial ion intensity normalization")
                            
                            TIC_norm=TRUE
                          }else{
                            
                            if(normalization.method=="cubicspline_norm"){
                              
                              
                             # print("Cubic spline normalization")
                              
                              cubicspline_norm=TRUE
                            }else{
                              
                              
                              if(normalization.method=="mad_norm"){
                                
                              #  print("Median absolute deviation normalization")
                                madscaling=TRUE
                              }
                            }
                            
                          }
                          
                        }
                        
                        
                      }
                    }
                    
                  }
                  
                  
                }
                
              }
              
            }
            
          }
          
          
        }
      }
      
      
    }
    
    
    }
  }
  cnames<-colnames(data_matrix)
  cnames<-tolower(cnames)
  
  
  if(input.intensity.scale=="log2"){
    
    log2transform=FALSE
  }
  check_names<-grep(cnames,pattern="^name$")
  
  names_with_mz_time<-NA
  
  X<-data_matrix
  if(length(check_names)>0){
    
    if(check_names==1){
      
      check_names1<-grep(cnames,pattern="^mz$")
      check_names2<-grep(cnames,pattern="^time$")
      
      
      if(length(check_names1)<1 & length(check_names2)<1){
        mz<-seq(1.00001,nrow(X)+1,1)
        time<-seq(1.01,nrow(X)+1,1.00)
        check_ind<-gregexpr(cnames,pattern="^name$")
        check_ind<-which(check_ind>0)
        X<-as.data.frame(X)
        
        
        Name<-as.character(X[,check_ind])
        
        X<-cbind(mz,time,X[,-check_ind])
        names_with_mz_time=cbind(Name,mz,time)
        
        names_with_mz_time<-as.data.frame(names_with_mz_time)
        X<-as.data.frame(X)
        
        
        write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        
      }else{
        
        if(length(check_names1)>0 & length(check_names2)>0){
          
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          Name<-as.character(X[,check_ind])
          X<-X[,-check_ind]
          names_with_mz_time=cbind(Name,X$mz,X$time)
          colnames(names_with_mz_time)<-c("Name","mz","time")
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          X<-as.data.frame(X)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
        }
      }
      
    }
  }else{
    
    
    
    check_names1<-grep(cnames[1],pattern="^mz$")
    check_names2<-grep(cnames[2],pattern="^time$")
    if(length(check_names1)<1 || length(check_names2)<1){
      stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
    }
  }
  
  data_matrix<-X
  #print(head(data_matrix))
  
  if(is.na(all.missing.thresh)==TRUE){
    
    all.missing.thresh=(-1)
  }
  
  if(is.na(samplermindex)==FALSE){
    data_matrix<-data_matrix[,-c(samplermindex)]
  }
  
  #use only unique records
  data_matrix<-unique(data_matrix)
  
  if(is.na(missing.val)==FALSE){
    
    #print("Replacing missing values with NAs.")
    data_matrix<-replace(as.matrix(data_matrix),which(data_matrix==missing.val),NA)
  }

  data_matrix_orig<-data_matrix
  
  
  snames<-colnames(data_matrix)
  
  dir.create(parentoutput_dir,showWarnings=FALSE)
 
  fheader="transformed_log2fc_threshold_"

  
  data_m<-as.matrix(data_matrix[,-c(1:2)])
  
 
  
  #Step 2) Average replicates
  if(summarize.replicates==TRUE)
  {
    if(num_replicates>1)
    {
      
      data_m<-getSumreplicates(data_matrix,alignment.tool="apLCMS",numreplicates=num_replicates,numcluster=10,rep.max.missing.thresh=rep.max.missing.thresh,summary.method=summary.method,summary.na.replacement, missing.val=missing.val)
      
      #data_m<-round(data_m,3)
      
      data_m<-replace(data_m,which(is.na(data_m)==TRUE),missing.val)
      
      if(summary.method=="mean"){
        print("Replicate averaging done")
        filename<-paste("Rawdata_averaged.txt",sep="")
      }else{
        if(summary.method=="median"){
          print("Replicate median summarization done")
          filename<-paste("Rawdata_median_summarized.txt",sep="")
        }
        
      }
      
      data_m_prenorm<-cbind(data_matrix[,c(1:2)],data_m)
      
      write.table(data_m_prenorm, file=filename,sep="\t",row.names=FALSE)
      
      data_matrix<-cbind(data_matrix[,c(1:2)],data_m)
    
    }
  }
  
  
  data_matrix<-cbind(data_matrix[,c(1:2)],data_m)
  
  data_matrix_orig<-data_matrix
  data_subjects<-data_m
  
  ordered_labels={}
  
  num_samps_group<-new("list")
  
  
  
  if(is.na(class_labels_file)==FALSE)
  {
    
    #print("Class labels file:")
   # print(class_labels_file)
    
    data_matrix={}
    
    if(is.na(Ymat)[1]==TRUE){
      classlabels<-read.table(class_labels_file,sep="\t",header=TRUE,stringsAsFactors = FALSE,check.names = FALSE)
    }else{
      classlabels<-Ymat
    }
    
    #class_labels_sampnames<-classlabels[,1]
    #data_matrix_sampnames<-colnames(data_m)
    
    #classlabels<-classlabels[match(class_labels_sampnames,data_matrix_sampnames),]
    
    classlabels<-as.data.frame(classlabels)
    if(pairedanalysis==TRUE){
      classlabels<-classlabels[,-c(2)]
      
    }
    
    
    
    
    cnames1<-colnames(classlabels)
    cnames1[1]<-c("SampleID")
    cnames1[2]<-c("Class")
    
    
    colnames(classlabels)<-cnames1 #c("SampleID","Class")
    
    
    f1<-table(classlabels$SampleID)
    
    
    
    classlabels<-as.data.frame(classlabels)
    classlabels<-classlabels[seq(1,dim(classlabels)[1],num_replicates),]
    #print(classlabels)
    class_labels_levels<-levels(as.factor(classlabels[,2]))
    bad_rows<-which(class_labels_levels=="")
    if(length(bad_rows)>0){
      class_labels_levels<-class_labels_levels[-bad_rows]
    }
    
    for(c in 1:length(class_labels_levels))
    {
      
      if(c>1){
        data_matrix<-cbind(data_matrix,data_subjects[,which(classlabels[,2]==class_labels_levels[c])])
      }else{
        data_matrix<-data_subjects[,which(classlabels[,2]==class_labels_levels[c])]
      }
      classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
      ordered_labels<-c(ordered_labels,as.character(classlabels[classlabels_index,2]))
      num_samps_group[[c]]<-length(classlabels_index)
      
    }
    
    #colnames(data_matrix)<-as.character(ordered_labels)
    data_matrix<-cbind(data_matrix_orig[,c(1:2)],data_matrix)
    data_m<-as.matrix(data_matrix[,-c(1:2)])
    
    
  }else
  {
    if(is.na(Ymat)[1]==TRUE)
    {
      classlabels<-rep("A",dim(data_m)[2])
      classlabels<-as.data.frame(classlabels)
      ordered_labels<-classlabels
      num_samps_group[[1]]<-dim(data_m)[2]
      class_labels_levels<-c("A")
      data_m<-as.matrix(data_matrix[,-c(1:2)])
      
    }else{
      classlabels<-Ymat
      classlabels<-as.data.frame(classlabels)
      
      if(pairedanalysis==TRUE){
        classlabels<-classlabels[,-c(2)]
        
      }
      
      cnames1<-colnames(classlabels)
      cnames1[1]<-c("SampleID")
      cnames1[2]<-c("Class")
      
      colnames(classlabels)<-cnames1
      #colnames(classlabels)<-c("SampleID","Class")
      f1<-table(classlabels$SampleID)
      
      
      classlabels<-as.data.frame(classlabels)
      classlabels<-classlabels[seq(1,dim(classlabels)[1],num_replicates),]
      #print(classlabels)
      
      
      if(alphabetical.order==FALSE){
        
        classlabels[,2]<-factor(classlabels[,2],levels=unique(classlabels[,2]))
        class_labels_levels<-levels(as.factor(classlabels[,2]))
        
      }else{
          class_labels_levels<-levels(as.factor(classlabels[,2]))
      }
      
      
      bad_rows<-which(class_labels_levels=="")
      if(length(bad_rows)>0){
        class_labels_levels<-class_labels_levels[-bad_rows]
      }
      
      for(c in 1:length(class_labels_levels))
      {
       
        classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
        ordered_labels<-c(ordered_labels,as.character(classlabels[classlabels_index,2]))
        num_samps_group[[c]]<-length(classlabels_index)
        
      }
      
     
    }
    
    
    
  }
  
  # ##save(class_labels_levels,file="class_labels_levels.Rda")
  #      ##save(classlabels,file="classlabels1.Rda")
  #  ##save(num_samps_group,file="num_samps_group.Rda")
  ###save(ordered_labels,file="ordered_labels1.Rda")
  
  rnames_xmat<-colnames(data_matrix[,-c(1:2)])
  
  if(is.na(classlabels)[1]==FALSE){
    
    
    rnames_ymat<-as.character(classlabels[,1])
  }else{
    rnames_ymat<-rnames_xmat
    
  }
  
 
  
  
  if(all(rnames_xmat==rnames_ymat)==FALSE){
    
    stop("Sample names do not match between feature table and classlabels. Please try replacing spaces and - with .")
  }
  
  
 
  
  #Step 3a) Remove features if signal is not detected in at least x% of all samples
  ##################################################################################
  metab_zeros={}
  data_clean<-{}
  clean_metabs<-{}
  total_good_metabs<-{}
  
  total_sigs<-apply(data_m,1,function(x){
    if(is.na(missing.val)==FALSE){return(length(which(x!=missing.val)))
    }else{
      return(length(which(is.na(x)==FALSE)))
    }})
  
  
  useful_metabs_1<-which(total_sigs>=dim(data_m)[2])
  
  useful_metabs_2<-which(total_sigs>=dim(data_m)[2]*0.95)
  
  
  if(is.na(all.missing.thresh)==FALSE)
  {
    
    total_sig_thresh<-dim(data_m)[2]*all.missing.thresh
    
    total_good_metabs<-which(total_sigs>total_sig_thresh)
    
  }
  
  #remove bad features based on all missing values criteria
  if(length(total_good_metabs)>0){
    data_m<-data_m[total_good_metabs,]
    data_matrix<-data_matrix[total_good_metabs,]
    #print(paste("Dimension of data matrix after overall ",all.missing.thresh,"% signal threshold filtering",sep=""))
    #print(paste("Dimension of data matrix after using overall ",100*all.missing.thresh, "% signal criteria for filtering:"),sep="")
    #print(dim(data_matrix))
  }else{
    stop(paste("None of the metabolites have signal in ",all.missing.thresh*100, "% of samples",sep=""))
  }
  
  
  #Step 3b) Find features for which the signal is not detected in at least x% of samples in either of the groups
  
  
  data_m<-data_matrix[,-c(1:2)]
  
  
  
  
  if(is.na(group.missing.thresh)==FALSE)
  {
    
    
    if(length(class_labels_levels)>1){
      
      
      
      
      clean_metabs<-lapply(1:dim(data_matrix)[1],function(metab_num)
      {
        clean_metabs<-NA
        for(c in 1:length(class_labels_levels)){
          
          classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
          templabels<-classlabels[,2]
          if(is.na(missing.val)==FALSE){
            num_cursig<-length(which(data_m[metab_num,which(templabels==class_labels_levels[c])]!=missing.val))
          }else{
            num_cursig<-length(which(is.na(data_m[metab_num,which(templabels==class_labels_levels[c])])==FALSE))
          }
          sig_thresh_cur<-length(which(templabels==class_labels_levels[c]))*group.missing.thresh
          if(num_cursig>=sig_thresh_cur)
          {
            clean_metabs<-metab_num
            break   #for(i in 1:4){if(i==3){break}else{print(i)}}
            
          }
          
        }
        return(clean_metabs)
      })
    }
    else{
      
      
      
      if(length(class_labels_levels)==1){
        num_samps_group[[1]]<-num_samps_group[[1]]
        
        
        sig_thresh_groupA<-group.missing.thresh*num_samps_group[[1]]
        
        
        clean_metabs<-lapply(1:dim(data_matrix)[1],function(metab_num)
        {
          if(is.na(missing.val)==FALSE){
            num_sigsA<-length(which(data_m[metab_num,1:num_samps_group[[1]]]!=missing.val))
            
          }else{
            
            num_sigsA<-length(which(is.na(data_m[metab_num,1:num_samps_group[[1]]])==FALSE))
          }
          
          if((num_sigsA>=sig_thresh_groupA) )
          {
            #clean_metabs<-c(clean_metabs,metab_num)
            
            return(metab_num)
          }else{
            
            return(NA)
          }
          
        })
      }
      
      
    }
    
    clean_metabs<-unlist(clean_metabs)
    clean_metabs<-na.omit(clean_metabs)
    
    
    
  }else{
    
    
    
    clean_metabs<-seq(1,dim(data_matrix)[1])
  }
  ####################################################################################
  
  #Step 4) Replace missing values
  if(summarize.replicates==TRUE)
  {
    
    {
      
      if(is.na(missing.val)==FALSE){
        
        #print("Replacing missing values with NAs.")
        data_m<-replace(as.matrix(data_m),which(data_m==missing.val),NA)
      }
      
      
      if(summary.na.replacement=="zeros"){
        data_m<-replace(data_m,which(is.na(data_m)==TRUE),0)
      }else{
        if(summary.na.replacement=="halfsamplemin"){
          data_m<-apply(data_m,2,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-(min(x,na.rm=TRUE)/2)}; return(x)})
        }else{
          
          if(summary.na.replacement=="halfdatamin"){
            
            
            min_val<-min(data_m,na.rm=TRUE)*0.5
            data_m<-replace(data_m,which(is.na(data_m)==TRUE),min_val)
            
            #data_m<-apply(data_m,1,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-min(x,na.rm=TRUE)/2}; return(x)})
          }else{
            if(summary.na.replacement=="halffeaturemin"){
              data_m<-apply(data_m,1,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-(min(x,na.rm=TRUE)/2)}; return(x)})
              data_m<-t(data_m)
            }else{
              
              
              if(summary.na.replacement=="bpca"){
                library(pcaMethods)
                
                
                pc1 <- pcaMethods::pca(t(data_m), method="bpca", nPcs=3,scale="uv")
                
                data_m<-pcaMethods::completeObs(pc1)
                
                try(detach("package:pcaMethods",unload=TRUE),silent=TRUE)
                
                data_m<-t(data_m)
                
              }else{
                
                if(summary.na.replacement=="knn"){
                  suppressMessages(library(impute))
                  
                  data_m<-apply(data_m,2,as.numeric)
                  data_m<-impute.knn(data.matrix(data_m),k = 10, rowmax = 0.5, colmax = 0.8, maxp = 1500, rng.seed=362436069)
                  data_m<-data_m$data
                  
                }else{
                  
                  if(summary.na.replacement=="featuremean"){
                    data_m<-apply(data_m,1,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-(mean(x,na.rm=TRUE))}; return(x)})
                    data_m<-t(data_m)
                  }else{
                    
                    if(summary.na.replacement=="randomforest"){
                      
                      #  #save(data_m,file="data_m.Rda")
                      final_set<-RFimpute(t(data_m))
                      
                      final_set<-t(final_set$ximp)
                      final_set<-as.data.frame(final_set)
                      
                      
                    }else{
                      
                      if(summary.na.replacement=="QRILC"){
                        
                        # final_set<-QRILCimpute(data_m)
                        library(tmvtnorm)
                        final_set<-QRILCimpute(data_m) #rows: features; cols: samples
                        ##save(final_set,file="final_set.Rda")
                        final_set<-ldply(final_set,rbind) 
                        final_set<-t(final_set)               
                        final_set<-as.data.frame(final_set)
                        
                        if(length(which(final_set<0))>0){
                          final_set<-replace(as.matrix(final_set),which(final_set<0),0)
                        }
                        
                      }else{
                        data_m<-data_m
                        
                      }
                      
                      
                    }
                    
                    
                  }
                  
                }
              }
              
              
              
            }
          }
        }
        
        
      }
    }
  }else
  {
    data_m<-data_matrix[,-c(1:2)]
    
    if(is.na(missing.val)==FALSE){
      
     # print("Replacing missing values with NAs.")
      data_m<-replace(as.matrix(data_m),which(data_m==missing.val),NA)
    }
    
    if(summary.na.replacement=="zeros"){
      data_m<-replace(data_m,which(is.na(data_m)==TRUE),0)
    }else{
      if(summary.na.replacement=="halfsamplemin"){
        data_m<-apply(data_m,2,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-(min(x,na.rm=TRUE)/2)}; return(x)})
      }else{
        
        if(summary.na.replacement=="halfdatamin"){
          
          
          min_val<-min(data_m,na.rm=TRUE)*0.5
          data_m<-replace(data_m,which(is.na(data_m)==TRUE),min_val)
          
          #data_m<-apply(data_m,1,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-min(x,na.rm=TRUE)/2}; return(x)})
        }else{
          if(summary.na.replacement=="halffeaturemin"){
            data_m<-apply(data_m,1,function(x){naind<-which(is.na(x)==TRUE); if(length(naind)>0){x[naind]<-(min(x,na.rm=TRUE)/2)}; return(x)})
            data_m<-t(data_m)
          }else{
            
            if(summary.na.replacement=="bpca"){
              
              suppressMessages(library(pcaMethods))
              pc1 <- pcaMethods::pca(t(data_m), method="bpca", nPcs=3, scale="uv")
              
              data_m<-completeObs(pc1)
              data_m<-t(data_m)
            }else{
              if(summary.na.replacement=="knn"){
                suppressMessages(library(impute))
                data_m<-impute.knn(data.matrix(data_m),k = 10, rowmax = 0.5, colmax = 0.8, maxp = 1500, rng.seed=362436069)
                data_m<-data_m$data
              }else{
                
                
                if(summary.na.replacement=="randomforest"){
                  
                  final_set<-RFimpute(t(data_m))
                  
                  final_set<-t(final_set$ximp)
                  final_set<-as.data.frame(final_set)
                  
                  
                }else{
                  
                  if(summary.na.replacement=="QRILC"){
                    
                    # final_set<-QRILCimpute(data_m)
                    
                    library(tmvtnorm)
                    final_set<-QRILCimpute(data_m) #rows: features; cols: samples
                    ##save(final_set,file="final_set.Rda")
                    final_set<-ldply(final_set,rbind) 
                    final_set<-t(final_set)               
                    final_set<-as.data.frame(final_set)
                    
                    if(length(which(final_set<0))>0){
                      final_set<-replace(as.matrix(final_set),which(final_set<0),0)
                    }
                    
                  }
                  
                  
                }
                
                
                
              }
            }
            
          }
        }
      }
      
      
    }
    
  }
  
  
  
  
  #group-wise missing values
  if(length(clean_metabs)>0)
  {
    data_m<-data_m[clean_metabs,]
    data_matrix<-data_matrix[clean_metabs,]
    
   # print(paste("Dimension of data matrix after using group-wise (Factor 1) ",100*group.missing.thresh, "% signal criteria for filtering:"),sep="")
    #print(dim(data_matrix))
    
  }
  
  data_m<-as.data.frame(data_m)
  data_matrix<-as.data.frame(data_matrix)
  
  ##save(data_matrix,file="data_matrix.Rda")
  ##save(data_m,file="data_m.Rda")
  
  
  data_matrix<-cbind(data_matrix[,c(1:2)],data_m)
  write.table(data_matrix,file="pretransformation.txt",sep="\t",row.names=FALSE)
  ####################################################################
  #Step 4) Data transformation and normalization
  
  data_m_prescaling<-data_m
  
  
  
  
  
  if(TIC_norm==TRUE){
    
    ####savedata_m,file="data_m_raw.Rda")
    
    
    data_m<-do_TIC_norm(data_m)
    
  }else{
    
    if(mstus==TRUE){
      
      
      data_m<-do_MSTUS_norm(data_m,missing.val=missing.val)
      
      
      
    }
    
  }
  
  if(cubicspline_norm==TRUE){
    
    data_m<-do_cubicspline_norm(data_m)
    
  }
  if(log2transform==TRUE)
  {
    data_m<-do_log2transform_norm(data_m,log2.transform.constant)
    
    
  }
  
  
  if(eigenms_norm==TRUE){
    
    feature_id_vector<-paste(data_matrix[,c(1)],"_",data_matrix[,c(2)],sep="")
    
    
    
    if(featselmethod=="limma2wayrepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="spls2wayrepeat"){
      analysistype="twowayrepeat"
      pairedanalysis=TRUE
    }else{
      
      if(featselmethod=="limma1wayrepeat" | featselmethod=="lm1wayanovarepeat" | featselmethod=="spls1wayrepeat"){
        analysistype="onewayrepeat"
        pairedanalysis=TRUE
      }else{
        pairedanalysis=FALSE
        
      }
      
    }
    
    data_m<-do_eigenms_norm(data_m,classlabels,featselmethod,feature_id_vector,pairedanalysis=pairedanalysis)
    
  }
  
  if(sva_norm==TRUE){
    
    data_m<-do_sva_norm(data_m,classlabels,featselmethod)
    
  }
  
  
  
  
  if(quantile_norm==TRUE)
  {
    data_m<-do_quantile_norm(data_m)
    
    
  }
  
  if(vsn_norm==TRUE)
  {
    data_m<-do_vsn_norm(data_m)
    
    
    
  }
  
  if(madscaling==TRUE)
  {
    
    colmedians=apply(data_m,2,function(x){median(x,na.rm=TRUE)})
    
    Y=sweep(data_m,2,colmedians)
    mad<-apply(abs(Y),2,function(x){median(x,na.rm=TRUE)})
    const<-1 #prod(mad)^(1/length(mad))
    scale.normalized<-sweep(Y,2,const/mad,"*")+mean(colmedians,na.rm=TRUE)
    
    
    data_m<-scale.normalized
    
  }
  
  if(lowess_norm==TRUE)
  {
    data_m<-do_loess_norm(data_m)
    #print("lowess")
  }
  
  
  
  if(medcenter==TRUE)
  {
    data_m<-do_medcenter_norm(data_m)
    
    
  }
  if(znormtransform==TRUE)
  {
    data_m<-do_znormtransform_norm(data_m)
  }
  
  
  
  if(paretoscaling==TRUE){
    #pareto scaling
    data_m<-do_paretoscaling_norm(data_m)
    
  }
  
  if(rangescaling==TRUE){
    #range scaling
    data_m<-do_rangescaling_norm(data_m)
  }
  
  
  
  
  
  data_matrix<-cbind(data_matrix[,c(1:2)],data_m)
  
  print(head(data_m))
  
  save(data_matrix,data_m,file="data_obj.Rda")
  
  data_m<-as.data.frame(data_m)
  data_m<-round(data_m,5)
  
  num_rows<-dim(data_m)[1]
  num_columns<-dim(data_m)[2]
  
  #print("num rows is ")
  #print(num_rows)
  #for apLCMS:
  rnames<-paste("mzid_",seq(1,num_rows),sep="")
  rownames(data_m)=rnames
  
  rnames_xmat<-colnames(data_m)
  rnames_ymat<-classlabels[,1]
  
  check_ylabel<-regexpr(rnames_ymat[1],pattern="^[0-9]*",perl=TRUE)
  check_xlabel<-regexpr(rnames_xmat[1],pattern="^X[0-9]*",perl=TRUE)
  
  
  if(length(check_ylabel)>0 && length(check_xlabel)>0){
    if(attr(check_ylabel,"match.length")>0 && attr(check_xlabel,"match.length")>0){
      
      rnames_ymat<-paste("X",rnames_ymat,sep="")
    }
  }
  classlabels<-classlabels[match(rnames_xmat,rnames_ymat),]
  
  
  filename<-paste("ordered_classlabels_file.txt",sep="")
  write.table(classlabels, file=filename,sep="\t",row.names=FALSE)
  
  filename<-paste("Normalized_sigthreshfilt_averaged_data.txt",sep="")
  data_matrix<-cbind(data_matrix[,c(1:2)],data_m)
  write.table(data_matrix, file=filename,sep="\t",row.names=FALSE)
  data_matrix_prescaling<-cbind(data_matrix[,c(1:2)],data_m_prescaling)
  setwd("../")
  return(list(data_matrix_afternorm_scaling=data_matrix,data_matrix_prescaling=data_matrix_prescaling,classlabels=classlabels,names_with_mz_time=names_with_mz_time))
  #return(data_matrix)
}




replace_outliers<-function(cdata,replace.by.NA=FALSE,iqr.multiplier=1.5,replace.by.median=FALSE){
  data_sum<-summary(cdata,na.rm=TRUE)
  iqr_value<-data_sum[5]-data_sum[2]
  upper_limit<-data_sum[5]+iqr.multiplier*iqr_value
  lower_limit<-data_sum[2]-(iqr.multiplier*iqr_value)
  
  if(replace.by.median==TRUE){
    
 
      cdata[which(cdata<lower_limit)]<-NA
      cdata[which(cdata>upper_limit)]<-NA
    
      data_median<-median(cdata,na.rm=TRUE)
      
      cdata[which(is.na(cdata)==TRUE)]<-data_median
        
  }else{
    
        
        if(is.na(iqr_value)==FALSE){
          #if(iqr_value>0)
            {
            if(length(which(cdata<lower_limit)==TRUE)>0){
              if(replace.by.NA==TRUE){
                cdata[which(cdata<lower_limit)]<-NA
              }else{
                cdata[which(cdata<lower_limit)]<-lower_limit #min(cdata[which(cdata>lower_limit & cdata<upper_limit)],na.rm=TRUE)
                
              }
            }
            
            if(length(which(cdata>upper_limit)==TRUE)>0){
              
              if(replace.by.NA==TRUE){
                cdata[which(cdata>upper_limit)]<-NA
              }else{
                
                cdata[which(cdata>upper_limit)]<-upper_limit #max(cdata[which(cdata>lower_limit & cdata<upper_limit)],na.rm=TRUE)
              }
            }
          }
        }
    
  }
  
  return(cdata)
}

pal_jco_custom<-function (palette = c("default"), alpha = 1) 
{
  palette = match.arg(palette)
  if (alpha > 1L | alpha <= 0L) 
    stop("alpha must be in (0, 1]")
  raw_cols = c(
    "Lochmara" = "#0073C2", "Corn" = "#EFC000",
    "Gray" = "#868686", "ChestnutRose" = "#CD534C",
    "Danube" = "#7AA6DC", "RegalBlue" = "#003C67",
    "Olive" = "#8F7700", "MineShaft" = "#3B3B3B",
    "WellRead" = "#A73030", "KashmirBlue" = "#4A6990"
  )
  
  raw_cols_rgb = col2rgb(raw_cols)
  alpha_cols = rgb(raw_cols_rgb[1L, ], raw_cols_rgb[2L, ], 
                   raw_cols_rgb[3L, ], alpha = alpha * 255L, names = names(raw_cols), 
                   maxColorValue = 255L)
  manual_pal(unname(alpha_cols))
}

pal_jama_custom<-function (palette = c("default"), alpha = 1) 
{
  palette = match.arg(palette)
  if (alpha > 1L | alpha <= 0L) 
    stop("alpha must be in (0, 1]")
  raw_cols = c(
    "Limed Spruce" = "#374E55", "Anzac" = "#DF8F44",
    "Cerulean" = "#00A1D5", "Apple Blossom" = "#B24745",
    "Acapulco" = "#79AF97", "Kimberly" = "#6A6599",
    "Makara" = "#80796B"
  )
  
  raw_cols_rgb = col2rgb(raw_cols)
  alpha_cols = rgb(raw_cols_rgb[1L, ], raw_cols_rgb[2L, ], 
                   raw_cols_rgb[3L, ], alpha = alpha * 255L, names = names(raw_cols), 
                   maxColorValue = 255L)
  manual_pal(unname(alpha_cols))
}



pal_lancet_custom<-function (palette = c("lanonc"), alpha = 1) 
{
  palette = match.arg(palette)
  if (alpha > 1L | alpha <= 0L) 
    stop("alpha must be in (0, 1]")
  raw_cols = c(
    "CongressBlue" = "#00468B", "Red" = "#ED0000",
    "Apple" = "#42B540", "BondiBlue" = "#0099B4",
    "TrendyPink" = "#925E9F", "MonaLisa" = "#FDAF91",
    "Carmine" = "#AD002A", "Edward" = "#ADB6B6",
    "CodGray" = "#1B1919"
  )
  
  raw_cols_rgb = col2rgb(raw_cols)
  alpha_cols = rgb(raw_cols_rgb[1L, ], raw_cols_rgb[2L, ], 
                   raw_cols_rgb[3L, ], alpha = alpha * 255L, names = names(raw_cols), 
                   maxColorValue = 255L)
  manual_pal(unname(alpha_cols))
}

pal_npg_custom<-function (palette = c("nrc"), alpha = 1) 
{
  
  
  palette = match.arg(palette)
  if (alpha > 1L | alpha <= 0L) 
    stop("alpha must be in (0, 1]")
  raw_cols = c(
    "Cinnabar" = "#E64B35", "Shakespeare" = "#4DBBD5",
    "PersianGreen" = "#00A087", "Chambray" = "#3C5488",
    "Apricot" = "#F39B7F", "WildBlueYonder" = "#8491B4",
    "MonteCarlo" = "#91D1C2", "Monza" = "#DC0000",
    "RomanCoffee" = "#7E6148", "Sandrift" = "#B09C85"
  )
  raw_cols_rgb = col2rgb(raw_cols)
  alpha_cols = rgb(raw_cols_rgb[1L, ], raw_cols_rgb[2L, ], 
                   raw_cols_rgb[3L, ], alpha = alpha * 255L, names = names(raw_cols), 
                   maxColorValue = 255L)
  manual_pal(unname(alpha_cols))
}

pal_nejm_custom<-function (palette = c("default"), alpha = 1) 
{
  palette = match.arg(palette)
  if (alpha > 1L | alpha <= 0L) 
    stop("alpha must be in (0, 1]")
  raw_cols = c(
    "TallPoppy" = "#BC3C29", "DeepCerulean" = "#0072B5",
    "Zest" = "#E18727", "Eucalyptus" = "#20854E",
    "WildBlueYonder" = "#7876B1", "Gothic" = "#6F99AD",
    "Salomie" = "#FFDC91", "FrenchRose" = "#EE4C97"
  )
  raw_cols_rgb = col2rgb(raw_cols)
  alpha_cols = rgb(raw_cols_rgb[1L, ], raw_cols_rgb[2L, ], 
                   raw_cols_rgb[3L, ], alpha = alpha * 255L, names = names(raw_cols), 
                   maxColorValue = 255L)
  manual_pal(unname(alpha_cols))
}


get_hexcolors_for_palettes<-function(color.palette=c("custom1","wong","npg","jama","jco","lancet","nejm"),alpha.col=1){
  
  suppressMessages(library(scales))
  if(color.palette[1]=="custom1"){
    color.palette=c("#474A49","#92C147","#F79646","#8064A2","#11BCFF","#0F7BA0")
  }else{
    
    if(color.palette[1]=="wong"){
      
      #https://www.nature.com/articles/nmeth.1618
      #rgb(204,121,167,maxColorValue = 255) Output: #CC79A7
      #remove black
      color.palette=c("#E69F00","#56B4E9","#009E73","#F0E442","#0072B2","#D55E00","#CC79A7")
      
    }else{
      #color.palette=color.palette[1]
      
      if(color.palette=="npg"){
        
        # color.palette=c("#E64B35FF","#4DBBD5FF","#00A087FF","#3C5488FF","#F39B7FFF","#8491B4FF",
        #                "#91D1C2FF","#DC0000FF","#7E6148FF","#B09C85FF")
        
        colfunc=pal_npg_custom(alpha=alpha.col)
        color.palette=colfunc(10)
      }else{
        
        if(color.palette=="nejm"){
          
          colfunc=pal_nejm_custom(alpha=alpha.col)
          color.palette=colfunc(8)
          
        }else{
          if(color.palette=="jco"){
            
            colfunc=pal_jco_custom(alpha=alpha.col)
            color.palette=colfunc(10)
            
          }else{
            
            if(color.palette=="jama"){
              
              colfunc=pal_jama_custom(alpha=alpha.col)
              color.palette=colfunc(7)
              
            }else{
              if(color.palette=="lancet"){
                
                colfunc=pal_lancet_custom(alpha=alpha.col)
                color.palette=colfunc(9)
                
              }else{
                
                #color.palette <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(unique(mycl_metabs)))
                
              }
              
            }
          }
          
        }
      }
    }
  }
  return(color.palette)
}

view_color_img<-function(color.palette=c("custom1","npg","jama","jco","lancet","nejm"),alpha.col=1){
  
  color.palette=get_hexcolors_for_palettes(color.palette,alpha.col=alpha.col)
  
  show_col(color.palette,ncol=1)
  
}


#diffexp.lite
#main function for data preprocessing, differential expression, clustering, boxplots, and network analysis
diffexp.lite<-function(Xmat=NA,Ymat=NA,outloc=NA,
                  summary.na.replacement="halffeaturemin",missing.val=0,
                  all.missing.thresh=0.1,group.missing.thresh=0.8,
                  input.intensity.scale="raw",
                
                  normalization.method=c("log2transform","znormtransform","lowess_norm","log2quantilenorm","quantile_norm","rangescaling",
                                         "paretoscaling","mstus","eigenms_norm","vsn_norm","sva_norm","tic_norm","cubicspline_norm","mad_norm","none"),
                  rsd.filt.list=1,
                  pca.global.eval=TRUE,
                  
                  pairedanalysis=FALSE,featselmethod=c("limma"),
                  pvalue.thresh=0.05,fdrthresh=0.05,fdrmethod="BH",
                  foldchangethresh=0,
                  analysismode="classification",
                  pls_vip_thresh=2,optselect=TRUE,max_comp_sel=2,
                  
                  hca_type="two-way",
                   
                  timeseries.lineplots=FALSE,alphabetical.order=FALSE,
                  
                  ylab_text="Abundance",boxplot.type="ggplot",
                  
                  color.palette=c("journal","npg","nejm","jco","lancet","custom1","brewer.RdYlBu","brewer.RdBu","brewer.PuOr","brewer.PRGn","brewer.PiYG","brewer.BrBG",
                                  "brewer.Set2","brewer.Paired","brewer.Dark2","brewer.YlGnBu","brewer.YlGn","brewer.YlOrRd","brewer.YlOrBr","brewer.PuBuGn",
                                  "brewer.PuRd","brewer.PuBu",
                                  "brewer.OrRd","brewer.GnBu","brewer.BuPu","brewer.BuGn","brewer.blues","black","grey65","terrain","rainbow","heat","topo"),
                  generate.boxplots=TRUE,
                  hca.cex.legend=0.7, lme.modeltype="lme.RI",globalcor=FALSE,abs.cor.thresh=0.4,cor.fdrthresh=NA,net_legend=TRUE,evaluate.classification.accuracy=FALSE,
                  limma.contrasts.type=c("contr.pairs","contr.sum","contr.treatment"),limmadecideTests=FALSE,cex.plots=0.9,parentoutput_dir=NA, hca.labRow.value = TRUE,hca.labCol.value = TRUE,
                  vcovHC.type=c("HC0","HC3"),...)
{
  
  options(warn=-1)
  time_start<-Sys.time()
  options(warn=-1)
   
  if(is.na(evaluate.classification.accuracy)==FALSE){
    
    if(evaluate.classification.accuracy==TRUE){
        rocclassifier="svm"
    }else{
      rocclassifier=NA
      
    }
  }else{
    
    rocclassifier=NA
  }
  
  if(is.na(outloc)==TRUE){
    
    if(is.na(parentoutput_dir)==FALSE){
      outloc=parentoutput_dir
    }
  }
  dir.create(outloc,showWarnings = FALSE)
  
  setwd(outloc)
  sink(file="tmp.txt")
  
  suppressMessages(require(tidyverse))
  suppressMessages(require(tidyr))
  suppressMessages(require(MASS))
  suppressMessages(require(RColorBrewer))
  suppressMessages(require(lattice))
  suppressMessages(require(tidyverse))
  if(globalcor==TRUE){
    suppressMessages(require(igraph))
    suppressMessages(require(fdrtool))
  }
  if(is.na(rocclassifier)==FALSE){
    suppressMessages(require(e1071))
    suppressMessages(require(ROCR))
    suppressMessages(require(pROC))
    
  }
  suppressMessages(require(parallel))
  num_nodes=detectCores()*0.5
  
  if(length(which(featselmethod%in%c("limma","limma1way","limma2way","limma2wayrepeat","limma1wayrepeat")))>0){
    
    suppressMessages(require(limma))
  }else{
    if(length(which(featselmethod%in%c("pls","spls","spls2way","spls2wayrepeat","spls1wayrepeat","o1pls","o2pls")))>0){
      
      suppressMessages(require(mixOmics))
    }else{
      
      if(length(which(featselmethod%in%c("lm1wayanova","lm2wayanova","lm2wayanovarepeat","lm1wayanovarepeat","lm1wayrepeat")))>0){
        
        suppressMessages(require(nlme))
        suppressMessages(require(multcomp))
        suppressMessages(require(lsmeans))
        
      }else{
        
        if(length(which(featselmethod%in%c("RF","rf")))>0){
          suppressMessages(require(Boruta))
          
        }else{
          if(length(which(featselmethod%in%c("svmrfe","rfesvm")))>0){
            suppressMessages(require(e1071))
          }else{
            
            if(length(which(featselmethod%in%c("pamr")))>0){
              suppressMessages(require(pamr))
            }else{
              
              if(length(which(featselmethod%in%c("MARS")))>0){
                suppressMessages(require(earth))
              }
            }
          }
          
        }
      }
    }
    
  }
  try(sink(file=NULL),silent=TRUE)
  
  try(unlink("tmp.txt"),silent=TRUE)
  #print(paste("g is ",group.missing.thresh,sep=""))
  
  #if (Sys.getenv("RSTUDIO") == "1" && !nzchar(Sys.getenv("RSTUDIO_TERM")) && 
  #   Sys.info()["sysname"] == "Darwin" && getRversion() >= "4.0.0") {
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  #}
  pvalue.dist.plot=FALSE
  lme.modeltype=lme.modeltype[1]
  
  if(lme.modeltype=="RI"){
    
    lme.modeltype="lme.RI"
  }else{
    if(lme.modeltype=="RIRS"){
      
      lme.modeltype="lme.RIRS"
    }
    
  }
  kfold=10
  output.device.type="png"
  feature_table_file=NA
  parentoutput_dir=outloc
  class_labels_file=NA
  num_replicates=1
  summarize.replicates=TRUE
  summary.method="mean"
  rep.max.missing.thresh=0.3
  
  log2transform=FALSE
  medcenter=FALSE
  znormtransform=FALSE
  quantile_norm=FALSE
  lowess_norm=FALSE
  madscaling=FALSE
  TIC_norm=FALSE
  rangescaling=FALSE
  mstus=FALSE
  paretoscaling=FALSE
  sva_norm=FALSE
  eigenms_norm=FALSE
  vsn_norm=FALSE
  normalization.method=normalization.method[1]
  cor.method="spearman"
  networktype=c("complete","GGM")
  
 # cor.fdrthresh=fdrthresh
  #kfold=10
  pred.eval.method="BER"
  
  target.metab.file=NA
  target.mzmatch.diff=10
  target.rtmatch.diff=NA
  max.cor.num=100
  numtrees=20000
  
  net_node_colors=c("green","red")
  
  network.label.cex=0.6
  svm_kernel="radial"
  
  pca.stage2.eval=FALSE
  scoreplot_legend=TRUE
 
  rocfeatlist=seq(1,5,1)
  rocfeatincrement=TRUE
  #rocclassifier=NA
  
  wgcnarsdthresh=20
  WGCNAmodules=FALSE
  

  
  max_varsel=100
  pls_ncomp=5
 
  saveRda=FALSE
  legendlocation="topleft"
  pcacenter=TRUE
  pcascale=TRUE
  pca.cex.val=6
  
  pca.ellipse=FALSE
  ellipse.conf.level=0.95
  pls.permut.count=NA
  svm.acc.tolerance=5
  
  pls.vip.selection="max"
  globalclustering=FALSE
  
  plots.res=600
  plots.width=10
  plots.height=8
  plots.type="cairo"
  xlab_text=NA
  
  
  pamr.threshold.select.max=FALSE
  aggregation.method="RankAggreg"
  aggregation.max.iter=1000
  mars.gcv.thresh=10
  
  error.bar=TRUE
  
 
  barplot.xaxis="Factor1"
  lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash")
  match_class_dist=TRUE
  
  kegg_species_code="hsa"
  database="pathway"
  reference_set=NA
  target.data.annot=NA
  add.pvalues=FALSE
  add.jitter=FALSE
  fcs.permutation.type=1
  fcs.method="zscore"
  fcs.min.hits=2
  names_with_mz_time=NA
  
  samplermindex=NA
  differential.network.analysis=FALSE
  degree.centrality.method="hybrid.DEC"
  log2.transform.constant=1
  balance.classes=FALSE
  balance.classes.sizefactor=10
  balance.classes.seed=1
  cv.perm.count=NA
  multiple.figures.perpanel=FALSE
  
  heatmap.col.opt="brewer.RdBu"
  manhattanplot.col.opt=c("red3","darkblue")
  
  modeltype=lme.modeltype[1]
  balance.classes.method="ROSE"
  
  alpha.col=1
  similarity.matrix="correlation"
  outlier.method=NA #c("pcout","sumtukey","pcatukey","pcachisq")
  removeRda=TRUE
  
  plot_DiNa_graph=FALSE
  
  
 # hca.labRow.value = TRUE
#  hca.labCol.value = TRUE
  plot.boxplots.raw=FALSE
  vcovHC.type=vcovHC.type[1] #"HC3"
  ggplot.type1=TRUE
  facet.nrow=1
  pairwise.correlation.analysis=globalcor
  


  match_col.opt=match(color.palette,c("journal","npg","nejm","jco","lancet","custom1","brewer.RdYlBu","brewer.RdBu","brewer.PuOr","brewer.PRGn","brewer.PiYG","brewer.BrBG",
                                        "brewer.Set2","brewer.Paired","brewer.Dark2","brewer.YlGnBu","brewer.YlGn","brewer.YlOrRd","brewer.YlOrBr","brewer.PuBuGn",
                                        "brewer.PuRd","brewer.PuBu",
                                        "brewer.OrRd","brewer.GnBu","brewer.BuPu","brewer.BuGn","brewer.blues","black","grey65","terrain","rainbow","heat","topo"))
  
  
  match_col.opt=length(which(is.na(match_col.opt)==TRUE))
  
  #all colors match
  if(length(match_col.opt)<1){
    
    color.palette=color.palette[1]
  }else{
    
    if(length(grep(color.palette,pattern="brewer."))>1){
      
      color.palette=color.palette[1]
    }
  }
  
  color.palette=get_hexcolors_for_palettes(color.palette=color.palette,alpha.col=alpha.col[1])
  
  
  limma.contrasts.type=limma.contrasts.type[1]
  outlier.method=outlier.method[1]
  lineplot.lty.option=lineplot.lty.option[1]
  networktype=networktype[1]
  differential.network.analysis.method=c("degree.centrality")
  differential.network.analysis.method=differential.network.analysis.method[1] #"st5.differential.correlation"
  
  boxplot.col.opt=color.palette
  barplot.col.opt=color.palette
  sample.col.opt=color.palette
  lineplot.col.opt=color.palette
  scatterplot.col.opt=color.palette
  individualsampleplot.col.opt=color.palette
  
  if(length(grep(heatmap.col.opt,pattern = "brewer."))>0){
    
    heatmap.col.opt<-gsub(heatmap.col.opt,pattern="brewer.",replacement="")
  }
  
  labRow.value=hca.labRow.value
  labCol.value=hca.labCol.value
  
  if(is.na(parentoutput_dir)==TRUE){
    
    parentoutput_dir=getwd()
  }
  
  if(is.na(Xmat)[1]==FALSE){
    
    feature_table_file=NA
  }
  if(is.na(Ymat)[1]==FALSE){
    
    class_labels_file=NA
  }
  if(differential.network.analysis==TRUE){
    
    
    
    degree_rank_method="diffrank"
    
  }else{
    degree_rank_method="none"
  }
  
  
  
  feat.filt.thresh=NA
  feat_weight=1
  samplermindex=NA
  #pcacenter=TRUE
  #pcascale=TRUE
  alphacol=0.3
  
  
  # print(parentoutput_dir)
  dir.create(parentoutput_dir,showWarnings = FALSE)
  
  
  # print(is(group.missing.thresh<0.8))
  
  if(is.na(group.missing.thresh)==FALSE){
    if(group.missing.thresh<0.8){
      
      
      
      
    }
  }
  options(warn=-1)
  
  if(input.intensity.scale=="raw" || input.intensity.scale=="log2"){
    
   # print("##################################################################################")
    #print("Note 1: The order of samples should be the same in the feature table and classlabels files")
    #print(paste("Note 2: Treating input intensities as ",input.intensity.scale," values",sep=""))
    
  }else{
    
    stop("Input intensities should either be at raw or log2 scale")
  }
  
  suppressMessages(suppressWarnings(try(sink(file=NULL),silent=TRUE)))
  #suppressMessages(suppressWarnings(sink(file=NULL)))
  x<-date()
  x<-strsplit(x,split=" ")
  
  #x<-gsub(x,pattern=":",replacement="_")
  targeted_feat_raw<-{}
  logistic_reg=FALSE
  x1<-unlist(x)
  x1<-gsub(x1,pattern=":",replacement="_")
  #fname<-paste(x1[2:5],collapse="_")
  
  #fname<-paste(x1[2:3],x1[5],x1[4],collapse="_")
  
  fname<-paste(x1[2:3],collapse="")
  
  #fname<-paste(fname,x1[6],sep="")
  x1[4]<-gsub(x1[4],pattern=":",replacement="_")
  fname<-paste(fname,x1[5],sep="")
  fname<-paste(fname,x1[4],sep="_")
  
  
  suppressWarnings(dir.create(parentoutput_dir,showWarnings = FALSE))
  setwd(parentoutput_dir)
  
  
  #fname<-paste(parentoutput_dir,"/Log",fname,".txt",sep="")
  
  fname<-paste(parentoutput_dir,"/Log.txt",sep="")
  
  
  if(is.na(foldchangethresh)==FALSE){
    if(log2transform==TRUE && znormtransform==TRUE){
      
      stop("Both log2transform and znormtransform can not be true if foldchangethresh is not equal to NA.")
    }
  }
  
  if(featselmethod[1]=="limma2way")
  {
    
    #print("Note 3: lm2wayanova option is recommended for greater than 2x2 designs and this includes post-hoc comparisons")
    
    
  }
  
  
  if(featselmethod[1]=="lm1wayanovarepeat" | featselmethod[1]=="spls1wayrepeat" | featselmethod[1]=="limma1wayrepeat")
  {
   # print("Note 3: Class labels format should be: Sample ID, Subject, Time. lm1wayanovarepeat is based on the nlme::lme() function with post-hoc Tukey HSD test.")
  }else{
    
    if(featselmethod[1]=="lm2wayanovarepeat" | featselmethod[1]=="spls2wayrepeat" | featselmethod[1]=="limma2wayrepeat")
    {
    #  print("Note 3: Class labels format should be: Sample ID, Subject, Factor, Time. lm2wayanovarepeat is based on the nlme::lme() funciton with post-hoc Tukey HSD test. ")
    }
    
  }
  
  
  #print("##############################Starting processing now################################")
  #print(paste("**Program is running. Please check the logfile for runtime status: ",fname,"**",sep=""))
  
  cat("","\n")
  cat("Starting processing...")
  cat("","\n")
  
  fname_params<-paste(parentoutput_dir,"/InputParameters.csv",sep="")
  #sink(fname_params)
  # ###savelist=ls(),file="cur.Rda")
  c1={}
  c2={}
  #c2<-rbind(c2,feature_table_file)
  c1<-rbind(c1,"parentoutput_dir:")
  c2<-rbind(c2,parentoutput_dir)

  c1<-rbind(c1,"summary.na.replacement:")
  c2<-rbind(c2,summary.na.replacement)

  c1<-rbind(c1,"all.missing.thresh:")
  c2<-rbind(c2,all.missing.thresh)
  c1<-rbind(c1,"group.missing.thresh:")
  c2<-rbind(c2,group.missing.thresh)
  c1<-rbind(c1,"input.intensity.scale:")
  c2<-rbind(c2,input.intensity.scale)
  
  c1<-rbind(c1,"normalization.method:")
  c2<-rbind(c2,normalization.method[1])
  

  
  c1<-rbind(c1,"rsd.filt.list:")
  c2<-rbind(c2,rsd.filt.list)
  c1<-rbind(c1,"pairedanalysis:")
  c2<-rbind(c2,pairedanalysis)
  c1<-rbind(c1,"featselmethod:")
  
  c2<-rbind(c2,paste(featselmethod,collapse=";"))
  
  c1<-rbind(c1,"pvalue.thresh:")
  c2<-rbind(c2,pvalue.thresh)
  c1<-rbind(c1,"fdrthresh:")
  c2<-rbind(c2,fdrthresh)
  c1<-rbind(c1,"fdrmethod:")
  c2<-rbind(c2,fdrmethod)
  c1<-rbind(c1,"cor.method:")
  c2<-rbind(c2,cor.method)
  c1<-rbind(c1,"abs.cor.thresh:")
  c2<-rbind(c2,abs.cor.thresh)
  c1<-rbind(c1,"cor.fdrthresh:")
  c2<-rbind(c2,cor.fdrthresh)

  c1<-rbind(c1,"globalcor:")
  c2<-rbind(c2,globalcor)

  c1<-rbind(c1,"missing.val:")
  c2<-rbind(c2,missing.val)
 
  c1<-rbind(c1,"analysismode:")
  c2<-rbind(c2,analysismode)
  c1<-rbind(c1,"net_node_colors:")
  c2<-rbind(c2,net_node_colors)
  c1<-rbind(c1,"net_legend:")
  c2<-rbind(c2,net_legend)

  c1<-rbind(c1,"pls_vip_thresh:")
  c2<-rbind(c2,pls_vip_thresh)

 
  c1<-rbind(c1,"pls_ncomp:")
  c2<-rbind(c2,pls_ncomp)
  
  c1<-rbind(c1,"foldchangethresh:")
  c2<-rbind(c2,foldchangethresh)
  
 # c1<-rbind(c1,"optselect:")
  #c2<-rbind(c2,optselect)
  
  c1<-rbind(c1,"max_comp_sel:")
  c2<-rbind(c2,max_comp_sel)

  c1<-rbind(c1,"limmadecideTests:")
  c2<-rbind(c2,limmadecideTests)
  c1<-rbind(c1,"pls.vip.selection:")
  c2<-rbind(c2,pls.vip.selection)

  c1<-rbind(c1,"timeseries.lineplots")
  c2<-rbind(c2,timeseries.lineplots)
  
  c1<-rbind(c1,"alphabetical.order")
  c2<-rbind(c2,alphabetical.order)
  
  
  
  c1<-rbind(c1,"ylab_text")
  c2<-rbind(c2,ylab_text)
  
  
  c1<-rbind(c1,"boxplot.type")
  c2<-rbind(c2,boxplot.type)
  
  
  c1<-rbind(c1,"color.palette:")
  c2<-rbind(c2,paste(color.palette,collapse=";"))
  
  
 
  c1<-rbind(c1,"limma.contrasts.type")
  c2<-rbind(c2,limma.contrasts.type)
  
  c1<-rbind(c1,"hca.cex.legend")
  c2<-rbind(c2,hca.cex.legend)
  
 
  c1<-cbind(c1,c2)
  c1<-as.data.frame(c1)
  
  colnames(c1)<-c("InputParameter:","Value")
  write.csv(c1,file=fname_params,row.names=FALSE)
  rm(c1)
  rm(c2)
  
  
  
 # sink(fname)
#  print(sessionInfo())
  analysistype="oneway"
  
  if(featselmethod=="limma2way" | featselmethod=="lm2wayanova" | featselmethod=="spls2way"){
    analysistype="twowayanova"
  }else{
    
    if(featselmethod=="limma2wayrepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="spls2wayrepeat"){
      analysistype="twowayrepeat"
      pairedanalysis=TRUE
    }else{
      
      if(featselmethod=="limma1wayrepeat" | featselmethod=="lm1wayanovarepeat" | featselmethod=="spls1wayrepeat"){
        analysistype="onewayrepeat"
        pairedanalysis=TRUE
      }
      
    }
    
  }
  
  if(length(featselmethod)>1){
    
    if(length(rsd.filt.list)>1){
      
     # print("Warning: only one RSD threshold allowed for multiple feature selection methods. Only the first RSD threshold will be used.")
      rsd.filt.list=rsd.filt.list[1]
      
    }
    
    consensus_res<-{}
    diffexp.res<-new("list")
    consensus_analysis=TRUE
    ranked_list<-{}
    common_feats<-{}
    
    pass_method_list<-{}
    
    for(i in 1:length(featselmethod))
    {
      
      if(featselmethod[i]=="rfesvm" && analysismode=="regression"){
        try(dev.off(),silent=TRUE)
        next;
      }
      
      outloc<-paste(parentoutput_dir,featselmethod[i],sep="/")
      
      #suppressWarnings(
      diffexp.res[[i]]<-diffexp.child(Xmat,Ymat,feature_table_file,parentoutput_dir,class_labels_file,num_replicates,feat.filt.thresh,summarize.replicates,summary.method,summary.na.replacement,missing.val,rep.max.missing.thresh,
                                      all.missing.thresh,group.missing.thresh,input.intensity.scale,
                                      log2transform,medcenter,znormtransform,quantile_norm,lowess_norm,madscaling,TIC_norm,rangescaling,mstus,paretoscaling,sva_norm,eigenms_norm,vsn_norm,
                                      normalization.method[1],rsd.filt.list,
                                      pairedanalysis,featselmethod[i],fdrthresh,fdrmethod,cor.method,networktype,network.label.cex,abs.cor.thresh,cor.fdrthresh,kfold,pred.eval.method,feat_weight,globalcor,
                                      target.metab.file,target.mzmatch.diff,target.rtmatch.diff,max.cor.num,samplermindex,pcacenter,pcascale,
                                      numtrees,analysismode,net_node_colors,net_legend,svm_kernel,heatmap.col.opt,manhattanplot.col.opt,boxplot.col.opt,barplot.col.opt,sample.col.opt,lineplot.col.opt, scatterplot.col.opt,hca_type,alphacol,pls_vip_thresh,num_nodes,max_varsel,
                                      pls_ncomp=pls_ncomp,pca.stage2.eval=pca.stage2.eval,scoreplot_legend=scoreplot_legend,pca.global.eval=pca.global.eval,rocfeatlist=rocfeatlist,rocfeatincrement=rocfeatincrement,rocclassifier=rocclassifier,foldchangethresh=foldchangethresh,wgcnarsdthresh=wgcnarsdthresh,WGCNAmodules=WGCNAmodules,
                                      optselect=optselect,max_comp_sel=max_comp_sel,saveRda=saveRda,legendlocation=legendlocation,degree_rank_method=degree_rank_method,pca.cex.val=pca.cex.val,pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,pls.permut.count=pls.permut.count,
                                      svm.acc.tolerance=svm.acc.tolerance,limmadecideTests=limmadecideTests,pls.vip.selection=pls.vip.selection,globalclustering=globalclustering,plots.res=plots.res,plots.width=plots.width,plots.height=plots.height,plots.type=plots.type,
                                      output.device.type=output.device.type,pvalue.thresh,individualsampleplot.col.opt,pamr.threshold.select.max,mars.gcv.thresh,error.bar,cex.plots,modeltype,barplot.xaxis,lineplot.lty.option,match_class_dist=match_class_dist,
                                      timeseries.lineplots=timeseries.lineplots,alphabetical.order=alphabetical.order,kegg_species_code=kegg_species_code,database=database,reference_set=reference_set,target.data.annot=target.data.annot,add.pvalues=add.pvalues,
                                      add.jitter=add.jitter,fcs.permutation.type=fcs.permutation.type,fcs.method=fcs.method,fcs.min.hits=fcs.min.hits,names_with_mz_time=names_with_mz_time,ylab_text=ylab_text,xlab_text=xlab_text,boxplot.type=boxplot.type,
                                      degree.centrality.method=degree.centrality.method,log2.transform.constant=log2.transform.constant,
                                      balance.classes=balance.classes,balance.classes.sizefactor=balance.classes.sizefactor,
                                      balance.classes.method=balance.classes.method,balance.classes.seed=balance.classes.seed,
                                      cv.perm.count=cv.perm.count,
                                      multiple.figures.perpanel=multiple.figures.perpanel,labRow.value = labRow.value, 
                                      labCol.value = labCol.value,alpha.col=alpha.col,
                                      similarity.matrix=similarity.matrix,outlier.method=outlier.method[1],removeRda=removeRda,color.palette=color.palette,plot_DiNa_graph=plot_DiNa_graph,
                                      limma.contrasts.type=limma.contrasts.type,hca.cex.legend=hca.cex.legend,
                                      differential.network.analysis.method=differential.network.analysis.method,plot.boxplots.raw=plot.boxplots.raw,vcovHC.type=vcovHC.type,
                                      ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                                      pairwise.correlation.analysis=pairwise.correlation.analysis,generate.boxplots=generate.boxplots,pvalue.dist.plot=pvalue.dist.plot)
      #,silent=TRUE)
      
      
      
      
      if(is(diffexp.res[[i]],"try-error")){
        print(paste("Error processing option ",featselmethod[i],sep=""))
        print(paste("Error message: ",diffexp.res[[i]],sep=""))
        
        #diffexp.res[[i]]<-
        
        
        
      }else{
        pass_method_list<-c(pass_method_list,i)
        #print(paste("Done with ",featselmethod[i],sep=""))
      }
      
      fname_del<-paste(outloc,"/Rplots.pdf",sep="")
      try(unlink(fname_del),silent=TRUE)
      
    }
    
    ##save(diffexp.res,featselmethod,file="diffexp.res.Rda")
    alphacol=alpha.col
    
    max_num_feats<-max(c(unlist(lapply(1:length(diffexp.res),function(j){
      
      if(j%in%pass_method_list){
        return(dim(diffexp.res[[j]]$all_metabs)[1])
      }
      
    }
    ))),0)
    
    if(max_num_feats<1){
      
      return("No features selected.")
    }
    
  
    
    ###save(sel_feat_matrix,file="feature.selection.different.methods.Rda")
    ###save(ranked_list,file="ranked_list.Rda")

    
 {
      
      
      
      time_end<-Sys.time()
      
      time_taken_panda<-round(time_end-time_start,2)
      
      
      cat(paste("**Program ended successfully in ",time_taken_panda," ",units(time_taken_panda),".**", sep=""),sep="\n")
      cat("",sep="\n")
    #  cat("Description of output folders:",sep="\n")
      
      
      
      s1<-"Stage 1 results: Includes raw (original) and preprocessed (filtered,normalized, and imputed) data tables"
      s2<-"Stage 2 results: Feature selection & evaluation results for each method. The following files and folders are generated for each method:: A) *selected.features.final.txt file includes final table of selected features; B) Figures subfolder: includes Manhattan plots, boxplots, HCA heatmap, and other figures, and C) Tables sub-folder: includes data files with feature selection results for all features, PCA (and PLS) scores and loadings, HCA clusters, k-fold CV results, and other tables.."
      
      sm<-rbind(s1,s2)
      
      #cat(sm,sep="\n")
      #cat("",sep="\n")
      #cat("##############################END################################",sep="\n")
      
      setwd(parentoutput_dir)
      write.table(sm,file="ReadMe.txt",sep="\t",row.names=FALSE)
      options(warn=0)
      return(list("individual.featsel.res"=diffexp.res))
      
    }
    
    
    
  }else{
    
    # suppressWarnings(
    diffexp.res<-diffexp.child(Xmat,Ymat,feature_table_file,parentoutput_dir,class_labels_file,num_replicates,feat.filt.thresh,summarize.replicates,summary.method,summary.na.replacement,missing.val,rep.max.missing.thresh,
                               all.missing.thresh,group.missing.thresh,input.intensity.scale,
                               log2transform,medcenter,znormtransform,quantile_norm,lowess_norm,madscaling,TIC_norm,rangescaling,mstus,paretoscaling,sva_norm,eigenms_norm,vsn_norm,
                               normalization.method,rsd.filt.list,
                               pairedanalysis,featselmethod,fdrthresh,fdrmethod,cor.method,networktype,network.label.cex,abs.cor.thresh,cor.fdrthresh,kfold,pred.eval.method,feat_weight,globalcor,
                               target.metab.file,target.mzmatch.diff,target.rtmatch.diff,max.cor.num,samplermindex,pcacenter,pcascale,
                               numtrees,analysismode,net_node_colors,net_legend,svm_kernel,heatmap.col.opt,manhattanplot.col.opt,boxplot.col.opt,barplot.col.opt,sample.col.opt,lineplot.col.opt,scatterplot.col.opt,hca_type,alphacol,pls_vip_thresh,num_nodes,max_varsel,
                               pls_ncomp,pca.stage2.eval,scoreplot_legend,pca.global.eval,rocfeatlist,rocfeatincrement,rocclassifier=rocclassifier,foldchangethresh,wgcnarsdthresh,WGCNAmodules,
                               optselect,max_comp_sel,saveRda,legendlocation,degree_rank_method,pca.cex.val,pca.ellipse,ellipse.conf.level,pls.permut.count,svm.acc.tolerance,limmadecideTests,pls.vip.selection,globalclustering,plots.res,plots.width,plots.height,
                               plots.type,output.device.type,pvalue.thresh,individualsampleplot.col.opt,pamr.threshold.select.max,mars.gcv.thresh,error.bar,cex.plots,modeltype,barplot.xaxis,lineplot.lty.option,match_class_dist=match_class_dist,
                               timeseries.lineplots=timeseries.lineplots,alphabetical.order=alphabetical.order,kegg_species_code=kegg_species_code,database=database,reference_set=reference_set,target.data.annot=target.data.annot,add.pvalues=add.pvalues,
                               add.jitter=add.jitter,fcs.permutation.type=fcs.permutation.type,
                               fcs.method=fcs.method,fcs.min.hits=fcs.min.hits,
                               names_with_mz_time=names_with_mz_time,ylab_text=ylab_text,
                               xlab_text=xlab_text,boxplot.type=boxplot.type,
                               degree.centrality.method=degree.centrality.method,
                               log2.transform.constant=log2.transform.constant,
                               balance.classes=balance.classes,
                               balance.classes.sizefactor=balance.classes.sizefactor,
                               balance.classes.method=balance.classes.method,
                               balance.classes.seed=balance.classes.seed,cv.perm.count=cv.perm.count,
                               multiple.figures.perpanel=multiple.figures.perpanel,
                               labRow.value = labRow.value, labCol.value = labCol.value,alpha.col=alpha.col,
                               similarity.matrix=similarity.matrix,outlier.method=outlier.method[1],removeRda=removeRda,color.palette=color.palette,
                               plot_DiNa_graph=plot_DiNa_graph,limma.contrasts.type=limma.contrasts.type,hca.cex.legend=hca.cex.legend,
                               differential.network.analysis.method=differential.network.analysis.method,plot.boxplots.raw=plot.boxplots.raw,
                               vcovHC.type=vcovHC.type,ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                               pairwise.correlation.analysis=pairwise.correlation.analysis,generate.boxplots=generate.boxplots,pvalue.dist.plot=pvalue.dist.plot) #,silent=TRUE)
    #)
    
    time_end<-Sys.time()
    
    time_taken_panda<-round(time_end-time_start,2)
    
    
 
   # print(paste("**Program ended successfully in ",time_taken_panda," ",units(time_taken_panda),".**", sep=""))
    
   
    #print("##############################END################################")
    cat(paste("**Program ended successfully in ",time_taken_panda," ",units(time_taken_panda),".**", sep=""),sep="\n")
    cat("",sep="\n")
    
    
    s1<-"Stage 1 results: Includes raw (original) and preprocessed (filtered,normalized, and imputed) data tables"
    s2<-"Stage 2 results: Feature selection & evaluation results for each method. The following files and folders are generated for each method:: A) *selected.features.final.txt file includes final table of selected features; B) Figures subfolder: includes Manhattan plots, boxplots, HCA heatmap, and other figures, and C) Tables sub-folder: includes data files with feature selection results for all features, PCA (and PLS) scores and loadings, HCA clusters, k-fold CV results, and other tables.."
    
    sm<-rbind(s1,s2)
   
   # cat("Description of output folders:",sep="\n")
    
    
    
    #s1<-"Stage 1 results: Includes raw (original) and preprocessed (filtered,normalized, and imputed) data tables"
    #s2<-"Stage 2 results: Feature selection & evaluation results for each method. The following files and folders are generated for each method:: A) *selected.features.final.txt file includes final table of selected features; B) Figures subfolder: includes Manhattan plots, boxplots, HCA heatmap, and other figures, and C) Tables sub-folder: includes data files with feature selection results for all features, PCA (and PLS) scores and loadings, HCA clusters, k-fold CV results, and other tables.."
    
    #sm<-rbind(s1,s2)
    
  #  cat(sm,sep="\n")
   # cat("",sep="\n")
  #  cat("##############################END################################",sep="\n")
    
    
    setwd(parentoutput_dir)
    write.table(sm,file="ReadMe.txt",sep="\t",row.names=FALSE)
    options(warn=0)
    return(diffexp.res)
    
    
  }
}



#######end diffexp.lite


#main function for data preprocessing, differential expression, clustering, boxplots, and network analysis
diffexp<-function(Xmat=NA,Ymat=NA,feature_table_file,parentoutput_dir=NA,class_labels_file,num_replicates=1,summarize.replicates=TRUE,summary.method="mean",
                  summary.na.replacement="zeros",missing.val=0,rep.max.missing.thresh=0.3,
                  all.missing.thresh=0.1,group.missing.thresh=0.7,input.intensity.scale="raw",
                  log2transform=FALSE,medcenter=FALSE,znormtransform=FALSE,quantile_norm=FALSE,lowess_norm=FALSE,madscaling=FALSE,TIC_norm=FALSE,rangescaling=FALSE,mstus=FALSE,paretoscaling=FALSE,sva_norm=FALSE,eigenms_norm=FALSE,vsn_norm=FALSE,
                  normalization.method=c("log2transform","znormtransform","log2quantilenorm","lowess_norm","quantile_norm","rangescaling",
                                                                       "paretoscaling","mstus","eigenms_norm","vsn_norm","sva_norm","tic_norm","cubicspline_norm","mad_norm","none"),rsd.filt.list=1,
                  pairedanalysis=FALSE,featselmethod=c("limma","pls"),fdrthresh=0.05,fdrmethod="BH",
                  cor.method="spearman",networktype=c("complete","GGM"),
                  abs.cor.thresh=0.4,cor.fdrthresh=0.05,kfold=10,
                  pred.eval.method="BER",globalcor=TRUE,
                  target.metab.file=NA,target.mzmatch.diff=10,target.rtmatch.diff=NA,max.cor.num=100, 
                  numtrees=20000,analysismode="classification",net_node_colors=c("green","red"), net_legend=TRUE,network.label.cex=0.6,
                  svm_kernel="radial",
                  heatmap.col.opt="brewer.RdBu",
                  manhattanplot.col.opt=c("darkblue","red3"),
                  hca_type="two-way",pls_vip_thresh=2,max_varsel=100,
                  pls_ncomp=5,pca.stage2.eval=FALSE,scoreplot_legend=TRUE,pca.global.eval=TRUE,rocfeatlist=seq(1,5,1),rocfeatincrement=TRUE,rocclassifier="svm",
                  foldchangethresh=1,wgcnarsdthresh=20,WGCNAmodules=FALSE,
                  optselect=TRUE,max_comp_sel=2,saveRda=FALSE,legendlocation="topleft",pcacenter=TRUE,pcascale=TRUE,pca.cex.val=6,
                  pca.ellipse=FALSE,ellipse.conf.level=0.95,pls.permut.count=NA,svm.acc.tolerance=5,limmadecideTests=FALSE,pls.vip.selection="max",globalclustering=FALSE,
                  plots.res=600,plots.width=10,plots.height=8,plots.type="cairo",
                  output.device.type="pdf",pvalue.thresh=0.05,pamr.threshold.select.max=FALSE,aggregation.method="RankAggreg",aggregation.max.iter=1000,
                  mars.gcv.thresh=10,
                  error.bar=TRUE,cex.plots=1,lme.modeltype="lme.RI",
                  barplot.xaxis="Factor1",lineplot.lty.option=c("solid", "dashed", "dotted", "dotdash", "longdash", "twodash"),
                  match_class_dist=TRUE,timeseries.lineplots=FALSE,alphabetical.order=FALSE,
                  kegg_species_code="hsa",database="pathway",reference_set=NA,target.data.annot=NA,add.pvalues=FALSE,add.jitter=FALSE,fcs.permutation.type=1,
                  fcs.method="zscore",fcs.min.hits=2,names_with_mz_time=NA,
                  ylab_text="Abundance",xlab_text=NA,boxplot.type="ggplot",
                  samplermindex=NA,differential.network.analysis=FALSE,
                  degree.centrality.method="hybrid.DEC",log2.transform.constant=1,
                  balance.classes=FALSE,balance.classes.sizefactor=10,
                  balance.classes.seed=1,cv.perm.count=NA,multiple.figures.perpanel=FALSE,
                  hca.labRow.value = FALSE, hca.labCol.value = FALSE,
                  alpha.col=1,similarity.matrix="correlation",outlier.method=c("pcout","sumtukey","pcatukey","MDchisq"),removeRda=TRUE,
                  color.palette=c("journal","npg","nejm","jco","lancet","custom1","brewer.RdYlBu","brewer.RdBu","brewer.PuOr","brewer.PRGn","brewer.PiYG","brewer.BrBG",
                                  "brewer.Set2","brewer.Paired","brewer.Dark2","brewer.YlGnBu","brewer.YlGn","brewer.YlOrRd","brewer.YlOrBr","brewer.PuBuGn",
                                  "brewer.PuRd","brewer.PuBu",
                                  "brewer.OrRd","brewer.GnBu","brewer.BuPu","brewer.BuGn","brewer.blues","black","grey65","terrain","rainbow","heat","topo"),
                  plot_DiNa_graph=FALSE,limma.contrasts.type=c("contr.pairs","contr.sum","contr.treatment"),
                  hca.cex.legend=0.7,plot.boxplots.raw=FALSE,vcovHC.type="HC3",ggplot.type1=TRUE,facet.nrow=1,pairwise.correlation.analysis=FALSE,
                  generate.boxplots=TRUE,pvalue.dist.plot=TRUE,...)
{
  
  options(warn=-1)
  time_start<-Sys.time()
  options(warn=-1)
  
  runtime_wd<-getwd()
  
  print("**")
  print("**")
  
  suppressMessages(require(parallel))
  num_nodes=detectCores()*0.5
  #print(paste("g is ",group.missing.thresh,sep=""))
  
  #if (Sys.getenv("RSTUDIO") == "1" && !nzchar(Sys.getenv("RSTUDIO_TERM")) && 
   #   Sys.info()["sysname"] == "Darwin" && getRversion() >= "4.0.0") {
    parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  #}
  
  lme.modeltype=lme.modeltype[1]
  
  if(lme.modeltype=="RI"){
    
    lme.modeltype="lme.RI"
  }else{
    if(lme.modeltype=="RIRS"){
      
      lme.modeltype="lme.RIRS"
    }
    
  }
  
  modeltype=lme.modeltype[1]
  balance.classes.method="ROSE"

  
  
  #fixhere
 # color.palette=tolower(color.palette)
 ## color.palette=get_hexcolors_for_palettes(color.palette=color.palette[1],alpha.col=alpha.col[1])
  
  match_col.opt=match(color.palette,c("journal","npg","nejm","jco","lancet","custom1","brewer.RdYlBu","brewer.RdBu","brewer.PuOr","brewer.PRGn","brewer.PiYG","brewer.BrBG",
                                      "brewer.Set2","brewer.Paired","brewer.Dark2","brewer.YlGnBu","brewer.YlGn","brewer.YlOrRd","brewer.YlOrBr","brewer.PuBuGn",
                                      "brewer.PuRd","brewer.PuBu",
                                      "brewer.OrRd","brewer.GnBu","brewer.BuPu","brewer.BuGn","brewer.blues","black","grey65","terrain","rainbow","heat","topo"))
  
  
  match_col.opt=length(which(is.na(match_col.opt)==TRUE))
  
  #all colors match
  if(length(match_col.opt)<1){
    
    color.palette=color.palette[1]
  }else{
    
    if(length(grep(color.palette,pattern="brewer."))>1){
      
      color.palette=color.palette[1]
    }
  }
  
  color.palette=get_hexcolors_for_palettes(color.palette=color.palette,alpha.col=alpha.col[1])
  
  #color.palette=get_hexcolors_for_palettes(color.palette=color.palette,alpha.col=alpha.col[1])
  
  
  limma.contrasts.type=limma.contrasts.type[1]
  outlier.method=outlier.method[1]
  lineplot.lty.option=lineplot.lty.option[1]
  networktype=networktype[1]
  differential.network.analysis.method=c("degree.centrality")
  differential.network.analysis.method=differential.network.analysis.method[1] #"st5.differential.correlation"
  
  boxplot.col.opt=color.palette
  barplot.col.opt=color.palette
  sample.col.opt=color.palette
  lineplot.col.opt=color.palette
  scatterplot.col.opt=color.palette
  individualsampleplot.col.opt=color.palette
  
  if(length(grep(heatmap.col.opt,pattern = "brewer."))>0){
    
    heatmap.col.opt<-gsub(heatmap.col.opt,pattern="brewer.",replacement="")
  }
  
  labRow.value=hca.labRow.value
  labCol.value=hca.labCol.value
  
  if(is.na(parentoutput_dir)==TRUE){
    
    parentoutput_dir=getwd()
  }
  
  if(is.na(Xmat)[1]==FALSE){
    
    feature_table_file=NA
  }
  if(is.na(Ymat)[1]==FALSE){
    
    class_labels_file=NA
  }
  if(differential.network.analysis==TRUE){
    
    
    
    degree_rank_method="diffrank"
    
  }else{
    degree_rank_method="none"
  }
  
  
  
  feat.filt.thresh=NA
  feat_weight=1
  samplermindex=NA
  #pcacenter=TRUE
  #pcascale=TRUE
  alphacol=0.3
  
  
 # print(parentoutput_dir)
  dir.create(parentoutput_dir,showWarnings = FALSE)
  
  
  # print(is(group.missing.thresh<0.8))
  
  if(is.na(group.missing.thresh)==FALSE){
    if(group.missing.thresh<0.8){
      
      
   
      
    }
  }
  options(warn=-1)
  
  if(input.intensity.scale=="raw" || input.intensity.scale=="log2"){
    
    print("##################################################################################")
    cat("The order of samples should be the same in the feature table and classlabels files",sep="\n")
    cat(paste("Treating input intensities as ",input.intensity.scale," values",sep=""),sep="\n")
    
  }else{
    
    stop("Input intensities should either be at raw or log2 scale")
  }
  
  suppressMessages(suppressWarnings(try(sink(file=NULL),silent=TRUE)))
  #suppressMessages(suppressWarnings(sink(file=NULL)))
  x<-date()
  x<-strsplit(x,split=" ")
  
  #x<-gsub(x,pattern=":",replacement="_")
  targeted_feat_raw<-{}
  logistic_reg=FALSE
  x1<-unlist(x)
  x1<-gsub(x1,pattern=":",replacement="_")
  #fname<-paste(x1[2:5],collapse="_")
  
  #fname<-paste(x1[2:3],x1[5],x1[4],collapse="_")
  
  fname<-paste(x1[2:3],collapse="")
  
  #fname<-paste(fname,x1[6],sep="")
  x1[4]<-gsub(x1[4],pattern=":",replacement="_")
  fname<-paste(fname,x1[5],sep="")
  fname<-paste(fname,x1[4],sep="_")
  
  
  suppressWarnings(dir.create(parentoutput_dir,showWarnings = FALSE))
  setwd(parentoutput_dir)
  
  
  #fname<-paste(parentoutput_dir,"/Log",fname,".txt",sep="")
  
  fname<-paste(parentoutput_dir,"/Log.txt",sep="")
  
  
  if(is.na(foldchangethresh)==FALSE){
    if(log2transform==TRUE && znormtransform==TRUE){
      
      stop("Both log2transform and znormtransform can not be true if foldchangethresh is not equal to NA.")
    }
  }
  
  if(featselmethod[1]=="limma2way")
  {
    
    #cat("Note: lm2wayanova option is recommended for greater than 2x2 designs and this includes post-hoc comparisons",sep="\n")
    
    
  }
  
  
  if(featselmethod[1]=="lm1wayanovarepeat" | featselmethod[1]=="spls1wayrepeat" | featselmethod[1]=="limma1wayrepeat")
  {
    cat("Class labels format should be: Sample ID, Subject, Time. lm1wayanovarepeat is based on the nlme::lme() function with post-hoc Tukey HSD test.",sep="\n")
  }else{
    
    if(featselmethod[1]=="lm2wayanovarepeat" | featselmethod[1]=="spls2wayrepeat" | featselmethod[1]=="limma2wayrepeat")
    {
      cat("Class labels format should be: Sample ID, Subject, Factor, Time. lm2wayanovarepeat is based on the nlme::lme() funciton with post-hoc Tukey HSD test. ",sep="\n")
    }
    
  }
  
  
  print("##############################Starting processing now################################")
  print(paste("**Program is running. Please check the logfile for runtime status: ",fname,"**",sep=""))
  

  
  fname_params<-paste(parentoutput_dir,"/InputParameters.csv",sep="")
  #sink(fname_params)
  # ###savelist=ls(),file="cur.Rda")
  c1<-"feature_table_file:"
  c2<-feature_table_file
  #c2<-rbind(c2,feature_table_file)
  c1<-rbind(c1,"parentoutput_dir:")
  c2<-rbind(c2,parentoutput_dir)
  c1<-rbind(c1,"class_labels_file:")
  c2<-rbind(c2,class_labels_file)
  
  c1<-rbind(c1,"num_replicates:")
  c2<-rbind(c2,num_replicates)
  c1<-rbind(c1,"summarize.replicates:")
  c2<-rbind(c2,summarize.replicates)
  c1<-rbind(c1,"summary.method:")
  c2<-rbind(c2,summary.method)
  c1<-rbind(c1,"summary.na.replacement:")
  c2<-rbind(c2,summary.na.replacement)
  c1<-rbind(c1,"rep.max.missing.thresh:")
  c2<-rbind(c2,rep.max.missing.thresh)
  c1<-rbind(c1,"all.missing.thresh:")
  c2<-rbind(c2,all.missing.thresh)
  c1<-rbind(c1,"group.missing.thresh:")
  c2<-rbind(c2,group.missing.thresh)
  c1<-rbind(c1,"input.intensity.scale:")
  c2<-rbind(c2,input.intensity.scale)
  
  c1<-rbind(c1,"normalization.method:")
  c2<-rbind(c2,normalization.method)
  
  
  c1<-rbind(c1,"log2transform:")
  c2<-rbind(c2,log2transform)
  c1<-rbind(c1,"medcenter:")
  c2<-rbind(c2,medcenter)
  c1<-rbind(c1,"znormtransform:")
  c2<-rbind(c2,znormtransform)
  c1<-rbind(c1,"quantile_norm:")
  c2<-rbind(c2,quantile_norm)
  
  
  c1<-rbind(c1,"TIC_norm:")
  c2<-rbind(c2,TIC_norm)
  c1<-rbind(c1,"lowess_norm:")
  c2<-rbind(c2,lowess_norm)
  c1<-rbind(c1,"madscaling:")
  c2<-rbind(c2,madscaling)
  
  c1<-rbind(c1,"rsd.filt.list:")
  c2<-rbind(c2,rsd.filt.list)
  c1<-rbind(c1,"pairedanalysis:")
  c2<-rbind(c2,pairedanalysis)
  c1<-rbind(c1,"featselmethod:")
  
  c2<-rbind(c2,paste(featselmethod,collapse=";"))
  
  c1<-rbind(c1,"pvalue.thresh:")
  c2<-rbind(c2,pvalue.thresh)
  c1<-rbind(c1,"fdrthresh:")
  c2<-rbind(c2,fdrthresh)
  c1<-rbind(c1,"fdrmethod:")
  c2<-rbind(c2,fdrmethod)
  c1<-rbind(c1,"cor.method:")
  c2<-rbind(c2,cor.method)
  c1<-rbind(c1,"abs.cor.thresh:")
  c2<-rbind(c2,abs.cor.thresh)
  c1<-rbind(c1,"cor.fdrthresh:")
  c2<-rbind(c2,cor.fdrthresh)
  c1<-rbind(c1,"kfold:")
  c2<-rbind(c2,kfold)
  c1<-rbind(c1,"globalcor:")
  c2<-rbind(c2,globalcor)
  c1<-rbind(c1,"target.metab.file:")
  c2<-rbind(c2,target.metab.file)
  c1<-rbind(c1,"target.mzmatch.diff:")
  c2<-rbind(c2,target.mzmatch.diff)
  c1<-rbind(c1,"target.rtmatch.diff:")
  c2<-rbind(c2,target.rtmatch.diff)
  c1<-rbind(c1,"max.cor.num:")
  c2<-rbind(c2,max.cor.num)
  c1<-rbind(c1,"missing.val:")
  c2<-rbind(c2,missing.val)
  c1<-rbind(c1,"networktype:")
  c2<-rbind(c2,networktype)
  c1<-rbind(c1,"samplermindex:")
  c2<-rbind(c2,samplermindex)
  c1<-rbind(c1,"numtrees:")
  c2<-rbind(c2,numtrees)
  c1<-rbind(c1,"analysismode:")
  c2<-rbind(c2,analysismode)
  c1<-rbind(c1,"net_node_colors:")
  c2<-rbind(c2,net_node_colors)
  c1<-rbind(c1,"net_legend:")
  c2<-rbind(c2,net_legend)
  c1<-rbind(c1,"heatmap.col.opt:")
  c2<-rbind(c2,heatmap.col.opt)
  c1<-rbind(c1,"manhattanplot.col.opt:")
  c2<-rbind(c2,paste(manhattanplot.col.opt,collapse=";"))
  c1<-rbind(c1,"boxplot.col.opt:")
  c2<-rbind(c2,boxplot.col.opt)
  
  c1<-rbind(c1,"barplot.col.opt:")
  c2<-rbind(c2,barplot.col.opt)
  
  c1<-rbind(c1,"sample.col.opt:")
  c2<-rbind(c2,sample.col.opt)
  c1<-rbind(c1,"alphacol:")
  c2<-rbind(c2,alphacol)
  c1<-rbind(c1,"pls_vip_thresh:")
  c2<-rbind(c2,pls_vip_thresh)
  c1<-rbind(c1,"alphacol:")
  c2<-rbind(c2,alphacol)
  c1<-rbind(c1,"max_varsel:")
  c2<-rbind(c2,max_varsel)
  c1<-rbind(c1,"pls_ncomp:")
  c2<-rbind(c2,pls_ncomp)
  c1<-rbind(c1,"pcacenter:")
  c2<-rbind(c2,pcacenter)
  c1<-rbind(c1,"pcascale:")
  c2<-rbind(c2,pcascale)
  
  c1<-rbind(c1,"pred.eval.method:")
  c2<-rbind(c2,pred.eval.method)
  
  c1<-rbind(c1,"rocfeatlist:")
  c2<-rbind(c2,paste(rocfeatlist,collapse=";"))
  
  c1<-rbind(c1,"rocfeatincrement:")
  c2<-rbind(c2,rocfeatincrement)
  c1<-rbind(c1,"rocclassifier:")
  c2<-rbind(c2,rocclassifier)
  c1<-rbind(c1,"foldchangethresh:")
  c2<-rbind(c2,foldchangethresh)
  c1<-rbind(c1,"wgcnarsdthresh:")
  c2<-rbind(c2,wgcnarsdthresh)
  c1<-rbind(c1,"WGCNAmodules:")
  c2<-rbind(c2,WGCNAmodules)
  c1<-rbind(c1,"optselect:")
  c2<-rbind(c2,optselect)
  c1<-rbind(c1,"max_comp_sel:")
  c2<-rbind(c2,max_comp_sel)
  c1<-rbind(c1,"saveRda:")
  c2<-rbind(c2,saveRda)
  c1<-rbind(c1,"pca.cex.val:")
  c2<-rbind(c2,pca.cex.val)
  c1<-rbind(c1,"pls.permut.count:")
  c2<-rbind(c2,pls.permut.count)
  c1<-rbind(c1,"pca.ellipse:")
  c2<-rbind(c2,pca.ellipse)
  c1<-rbind(c1,"ellipse.conf.level:")
  c2<-rbind(c2,ellipse.conf.level)
  c1<-rbind(c1,"legendlocation:")
  c2<-rbind(c2,legendlocation)
  c1<-rbind(c1,"svm.acc.tolerance:")
  c2<-rbind(c2,svm.acc.tolerance)
  c1<-rbind(c1,"limmadecideTests:")
  c2<-rbind(c2,limmadecideTests)
  c1<-rbind(c1,"pls.vip.selection:")
  c2<-rbind(c2,pls.vip.selection)
  c1<-rbind(c1,"globalclustering:")
  c2<-rbind(c2,globalclustering)
  c1<-rbind(c1,"plots.res:")
  c2<-rbind(c2,plots.res)
  c1<-rbind(c1,"plots.width:")
  c2<-rbind(c2,plots.width)
  c1<-rbind(c1,"plots.height:")
  c2<-rbind(c2,plots.height)
  c1<-rbind(c1,"plots.type:")
  c2<-rbind(c2,plots.type)
  c1<-rbind(c1,"output.device.type:")
  c2<-rbind(c2,output.device.type)
  c1<-rbind(c1,"pamr.threshold.select.max:")
  c2<-rbind(c2,pamr.threshold.select.max)
  c1<-rbind(c1,"aggregation.method:")
  c2<-rbind(c2,aggregation.method)
  c1<-rbind(c1,"mars.gcv.thresh")
  c2<-rbind(c2,mars.gcv.thresh)
  c1<-rbind(c1,"error.bar")
  c2<-rbind(c2,error.bar)
  c1<-rbind(c1,"timeseries.lineplots")
  c2<-rbind(c2,timeseries.lineplots)
  
  c1<-rbind(c1,"alphabetical.order")
  c2<-rbind(c2,alphabetical.order)
  
 
  c1<-rbind(c1,"kegg_species_code")
  c2<-rbind(c2,kegg_species_code)
  
  c1<-rbind(c1,"database")
  c2<-rbind(c2,database)
  
  c1<-rbind(c1,"reference_set")
  c2<-rbind(c2,reference_set)
  
  c1<-rbind(c1,"target.data.annot")
  c2<-rbind(c2,target.data.annot)
  
  c1<-rbind(c1,"add.pvalues")
  c2<-rbind(c2,add.pvalues)
  
  c1<-rbind(c1,"add.jitter")
  c2<-rbind(c2,add.jitter)
  
  c1<-rbind(c1,"fcs.permutation.type")
  c2<-rbind(c2,fcs.permutation.type)
  
  c1<-rbind(c1,"fcs.method")
  c2<-rbind(c2,fcs.method)
  
  c1<-rbind(c1,"fcs.min.hits")
  c2<-rbind(c2,fcs.min.hits)
  
  c1<-rbind(c1,"names_with_mz_time")
  c2<-rbind(c2,names_with_mz_time)
  
  c1<-rbind(c1,"ylab_text")
  c2<-rbind(c2,ylab_text)
  
  c1<-rbind(c1,"xlab_text")
  c2<-rbind(c2,xlab_text)
 
  c1<-rbind(c1,"boxplot.type")
  c2<-rbind(c2,boxplot.type)
  
  c1<-rbind(c1,"samplermindex")
  c2<-rbind(c2,samplermindex)
  
  c1<-rbind(c1,"differential.network.analysis")
  c2<-rbind(c2,differential.network.analysis)
  
  c1<-rbind(c1,"degree.centrality.method")
  c2<-rbind(c2,degree.centrality.method)
  
  c1<-rbind(c1,"log2.transform.constant")
  c2<-rbind(c2,log2.transform.constant)
  

  c1<-rbind(c1,"balance.classes")
  c2<-rbind(c2,balance.classes)
  c1<-rbind(c1,"balance.classes.sizefactor")
  c2<-rbind(c2,balance.classes.sizefactor)
  c1<-rbind(c1,"balance.classes.seed")
  c2<-rbind(c2,balance.classes.seed)
  
  c1<-rbind(c1,"cv.perm.count")
  c2<-rbind(c2,cv.perm.count)
  
  c1<-rbind(c1,"multiple.figures.perpanel")
  c2<-rbind(c2,multiple.figures.perpanel)
  
  c1<-rbind(c1,"hca.labRow.value")
  c2<-rbind(c2,hca.labRow.value)
  
  c1<-rbind(c1,"hca.labCol.value")
  c2<-rbind(c2,hca.labCol.value)
  
  
  c1<-rbind(c1,"alpha.col")
  c2<-rbind(c2,alpha.col)
  
  c1<-rbind(c1,"similarity.matrix")
  c2<-rbind(c2,similarity.matrix)
 
  c1<-rbind(c1,"outlier.method")
  c2<-rbind(c2,outlier.method)
  
  c1<-rbind(c1,"removeRda")
  c2<-rbind(c2,removeRda)
  
  c1<-rbind(c1,"color.palette")
  c2<-rbind(c2,color.palette)
  
  c1<-rbind(c1,"plot_DiNa_graph")
  c2<-rbind(c2,plot_DiNa_graph)
  
  c1<-rbind(c1,"limma.contrasts.type")
  c2<-rbind(c2,limma.contrasts.type)
  
  c1<-rbind(c1,"hca.cex.legend")
  c2<-rbind(c2,hca.cex.legend)
  

  c1<-rbind(c1,"differential.network.analysis.method")
  c2<-rbind(c2,differential.network.analysis.method)
 
  c1<-rbind(c1,"plot.boxplots.raw")
  c2<-rbind(c2,plot.boxplots.raw)
  
  c1<-rbind(c1,"facet.nrow")
  c2<-rbind(c2,facet.nrow)
  

  c1<-cbind(c1,c2)
  c1<-as.data.frame(c1)
  
  colnames(c1)<-c("InputParameter:","Value")
  write.csv(c1,file=fname_params,row.names=FALSE)
  rm(c1)
  
  
  
  
  sink(fname)
  print(sessionInfo())
  analysistype="oneway"
  
  if(featselmethod=="limma2way" | featselmethod=="lm2wayanova" | featselmethod=="spls2way"){
    analysistype="twowayanova"
  }else{
    
    if(featselmethod=="limma2wayrepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="spls2wayrepeat"){
      analysistype="twowayrepeat"
      pairedanalysis=TRUE
    }else{
      
      if(featselmethod=="limma1wayrepeat" | featselmethod=="lm1wayanovarepeat" | featselmethod=="spls1wayrepeat"){
        analysistype="onewayrepeat"
        pairedanalysis=TRUE
      }
      
    }
    
  }
  
  if(length(featselmethod)>1){
    
    if(length(rsd.filt.list)>1){
      
      print("Warning: only one RSD threshold allowed for multiple feature selection methods. Only the first RSD threshold will be used.")
      rsd.filt.list=rsd.filt.list[1]
      
    }
    
    consensus_res<-{}
    diffexp.res<-new("list")
    consensus_analysis=TRUE
    ranked_list<-{}
    common_feats<-{}
    
    pass_method_list<-{}
    
    for(i in 1:length(featselmethod))
    {
      
      if(featselmethod[i]=="rfesvm" && analysismode=="regression"){
        try(dev.off(),silent=TRUE)
        next;
      }
      
      outloc<-paste(parentoutput_dir,featselmethod[i],sep="/")
    
      #suppressWarnings(
        diffexp.res[[i]]<-diffexp.child(Xmat,Ymat,feature_table_file,parentoutput_dir,class_labels_file,num_replicates,feat.filt.thresh,summarize.replicates,summary.method,summary.na.replacement,missing.val,rep.max.missing.thresh,
                                                           all.missing.thresh,group.missing.thresh,input.intensity.scale,
                                                           log2transform,medcenter,znormtransform,quantile_norm,lowess_norm,madscaling,TIC_norm,rangescaling,mstus,paretoscaling,sva_norm,eigenms_norm,vsn_norm,
                                                           normalization.method[1],rsd.filt.list,
                                                           pairedanalysis,featselmethod[i],fdrthresh,fdrmethod,cor.method,networktype,network.label.cex,abs.cor.thresh,cor.fdrthresh,kfold,pred.eval.method,feat_weight,globalcor,
                                                           target.metab.file,target.mzmatch.diff,target.rtmatch.diff,max.cor.num,samplermindex,pcacenter,pcascale,
                                                           numtrees,analysismode,net_node_colors,net_legend,svm_kernel,heatmap.col.opt,manhattanplot.col.opt,boxplot.col.opt,barplot.col.opt,sample.col.opt,lineplot.col.opt, scatterplot.col.opt,hca_type,alphacol,pls_vip_thresh,num_nodes,max_varsel, pls_ncomp=pls_ncomp,pca.stage2.eval=pca.stage2.eval,scoreplot_legend=scoreplot_legend,pca.global.eval=pca.global.eval,
                                        rocfeatlist=rocfeatlist,rocfeatincrement=rocfeatincrement,rocclassifier=rocclassifier,foldchangethresh=foldchangethresh,wgcnarsdthresh=wgcnarsdthresh,WGCNAmodules=WGCNAmodules,
                                                           optselect=optselect,max_comp_sel=max_comp_sel,saveRda=saveRda,legendlocation=legendlocation,degree_rank_method=degree_rank_method,pca.cex.val=pca.cex.val,pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,pls.permut.count=pls.permut.count,
                                                           svm.acc.tolerance=svm.acc.tolerance,limmadecideTests=limmadecideTests,pls.vip.selection=pls.vip.selection,globalclustering=globalclustering,plots.res=plots.res,plots.width=plots.width,plots.height=plots.height,plots.type=plots.type,
                                                           output.device.type=output.device.type,pvalue.thresh,individualsampleplot.col.opt,pamr.threshold.select.max,mars.gcv.thresh,error.bar,cex.plots,modeltype,barplot.xaxis,lineplot.lty.option,match_class_dist=match_class_dist,
                                                           timeseries.lineplots=timeseries.lineplots,alphabetical.order=alphabetical.order,kegg_species_code=kegg_species_code,database=database,reference_set=reference_set,target.data.annot=target.data.annot,add.pvalues=add.pvalues,
                                                           add.jitter=add.jitter,fcs.permutation.type=fcs.permutation.type,fcs.method=fcs.method,fcs.min.hits=fcs.min.hits,names_with_mz_time=names_with_mz_time,ylab_text=ylab_text,xlab_text=xlab_text,boxplot.type=boxplot.type,
                                                           degree.centrality.method=degree.centrality.method,log2.transform.constant=log2.transform.constant,
                                                           balance.classes=balance.classes,balance.classes.sizefactor=balance.classes.sizefactor,
                                                           balance.classes.method=balance.classes.method,balance.classes.seed=balance.classes.seed,
                                                           cv.perm.count=cv.perm.count,
                                     multiple.figures.perpanel=multiple.figures.perpanel,labRow.value = labRow.value, 
                                     labCol.value = labCol.value,alpha.col=alpha.col,
                                     similarity.matrix=similarity.matrix,outlier.method=outlier.method[1],removeRda=removeRda,color.palette=color.palette,plot_DiNa_graph=plot_DiNa_graph,
                                     limma.contrasts.type=limma.contrasts.type,hca.cex.legend=hca.cex.legend,
                                     differential.network.analysis.method=differential.network.analysis.method,plot.boxplots.raw=plot.boxplots.raw,vcovHC.type=vcovHC.type,
                                     ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,pairwise.correlation.analysis=pairwise.correlation.analysis,
                                     generate.boxplots=generate.boxplots,pvalue.dist.plot=pvalue.dist.plot)
                                     #,silent=TRUE)
        
                                             
                                             
      
      if(is(diffexp.res[[i]],"try-error")){
        print(paste("Error processing option ",featselmethod[i],sep=""))
        print(paste("Error message: ",diffexp.res[[i]],sep=""))
        
        #diffexp.res[[i]]<-
        
        
        
      }else{
        pass_method_list<-c(pass_method_list,i)
       # print(paste("Done with ",featselmethod[i],sep=""))
      }
      
      fname_del<-paste(outloc,"/Rplots.pdf",sep="")
      try(unlink(fname_del),silent=TRUE)
      
    }
    
    ##save(diffexp.res,featselmethod,file="diffexp.res.Rda")
    
    max_num_feats<-max(c(unlist(lapply(1:length(diffexp.res),function(j){
      
      if(j%in%pass_method_list){
        return(dim(diffexp.res[[j]]$all_metabs)[1])
      }
      
    }
    ))),0)
    
    if(max_num_feats<1){
      
      return("No features selected.")
    }
    
    sel_feat_matrix<-matrix(0,nrow=max_num_feats,ncol=length(featselmethod))
    
    feat_rank_matrix<-matrix(1,nrow=max_num_feats,ncol=length(featselmethod))
    
    ranked_list<-{}
    
    for(i in 1:length(featselmethod))
    {
      if(is.na(aggregation.method)==TRUE){
        consensus_analysis=FALSE
      }else{
        
        if(aggregation.method=="none"){
          consensus_analysis=FALSE
        }else{
          if(aggregation.method=="consensus"){
            
            consensus_analysis=TRUE
            
          }
          
        }
      }
      if(length(diffexp.res[[i]]$all_metabs)>0 && consensus_analysis==TRUE){
        
        tvec=diffexp.res[[i]]$all_metabs$diffexp_rank
        
        if(length(tvec)<1){
          
          try(dev.off(),silent=TRUE)
          next;
        }
        cur_data_res<-diffexp.res[[i]]$all_metabs
        
        diffexp.res[[i]]$all_metabs<-diffexp.res[[i]]$all_metabs[order(diffexp.res[[i]]$all_metabs$mz),]
        mz_rt_all<-paste(diffexp.res[[i]]$all_metabs$mz,"_",diffexp.res[[i]]$all_metabs$time,sep="")
        mz_rt_selected<-paste(diffexp.res[[i]]$diffexp_metabs$mz,"_",diffexp.res[[i]]$diffexp_metabs$time,sep="")
        
        
        sel_feat_matrix[which(mz_rt_all%in%mz_rt_selected),i]<-1
        
        rownames(sel_feat_matrix)<-mz_rt_all
        
        if(i==1){
          
          #sort(rankingCriteria, index.return = TRUE)$ix
          ranked_indices=sort(tvec,index.return=TRUE)$ix
          ranked_list<-mz_rt_all[ranked_indices]
          
        }
        if(i>1){
          
          if(length(ranked_list)>0){
            
            ranked_list<-rbind(ranked_list,mz_rt_all[sort(tvec,index.return=TRUE)$ix])
          }else{
            
            ranked_indices=sort(tvec,index.return=TRUE)$ix
            ranked_list<-mz_rt_all[ranked_indices]
          }
          
          
        }
      }
    }
    
    ###save(sel_feat_matrix,file="feature.selection.different.methods.Rda")
    ###save(ranked_list,file="ranked_list.Rda")
    
    if(length(ranked_list)<1){
      consensus_analysis=FALSE
      
    }
    
    if(consensus_analysis==TRUE){
      
      print("################")
      print(paste("Aggregating results from different methods using ",aggregation.method," aggregation method.",sep=""))
      
      
      
      print("################")
      
      if(aggregation.method=="RankAggreg" | aggregation.method=="RankAggregGA"){
        
        if(max_varsel>dim(ranked_list)[2]){
          max_varsel=round(dim(ranked_list)[2]*0.3)
          
          
        }
        
        if(aggregation.method=="RankAggreg"){
          r1<-RankAggreg(x=ranked_list,k=max_varsel,verbose=TRUE,distance="Spearman",method="CE",maxIter=aggregation.max.iter)
        }else{
          
          r1<-RankAggreg(x=ranked_list,k=max_varsel,verbose=TRUE,distance="Spearman",method="GA",maxIter=aggregation.max.iter)
        }
        
        common_row_index<-which(mz_rt_all%in%r1$top.list)
        
        
        common_feats<-cur_data_res[common_row_index,]
        
        cnamesd1<-colnames(common_feats)
        time_ind<-which(cnamesd1=="time")
        mz_ind<-which(cnamesd1=="mz")
        
        
      }else{
        
        if(length(featselmethod)>=1){
          
          check_sel_status<-apply(sel_feat_matrix,1,sum)
          
          common_row_index<-which(check_sel_status==length(featselmethod))
          if(length(common_row_index)>0){
            common_feats<-cur_data_res[common_row_index,]
          }else{
            
            print("No features selected by all methods.")
          }
        }
        
        
      }
      
      cnames_1<-try(colnames(common_feats),silent=TRUE)
      
      
      if(consensus_analysis==FALSE | is(cnames_1,"try-error") | length(common_feats)<1){
        
        print("Skipping aggregation.")
      }else{
        
        
        bad_colind<-grep(tolower(cnames_1),pattern="rank")
        
        bad_colind_2<-grep(tolower(cnames_1),pattern="fold.change.value")
        
        if(length(bad_colind_2)>1){
          bad_colind_2<-bad_colind_2[-c(1)]
        }
        
        bad_colind<-c(bad_colind,bad_colind_2)
        
        
        if(nrow(common_feats)>0){
          
          if(length(bad_colind)>0){
            common_feats<-common_feats[,-c(bad_colind)]
          }
        }
        
        
        common_feats<-unique(common_feats)
        print("Dimension of aggregated feature table of selected features:")
        print(dim(common_feats))
        
        num_common_feats<-dim(common_feats)[1]
        
        if(num_common_feats<1){
          
          stop("No common features found.")
        }
        ####savecommon_feats,file="common_feats.Rda")
        
        
        cnamesd1<-colnames(common_feats)
        time_ind<-which(cnamesd1=="time")
        mz_ind<-which(cnamesd1=="mz")
        
        
        #Xmat<-common_feats[,-c(1:2)]
        mz<-common_feats[,mz_ind]
        time<-common_feats[,time_ind]
        rnames1<-paste(mz,time,sep="_")
        
        Xmat<-cbind(mz,time,common_feats[,-c(1:time_ind)])
        
        rownames(Xmat)<-rnames1
        
        if(max_varsel>nrow(Xmat)){
          
          max_varsel<-nrow(Xmat)
        }
        
        #Ymat<-cbind(colnames(demetabs_res$norm_data[,-c(1:2)]),diffexp.res[i]$classlabels)
        Ymat<-diffexp.res[[i]]$classlabels
        
        
        outloc<-paste(parentoutput_dir,"AggregatedResults/",sep="/")
        
        if(log2transform==TRUE){
          
          input.intensity.scale="log2"
        }else{
          input.intensity.scale="raw"
        }
        
        suppressWarnings(dir.create(outloc,showWarnings = FALSE))
        setwd(outloc)
        
        dir.create("Tables",showWarnings = FALSE)
        
        write.table(Xmat,file="Tables/Aggregated_selected_features.txt",sep="\t",row.names=FALSE)
        
        if(nrow(Xmat)>2){
          
          dir.create("Figures",showWarnings = FALSE)
          
          subdata<-t(Xmat[,-c(1:2)])
          classlabels<-Ymat[,2]
          classlabels<-as.data.frame(classlabels)
          if(analysismode=="classification"){
            svm_model<-try(svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
            #
            #svm_model<-svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist)
            
            
            if(is(svm_model,"try-error")){
              kfold_acc<-NA
              
            }else{
              kfold_acc<-svm_model$avg_acc
            }
          }else{
            
            svm_model_reg<-try(svm(x=subdata,y=(classlabels[,1]),type="eps",cross=kfold),silent=TRUE)
            
            if(is(svm_model_reg,"try-error")){
              kfold_acc<-NA
              
            }else{
              
              kfold_acc<-svm_model_reg$tot.MSE
            }
          }
          numcores<-num_nodes #round(detectCores()*0.6)
          
          kfold_acc_rand<-{}
          #for(p1 in 1:100){
          cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
          clusterEvalQ(cl,library(e1071))
          clusterEvalQ(cl,library(pROC))
          clusterEvalQ(cl,library(ROCR))
          clusterEvalQ(cl,library(CMA))
          clusterExport(cl,"svm_cv",envir = .GlobalEnv)
         # clusterExport(cl,"svm",envir = .GlobalEnv)
          if(analysismode=="classification"){
            kfold_acc_rand<-parLapply(cl,1:100,function(p1){
              
              sample_ind<-sample(1:dim(classlabels)[1],size=dim(classlabels)[1])
              classlabels_rand<-classlabels[sample_ind,]
              classlabels_rand<-as.data.frame(classlabels_rand)
              svm_model<-try(svm_cv(v=kfold,x=subdata,y=classlabels_rand,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
              #
              
              if(is(svm_model,"try-error")){
                # kfold_acc_rand<-c(kfold_acc_rand,NA)
                return(NA)
              }else{
                #kfold_acc_rand<-c(kfold_acc_rand,svm_model$avg_acc)
                return(svm_model$avg_acc)
              }
            })
            
          }else{
            
            kfold_acc_rand<-parLapply(cl,1:100,function(p1){
              
              sample_ind<-sample(1:dim(classlabels)[1],size=dim(classlabels)[1])
              classlabels_rand<-classlabels[sample_ind,]
              classlabels_rand<-as.data.frame(classlabels_rand)
              
              svm_model_reg<-try(svm(x=subdata,y=(classlabels[,1]),type="eps",cross=kfold),silent=TRUE)
              
              if(is(svm_model_reg,"try-error")){
                # kfold_acc_rand<-c(kfold_acc_rand,NA)
                return(NA)
              }else{
                #kfold_acc_rand<-c(kfold_acc_rand,svm_model$avg_acc)
                return(svm_model_reg$tot.MSE)
              }
            })
          }
          stopCluster(cl)
          
          kfold_acc_rand<-unlist(kfold_acc_rand)
          
          kfold_acc_rand<-mean(kfold_acc_rand,na.rm=TRUE)
          
          num_common_feats<-dim(common_feats)[1]
          summary_res<-cbind(num_common_feats,kfold_acc,kfold_acc_rand)
          colnames(summary_res)<-c("Number of selected features after aggregation",paste(pred.eval.method,"-accuracy",sep=""),paste(pred.eval.method," permuted accuracy",sep=""))
          
          
          file_name<-paste("../Results_summary_aggregated.txt",sep="")
          write.table(summary_res,file=file_name,sep="\t",row.names=FALSE)
          
          if(output.device.type=="pdf"){
            pdf("Figures/Aggregatedresults.pdf")
          }
          
          if(output.device.type!="pdf"){
            
            temp_filename_1<-"Figures/HCA_aggregated_selectedfeats.png"
            
            png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
          }
          
          #   print("here")
          #print(head(Ymat))
          ####saveXmat,file="Xmat.Rda")
          ####saveYmat,file="Ymat.Rda")
          
          g1<-try(get_hca(feature_table_file=NA,parentoutput_dir=outloc,class_labels_file=NA,X=Xmat,Y=Ymat,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode=analysismode,
                      sample.col.opt=sample.col.opt,plots.width=plots.width,plots.height=plots.height,plots.res=plots.res, plots.type=plots.type, alphacol=0.3, hca_type=hca_type,newdevice=FALSE,
                      input.type="intensity",mainlab="",alphabetical.order=alphabetical.order,study.design=analysistype,similarity.matrix=similarity.matrix,
                      cexRow=cex.plots,cexCol=cex.plots),silent=TRUE)
          
          
          if(output.device.type!="pdf"){
            
            try(dev.off(),silent=TRUE)
          }
          
          
          if(analysismode=="classification")
          {
            best_subset<-{}
            best_acc<-0
            
            xvec<-{}
            yvec<-{}
            for(i in 2:max_varsel){
              
              subdata<-t(Xmat[1:i,-c(1:2)])
              svm_model<-try(svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
              #svm_model<-svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95
              
              if(is(svm_model,"try-error")){
                
                svm_model<-NA
                
              }else{
                
                xvec<-c(xvec,i)
                yvec<-c(yvec,svm_model$avg_acc)
                if(svm_model$avg_acc>best_acc){
                  
                  best_acc<-svm_model$avg_acc
                  best_subset<-seq(1,i)
                  
                  
                }
                
                if(svm_model$avg_acc<best_acc){
                  
                  diff_acc<-best_acc-svm_model$avg_acc
                  if(diff_acc>50){
                    
                    break;
                    
                  }
                  
                }
              }
              
              
            }
            
            if(pred.eval.method=="CV"){
              ylab_text=paste(pred.eval.method," accuracy (%)",sep="")
              
            }else{
              if(pred.eval.method=="BER"){
                ylab_text=paste("Balanced accuracy"," (%)",sep="")
              }else{
                
                ylab_text=paste("AUC"," (%)",sep="")
              }
            }
            
            
            if(length(yvec)>0){
              
              msg1<-paste("k-fold CV classification accuracy based on forward selection of\n aggregated features ordered by ",featselmethod[1],sep="")
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/kfold_forward_selection_aggregated_selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              
              plot(x=xvec,y=yvec,main=msg1,xlab="Feature index",ylab=ylab_text,type="b",col="brown")
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              
              cv_mat<-cbind(xvec,yvec)
              colnames(cv_mat)<-c("Feature Index",ylab_text)
              
              write.table(cv_mat,file="Tables/aggregated_kfold_cv_mat.txt",sep="\t")
            }
            
            if(FALSE){
            
            if(output.device.type!="pdf"){
              
              temp_filename_1<-"Figures/Boxplots_aggregated_selectedfeats.png"
              
              #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              #pdf(temp_filename_1)
              pdf(temp_filename_1,width=plots.width,height=plots.height)
              
            }
            
            if(log2transform==TRUE || input.intensity.scale=="log2"){
              
              if(znormtransform==TRUE){
                ylab_text_2="scale normalized"
              }else{
                if(quantile_norm==TRUE){
                  
                  ylab_text_2="quantile normalized"
                }else{
                  
                  ylab_text_2=""
                }
              }
              ylab_text=paste("log2 intensity ",ylab_text_2,sep="")
            }else{
              if(znormtransform==TRUE){
                ylab_text_2="scale normalized"
              }else{
                if(quantile_norm==TRUE){
                  
                  ylab_text_2="quantile normalized"
                }else{
                  ylab_text_2=""
                }
              }
              ylab_text=paste("Raw intensity ",ylab_text_2,sep="")
            }
            
            
            
            # par(mfrow=c(2,2))
            par(mfrow=c(1,1),family="sans",cex=cex.plots)
            get_boxplots(X=Xmat,Y=Ymat,parentoutput_dir=outloc,sample.col.opt=sample.col.opt,
                         boxplot.col.opt=boxplot.col.opt, newdevice=FALSE,
                         cex.plots=cex.plots,ylabel=ylab_text,alphabetical.order=alphabetical.order,
                         boxplot.type=boxplot.type,study.design=analysistype,
                         multiple.figures.perpanel=multiple.figures.perpanel,
                         ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                         boxplot.strip.position ="bottom",remove.xaxis.labels=TRUE,
                         replace.outliers =FALSE)
            
            
            
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
            }
            
            
            
            if(output.device.type!="pdf"){
              
              temp_filename_1<-"Figures/Barplots_aggregated_selectedfeats.pdf"
              
              #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              #pdf(temp_filename_1)
              
              pdf(temp_filename_1,width=plots.width,height=plots.height)
              
            }
            # par(mfrow=c(2,2))
            
            
            
            par(mfrow=c(1,1),family="sans",cex=cex.plots)
            
            get_barplots(feature_table_file=NA,class_labels_file=NA,X=Xmat,Y=Ymat,parentoutput_dir=outloc,newdevice=FALSE,ylabel=ylab_text,cex.plots=cex.plots,barplot.col.opt=barplot.col.opt,error.bar=error.bar,barplot.xaxis=barplot.xaxis,study.design=analysistype)
            
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
            }
           
            if(FALSE){ 
            
            if(output.device.type!="pdf"){
              
              temp_filename_1<-"Figures/Individual_sample_plots_aggregated_selectedfeats.png"
              
              #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              #pdf(temp_filename_1)
              
              pdf(temp_filename_1,width=plots.width,height=plots.height)
            }
            
            par(mfrow=c(1,1),family="sans",cex=cex.plots)
            get_individualsampleplots(feature_table_file=NA,class_labels_file=NA,X=Xmat,Y=Ymat,parentoutput_dir=outloc,newdevice=FALSE,
                                      ylabel=ylab_text,cex.plots=cex.plots,sample.col.opt=individualsampleplot.col.opt)
            
            
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
            }
          }
            
            if(pairedanalysis==TRUE || timeseries.lineplots==TRUE)
            {
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/Lineplots_aggregated_selectedfeats.png"
               # pdf(temp_filename_1)
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              par(mfrow=c(1,1),family="sans",cex=cex.plots)
              classlabels_orig<-read.table("../Stage2/classlabels_orig.txt",sep="\t",header=TRUE,stringsAsFactors = FALSE,check.names = FALSE, quote="")
              classlabels_orig<-classlabels_orig[,-c(1)]
              
              #save(Xmat,classlabels_orig,lineplot.col.opt,col_vec,pairedanalysis,
              #     pca.cex.val,pca.ellipse,ellipse.conf.level,legendlocation,ylab_text,error.bar,
               #    cex.plots,lineplot.lty.option,timeseries.lineplots,analysistype,file="debuga_lineplots.Rda")
              
              get_lineplots(X=Xmat,Y=classlabels_orig,feature_table_file=NA,parentoutput_dir=getwd(),
                                class_labels_file=NA,lineplot.col.opt=lineplot.col.opt, 
                                alphacol=0.3,col_vec=col_vec,pairedanalysis=pairedanalysis,
                                point.cex.val=pca.cex.val,legendlocation=legendlocation,
                                pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,
                                filename="selected",ylabel=ylab_text,error.bar=error.bar,cex.plots=cex.plots,
                                lineplot.lty.option=lineplot.lty.option,timeseries.lineplots=timeseries.lineplots,
                                study.design=analysistype,multiple.figures.perpanel = multiple.figures.perpanel) #,silent=TRUE)
            }
            
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
            }
          }
          }
          
          if(output.device.type=="pdf"){
            try(dev.off(),silent=TRUE)
          }
        }
      }
     
     # suppressWarnings(sink(file=NULL))
      suppressMessages(suppressWarnings(try(sink(file=NULL),silent=TRUE)))
      
      #print("###############################")
      #print("###############################")
      #print("###############################")
      time_end<-Sys.time()
      
      time_taken_panda<-round(time_end-time_start,2)
      
      
      #print("*********")
      cat(paste("**Program ended successfully in ",time_taken_panda," ",units(time_taken_panda),". Please see the ReadMe.txt file for description of output files and folders.**", sep=""),sep="\n")
      
      #print("*********")
      #print(paste("All result files are in the specified output location: ",parentoutput_dir,sep=""))
      #print("*********")
      #print("There will be a sub-folder for each step: Stage 1: pre-processing, Stage 2: statistical analysis (e.g. limma, PLS)")
      #print("*********")
      #print("")
      #print("*********")
      # print("Enjoy!")
      #cat("",sep="\n")
     #cat("##############################END################################",sep="\n")
      
      
      
      
      s1<-"Stage 1 results: Includes raw (original) and preprocessed (filtered,normalized, and imputed) data tables"
      s2<-"Stage 2 results: Feature selection & evaluation results for each method. The following files and folders are generated for each method:: A) *selected.features.final.txt file includes final table of selected features; B) Figures subfolder: includes Manhattan plots, boxplots, HCA heatmap, and other figures, and C) Tables sub-folder: includes data files with feature selection results for all features, PCA (and PLS) scores and loadings, HCA clusters, k-fold CV results, and other tables.."
     # s3<-"Stage 3 results: Correlation based network analysis"
      #s4<-"Stage 4 results: Correlation based targeted network analysis"
      #s5<-"Consensus results: HCA, k-fold CV, boxplots, and barplots for aggregated selected features"
      sm<-rbind(s1,s2) #,s3,s4,s5)
      
     # cat("Description of output folders:",sep="\n")
      
      
      
      
   #   cat(sm,sep="\n")
    #  cat("",sep="\n")
     # cat("##############################END################################",sep="\n")
      
      #cat(sm,sep="\n")
      setwd(parentoutput_dir)
      write.table(sm,file="ReadMe.txt",sep="\t",row.names=FALSE)
      return(list("individual.featsel.res"=diffexp.res,"aggregated.res"=common_feats))
    }else{
      
     
     # suppressWarnings(sink(file=NULL))
      suppressMessages(suppressWarnings(try(sink(file=NULL),silent=TRUE)))
      
      # print("###############################")
      #print("###############################")
      #print("###############################")
      time_end<-Sys.time()
      
      time_taken_panda<-round(time_end-time_start,2)
      
      cat(paste("**Program ended successfully in ",time_taken_panda," ",units(time_taken_panda),". Please see the ReadMe.txt file for description of output files and folders.**", sep=""),sep="\n")
      
      
      # print(paste("*******Program ended successfully in ",round(time_taken_panda,2)," minutes*******", sep=""))
      
      #  print("*     *")
      #  print("Consensus analysis could not be performed as not all features were selected by all feature selection methods.")
      #print("*     *")
      #print(paste("All result files are in the specified output location: ",parentoutput_dir,sep=""))
      # print("*     *")
      #print("There will be a sub-folder for each step: Stage 1: pre-processing, Stage 2: statistical analysis (e.g. limma, PLS), and Stages 3 and 4: network analysis (Global and/or Targeted).")
      #  print("*     *")
      
      #print("Please see the ReadMe.txt file for more information.")
      # print("*     *")
      # print("Enjoy!")
     # cat("",sep="\n")
     #cat("##############################END################################",sep="\n")
      
      
      
      s1<-"Stage 1 results: Includes raw (original) and preprocessed (filtered,normalized, and imputed) data tables"
      s2<-"Stage 2 results: Feature selection & evaluation results for each method. The following files and folders are generated for each method:: A) *selected.features.final.txt file includes final table of selected features; B) Figures subfolder: includes Manhattan plots, boxplots, HCA heatmap, and other figures, and C) Tables sub-folder: includes data files with feature selection results for all features, PCA (and PLS) scores and loadings, HCA clusters, k-fold CV results, and other tables.."
      #s3<-"Stage 3 results: Correlation based network analysis"
      #s4<-"Stage 4 results: Correlation based targeted network analysis"
      
      sm<-rbind(s1,s2)
     # cat(sm,sep="\n")
      
    #  cat("Description of output folders:",sep="\n")
      
      
     
      
     # cat(sm,sep="\n")
      #cat("",sep="\n")
      #cat("##############################END################################",sep="\n")
      
      setwd(parentoutput_dir)
      write.table(sm,file="ReadMe.txt",sep="\t",row.names=FALSE)
      options(warn=0)
      return(list("individual.featsel.res"=diffexp.res))
      
    }
    
    
    
  }else{
    
   # suppressWarnings(
      diffexp.res<-diffexp.child(Xmat,Ymat,feature_table_file,parentoutput_dir,class_labels_file,num_replicates,feat.filt.thresh,summarize.replicates,summary.method,summary.na.replacement,missing.val,rep.max.missing.thresh,
                                 all.missing.thresh,group.missing.thresh,input.intensity.scale,
                                 log2transform,medcenter,znormtransform,quantile_norm,lowess_norm,madscaling,TIC_norm,rangescaling,mstus,paretoscaling,sva_norm,eigenms_norm,vsn_norm,
                                 normalization.method,rsd.filt.list,
                                 pairedanalysis,featselmethod,fdrthresh,fdrmethod,cor.method,networktype,network.label.cex,abs.cor.thresh,cor.fdrthresh,kfold,pred.eval.method,feat_weight,globalcor,
                                 target.metab.file,target.mzmatch.diff,target.rtmatch.diff,max.cor.num,samplermindex,pcacenter,pcascale,
                                 numtrees,analysismode,net_node_colors,net_legend,svm_kernel,heatmap.col.opt,manhattanplot.col.opt,boxplot.col.opt,barplot.col.opt,sample.col.opt,lineplot.col.opt,scatterplot.col.opt,hca_type,alphacol,pls_vip_thresh,num_nodes,max_varsel, 
                                 pls_ncomp,pca.stage2.eval,scoreplot_legend,pca.global.eval,rocfeatlist,rocfeatincrement,rocclassifier,foldchangethresh,wgcnarsdthresh,WGCNAmodules,
                                 optselect,max_comp_sel,saveRda,legendlocation,degree_rank_method,pca.cex.val,pca.ellipse,ellipse.conf.level,pls.permut.count,svm.acc.tolerance,limmadecideTests,pls.vip.selection,globalclustering,plots.res,plots.width,plots.height,
                                 plots.type,output.device.type,pvalue.thresh,individualsampleplot.col.opt,pamr.threshold.select.max,mars.gcv.thresh,error.bar,cex.plots,modeltype,barplot.xaxis,lineplot.lty.option,match_class_dist=match_class_dist,
                                 timeseries.lineplots=timeseries.lineplots,alphabetical.order=alphabetical.order,kegg_species_code=kegg_species_code,database=database,reference_set=reference_set,target.data.annot=target.data.annot,add.pvalues=add.pvalues,
                                 add.jitter=add.jitter,fcs.permutation.type=fcs.permutation.type,
                                 fcs.method=fcs.method,fcs.min.hits=fcs.min.hits,
                                 names_with_mz_time=names_with_mz_time,ylab_text=ylab_text,
                                 xlab_text=xlab_text,boxplot.type=boxplot.type,
                                 degree.centrality.method=degree.centrality.method,
                                 log2.transform.constant=log2.transform.constant,
                                 balance.classes=balance.classes,
                                 balance.classes.sizefactor=balance.classes.sizefactor,
                                 balance.classes.method=balance.classes.method,
                                 balance.classes.seed=balance.classes.seed,cv.perm.count=cv.perm.count,
                                 multiple.figures.perpanel=multiple.figures.perpanel,
                                 labRow.value = labRow.value, labCol.value = labCol.value,alpha.col=alpha.col,
                                 similarity.matrix=similarity.matrix,outlier.method=outlier.method[1],removeRda=removeRda,color.palette=color.palette,
                                 plot_DiNa_graph=plot_DiNa_graph,limma.contrasts.type=limma.contrasts.type,hca.cex.legend=hca.cex.legend,
                                 differential.network.analysis.method=differential.network.analysis.method,plot.boxplots.raw=plot.boxplots.raw,
                                 vcovHC.type=vcovHC.type,ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                                 pairwise.correlation.analysis=pairwise.correlation.analysis,generate.boxplots=generate.boxplots,pvalue.dist.plot=pvalue.dist.plot) #,silent=TRUE)
    #)
    
    time_end<-Sys.time()
    
    time_taken_panda<-round(time_end-time_start,2)
    
    
   
    #suppressWarnings(sink(file=NULL))
    suppressMessages(suppressWarnings(try(sink(file=NULL),silent=TRUE)))
    
    cat(paste("**Program ended successfully in ",time_taken_panda," ",units(time_taken_panda),". Please see the ReadMe.txt file for description of output files and folders.**", sep=""),sep="\n")
    
    #     print("###############################")
    #print("###############################")
    #print("###############################")
    #print("*     *")
    
    # print(paste("***Program ended successfully in ",round(time_taken_panda,2)," minutes***", sep=""))
    #  print(paste("*******Program ended successfully in ",round(time_taken_panda,2)," minutes*******", sep=""))
    
    # print("*     *")
    #    print(paste("All result files are in the specified output location: ",parentoutput_dir,sep=""))
    # print("*     *")
    #   print("There will be a sub-folder for each step: Stage 1: pre-processing, Stage 2: statistical analysis (e.g. limma, PLS), and Stages 3 and 4: network analysis (Global and/or Targeted).")
    # print("*     *")
    
    #   print("Please see the ReadMe.txt file for more information.")
    #   print("*     *")
    # print("Enjoy!")
    #cat("",sep="\n")
    #cat("##############################END################################",sep="\n")
    
    
    s1<-"Stage 1 results: Includes raw (original) and preprocessed (filtered,normalized, and imputed) data tables"
    s2<-"Stage 2 results: Feature selection & evaluation results for each method. The following files and folders are generated for each method:: A) *selected.features.final.txt file includes final table of selected features; B) Figures subfolder: includes Manhattan plots, boxplots, HCA heatmap, and other figures, and C) Tables sub-folder: includes data files with feature selection results for all features, PCA (and PLS) scores and loadings, HCA clusters, k-fold CV results, and other tables.."
    s3<-"Stage 3 results: Correlation based network analysis"
    s4<-"Stage 4 results: Correlation based targeted network analysis"
    sm<-rbind(s1,s2) #,s3,s4)
   # cat(sm,sep="\n")
    
   # cat("Description of output folders:",sep="\n")
    
    
    
    #s1<-"Stage 1 results: Includes raw (original) and preprocessed (filtered,normalized, and imputed) data tables"
    #s2<-"Stage 2 results: Feature selection & evaluation results for each method. The following files and folders are generated for each method:: A) *selected.features.final.txt file includes final table of selected features; B) Figures subfolder: includes Manhattan plots, boxplots, HCA heatmap, and other figures, and C) Tables sub-folder: includes data files with feature selection results for all features, PCA (and PLS) scores and loadings, HCA clusters, k-fold CV results, and other tables.."
    
    #sm<-rbind(s1,s2)
    
    #cat(sm,sep="\n")
   # cat("",sep="\n")
  #  cat("##############################END################################",sep="\n")
    
    setwd(parentoutput_dir)
    write.table(sm,file="ReadMe.txt",sep="\t",row.names=FALSE)
    options(warn=0)
    return(diffexp.res)
    
    
  }

  
  setwd(runtime_wd)
  }

#Xmat: 
#column A: X-axis data (e.g. group labels)
#column B: Y-axis data (e.g. pathway names)
#column C: Z-axis data (e.g. statistic)
#column D: optional group by variable
get_bubbleplot<-function(Xmat, GroupBy=FALSE,xlab.name="X",ylab.name="Y",cex.plots=0.8,newdevice=TRUE,
                         
                         filename="bubbleplot",file.format="pdf",
                         
                         plot.width=8,plot.height=8,plot.res=300,color.scale=c("blue","red"),statistic.type="pvalue",
                         
                         reverse.yaxis=FALSE,sizerange=c(0.01,6)){
  
  options(warn=-1)
  
  
  
  Xmat<-as.data.frame(Xmat)
  
  if(GroupBy==TRUE){
    
    
    
    colnames(Xmat)<-c("X","Y","Statistic","GroupBy")
    
  }else{
    
    colnames(Xmat)<-c("X","Y","Statistic")
    
    
    
  }
  
  
  
  Xmat$Statistic<-as.numeric(as.character(Xmat$Statistic))
  
 # print(head(Xmat))
  
  #save(Xmat,file="Xmat.Rda")
  
  
  
  if(statistic.type=="pvalue"){
    
    p=ggplot(Xmat,
             
             aes(x = X, y = Y)) +  suppressWarnings(geom_point(aes(size = abs(Statistic)), pch = 21, show.legend= TRUE))
    
  }else{
    
   
    if(statistic.type=="correlation"){
      
      p=ggplot(Xmat,
               
               aes(x = X, y = Y)) +  suppressWarnings(geom_point(aes(size = abs(Statistic)), pch = 21, show.legend= TRUE))
      
    }else{
      
      
      
      p=ggplot(Xmat,
               
               aes(x = X, y = Y)) +  suppressWarnings(geom_point(aes(size = abs(Statistic)), pch = 21, show.legend= TRUE))
      
    }
    
  }
  
  if(GroupBy==TRUE){
    
    p=p+  facet_wrap(~ GroupBy, scale="free_x",nrow=1)
    
    
    
  }
  
  p=p+labs(x=xlab.name,y=ylab.name)
  
  p=p +aes(fill = Statistic) + theme_bw()
  
  if(statistic.type=="correlation"){
  p=p+scale_fill_gradient2(low=color.scale[1],mid="white",high=color.scale[2],limits=c(-1,1))+scale_size(range=sizerange)
  }else{
    
    p=p+scale_fill_gradient2(low=color.scale[1],mid="white",high=color.scale[2])+scale_size(range=sizerange)
  }
  
  
  #scale_size(range=c(floor(min(abs(Xmat$Statistic),na.rm=TRUE)),ceiling(max(abs(Xmat$Statistic),na.rm=TRUE))))
  
  
  
  #scale_size(range = c(0.5, 12)
  
  
  
  p=p+theme(panel.border = element_blank(), panel.grid.major = element_blank(),
            
            panel.grid.minor = element_blank(),
            
            panel.spacing=unit(1,"lines"),
            
            axis.line = element_line(colour = "black",size=1),
            
            axis.text= element_text(size=14*cex.plots), axis.title=element_text(size=18*cex.plots,face="bold"),
            
            plot.title = element_text(hjust = 0.5,size=18*cex.plots),
            
            axis.ticks.length = unit(-0.05, "in"),
            
            axis.text.y = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
            
            axis.text.x = element_text(margin=unit(c(0.3,0.3,0.3,0.3), "cm")),
            
            axis.ticks.x = element_blank(),
            
            # aspect.ratio = 1,
            
            strip.background=element_rect(colour="#f0f0f0",fill="#f0f0f0"),
            
            strip.text = element_text(face="bold")) + theme(axis.text.x = element_text(angle = 45, hjust = 1))
  
  
  
  #p=p+scale_fill_manual(values = c("blue","red"))
  
  
  
  if(reverse.yaxis==TRUE){
    
    p=p+scale_y_discrete(limits=rev)
    
  }
  
  p=p+theme(axis.title = element_blank())
  
  if(newdevice==TRUE){
    
    
    
    if(file.format=="pdf"){
      
      fname=paste(filename,".pdf",sep="")
      
      pdf(fname,width=plot.width,height=plot.height)
      
    }else{
      
      fname=paste(filename,".png",sep="")
      
      png(fname,width=plot.width,height=plot.height,res=plots.res,type="cairo",units="in")
      
    }
    
    print(p)
    
    dev.off()
    
  }else{
    
    #print(p)
    
  }
  
  
  
  options(warn=0)
  
  return(p)
  
}


diffexp.child<-function(Xmat,Ymat,feature_table_file,parentoutput_dir,class_labels_file,num_replicates,feat.filt.thresh,summarize.replicates,summary.method,
                        summary.na.replacement,missing.val,rep.max.missing.thresh,
                        all.missing.thresh,group.missing.thresh,input.intensity.scale,
                        log2transform,medcenter,znormtransform,quantile_norm,lowess_norm,madscaling,TIC_norm,rangescaling,mstus,paretoscaling,sva_norm,eigenms_norm,vsn_norm,
                        normalization.method,rsd.filt.list,
                        pairedanalysis,featselmethod,fdrthresh,fdrmethod,cor.method,networktype,network.label.cex,abs.cor.thresh,cor.fdrthresh,kfold,pred.eval.method,feat_weight,globalcor,
                        target.metab.file,target.mzmatch.diff,target.rtmatch.diff,max.cor.num, samplermindex,pcacenter,pcascale,
                        numtrees,analysismode,net_node_colors,net_legend,svm_kernel,heatmap.col.opt,manhattanplot.col.opt,boxplot.col.opt,barplot.col.opt,sample.col.opt,lineplot.col.opt,scatterplot.col.opt,hca_type,alphacol,pls_vip_thresh,num_nodes,max_varsel,
                        pls_ncomp,pca.stage2.eval,scoreplot_legend,pca.global.eval,rocfeatlist,rocfeatincrement,
                        rocclassifier,foldchangethresh,wgcnarsdthresh,WGCNAmodules,optselect,max_comp_sel,saveRda,legendlocation,degree_rank_method,
                        pca.cex.val,pca.ellipse,ellipse.conf.level,pls.permut.count,svm.acc.tolerance,limmadecideTests,pls.vip.selection,globalclustering,plots.res,plots.width,plots.height,plots.type,output.device.type,pvalue.thresh,individualsampleplot.col.opt,
                        pamr.threshold.select.max,mars.gcv.thresh,error.bar,cex.plots,modeltype,barplot.xaxis,lineplot.lty.option,match_class_dist,timeseries.lineplots,alphabetical.order,kegg_species_code,database,reference_set,target.data.annot,
                        add.pvalues=TRUE,add.jitter=TRUE,fcs.permutation.type,fcs.method,
                        fcs.min.hits,names_with_mz_time,ylab_text,xlab_text,boxplot.type,
                        degree.centrality.method,log2.transform.constant,balance.classes,
                        balance.classes.sizefactor,balance.classes.method,balance.classes.seed,
                        cv.perm.count=100,multiple.figures.perpanel=TRUE,labRow.value = TRUE, labCol.value = TRUE,
                        alpha.col=1,similarity.matrix,outlier.method,removeRda=TRUE,color.palette=c("journal"),
                        plot_DiNa_graph=FALSE,limma.contrasts.type=c("contr.pairs","contr.sum","contr.treatment"),hca.cex.legend=0.7,differential.network.analysis.method,
                        plot.boxplots.raw=FALSE,vcovHC.type,ggplot.type1,facet.nrow,facet.ncol,pairwise.correlation.analysis=FALSE,
                        generate.boxplots=FALSE,pvalue.dist.plot=TRUE,...)
{
  
  
  
  #############
  options(warn=-1)
  
  roc_res<-NA
  lme.modeltype=modeltype
  remove_firstrun=FALSE #TRUE or FALSE
  run_number=1
  minmaxtransform=FALSE
  pca.CV=TRUE
  max_rf_var=5000
  alphacol=alpha.col
  
  
  hca.labRow.value=labRow.value
  hca.labCol.value=labCol.value
  logistic_reg=FALSE
  poisson_reg=FALSE
  goodfeats_allfields={}
  mwan_fdr={}
  targetedan_fdr={}
  data_m_fc_withfeats={}
  classlabels_orig={}
  robust.estimate=FALSE
  #alphabetical.order=FALSE
  
  analysistype="oneway"
  
  plot.ylab_text=ylab_text
  
  limmarobust=FALSE
  
  featselmethod<-unique(featselmethod)
  
  if(featselmethod=="rf"){
    
    featselmethod="RF"
  }
  
  parentfeatselmethod=featselmethod
  
  factor1_msg=NA
  factor2_msg=NA
  
  
    cat(paste("Running feature selection method: ",featselmethod,sep=""),sep="\n")
  #}
  
  
  if(featselmethod=="limmarobust"){
    
    featselmethod="limma"
    limmarobust=TRUE
  }else{
    
    if(featselmethod=="limma1wayrepeatrobust"){
      
      featselmethod="limma1wayrepeat"
      limmarobust=TRUE
    }else{
      if(featselmethod=="limma2wayrepeatrobust"){
        
        featselmethod="limma2wayrepeat"
        limmarobust=TRUE
      }else{
        
        if(featselmethod=="limma2wayrobust"){
          
          featselmethod="limma2way"
          limmarobust=TRUE
        }else{
          if(featselmethod=="limma1wayrobust"){
            
            featselmethod="limma1way"
            limmarobust=TRUE
          }
          
        }
        
      }
      
    }
    
  }
  
  #if(FALSE)
    {
  if(normalization.method=="log2quantilenorm" || normalization.method=="log2quantnorm"){
    cat("Performing log2 transformation and quantile normalization",sep="\n")
    log2transform=TRUE
    quantile_norm=TRUE
    
  }else{
    if(normalization.method=="log2transform"){
      cat("Performing log2 transformation",sep="\n")
      log2transform=TRUE
    }else{
      if(normalization.method=="znormtransform"){
        cat("Performing autoscaling",sep="\n")
        znormtransform=TRUE
        
      }else{
        if(normalization.method=="quantile_norm"){
          suppressMessages(library(limma))
          cat("Performing quantile normalization",sep="\n")
          quantile_norm=TRUE
        }else{
          if(normalization.method=="lowess_norm"){
            suppressMessages(library(limma))
            cat("Performing Cyclic Lowess normalization",sep="\n")
            lowess_norm=TRUE
          }else{
            
            if(normalization.method=="rangescaling"){
              cat("Performing Range scaling",sep="\n")
              rangescaling=TRUE
            }else{
              if(normalization.method=="paretoscaling"){
                cat("Performing Pareto scaling",sep="\n")
                paretoscaling=TRUE
              }else{
                
                if(normalization.method=="mstus"){
                  
                  cat("Performing MS Total Useful Signal (MSTUS) normalization",sep="\n")
                  mstus=TRUE
                }else{
                  
                  if(normalization.method=="sva_norm"){
                    suppressMessages(library(sva))
                    cat("Performing Surrogate Variable Analysis (SVA) normalization",sep="\n")
                    sva_norm=TRUE
                    log2transform=TRUE
                  }else{
                    if(normalization.method=="eigenms_norm"){
                      cat("Performing EigenMS normalization",sep="\n")
                      eigenms_norm=TRUE
                      if(input.intensity.scale=="raw"){
                        log2transform=TRUE
                      }
                      
                    }else{
                      if(normalization.method=="vsn_norm"){
                        suppressMessages(library(limma))
                        cat("Performing variance stabilizing normalization",sep="\n")
                        vsn_norm=TRUE
                        
                      }
                    }
                  }
                  
                }
                
                
              }
              
            }
            
          }
          
        }
        
        
      }
    }
    
    
  }
  
  }
  if(input.intensity.scale=="log2"){
    
    log2transform=FALSE
  }
  
  rfconditional=FALSE
  
 # print("############################")
  
  
  #print("############################")
  if(featselmethod=="rf" | featselmethod=="RF"){
    
    suppressMessages(library(randomForest))
    suppressMessages(library(Boruta))
    
    featselmethod="RF"
    
    rfconditional=FALSE
  }else{
    
    if(featselmethod=="rfconditional" | featselmethod=="RFconditional" | featselmethod=="RFcond" | featselmethod=="rfcond"){
      
      
      suppressMessages(library(party))
      
      featselmethod="RF"
      
      rfconditional=TRUE
    }
  }
  
  
  if(featselmethod=="rf"){
    
    featselmethod="RF"
  }else{
    if(featselmethod=="mars"){
      
      
      suppressMessages(library(earth))
      featselmethod="MARS"
    }
  }
  
  if(featselmethod=="lmregrobust"){
    
    suppressMessages(library(sandwich))
    robust.estimate=TRUE
    featselmethod="lmreg"
  }else{
    
    if(featselmethod=="logitregrobust"){
      robust.estimate=TRUE
      suppressMessages(library(sandwich))
      featselmethod="logitreg"
    }else{
      
      if(featselmethod=="poissonregrobust"){
        robust.estimate=TRUE
        suppressMessages(library(sandwich))
        featselmethod="poissonreg"
      }
    }
  }
  
  if(featselmethod=="plsrepeat"){
    
    featselmethod="pls"
    pairedanalysis=TRUE
    
  }else{
    if(featselmethod=="splsrepeat"){
      featselmethod="spls"
      pairedanalysis=TRUE
    }else{
      if(featselmethod=="o1plsrepeat"){
        featselmethod="o1pls"
        pairedanalysis=TRUE
      }else{
        if(featselmethod=="o1splsrepeat"){
          featselmethod="o1spls"
          pairedanalysis=TRUE
        }
        
      }
      
    }
    
  }
  
  
  log2.fold.change.thresh_list<-rsd.filt.list
  if(featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="limma2wayrepeat" | featselmethod=="limma1wayrepeat"){
    
    if(analysismode=="regression"){
      
      stop("Invalid analysis mode. Please set analysismode=\"classification\".")
    }else{
      suppressMessages(library(limma))
     # print("##############Level 1: Using LIMMA function to find differentially expressed metabolites###########")
    }
  }else{
    if(featselmethod=="RF"){
      
      #print("##############Level 1: Using random forest function to find discriminatory metabolites###########")
      
      
    }else{
      if(featselmethod=="RFcond"){
        suppressMessages(library(party))
       # print("##############Level 1: Using conditional random forest function to find discriminatory metabolites###########")
        #stop("Please use \"limma\", \"RF\", or \"MARS\".")
        
      }else{
        if(featselmethod=="MARS"){
          suppressMessages(library(earth))
          
        #  print("##############Level 1: Using MARS to find discriminatory metabolites###########")
          #log2.fold.change.thresh_list<-c(0)
        }else{
          
          if(featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="poissonreg" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="rfesvm" | 
             featselmethod=="wilcox" | featselmethod=="ttest" | featselmethod=="pamr" | featselmethod=="ttestrepeat" | featselmethod=="wilcoxrepeat" | featselmethod=="lmregrepeat"){
         #   print("##########Level 1: Finding discriminatory metabolites ###########")
            
            if(featselmethod=="logitreg"){
              
              featselmethod="lmreg"
              logistic_reg=TRUE
              poisson_reg=FALSE
            }else{
              
              if(featselmethod=="poissonreg"){
                poisson_reg=TRUE
                featselmethod="lmreg"
                logistic_reg=FALSE
              }else{
                logistic_reg=FALSE
                poisson_reg=FALSE
                
                if(featselmethod=="rfesvm"){
                  
                  suppressMessages(library(e1071))
                }else{
                  if(featselmethod=="pamr"){
                    
                    suppressMessages(library(pamr))
                  }else{
                    
                    if(featselmethod=="lm2wayanovarepeat" | featselmethod=="lm1wayanovarepeat"){
                      
                      suppressMessages(library(nlme))
                      suppressMessages(library(lsmeans))
                    }
                    
                  }
                  
                }
                
              }
              
            }
          }else{
            
            if(featselmethod=="pls" | featselmethod=="o1pls" | featselmethod=="o2pls" | featselmethod=="spls" | featselmethod=="spls1wayrepeat" | featselmethod=="spls2wayrepeat" | featselmethod=="pls2way" | featselmethod=="spls2way" | featselmethod=="o1spls" | featselmethod=="o2spls"){
              
              suppressMessages(library(mixOmics))
           #   suppressMessages(library(pls))
              suppressMessages(library(plsgenomics))
              
             # print("##########Level 1: Finding discriminatory metabolites ###########")
              
            }else{
              
              
              stop("Invalid featselmethod specified.")
            }
            
          }
          
          #stop("Invalid featselmethod specified. Please use \"limma\", \"RF\", or \"MARS\".")
        }
        
      }
      
    }
    
  }
  ####################################################################################
  
  
  dir.create(parentoutput_dir,showWarnings=FALSE)
  parentoutput_dir1<-paste(parentoutput_dir,"/Stage1/",sep="")
  
  dir.create(parentoutput_dir1,showWarnings=FALSE)
  
  setwd(parentoutput_dir1)	
  if(is.na(Xmat)[1]==TRUE){
    X<-read.table(feature_table_file,sep="\t",header=TRUE,stringsAsFactors=FALSE,check.names=FALSE)
    
  
    cnames<-colnames(X)
    
    cnames<- gsub(cnames,pattern="[\\s]*",replacement="",perl=TRUE)
    cnames<- gsub(cnames,pattern="[(|)|\\[|\\]]",replacement="",perl=TRUE)
    
    cnames<-gsub(cnames,pattern="\\||-|;|,|\\.",replacement="_",perl=TRUE)
    
    
    colnames(X)<-cnames
    
    cnames<-tolower(cnames)
    
    check_names<-grep(cnames,pattern="^name$")
    
    #if the Name column exists
    if(length(check_names)>0){
      
      if(check_names==1){
        
        check_names1<-grep(cnames,pattern="^mz$")
        check_names2<-grep(cnames,pattern="^time$")
        
        if(length(check_names1)<1 & length(check_names2)<1){
          mz<-seq(1.00001,nrow(X)+1,1)
          time<-seq(1.01,nrow(X)+1,1.00)
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          X<-as.data.frame(X)	
          Name<-as.character(X[,check_ind])
          if(length(which(duplicated(Name)==TRUE))>0){
            stop("Duplicate variable names are not allowed.")
          }
          X<-cbind(mz,time,X[,-check_ind])
          names_with_mz_time=cbind(Name,mz,time)		
          
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          X<-as.data.frame(X)
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
          
        }else{
          
          if(length(check_names1)>0 & length(check_names2)>0){
            
            check_ind<-gregexpr(cnames,pattern="^name$")
            check_ind<-which(check_ind>0)
            Name<-as.character(X[,check_ind])
            X<-X[,-check_ind]
            
            names_with_mz_time=cbind(Name,X$mz,X$time)
            colnames(names_with_mz_time)<-c("Name","mz","time")
            names_with_mz_time<-as.data.frame(names_with_mz_time)
            X<-as.data.frame(X)
            write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
          }
        }		
        
      }
    }else{
      
      #mz time format
      check_names1<-grep(cnames[1],pattern="^mz$")
      check_names2<-grep(cnames[2],pattern="^time$")
      if(length(check_names1)<1 || length(check_names2)<1){
        stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")			
      }
      
      #X<-X[order(X[,c(1,2)]),]
      
       X<-X[order(X[,c("mz")]),]
      X[,1]<-round(X[,1],5)
      X[,2]<-round(X[,2],2)
      
      mz_time<-paste(round(X[,1],5),"_",round(X[,2],2),sep="")
      if(length(which(duplicated(mz_time)==TRUE))>0){
        
        stop("Duplicate variable names are not allowed.")
      }
      Name<-mz_time
      names_with_mz_time=cbind(Name,X$mz,X$time)
      colnames(names_with_mz_time)<-c("Name","mz","time")
      names_with_mz_time<-as.data.frame(names_with_mz_time)
      X<-as.data.frame(X)
      write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
      
      
    } 
    
    X[,1]<-round(X[,1],5)
    X[,2]<-round(X[,2],2)
    
    Xmat<-t(X[,-c(1:2)])
    
    rownames(Xmat)<-colnames(X[,-c(1:2)])
    
    Xmat<-as.data.frame(Xmat)
    
    colnames(Xmat)<-names_with_mz_time$Name
    
  }else{
    X<-Xmat
    
    
    cnames<-colnames(X)
    
   
    cnames<- gsub(cnames,pattern="[\\s]*",replacement="",perl=TRUE)
    cnames<- gsub(cnames,pattern="[(|)|\\[|\\]]",replacement="",perl=TRUE)
    
    cnames<-gsub(cnames,pattern="\\||-|;|,|\\.",replacement="_",perl=TRUE)
    
    colnames(X)<-cnames
    
    
    cnames<-tolower(cnames)
    
    check_names<-grep(cnames,pattern="^name$")
    
    
    if(length(check_names)>0){
      
      if(check_names==1){
        
        check_names1<-grep(cnames,pattern="^mz$")
        check_names2<-grep(cnames,pattern="^time$")
        
        
        if(length(check_names1)<1 & length(check_names2)<1){
          mz<-seq(1.00001,nrow(X)+1,1)
          time<-seq(1.01,nrow(X)+1,1.00)
          check_ind<-gregexpr(cnames,pattern="^name$")
          check_ind<-which(check_ind>0)
          X<-as.data.frame(X)
          
          
          Name<-as.character(X[,check_ind])
          
          
          X<-cbind(mz,time,X[,-check_ind])
          names_with_mz_time=cbind(Name,mz,time)
          
          names_with_mz_time<-as.data.frame(names_with_mz_time)
          X<-as.data.frame(X)
          
          # print(getwd())
          
          
          write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
          
        }else{
          
          if(length(check_names1)>0 & length(check_names2)>0){
            
            check_ind<-gregexpr(cnames,pattern="^name$")
            check_ind<-which(check_ind>0)
            Name<-as.character(X[,check_ind])
            X<-X[,-check_ind]
            names_with_mz_time=cbind(Name,X$mz,X$time)
            colnames(names_with_mz_time)<-c("Name","mz","time")
            names_with_mz_time<-as.data.frame(names_with_mz_time)
            X<-as.data.frame(X)
            write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
          }
        }
        
      }
    }else{
      
      
      
      
      check_names1<-grep(cnames[1],pattern="^mz$")
      check_names2<-grep(cnames[2],pattern="^time$")
      if(length(check_names1)<1 || length(check_names2)<1){
        stop("Invalid feature table format. The format should be either Name in column A or mz and time in columns A and B. Please check example files.")
      }
      
      X[,1]<-round(X[,1],5)
      X[,2]<-round(X[,2],3)
      
      mz_time<-paste(round(X[,1],5),"_",round(X[,2],3),sep="")
      if(length(which(duplicated(mz_time)==TRUE))>0){
        
        stop("Duplicate variable names are not allowed.")
      }
      Name<-mz_time
      names_with_mz_time=cbind(Name,X$mz,X$time)
      colnames(names_with_mz_time)<-c("Name","mz","time")
      names_with_mz_time<-as.data.frame(names_with_mz_time)
      X<-as.data.frame(X)
      write.table(names_with_mz_time,file="Name_mz_time_mapping.txt",sep="\t",row.names=FALSE)
      
    }
    
    
    
    Xmat<-t(X[,-c(1:2)])
    
    rownames(Xmat)<-colnames(X[,-c(1:2)])
    Xmat<-as.data.frame(Xmat)
    colnames(Xmat)<-names_with_mz_time$Name
  }
  
 # if(featselmethod=="lmregrepeat" || featselmethod=="splsrepeat" || featselmethod=="plsrepeat" || featselmethod=="o1splsrepeat" || featselmethod=="lm1wayrepeat"){
  if(length(grep(featselmethod,pattern="repeat"))>0)
  {
    pairedanalysis=TRUE
  }
  
  ####saveXmat,file="Xmat.Rda")
  
  if(analysismode=="regression")
  {
    
    #log2.fold.change.thresh_list<-c(0)
    
    #print("Performing regression analysis")
    if(is.na(Ymat[1])==TRUE){
      classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
    
      
      Ymat<-classlabels			
    }else{
      classlabels<-Ymat
      
    }
    
    
    
    classlabels[,1]<- gsub(classlabels[,1],pattern="[\\s]*",replacement="",perl=TRUE)
    classlabels[,1]<- gsub(classlabels[,1],pattern="[(|)|\\[|\\]]",replacement="",perl=TRUE)
    
    classlabels[,1]<-gsub(classlabels[,1],pattern="\\||-|;|,|\\.",replacement="_",perl=TRUE)
    
    #classlabels[,1]<-gsub(classlabels[,1],pattern=" |-",replacement=".")
   # Ymat[,1]<-gsub(Ymat[,1],pattern=" |-",replacement=".")
    
    Ymat<-classlabels
    
    classlabels_orig<-classlabels
    classlabels_sub<-classlabels
    
    class_labels_levels<-c("A")
    
  
    
    if(featselmethod=="lmregrepeat" || featselmethod=="splsrepeat" || featselmethod=="plsrepeat" || featselmethod=="spls" || featselmethod=="pls" || featselmethod=="o1pls" || featselmethod=="o1splsrepeat"){
      if(pairedanalysis==TRUE){
        colnames(classlabels)<-c("SampleID","SubjectNum",paste("Response",sep=""))
        
        
        #Xmat<-chocolate[,1]
        Xmat_temp<-Xmat #t(Xmat)
        Xmat_temp<-cbind(classlabels,Xmat_temp)
        
        #Xmat_temp<-Xmat_temp[order(Xmat_temp[,3],Xmat_temp[,2]),]
        
        cnames<-colnames(Xmat_temp)
        
        factor_lastcol<-grep("^Response", cnames)
        
        classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
        
        subject_inf<-classlabels[,2]
        classlabels<-classlabels[,-c(2)]
        
        Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
      }
      
    }
    
    
    classlabels<-as.data.frame(classlabels)
    classlabels_response_mat<-classlabels[,-c(1)]
    classlabels_response_mat<-as.data.frame(classlabels_response_mat)
    Ymat<-classlabels
    Ymat<-as.data.frame(Ymat)
    
    
    
    rnames_xmat<-as.character(rownames(Xmat))
    rnames_ymat<-as.character(Ymat[,1])
    
    
    
    if(length(which(duplicated(rnames_ymat)==TRUE))>0){
      
      stop("Duplicate sample IDs are not allowed. Please represent replicates by _1,_2,_3.")
    }
    
    check_ylabel<-regexpr(rnames_ymat[1],pattern="^[0-9]*",perl=TRUE)
    check_xlabel<-regexpr(rnames_xmat[1],pattern="^X[0-9]*",perl=TRUE)
    
    
    if(length(check_ylabel)>0 && length(check_xlabel)>0){
      if(attr(check_ylabel,"match.length")>0 && attr(check_xlabel,"match.length")>0){
        
        rnames_ymat<-paste("X",rnames_ymat,sep="")
      }
    }
    
    match_names<-match(rnames_xmat,rnames_ymat)
    
    bad_colnames<-length(which(is.na(match_names)==TRUE))
    
   # save(rnames_xmat,rnames_ymat,Xmat,Ymat,file="debugnames.Rda")
    #   print("Check here2")
    #if(is.na()==TRUE){
    
    bool_names_match_check<-all(rnames_xmat==rnames_ymat)
    
    if(bad_colnames>0 | bool_names_match_check==FALSE){
      print("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names.")
      print("Sample names in feature table")
      print(head(rnames_xmat))
      print("Sample names in classlabels file")
      
      print(head(rnames_ymat))
      stop("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names. Please try again.")
    }
    
    Xmat<-t(Xmat)
    Xmat<-cbind(X[,c(1:2)],Xmat)
    Xmat<-as.data.frame(Xmat)
    
    rownames(Xmat)<-names_with_mz_time$Name
    
    num_features_total=nrow(Xmat)
    
    if(is.na(all(diff(match(rnames_xmat,rnames_ymat))))==FALSE){
      if(all(diff(match(rnames_xmat,rnames_ymat)) > 0)==TRUE){
        
        setwd("../")
        
        
        #data preprocess regression
        data_matrix<-data_preprocess(Xmat=Xmat,Ymat=Ymat,feature_table_file=feature_table_file,parentoutput_dir=parentoutput_dir,class_labels_file=NA,num_replicates=num_replicates,feat.filt.thresh=NA,summarize.replicates=summarize.replicates,summary.method=summary.method,
                                     all.missing.thresh=all.missing.thresh,group.missing.thresh=NA,
                                     log2transform=log2transform,medcenter=medcenter,znormtransform=znormtransform,,quantile_norm=quantile_norm,lowess_norm=lowess_norm,
                                     rangescaling=rangescaling,paretoscaling=paretoscaling,mstus=mstus,sva_norm=sva_norm,eigenms_norm=eigenms_norm,
                                     vsn_norm=vsn_norm,madscaling=madscaling,missing.val=0,samplermindex=NA, rep.max.missing.thresh=rep.max.missing.thresh,
                                     summary.na.replacement=summary.na.replacement,featselmethod=featselmethod,TIC_norm=TIC_norm,normalization.method=normalization.method,
                                     input.intensity.scale=input.intensity.scale,log2.transform.constant=log2.transform.constant,alphabetical.order=alphabetical.order)
        
      }
    }else{
      
      #print(diff(match(rnames_xmat,rnames_ymat)))
      stop("Orders of feature table and classlabels do not match")
    }
    
    
  }else{
    if(analysismode=="classification")
    {
      
      analysistype="oneway"
      
      classlabels_sub<-NA
      
      if(featselmethod=="limma2way" | featselmethod=="lm2wayanova" | featselmethod=="spls2way"){
        analysistype="twoway"
      }else{
        
        if(featselmethod=="limma2wayrepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="spls2wayrepeat"){
          analysistype="twowayrepeat"
          pairedanalysis=TRUE
        }else{
          
          if(featselmethod=="limma1wayrepeat" | featselmethod=="lm1wayanovarepeat" | featselmethod=="spls1wayrepeat" |  featselmethod=="lmregrepeat" | featselmethod=="ttestrepeat" | featselmethod=="wilcoxrepeat"){
            analysistype="onewayrepeat"
            pairedanalysis=TRUE
          }
          
        }
        
      }
      
      

      
      
      if(is.na(Ymat)[1][1]==TRUE){
        classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
        
 
        Ymat<-classlabels
        
      }else{
        classlabels<-Ymat
        
      }
      
      classlabels[,1]<- gsub(classlabels[,1],pattern="[\\s]*",replacement="",perl=TRUE)
      classlabels[,1]<- gsub(classlabels[,1],pattern="[(|)|\\[|\\]]",replacement="",perl=TRUE)
      
      classlabels[,1]<-gsub(classlabels[,1],pattern="\\||-|;|,|\\.",replacement="_",perl=TRUE)
      
      #classlabels[,1]<-gsub(classlabels[,1],pattern=" |-",replacement=".")
      # Ymat[,1]<-gsub(Ymat[,1],pattern=" |-",replacement=".")
      
      Ymat<-classlabels
      
     # classlabels[,1]<-gsub(classlabels[,1],pattern=" |-",replacement=".")
      Ymat[,1]<-gsub(Ymat[,1],pattern=" |-",replacement=".")
      
     # print(paste("Number of samples in class labels file:",dim(Ymat)[1],sep=""))
      #print(paste("Number of samples in feature table:",dim(Xmat)[1],sep=""))
      
      if(dim(Ymat)[1]!=(dim(Xmat)[1]))
      {
        
        stop("Number of samples are different in feature table and class labels file.")
      }
      
      
      if(fdrmethod=="none"){
        
        fdrthresh=pvalue.thresh
      }
      
      if(featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="limma2wayrepeat" | featselmethod=="limma1way" | featselmethod=="limma1wayrepeat" | 
         featselmethod=="MARS" | featselmethod=="RF" | featselmethod=="pls" | featselmethod=="o1pls" | featselmethod=="o2pls" | featselmethod=="lmreg" | featselmethod=="logitreg" | 
         featselmethod=="spls" | featselmethod=="pls1wayrepeat" | featselmethod=="spls1wayrepeat" | featselmethod=="pls2wayrepeat" | 
         featselmethod=="spls2wayrepeat" | featselmethod=="pls2way" | featselmethod=="spls2way" | featselmethod=="o1spls" | 
         featselmethod=="o2spls" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | 
         featselmethod=="lm2wayanovarepeat" | featselmethod=="rfesvm" | featselmethod=="wilcox" | featselmethod=="ttest" | 
         featselmethod=="pamr" | featselmethod=="ttestrepeat" | featselmethod=="poissonreg" | featselmethod=="wilcoxrepeat" | featselmethod=="lmregrepeat")
      {
        #analysismode="classification"
        
        #save(classlabels,file="thisclasslabels.Rda")
        #if(is.na(Ymat)[1]==TRUE)
        {
          #classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
          
          if(analysismode=="classification"){
            if(featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="poissonreg")
            {
              if(alphabetical.order==FALSE){
                classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
              }
              
              levels_classA<-levels(factor(classlabels[,2]))
              for(l1 in levels_classA){
                g1<-grep(x=l1,pattern="[0-9]")
                
                if(length(g1)>0){
                  #stop("Class labels or factor levels should not have any numbers.")
                }
              }
              
            }else{
              
              if(featselmethod=="lmregrepeat"){
                if(alphabetical.order==FALSE){
                  classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
                }
                
                levels_classA<-levels(factor(classlabels[,3]))
                for(l1 in levels_classA){
                  g1<-grep(x=l1,pattern="[0-9]")
                  
                  if(length(g1)>0){
                    #stop("Class labels or factor levels should not have any numbers.")
                  }
                }
                  
              }else{
              for(c1 in 2:dim(classlabels)[2]){
                
                if(alphabetical.order==FALSE){
                  classlabels[,c1] <- factor(classlabels[,c1], levels=unique(classlabels[,c1]))
                }
                levels_classA<-levels(factor(classlabels[,c1]))
                for(l1 in levels_classA){
                  g1<-grep(x=l1,pattern="[0-9]")
                  
                  if(length(g1)>0){
                    #stop("Class labels or factor levels should not have any numbers.")
                  }
                  
                }
                
              }
            }
            }
          }
          
          
          classlabels_orig<-classlabels
          
          
          if(featselmethod=="limma1way"){
            
            featselmethod="limma"
          }
          
          
          
          
          # | featselmethod=="limma1wayrepeat"
          if(featselmethod=="limma" | featselmethod=="limma1way" | featselmethod=="MARS" | featselmethod=="RF" | featselmethod=="pls" | featselmethod=="o1pls" | featselmethod=="o2pls" | featselmethod=="lmreg" | 
             featselmethod=="logitreg" | featselmethod=="spls" | featselmethod=="o1spls" | featselmethod=="o2spls" | featselmethod=="rfesvm" | featselmethod=="pamr" | 
             featselmethod=="poissonreg" | featselmethod=="ttest" | featselmethod=="wilcox" | featselmethod=="lm1wayanova")
          {
            
            
            if(featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="poissonreg")
            {
              factor_inf<-classlabels[,-c(1)]
              factor_inf<-as.data.frame(factor_inf)
              #print(factor_inf)
              
              classlabels_orig<-colnames(classlabels[,-c(1)])
              colnames(classlabels)<-c("SampleID",paste("Factor",seq(1,dim(factor_inf)[2]),sep=""))
              
              Xmat_temp<-Xmat #t(Xmat)
              
              #print(Xmat_temp[1:2,1:3])
              Xmat_temp<-cbind(classlabels,Xmat_temp)
              #print("here")				
              
              if(alphabetical.order==TRUE){
              Xmat_temp<-Xmat_temp[order(Xmat_temp[,2]),]
              }else{
                if(analysismode=="classification"){
                    Xmat_temp[,2] <- factor(Xmat_temp[,2], levels=unique(Xmat_temp[,2]))
                }
              }
              
              cnames<-colnames(Xmat_temp)
              
              factor_lastcol<-grep("^Factor", cnames)
              
              classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
              
              levels_classA<-levels(factor(classlabels[,2]))
              
             
              factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
              
            
              classlabels_class<-as.factor(classlabels[,2])
              classtable1<-table(classlabels[,2])
              
              classlabels_xyplots<-classlabels
              #classlabels_orig<-classlabels
              
              # classlabels_orig<-classlabels_orig[seq(1,dim(classlabels)[1],num_replicates),]
              classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
              classlabels_xyplots<-classlabels
              
              rownames(Xmat_temp)<-as.character(Xmat_temp[,1])
              Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
              
              classlabels_response_mat<-classlabels[,-c(1)]
              
              classlabels<-as.data.frame(classlabels)
              
              #keeps the class order as in the input file
              if(alphabetical.order==FALSE){
                classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
              }
              classlabels_response_mat<-classlabels[,-c(1)]
              
              classlabels_response_mat<-as.data.frame(classlabels_response_mat)
              
              #colnames(classlabels_response_mat)<-as.character(classlabels_orig)
              
              
              
              
              Ymat<-classlabels
              
              classlabels_orig<-classlabels
              
            }else
            {
              
              
              
              if(dim(classlabels)[2]>2){
                if(pairedanalysis==FALSE){	
                  #print("Invalid classlabels file format. Correct format: \nColumnA: SampleID\nColumnB: Class")
                  print("Using the first column as sample ID and second column as Class. Ignoring additional columns.")
                  classlabels<-classlabels[,c(1:2)]
                }
              }
              
              if(analysismode=="classification")
              {
                factor_inf<-classlabels[,-c(1)]
                factor_inf<-as.data.frame(factor_inf)
                
                colnames(classlabels)<-c("SampleID",paste("Factor",seq(1,dim(factor_inf)[2]),sep=""))
                
                Xmat_temp<-Xmat #t(Xmat)
                
                Xmat_temp<-cbind(classlabels,Xmat_temp)
                
                #  	##save(Xmat_temp,file="Xmat_temp.Rda")
                rownames(Xmat_temp)<-as.character(Xmat_temp[,1])						
                
                   
                if(alphabetical.order==TRUE){
                  
                  Xmat_temp<-Xmat_temp[order(Xmat_temp[,2]),]
                  
              
                }else{
                  Xmat_temp[,2] <- factor(Xmat_temp[,2], levels=unique(Xmat_temp[,2]))
                  
                 
                }
                
                cnames<-colnames(Xmat_temp)
                
                factor_lastcol<-grep("^Factor", cnames)
                
                classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
                
                
                Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
                
                
                levels_classA<-levels(factor(classlabels[,2]))
                
               
                factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
                
               
                
                classlabels_class<-as.factor(classlabels[,2])
                
                classtable1<-table(classlabels[,2])
                
                classlabels_xyplots<-classlabels
                #classlabels_orig<-classlabels
                
                # classlabels_orig<-classlabels_orig[seq(1,dim(classlabels)[1],num_replicates),]
                classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
                
                #rownames(Xmat)<-rownames(Xmat_temp)
                classlabels_xyplots<-classlabels
                
                classlabels_sub<-classlabels[,-c(1)]
               
                if(alphabetical.order==FALSE){
                  classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
                  
                  
                  if(dim(classlabels)[2]>2){
                    #classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
                    stop("Invalid classlabels format.")
                  }
                }
              }
              
              classlabels_response_mat<-classlabels[,-c(1)]
              
              
              classlabels<-as.data.frame(classlabels)
              classlabels_response_mat<-classlabels[,-c(1)]
              classlabels_response_mat<-as.data.frame(classlabels_response_mat)
              
              #classlabels[,1]<-as.factor(classlabels[,1])
              Ymat<-classlabels
              
              classlabels_orig<-classlabels
              
            }
            
            #print("here 2")
            
          }
          
          if(featselmethod=="limma1wayrepeat"){
            factor_inf<-classlabels[,-c(1:2)]
            factor_inf<-as.data.frame(factor_inf)
            
            # print("here")
            colnames(classlabels)<-c("SampleID","SubjectNum",paste("Factor",seq(1,length(factor_inf)),sep=""))
            
            
            #Xmat<-chocolate[,1]
            Xmat_temp<-Xmat #t(Xmat)
            Xmat_temp<-cbind(classlabels,Xmat_temp)
            
            if(alphabetical.order==TRUE){
                Xmat_temp<-Xmat_temp[order(Xmat_temp[,3],Xmat_temp[,2]),]
            }else{
              
              Xmat_temp[,3] <- factor(Xmat_temp[,3], levels=unique(Xmat_temp[,3]))
              
              
            }
            
            cnames<-colnames(Xmat_temp)
            
            factor_lastcol<-grep("^Factor", cnames)
            
            classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
            
            if(alphabetical.order==FALSE){
             
              classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
              
              
            }
            
            subject_inf<-classlabels[,2]
            classlabels_sub<-classlabels[,-c(1)]
            subject_inf<-subject_inf[seq(1,dim(classlabels)[1],num_replicates)]
            classlabels<-classlabels[,-c(2)]
            
            levels_classA<-levels(factor(classlabels[,2]))
            
           
           factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
            
         
            classlabels_class<-as.factor(classlabels[,2])
            classtable1<-table(classlabels[,2])
            
            classlabels_xyplots<-classlabels
            #classlabels_orig<-classlabels
            
            # classlabels_orig<-classlabels_orig[seq(1,dim(classlabels)[1],num_replicates),]
            classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
            
            classlabels_xyplots<-classlabels
            
            Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
            
            classlabels_response_mat<-classlabels[,-c(1)]
            
            classlabels<-as.data.frame(classlabels)
            classlabels_response_mat<-classlabels[,-c(1)]
            classlabels_response_mat<-as.data.frame(classlabels_response_mat)
            Ymat<-classlabels
            
            
            
            if(featselmethod=="limma1wayrepeat"){	
              featselmethod="limma"
              pairedanalysis = TRUE
            }else{
              
              if(featselmethod=="spls1wayrepeat"){
                featselmethod="spls"
                pairedanalysis = TRUE
              }else{
                if(featselmethod=="pls1wayrepeat"){
                  featselmethod="pls"
                  pairedanalysis = TRUE
                }
              }
            }
            pairedanalysis = TRUE
            
          }
          
          
          
          if(featselmethod=="limma2way"){
            
            factor_inf<-classlabels[,-c(1)]
            factor_inf<-as.data.frame(factor_inf)
            
            colnames(classlabels)<-c("SampleID",paste("Factor",seq(1,dim(factor_inf)[2]),sep=""))
            
            Xmat_temp<-Xmat #t(Xmat)
            
            ####saveXmat,file="Xmat.Rda")
            
            ####saveclasslabels,file="Xmat_classlabels.Rda")
            
            if(dim(classlabels)[2]>2){
              
              
             # save(Xmat_temp,classlabels,file="Xmat_temp_limma.Rda")
              
              
              Xmat_temp<-cbind(classlabels,Xmat_temp)
              
              
              
              
              #		print(Xmat_temp[1:10,1:10])
              
             if(alphabetical.order==TRUE){
                  Xmat_temp<-Xmat_temp[order(Xmat_temp[,2],Xmat_temp[,3]),]
              }else{
                Xmat_temp[,2] <- factor(Xmat_temp[,2], levels=unique(Xmat_temp[,2]))
                Xmat_temp[,3] <- factor(Xmat_temp[,3], levels=unique(Xmat_temp[,3]))
                
              }
              #		print(Xmat_temp[1:10,1:10])
              cnames<-colnames(Xmat_temp)
              
              factor_lastcol<-grep("^Factor", cnames)
              
              classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
              
              Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
              classlabels_sub<-classlabels[,-c(1)]
              
              classlabels_response_mat<-classlabels[,-c(1)]
              classlabels<-as.data.frame(classlabels)
              
              classlabels_response_mat<-as.data.frame(classlabels_response_mat)
              
              if(alphabetical.order==FALSE){
                classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
                classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
              }
              levels_classA<-levels(factor(classlabels[,2]))
              
              levels_classB<-levels(factor(classlabels[,3]))
              factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
              
              factor2_msg=(paste("Factor 2 levels: ",paste(levels_classB,collapse=","),sep=""))
              
              classlabels_class<-as.factor(classlabels[,2]):as.factor(classlabels[,3])
              classtable1<-table(classlabels[,2],classlabels[,3])
              
              classlabels_xyplots<-classlabels
           
              
              #Change v1.0.9.44: Commented this line on 3/1/2022 at 11:43 AM 
             # classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
              Ymat<-classlabels
              
              
            
              classlabels<-as.data.frame(classlabels)
              #classlabels_response_mat<-classlabels[,-c(1)]
              #classlabels_response_mat<-as.data.frame(classlabels_response_mat)
              Ymat<-classlabels
              
              
              #classlabels_orig<-classlabels
              
              
              
            }
            else{
              stop("Only one factor specificied in the class labels file.")			
            }
            
          }
          
          
          
          if(featselmethod=="limma2wayrepeat"){
            factor_inf<-classlabels[,-c(1:2)]
            factor_inf<-as.data.frame(factor_inf)
            
            
            
            colnames(classlabels)<-c("SampleID","SubjectNum",paste("Factor",seq(1,dim(factor_inf)[2]),sep=""))
            
            Xmat_temp<-Xmat
            if(dim(classlabels)[2]>2)
            {
              
              levels_classA<-levels(factor(classlabels[,3]))
              
              if(length(levels_classA)>2){
                
                #stop("Factor 1 can only have two levels/categories. Factor 2 can have upto 6 levels. \nPlease rearrange the factors in your classlabels file.")
                #	classtemp<-classlabels[,3]
                #	classlabels[,3]<-classlabels[,4]
                #	classlabels[,4]<-classtemp
              }
              
              levels_classA<-levels(factor(classlabels[,3]))
              
              if(length(levels_classA)>2){
                #stop("Only one of the factors can have more than 2 levels/categories. \nPlease rearrange the factors in your classlabels file or use lm2wayanovarepeat.")
                #stop("Please select lm2wayanova or lm2wayanovarepeat option for greater than 2x2 designs.")
               # stop("Factor 1 can only have two levels/categories. Factor 2 can have upto 6 levels. \nPlease rearrange the factors in your classlabels file. Or use lm2wayanova option.")
              }
              
              levels_classB<-levels(factor(classlabels[,4]))
              if(length(levels_classB)>7){
                #stop("Only one of the factors can have more than 2 levels/categories. \nPlease rearrange the factors in your classlabels file or use lm2wayanova.")
                
               # stop("Please select lm2wayanovarepeat option for greater than 2x7 designs.")
              }							
              
              
              Xmat_temp<-cbind(classlabels,Xmat_temp)
              
              
              
              if(alphabetical.order==TRUE){
                #Xmat_temp<-Xmat_temp[order(Xmat_temp[,2],Xmat_temp[,3]),]
                
                Xmat_temp<-Xmat_temp[order(Xmat_temp[,3],Xmat_temp[,4],Xmat_temp[,2]),]
                
              }else{
                Xmat_temp[,4] <- factor(Xmat_temp[,4], levels=unique(Xmat_temp[,4]))
                Xmat_temp[,3] <- factor(Xmat_temp[,3], levels=unique(Xmat_temp[,3]))
                
              }
              
            
              cnames<-colnames(Xmat_temp)
              
              factor_lastcol<-grep("^Factor", cnames)
              
              classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
              
              classlabels_sub<-classlabels[,-c(1)]
              subject_inf<-classlabels[,2]
              classlabels<-classlabels[,-c(2)]
              
              classlabels_response_mat<-classlabels[,-c(1)]
              classlabels<-as.data.frame(classlabels)
              
              classlabels_response_mat<-as.data.frame(classlabels_response_mat)
              
              classlabels_xyplots<-classlabels
              subject_inf<-subject_inf[seq(1,dim(classlabels)[1],num_replicates)]
              
              write.table(classlabels,file="organized_classlabelsA1.txt",sep="\t",row.names=FALSE)
              Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
              
              
              #write.table(Xmat_temp,file="organized_featuretableA1.txt",sep="\t",row.names=TRUE)
              
              if(alphabetical.order==FALSE){
                classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
                classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
                
              }
              
              levels_classA<-levels(factor(classlabels[,2]))
              
              levels_classB<-levels(factor(classlabels[,3]))
             factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
              
              factor2_msg=(paste("Factor 2 levels: ",paste(levels_classB,collapse=","),sep=""))
              classlabels_class<-as.factor(classlabels[,2]):as.factor(classlabels[,3])
              classtable1<-table(classlabels[,2],classlabels[,3])
              
              #classlabels_orig<-classlabels
              #classlabels<-cbind(as.character(classlabels[,1]),as.character(classlabels_class))
              
             
              #Change v1.0.9.44: Commented this line on 3/1/2022 at 11:57 AM
               #classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
              
              Ymat<-classlabels
              
              
            #  print("Class labels file limma2wayrep:")
             # print(head(classlabels))
              #rownames(Xmat)<-as.character(classlabels[,1])
              
              write.table(classlabels,file="organized_classlabels.txt",sep="\t",row.names=FALSE)
              
              Xmat1<-cbind(classlabels,Xmat)
              #write.table(Xmat1,file="organized_featuretable.txt",sep="\t",row.names=TRUE)
              
              featselmethod="limma2way"
              pairedanalysis = TRUE
              
            }
            else{
              stop("Only one factor specificied in the class labels file.")			
            }
          }
          
          
          
        }
        
        classlabels<-as.data.frame(classlabels)
        
        
        
        
        
        
        
        
        if(featselmethod=="lm2wayanova" | featselmethod=="pls2way" | featselmethod=="spls2way"){
          
          analysismode="classification"
          
          #classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
          
          if(is.na(Ymat)[1]==TRUE){
            classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
            Ymat<-classlabels
            
          }else{
            classlabels<-Ymat
            
          }
          
          
          
          #cnames[2]<-"Factor1"
          
          cnames<-colnames(classlabels)
          
          factor_inf<-classlabels[,-c(1)]
          factor_inf<-as.data.frame(factor_inf)
          
          colnames(classlabels)<-c("SampleID",paste("Factor",seq(1,dim(factor_inf)[2]),sep=""))
          
          analysismode="classification"
          
          Xmat_temp<-Xmat #t(Xmat)
          
        #  save(Xmat_temp,classlabels,file="Xmat_temp_lm2way.Rda")
          
          
          
          Xmat_temp<-cbind(classlabels,Xmat_temp)
          
          
          rnames_xmat<-rownames(Xmat)
          rnames_ymat<-as.character(Ymat[,1])
          
          
          # ###saveXmat_temp,file="Xmat_temp.Rda")
          
          
            if(featselmethod=="lm2wayanova" | featselmethod=="pls2way" | featselmethod=="spls2way"){
              
              if(alphabetical.order==TRUE){
                Xmat_temp<-Xmat_temp[order(Xmat_temp[,2],Xmat_temp[,3]),]
              }
              
            }
          
          cnames<-colnames(Xmat_temp)
          
          factor_lastcol<-grep("^Factor", cnames)
          
      #   save(Xmat_temp,classlabels,factor_lastcol,file="debudsort.Rda")
          
          if(alphabetical.order==FALSE){
            
            Xmat_temp[,2] <- factor(Xmat_temp[,2], levels=unique(Xmat_temp[,2]))
            Xmat_temp[,3] <- factor(Xmat_temp[,3], levels=unique(Xmat_temp[,3]))
            
            classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
            
            classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
            classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
            
          }else{
            
            classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
            
          }
          
          levels_classA<-levels(factor(classlabels[,2]))
          levels_classB<-levels(factor(classlabels[,3]))
          
         factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
         factor2_msg=(paste("Factor 2 levels: ",paste(levels_classB,collapse=","),sep=""))
          
          classlabels_sub<-classlabels[,-c(1)]
          
          classlabels_response_mat<-classlabels[,-c(1)]
          
          
          Ymat<-classlabels
          
          classlabels_orig<-classlabels
          
          #Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
          ###save(Xmat,file="Xmat2.Rda")
          if(featselmethod=="lm2wayanova" | featselmethod=="pls2way" | featselmethod=="spls2way"){
            
            
            classlabels_class<-as.factor(classlabels[,2]):as.factor(classlabels[,3])
            classtable1<-table(classlabels[,2],classlabels[,3])
            
            classlabels_xyplots<-classlabels
            #classlabels_orig<-classlabels
            
            # classlabels_orig<-classlabels_orig[seq(1,dim(classlabels)[1],num_replicates),]
            classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
            Ymat<-classlabels
            if(featselmethod=="pls2way"){
              featselmethod="pls"
            }else{
              
              if(featselmethod=="spls2way"){
                featselmethod="spls"
              }
            }
            
          }
          
          
          # write.table(classlabels,file="organized_classlabelsB.txt",sep="\t",row.names=FALSE)
          Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
          
          
          #write.table(Xmat_temp,file="organized_featuretableA.txt",sep="\t",row.names=TRUE)
          #write.table(classlabels,file="organized_classlabelsA.txt",sep="\t",row.names=FALSE)
          
          
        }
        
        if(featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="pls1wayrepeat" | featselmethod=="spls1wayrepeat" | featselmethod=="pls2wayrepeat" | 
           featselmethod=="spls2wayrepeat" | featselmethod=="ttestrepeat" | featselmethod=="wilcoxrepeat" | featselmethod=="lmregrepeat"){
          
    
          #analysismode="classification"
          pairedanalysis=TRUE
          #							classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
          
          
          if(is.na(Ymat)[1]==TRUE){
            classlabels<-read.table(class_labels_file,sep="\t",header=TRUE)
            Ymat<-classlabels
            
          }else{
            classlabels<-Ymat
            
          }
          
          
          cnames<-colnames(classlabels)
          
          factor_inf<-classlabels[,-c(1:2)]
          factor_inf<-as.data.frame(factor_inf)
          
          colnames(classlabels)<-c("SampleID","SubjectNum",paste("Factor",seq(1,dim(factor_inf)[2]),sep=""))
          
          classlabels_orig<-classlabels
          #Xmat<-chocolate[,1]
          Xmat_temp<-Xmat #t(Xmat)
          Xmat_temp<-cbind(classlabels,Xmat_temp)
          
          save(Xmat_temp,file="Xmat_temp1.Rda")
          
          pairedanalysis=TRUE
          if(featselmethod=="lm1wayanovarepeat" | featselmethod=="pls1wayrepeat" | featselmethod=="spls1wayrepeat" | featselmethod=="ttestrepeat" | featselmethod=="wilcoxrepeat" | featselmethod=="lmregrepeat"){
            
            if(alphabetical.order==TRUE){
            Xmat_temp<-Xmat_temp[order(Xmat_temp[,3],Xmat_temp[,2]),]
            }else{
              Xmat_temp[,3] <- factor(Xmat_temp[,3], levels=unique(Xmat_temp[,3]))
              
            }
            
            
           
            
            
            cnames<-colnames(Xmat_temp)
            
            factor_lastcol<-grep("^Factor", cnames)
            
            classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
            
            subject_inf<-classlabels[,2]
            
            subject_inf<-subject_inf[seq(1,dim(classlabels)[1],num_replicates)]
            
            classlabels_response_mat<-classlabels[,-c(1:2)]
            
            
            
            # classlabels_orig<-classlabels
            classlabels_sub<-classlabels[,-c(1)]
            
            if(alphabetical.order==FALSE){
              classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
            }
            
            levels_classA<-levels(factor(classlabels[,3]))
            factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
            
            
            classlabels<-classlabels[,-c(2)]
            
            if(alphabetical.order==FALSE){
              classlabels[,2] <- factor(classlabels[,2], levels=unique(classlabels[,2]))
            }
            
            classlabels_class<-classlabels[,2]
            
            classtable1<-table(classlabels[,2])
            
            
            #classlabels<-cbind(as.character(classlabels[,1]),as.character(classlabels_class))
            
            classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
            
            Ymat<-classlabels
            
            classlabels_xyplots<-classlabels
            
            
            # classlabels<-classlabels[seq(1,dim(classlabels)[1],num_replicates),]
            Ymat<-classlabels
            
            Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
            
            
            
            # write.table(Xmat_temp,file="organized_featuretableA.txt",sep="\t",row.names=FALSE)
            
            ####saveYmat,file="Ymat.Rda")
            #                                       ###saveXmat,file="Xmat.Rda")
            
            if(featselmethod=="spls1wayrepeat"){
              featselmethod="spls"
              
            }else{
              if(featselmethod=="pls1wayrepeat"){
                featselmethod="pls"
              }														
            }
            
            
            if(featselmethod=="wilcoxrepeat"){
              
              featselmethod=="wilcox"
              pairedanalysis=TRUE
            }
            
            if(featselmethod=="ttestrepeat"){
              
              featselmethod=="ttest"
              pairedanalysis=TRUE
            }
            
            
            print("AT this step")
            print(pairedanalysis)
            
          }
          if(featselmethod=="lm2wayanovarepeat" | featselmethod=="pls2wayrepeat" | featselmethod=="spls2wayrepeat"){
            
            if(alphabetical.order==TRUE){
            Xmat_temp<-Xmat_temp[order(Xmat_temp[,3],Xmat_temp[,4],Xmat_temp[,2]),]
            }else{
              
              Xmat_temp[,3] <- factor(Xmat_temp[,3], levels=unique(Xmat_temp[,3]))
              Xmat_temp[,4] <- factor(Xmat_temp[,4], levels=unique(Xmat_temp[,4]))
            }
            
            
            
            
            cnames<-colnames(Xmat_temp)
            
            factor_lastcol<-grep("^Factor", cnames)
            
            classlabels<-Xmat_temp[,c(1:factor_lastcol[length(factor_lastcol)])]
            classlabels_sub<-classlabels[,-c(1)]
            
            subject_inf<-classlabels[,2]
            
            subject_inf<-subject_inf[seq(1,dim(classlabels)[1],num_replicates)]
            classlabels_response_mat<-classlabels[,-c(1:2)]
            
            Ymat<-classlabels
            
            
            
            classlabels_xyplots<-classlabels[,-c(2)]
            
            if(alphabetical.order==FALSE){
              classlabels[,4] <- factor(classlabels[,4], levels=unique(classlabels[,4]))
              classlabels[,3] <- factor(classlabels[,3], levels=unique(classlabels[,3]))
            }
            
            levels_classA<-levels(factor(classlabels[,3]))
            factor1_msg=(paste("Factor 1 levels: ",paste(levels_classA,collapse=","),sep=""))
            levels_classB<-levels(factor(classlabels[,4]))
            
            factor2_msg=(paste("Factor 2 levels: ",paste(levels_classB,collapse=","),sep=""))
            Ymat<-classlabels
            
            
            #print(head(classlabels))
            
            
            classlabels<-classlabels[,-c(2)]
            
            classlabels_class<-paste(classlabels[,2],":",classlabels[,3],sep="")
            
            classtable1<-table(classlabels[,2],classlabels[,3])
            
            
            #classlabels<-cbind(as.character(classlabels[,1]),as.character(classlabels_class))
            
            classlabels<-cbind(as.data.frame(classlabels[,1]),as.data.frame(classlabels_class))
            
            Ymat<-classlabels
            
            
            # write.table(classlabels,file="organized_classlabelsA1.txt",sep="\t",row.names=FALSE)
            Xmat<-Xmat_temp[,-c(1:factor_lastcol[length(factor_lastcol)])]
            
            
            
            
            #write.table(Xmat_temp,file="organized_featuretableA.txt",sep="\t",row.names=FALSE)
            #write.table(Xmat,file="organized_featuretableB1.txt",sep="\t",row.names=FALSE)
            pairedanalysis=TRUE
            if(featselmethod=="spls2wayrepeat"){
              featselmethod="spls"
              
            }
          }
      
          
          
        }
        
      }
      
      save(Xmat,Xmat_temp,file="Xmat1.Rda")
      
      rownames(Xmat)<-as.character(Xmat_temp[,1])
      
     # 
      #save(Ymat,file="Ymat1.Rda")
      rnames_xmat<-rownames(Xmat)
      rnames_ymat<-as.character(Ymat[,1])
      
      
      if(length(which(duplicated(rnames_ymat)==TRUE))>0){
        
        stop("Duplicate sample IDs are not allowed. Please represent replicates by _1,_2,_3.")
      }
      
      check_ylabel<-regexpr(rnames_ymat[1],pattern="^[0-9]*",perl=TRUE)
      check_xlabel<-regexpr(rnames_xmat[1],pattern="^X[0-9]*",perl=TRUE)
      
      if(length(check_ylabel)>0 && length(check_xlabel)>0){
        if(attr(check_ylabel,"match.length")>0 && attr(check_xlabel,"match.length")>0){
          
          rnames_ymat<-paste("X",rnames_ymat,sep="") #gsub(rnames_ymat,pattern="\\.[0-9]*",replacement="")
          
          
        }
      }
      
      
      
      Xmat<-t(Xmat)
      
      
      
      colnames(Xmat)<-as.character(Ymat[,1])
      
      Xmat<-cbind(X[,c(1:2)],Xmat)
      
      Xmat<-as.data.frame(Xmat)
      Ymat<-as.data.frame(Ymat)
      
      
      match_names<-match(rnames_xmat,rnames_ymat)
      
      bad_colnames<-length(which(is.na(match_names)==TRUE))
      
      #print(match_names) 
      #if(is.na()==TRUE){
     #save(rnames_xmat,rnames_ymat,Xmat,Ymat,file="debugnames.Rda")
      
      bool_names_match_check<-all(rnames_xmat==rnames_ymat)
      
      if(bad_colnames>0 | bool_names_match_check==FALSE){
        
     # if(bad_colnames>0){
        print("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names.")
        print("Sample names in feature table")
        print(head(rnames_xmat))
        print("Sample names in classlabels file")
        
        print(head(rnames_ymat))
        stop("Sample names do not match between feature table and class labels files.\n Please try replacing any \"-\" with \".\" in sample names. Please try again.")
      }
      
      if(is.na(all(diff(match(rnames_xmat,rnames_ymat))))==FALSE){
        if(all(diff(match(rnames_xmat,rnames_ymat)) > 0)==TRUE){
          
          setwd("../")
          
          
          
         #save(Xmat,Ymat,names_with_mz_time,feature_table_file,parentoutput_dir,class_labels_file,num_replicates,feat.filt.thresh,summarize.replicates,
          #    summary.method,all.missing.thresh,group.missing.thresh,missing.val,samplermindex,rep.max.missing.thresh,summary.na.replacement,featselmethod,pairedanalysis,input.intensity.scale,file="data_preprocess_in.Rda")
          ######
          
         rownames(Xmat)<-names_with_mz_time$Name
         
         num_features_total=nrow(Xmat)
          #data preprocess classification
          data_matrix<-data_preprocess(Xmat=Xmat,Ymat=Ymat,feature_table_file=feature_table_file,parentoutput_dir=parentoutput_dir,class_labels_file=NA,num_replicates=num_replicates,feat.filt.thresh=NA,summarize.replicates=summarize.replicates,summary.method=summary.method,
                                       all.missing.thresh=all.missing.thresh,group.missing.thresh=group.missing.thresh,
                                       log2transform=log2transform,medcenter=medcenter,znormtransform=znormtransform,,quantile_norm=quantile_norm,lowess_norm=lowess_norm,rangescaling=rangescaling,paretoscaling=paretoscaling,
                                       mstus=mstus,sva_norm=sva_norm,eigenms_norm=eigenms_norm,vsn_norm=vsn_norm,madscaling=madscaling,missing.val=missing.val, rep.max.missing.thresh=rep.max.missing.thresh,
                                       summary.na.replacement=summary.na.replacement,featselmethod=featselmethod,TIC_norm=TIC_norm,normalization.method=normalization.method,
                                       input.intensity.scale=input.intensity.scale,log2.transform.constant=log2.transform.constant,alphabetical.order=alphabetical.order)
          
        #  save(data_matrix,names_with_mz_time,file="data_preprocess_out.Rda")
          
        }else{
          
          
          stop("Orders of feature table and classlabels do not match")
        }
        
        
        
      }else{
        
        #print(diff(match(rnames_xmat,rnames_ymat)))
        stop("Orders of feature table and classlabels do not match")
      }
      
      
      
      if(FALSE){
        data_matrix<-data_preprocess(Xmat,Ymat,
                                     feature_table_file,
                                     parentoutput_dir="C:/Users/kuppal2/Documents/Projects/EGCG_pos//xmsPANDA_preprocess3/",
                                     class_labels_file=NA,num_replicates=1,feat.filt.thresh=NA,summarize.replicates=TRUE,
                                     summary.method="mean", all.missing.thresh=0.5,group.missing.thresh=0.5,
                                     log2transform =FALSE, medcenter=FALSE, znormtransform = FALSE, 
                                     quantile_norm = FALSE, lowess_norm = FALSE, madscaling = FALSE, 
                                     missing.val=0, samplermindex=NA,rep.max.missing.thresh=0.5,summary.na.replacement="zeros")
        
      }
    }else{
      stop("Invalid value for analysismode parameter. Please use regression or classification.")
    }
    
    
  }
  
  if(is.na(names_with_mz_time)[1]==TRUE){
    names_with_mz_time=data_matrix$names_with_mz_time
  }
  #  #save(data_matrix,file="data_matrix.Rda")
  data_matrix_beforescaling<-data_matrix$data_matrix_prescaling
  
  data_matrix_beforescaling<-as.data.frame( data_matrix_beforescaling)
  data_matrix<-data_matrix$data_matrix_afternorm_scaling
  
  
  
  
  
  
  #classlabels<-as.data.frame(classlabels)
  if(dim(classlabels)[2]<2){
    
    stop("The class labels/response matrix should have two columns: SampleID, Class/Response. Please see the example.")
  }
  
  
  
  data_m<-data_matrix[,-c(1:2)]
  classlabels<-classlabels[seq(1,dim(classlabels)[1],num_replicates),]
  

  classlabels_raw_boxplots<-classlabels
  
#  save(classlabels,data_matrix,classlabels_orig,Ymat,classlabels_raw_boxplots,file="classlabelsstage1.Rda")
  
  
  if(dim(classlabels)[2]==2){
    if(length(levels(as.factor(classlabels[,2])))==2){
      if(balance.classes==TRUE){
        
        table_classes<-table(classlabels[,2])
        
        
        suppressWarnings(library(ROSE))
        Ytrain<-classlabels[,2]
        data1=cbind(Ytrain,t(data_matrix[,-c(1:2)]))
        
        ##save(data1,classlabels,data_matrix,file="Stage1/data1.Rda")
        
        #   data_matrix_presim<-data_matrix
        
        data1<-as.data.frame(data1)
        
        colnames(data1)<-c("Ytrain",paste("var",seq(1,ncol(data1)-1),sep=""))
        
        data1$Ytrain<-classlabels[,2]
        
        if(table_classes[1]==table_classes[2])
        {
          
          
          set.seed(balance.classes.seed)
          
          data1[,-c(1)]<-apply(data1[,-c(1)],2,as.numeric)
          new_sample<-aggregate(x=data1[,-c(1)],by=list(as.factor(data1$Ytrain)),mean)
          colnames(new_sample)<-colnames(data1)
          data1<-rbind(data1,new_sample[1,])
          set.seed(balance.classes.seed)
          
          # #save(data1,classlabels,file="Stage1/dataB.Rda")
          
          newData <- ROSE((Ytrain) ~ ., data1, seed = balance.classes.seed,N=nrow(data1)*balance.classes.sizefactor)$data
          
          # newData <- SMOTE(Ytrain ~ ., data=data1, perc.over = 100)
          #*balance.classes.sizefactor,perc.under=200*(balance.classes.sizefactor/(balance.classes.sizefactor/0.5)))
          
        }else{
          if(balance.classes.method=="ROSE"){
            set.seed(balance.classes.seed)
            data1[,-c(1)]<-apply(data1[,-c(1)],2,as.numeric)
            
            
            newData <- ROSE((Ytrain) ~ ., data1, seed = balance.classes.seed,N=nrow(data1)*balance.classes.sizefactor)$data
          }else{
            
            set.seed(balance.classes.seed)
            newData <- SMOTE(Ytrain ~ ., data=data1, perc.over = 100)
            #*balance.classes.sizefactor,perc.under=200*(balance.classes.sizefactor/(balance.classes.sizefactor/0.5)))
            
          }
        }
        newData<-na.omit(newData)
        Xtrain<-newData[,-c(1)]
        Xtrain<-as.matrix(Xtrain)
        Ytrain<-newData[,c(1)]
        
        Ytrain_mat<-cbind((rownames(Xtrain)),(Ytrain))
        Ytrain_mat<-as.data.frame(Ytrain_mat)
        print("new data")
        print(dim(Xtrain))
        print(dim(Ytrain_mat))
        print(table(newData$Ytrain))
        
        data_m<-t(Xtrain)
        data_matrix<-cbind(data_matrix[,c(1:2)],data_m)
        classlabels<-cbind(paste("S",seq(1,nrow(newData)),sep=""),Ytrain)
        classlabels<-as.data.frame(classlabels)
        print(dim(classlabels))
        classlabels_orig<-classlabels
        classlabels_sub<-classlabels[,-c(1)]
        Ymat<-classlabels
        
        ##save(newData,file="Stage1/newData.Rda")
        
      }
    }
  }
  
  
  classlabelsA<-classlabels
  Xmat<-data_matrix
  
  
  #if(dim(classlabels_orig)==TRUE){
  
  
  
  
  
  classlabels_orig<-classlabels_orig[seq(1,dim(classlabels_orig)[1],num_replicates),]
  
  classlabels_response_mat<-as.data.frame(classlabels_response_mat)
  
  classlabels_response_mat<-classlabels_response_mat[seq(1,dim(classlabels_response_mat)[1],num_replicates),]
  
  
  
  class_labels_levels_main<-c("S")
  Ymat<-classlabels
  
  
  rnames1<-as.character(Ymat[,1])
  rnames2<-as.character(classlabels_orig[,1])
  
  sorted_index<-{}
  for(i in 1:length(rnames1)){
    
    
    sorted_index<-c(sorted_index,grep(x=rnames2,pattern=paste("^",rnames1[i],"$",sep="")))
    
  }
  classlabels_orig<-classlabels_orig[sorted_index,]
  
  #write.table(classlabels_response_mat,file="original_classlabelsB.txt",sep="\t",row.names=TRUE)
  classlabelsA<-classlabels
  
  
  if(length(which(duplicated(classlabels)==TRUE))>0){
    rownames(classlabels)<-paste("S",seq(1,dim(classlabels)[1]),sep="")
  }else{
    rownames(classlabels)<-as.character(classlabels[,1])
  }#as.character(classlabels[,1])
  #print(classlabels)
  #print(classlabels[1:10,])
  
#  save(classlabels,file="classlabels.Rda")
#  save(classlabels_orig,file="classlabels_orig.Rda")
  
 # save(classlabels_response_mat,file="classlabels_response_mat.Rda")
  
  if(pairedanalysis==TRUE){
    
    #save(subject_inf,file="subjectinf.Rda")
  }
  
  if(analysismode=="classification")
  {	
    
    
    class_labels_levels<-levels(as.factor(classlabels[,2]))
    
   # print("Using the following class labels")			
    #print(class_labels_levels)
    
    class_labels_levels_main<-class_labels_levels
    
    class_labels_levels<-unique(class_labels_levels)
    
    
    bad_rows<-which(class_labels_levels=="")
    if(length(bad_rows)>0){
      class_labels_levels<-class_labels_levels[-bad_rows]
    }
    ordered_labels={}
    num_samps_group<-new("list")
    num_samps_group[[1]]<-0
    groupwiseindex<-new("list")
    groupwiseindex[[1]]<-0
    
    for(c in 1:length(class_labels_levels))
    {
      
      classlabels_index<-which(classlabels[,2]==class_labels_levels[c])
      ordered_labels<-c(ordered_labels,as.character(classlabels[classlabels_index,2]))
      num_samps_group[[c]]<-length(classlabels_index)
      groupwiseindex[[c]]<-classlabels_index
    }
    
    Ymatorig<-classlabels
    
    #debugclasslabels
  # save(classlabels,class_labels_levels,num_samps_group,Ymatorig,data_matrix,data_m_fc_withfeats,data_m,file="classlabels_1.Rda")
    ####saveclass_labels_levels,file="class_labels_levels.Rda")
    
   # print("HERE1")

    classlabels_dataframe<-classlabels
      
      class_label_alphabets<-class_labels_levels
      classlabels<-{}
      
      if(length(class_labels_levels)==2){
        #num_samps_group[[1]]=length(which(ordered_labels==class_labels_levels[1]))
        #num_samps_group[[2]]=length(which(ordered_labels==class_labels_levels[2]))
        class_label_A<-class_labels_levels[[1]]
        class_label_B<-class_labels_levels[[2]]
        #classlabels<-c(rep("ClassA",num_samps_group[[1]]),rep("ClassB",num_samps_group[[2]]))
        classlabels<-c(rep(class_label_A,num_samps_group[[1]]),rep(class_label_B,num_samps_group[[2]]))
      }else{
        if(length(class_labels_levels)==3){
          
          class_label_A<-class_labels_levels[[1]]
          class_label_B<-class_labels_levels[[2]]
          class_label_C<-class_labels_levels[[3]]
          classlabels<-c(rep(class_label_A,num_samps_group[[1]]),rep(class_label_B,num_samps_group[[2]]),rep(class_label_C,num_samps_group[[3]]))
        }else{
          
          for(c in 1:length(class_labels_levels)){
            
            num_samps_group_cur=length(which(Ymatorig[,2]==class_labels_levels[c]))
            
            classlabels<-c(classlabels,rep(paste(class_labels_levels[c],sep=""),num_samps_group_cur))
            #,rep("ClassB",num_samps_group[[2]]),rep("ClassC",num_samps_group[[3]]))
            
          }
          
        }
      }
      #   print("Class mapping:")
      # print(cbind(class_labels_levels,classlabels))
      
      
      
    
    #Change: Made this conditional for one factor analyses in v1.0.9.44 on 3/1/2022 at 12:24 PM
      if(dim(classlabels_dataframe)[2]==2){
        
            classlabels<-classlabels_dataframe[,2]
      }else{
        classlabels<-factor(classlabels_dataframe[,2]):factor(classlabels_dataframe[,3])
        
      }
      
  
    classlabels_2=classlabels
    
    
  #  save(classlabels_2,classlabels_dataframe,classlabels,classlabels_orig,classlabels_response_mat,class_labels_levels,Ymatorig,data_matrix,data_m_fc_withfeats,data_m,file="classlabels_all.Rda")
    
    
    ####################################################################################
    #print(head(data_m))
    
    snames<-colnames(data_m)
    
    Ymat<-as.data.frame(classlabels)
    m1<-match(snames,Ymat[,1])
    #Ymat<-Ymat[m1,]
    
    data_temp<-data_matrix_beforescaling[,-c(1:2)]
    
    
   rnames<-paste("mzid_",seq(1,nrow(data_matrix)),sep="")
   rownames(data_m)=rnames
    
    mzid_mzrt<-data_matrix[,c(1:2)]
    colnames(mzid_mzrt)<-c("mz","time")
    rownames(mzid_mzrt)=rnames
    write.table(mzid_mzrt, file="Stage1/mzid_mzrt.txt",sep="\t",row.names=TRUE)
    
    
    cl<-makeCluster(num_nodes)
    
    
    
    mean_overall<-apply(data_temp,1,do_mean)
    
    #clusterExport(cl,"do_mean")
    #mean_overall<-parApply(cl,data_temp,1,do_mean)
    
    #stopCluster(cl)
    
    #mean_overall<-unlist(mean_overall)
   # print("mean overall")
    #print(summary(mean_overall))
    bad_feat<-which(mean_overall==0)
    
    if(length(bad_feat)>0){
      
      data_matrix_beforescaling<-data_matrix_beforescaling[-bad_feat,]
      data_m<-data_m[-bad_feat,]
      data_matrix<-data_matrix[-bad_feat,]
      
    } 
    
    
    #Step 5) RSD/CV calculation
    
    
  }else{
    
    classlabels<-(classlabels[,-c(1)])
  }
  
  #	print("######classlabels#########")
  #print(classlabels)
  
  
  class_labels_levels_new<-levels(classlabels)
  
  if(analysismode=="classification"){
    test_classlabels<-cbind(class_labels_levels_main,class_labels_levels_new)
  }
  
  if(featselmethod=="ttest" | featselmethod=="wilcox"){
    
    if(length(class_labels_levels)>2){
      
      print("#######################")
      print(paste("Warning: More than two classes detected. Invalid feature selection option. Skipping the feature selection for option ",featselmethod,sep=""))
      
      print("#######################")
      
      return("More than two classes detected. Invalid feature selection option.")
      
    }
    
  }
  
  
  #print("here 2")
  ######################################################################################
  
  #Step 6) Log2 mean fold change criteria from 0 to 1 with step of 0.1
  feat_eval<-{}
  feat_sigfdrthresh<-{}
  feat_sigfdrthresh_cv<-{}
  feat_sigfdrthresh_permut<-{}
  
  permut_acc<-{}
  feat_sigfdrthresh<-rep(0,length(log2.fold.change.thresh_list))
  feat_sigfdrthresh_cv<-rep(NA,length(log2.fold.change.thresh_list))
  
  feat_sigfdrthresh_permut<-rep(NA,length(log2.fold.change.thresh_list))
  res_score_vec<-rep(0,length(log2.fold.change.thresh_list))
  #feat_eval<-seq(0,1,0.1)
  
  if(analysismode=="classification"){
    
    best_cv_res<-(-1)*10^30
  }else{
    best_cv_res<-(1)*10^30
    
  }
  
  
  best_feats<-{}
  
  goodfeats<-{}
  mwan_fdr<-{}
  targetedan_fdr<-{}
  best_limma_res<-{}
  best_acc<-{}
  termA<-{}
  
  fheader="transformed_log2fc_threshold_"
  
  
  X<-t(data_m)
  
  X<-replace(as.matrix(X),which(is.na(X)==TRUE),0)
  
  
  
  
  
  # rm(pcaMethods)
  #try(detach("package:pcaMethods",unload=TRUE),silent=TRUE)
  #library(mixOmics)
  
  if(featselmethod=="lmreg" || featselmethod=="lmregrobust" || featselmethod=="logitreg" || featselmethod=="logitregrobust"){
    
    if(length(class_labels_levels)>2){
      
      stop(paste(featselmethod, " feature selection option is only available for 2 class comparisons."),sep="")
      
      
      
    }
  }
  
  
  
  if(sample.col.opt=="default"){
    
    col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","cornflowerblue","cyan4","skyblue",
               "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
               "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
               "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
    
  }else{ 
    if(sample.col.opt=="topo"){
      #col_vec<-topo.colors(256) #length(class_labels_levels)) 
      
      #col_vec<-col_vec[seq(1,length(col_vec),)]
      
      col_vec <- topo.colors(length(class_labels_levels), alpha=alphacol)
    }else{
      if(sample.col.opt=="heat"){
        #col_vec<-heat.colors(256) #length(class_labels_levels))
        
        col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
      }else{
        if(sample.col.opt=="rainbow"){
          #col_vec<-heat.colors(256) #length(class_labels_levels))
          col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
          
          #col_vec <- heat.colors(length(class_labels_levels), alpha=alphacol)
        }else{
          
          if(sample.col.opt=="terrain"){
            #col_vec<-heat.colors(256) #length(class_labels_levels))
            #col_vec<-rainbow(length(class_labels_levels), start = 0, end = alphacol)
            
            col_vec <- cm.colors(length(class_labels_levels), alpha=alphacol)
          }else{
            
            if(sample.col.opt=="colorblind"){
              #col_vec <-c("#386cb0","#fdb462","#7fc97f","#ef3b2c","#662506","#a6cee3","#fb9a99","#984ea3","#ffff33")
              # col_vec <- c("#0072B2", "#E69F00", "#009E73", "gold1", "#56B4E9", "#D55E00", "#CC79A7","black")
              
              if(length(class_labels_levels)<9){
                
                col_vec <- c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "#E64B35FF", "grey57")
                
              }else{
                
                #col_vec<-colorRampPalette(brewer.pal(10, "RdBu"))(length(class_labels_levels))
                col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35B2", "#4DBBD5B2","#00A087B2","#3C5488B2","#F39B7FB2","#8491B4B2","#91D1C2B2","#DC0000B2","#7E6148B2",
                           "#374E55B2","#DF8F44B2","#00A1D5B2","#B24745B2","#79AF97B2","#6A6599B2","#80796BB2","#0073C2B2","#EFC000B2", "#868686B2","#CD534CB2","#7AA6DCB2","#003C67B2","grey57")
                
              }
              
              
            }else{
              
              check_brewer<-grep(pattern="brewer",x=sample.col.opt)
              
              if(length(check_brewer)>0){
                
                sample.col.opt_temp=gsub(x=sample.col.opt,pattern="brewer.",replacement="")
                col_vec <- colorRampPalette(brewer.pal(10, sample.col.opt_temp))(length(class_labels_levels))
                
              }else{
                
                if(sample.col.opt=="journal"){
                  
                  col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                             "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                             "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                             
                             "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF",
                             "#E64B3519","#4DBBD519","#631879E5","grey75")
                  if(length(class_labels_levels)<8){
                    col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75")
                    
                    #col_vec2<-brewer.pal(n = 8, name = "Dark2")
                    
                  }else{
                    if(length(class_labels_levels)<=28){
                      # col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7", "grey75","#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666","#1B9E77", "#7570B3", "#E7298A", "#A6761D", "#666666", "#1B9E77", "#D95F02", "#7570B3", "#E7298A", "#66A61E", "#E6AB02", "#A6761D", "#666666")
                      
                      col_vec<-c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","#E64B35FF","#3C5488FF","#F39B7FFF",
                                 "#8491B4FF","#91D1C2FF","#DC0000FF","#B09C85FF","#5F559BFF",
                                 "#808180FF","#20854EFF","#FFDC91FF","#B24745FF",
                                 
                                 "#374E55FF","#8F7700FF","#5050FFFF","#6BD76BFF", "#8BD76BFF",
                                 "#E64B3519","#9DBBD0FF","#631879E5","#666666","grey75")
                      
                    }else{
                      
                      
                      
                      
                      colfunc <-colorRampPalette(c("#0072B2", "#E69F00", "#009E73", "#56B4E9", "#D55E00", "#CC79A7","grey75"));col_vec<-colfunc(length(class_labels_levels))
                      
                      col_vec<-col_vec[sample(col_vec)]
                      
                      
                    }
                  }
                  
                }else{
                  #colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                #  if(length(sample.col.opt)==1){
                 #   col_vec <-rep(sample.col.opt,length(class_labels_levels))
                #  }else{
                    
                 #   colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    
                  #  col_vec<-col_vec[sample(col_vec)]
                    
                  #}
                  
                  if(length(sample.col.opt)==1){
                    col_vec <-rep(sample.col.opt,length(class_labels_levels))
                  }else{
                    
                    if(length(sample.col.opt)>=length(class_labels_levels)){
                      
                      col_vec <-sample.col.opt
                      col_vec <- rep(col_vec,length(class_labels_levels))
                      
                      
                    }else{
                      colfunc <-colorRampPalette(sample.col.opt);col_vec<-colfunc(length(class_labels_levels))
                    }
                    
                  }
                  
                  
                  
                }
                
              }
              
            }
          }
          
          
        }
        
      }
      
    }	
  }
  #pca_col_vec<-col_vec
  
  pca_col_vec<-c("mediumpurple4","mediumpurple1","blueviolet","darkblue","blue","cornflowerblue","cyan4","skyblue",
                 "darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
                 "red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
                 "aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
  
  
  if(is.na(individualsampleplot.col.opt)[1]==TRUE){
    
    individualsampleplot.col.opt=col_vec
  }
  
  
  
  
  #cl<-makeCluster(num_nodes)
  #feat_sds<-parApply(cl,data_m,1,sd)
  feat_sds<-apply(data_m,1,function(x){sd(x,na.rm=TRUE)})
  
  #stopCluster(cl)
  
  bad_sd_ind<-c(which(feat_sds==0),which(is.na(feat_sds)==TRUE))
  
  bad_sd_ind<-unique(bad_sd_ind)
  
  if(length(bad_sd_ind)>0){
    
    data_matrix<-data_matrix[-c(bad_sd_ind),]
    
    data_m<-data_m[-c(bad_sd_ind),]
    
    data_matrix_beforescaling<-data_matrix_beforescaling[-c(bad_sd_ind),]
  }
  
  data_temp<-data_matrix_beforescaling[,-c(1:2)]
  
  
  
  
  
  #cl<-makeCluster(num_nodes)
  
  #clusterExport(cl,"do_rsd")
  #feat_rsds<-parApply(cl,data_temp,1,do_rsd)
  feat_rsds<-apply(data_temp,1,do_rsd)
  #stopCluster(cl)
  #  #save(feat_rsds,data_temp,data_matrix_beforescaling,data_m,file="rsds.Rda")
  sum_rsd<-summary(feat_rsds,na.rm=TRUE)
  max_rsd<-max(feat_rsds,na.rm=TRUE)
  max_rsd<-round(max_rsd,2)
  
  
 # print("Summary of RSD across all features:")
  #print(sum_rsd)
  
  if(log2.fold.change.thresh_list[length(log2.fold.change.thresh_list)]>max_rsd){
    stop(paste("The maximum relative standard deviation threshold in rsd.filt.list should be below ",max_rsd,sep=""))
  }
  
  classlabels_parent<-classlabels
  classlabels_sub_parent<-classlabels_sub
  classlabels_orig_parent<-classlabels_orig
  
  #write.table(classlabels_orig,file="classlabels.txt",sep="\t",row.names=FALSE)
  classlabels_response_mat_parent<-classlabels_response_mat
  
  
  
  
  
  parent_data_m<-round(data_m,5)
  
  
  res_score<-0
  #best_cv_res<-0
  best_feats<-{}
  
  best_acc<-0
  best_limma_res<-{}
  best_logfc_ind<-1
  
  
  
  output_dir1<-paste(parentoutput_dir,"/Stage2/",sep="")
  dir.create(output_dir1,showWarnings=FALSE)
  
  setwd(output_dir1)
  
  classlabels_sub_parent<-classlabels_sub
  classlabels_orig_parent<-classlabels_orig
  
  #write.table(classlabels_orig,file="classlabels.txt",sep="\t",row.names=FALSE)
  classlabels_response_mat_parent<-classlabels_response_mat
  
#  rocfeatlist<-rocfeatlist+1
  
  if(pairedanalysis==TRUE){
    #print(subject_inf)
    write.table(subject_inf,file="subject_inf.txt",sep="\t")
    paireddesign=subject_inf
  }else{
    paireddesign=NA
    
    
  }
  #write.table(classlabels_orig,file="classlabels_orig.txt",sep="\t")
  #write.table(classlabels,file="classlabels.txt",sep="\t")
  #write.table(classlabels_response_mat,file="classlabels_response_mat.txt",sep="\t")
  
  if(is.na(max_varsel)[1]==TRUE){
    
    max_varsel=dim(data_m)[1]
  }
  
  for(lf in 1:length(log2.fold.change.thresh_list))
  {
    
    allmetabs_res<-{}
    classlabels_response_mat<-classlabels_response_mat_parent
    classlabels_sub<-classlabels_sub_parent
    classlabels_orig<-classlabels_orig_parent
    
    setwd(parentoutput_dir)
    log2.fold.change.thresh=log2.fold.change.thresh_list[lf]
    
    
    output_dir1<-paste(parentoutput_dir,"/Stage2/",sep="")
    dir.create(output_dir1,showWarnings=FALSE)
    
    setwd(output_dir1)
    
    
    
    if(logistic_reg==TRUE){
      
      if(robust.estimate==FALSE){ output_dir<-paste(output_dir1,"logitreg","signalthresh",group.missing.thresh,"RSD",log2.fold.change.thresh,"/",sep="")
      }else{
        
        if(robust.estimate==TRUE){ output_dir<-paste(output_dir1,"logitregrobust","signalthresh",group.missing.thresh,"RSD",log2.fold.change.thresh,"/",sep="")
        }
      }
    }else{
      
      
      if(poisson_reg==TRUE){
        
        if(robust.estimate==FALSE){ output_dir<-paste(output_dir1,"poissonreg","signalthresh",group.missing.thresh,"RSD",log2.fold.change.thresh,"/",sep="")
        }else{
          if(robust.estimate==TRUE){
            output_dir<-paste(output_dir1,"poissonregrobust","signalthresh",group.missing.thresh,"RSD",log2.fold.change.thresh,"/",sep="")
            
          }
          
        }
      }else{
        
        if(featselmethod=="lmreg"){
          
          if(robust.estimate==TRUE){
            output_dir<-paste(output_dir1,"lmregrobust","signalthresh",group.missing.thresh,"RSD",log2.fold.change.thresh,"/",sep="")
            
          }else{
            
            output_dir<-paste(output_dir1,"lmreg","signalthresh",group.missing.thresh,"RSD",log2.fold.change.thresh,"/",sep="")
            
            
          }
          
        }else{
          
          
          
          output_dir<-paste(output_dir1,parentfeatselmethod,"signalthresh",group.missing.thresh,"RSD",log2.fold.change.thresh,"/",sep="")
        }
        
      }
    }
    dir.create(output_dir,showWarnings=FALSE)
    
    setwd(output_dir)
    
    dir.create("Figures",showWarnings = FALSE)
    
    dir.create("Tables",showWarnings = FALSE)
    
    
    
    data_m<-parent_data_m
    
    #print("dim of data_m")
    #print(dim(data_m))
    
    pdf_fname<-paste("Figures/Results_RSD",log2.fold.change.thresh,".pdf",sep="")
    
    #zip_fname<-paste("Results_RSD",log2.fold.change.thresh,".zip",sep="")
    
    if(output.device.type=="pdf"){
      pdf(pdf_fname,width=10,height=10)
    }
    
    if(analysismode=="classification" | analysismode=="regression"){
      
     rsd_filt_msg=(paste("Performing RSD filtering using ",log2.fold.change.thresh, " as threshold",sep=""))
      if(log2.fold.change.thresh>=0){
        
        if(log2.fold.change.thresh==0){
          log2.fold.change.thresh=0.001
        }
        
        
        #good_metabs<-which(abs(mean_groups)>log2.fold.change.thresh)
        abs_feat_rsds<-abs(feat_rsds)
        
        good_metabs<-which(abs_feat_rsds>log2.fold.change.thresh)
        
        #print("length of good_metabs")
        #print(good_metabs)
        
      }else{
        good_metabs<-seq(1,dim(data_m)[1])
      }
      
      if(length(good_metabs)>0){
        
        data_m_fc<-data_m[good_metabs,]
        
        data_m_fc_withfeats<-data_matrix[good_metabs,c(1:2)]
        
        data_matrix_beforescaling_rsd<-data_matrix_beforescaling[good_metabs,]
        
        data_matrix<-data_matrix[good_metabs,]
        
      }else{
        #data_m_fc<-data_m
        #data_m_fc_withfeats<-data_matrix[,c(1:2)]
        
        stop(paste("Please decrease the maximum relative standard deviation (rsd.filt.thresh) threshold to ",max_rsd,sep=""))
        
      }
    }else{
      
      data_m_fc<-data_m
      data_m_fc_withfeats<-data_matrix[,c(1:2)]
    }
   # save(data_m_fc_withfeats,data_m_fc,data_m,data_matrix,file="datadebug.Rda")
    
    
    ylab_text_raw<-ylab_text
    
    if(log2transform==TRUE || input.intensity.scale=="log2"){
      
      if(znormtransform==TRUE){
        ylab_text_2="scale normalized"
      }else{
        if(quantile_norm==TRUE){
          
          ylab_text_2="quantile normalized"
        }else{
          ylab_text_2=""
        }
      }
      ylab_text=paste("log2 ",ylab_text," ",ylab_text_2,sep="")
    }else{
      if(znormtransform==TRUE){
        ylab_text_2="scale normalized"
      }else{
        if(quantile_norm==TRUE){
          
          ylab_text_2="quantile normalized"
        }else{
          ylab_text_2=""
        }
      }
      ylab_text=paste("Raw ",ylab_text," ",ylab_text_2,sep="") #paste("Raw intensity ",ylab_text_2,sep="")
    }
    #ylab_text=paste("Abundance",sep="")
    
    
    if(is.na(names_with_mz_time)[1]==FALSE){
      data_m_fc_with_names<-merge(names_with_mz_time,data_m_fc_withfeats,by=c("mz","time"))
      data_m_fc_with_names<-data_m_fc_with_names[match(data_m_fc_withfeats$mz,data_m_fc_with_names$mz),]
      #save(names_with_mz_time,goodfeats,goodfeats_with_names,file="goodfeats_with_names.Rda")
      
      # goodfeats_name<-goodfeats_with_names$Name
      #}
    }
    
  #  save(data_m_fc_withfeats,data_matrix,data_m,data_m_fc,data_m_fc_with_names,names_with_mz_time,file="debugnames.Rda")
    
    
    
    if(dim(data_m_fc)[2]>50){
      
      if(output.device.type!="pdf"){
        
        temp_filename_1<-"Figures/SampleIntensityDistribution.png"
        
        png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
        
      }
      
      size_num<-min(100,dim(data_m_fc)[2])
      
      par(mfrow=c(1,1),family="sans",cex=cex.plots)
      samp_index<-sample(x=1:dim(data_m_fc)[2],size=size_num)
      #  try(boxplot(data_m_fc[,samp_index],main="Intensity distribution across samples after preprocessing",xlab="Samples",ylab=ylab_text,col=boxplot.col.opt),silent=TRUE)
      
      #samp_dist_col<-get_boxplot_colors(boxplot.col.opt,class_labels_levels=c(1))
      
      boxplot(data_m_fc[,samp_index],main="Intensity distribution across samples after preprocessing",xlab="Samples",ylab=ylab_text,col="white")
      
      if(output.device.type!="pdf"){
        
        try(dev.off(),silent=TRUE)
      }
      
    }else{
      
      if(output.device.type!="pdf"){
        
        temp_filename_1<-"Figures/SampleIntensityDistribution.png"
        
        png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
      }
      par(mfrow=c(1,1),family="sans",cex=cex.plots)
      try(boxplot(data_m_fc,main="Intensity distribution across samples after preprocessing",xlab="Samples",ylab=ylab_text,col="white"),silent=TRUE)
      if(output.device.type!="pdf"){
        
        try(dev.off(),silent=TRUE)
      }
      
    }
    
  if(is.na(outlier.method)[1]==FALSE){
    if(output.device.type!="pdf"){
      
      temp_filename_1<-paste("Figures/OutlierDetection",outlier.method,".png",sep="")
      
      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
    }
    par(mfrow=c(1,1),family="sans",cex=cex.plots)
    
    ##save(data_matrix,file="dm1.Rda")
    
    
    outlier_detect(data_matrix=data_matrix,ncomp=2,column.rm.index=c(1,2),outlier.method=outlier.method[1])
    
   # print("done outlier")
    
    if(output.device.type!="pdf"){
      
      try(dev.off(),silent=TRUE)
    }
  }
    
    
    
    data_m_fc_withfeats<-cbind(data_m_fc_withfeats,data_m_fc)
    
    allmetabs_res_withnames<-{}
    
    feat_eval[lf]<-0
    res_score_vec[lf]<-0
    #feat_sigfdrthresh_cv[lf]<-0
    
    filename<-paste(fheader,log2.fold.change.thresh,".txt",sep="")
    #write.table(data_m_fc_withfeats, file=filename,sep="\t",row.names=FALSE)
    
    
    if(length(data_m_fc)>=dim(parent_data_m)[2])
    {
      
      
      if(dim(data_m_fc)[1]>0){
        
        if(ncol(data_m_fc)<30){
          
          kfold=ncol(data_m_fc)
        }
        
        
        feat_eval[lf]<-dim(data_m_fc)[1]
        
        # col_vec<-c("#CC0000","#AAC000","blue","mediumpurple4","mediumpurple1","blueviolet","darkblue","blue","cornflowerblue","cyan4","skyblue",
        #"darkgreen", "seagreen1", "green","yellow","orange","pink", "coral1", "palevioletred2",
        #"red","saddlebrown","brown","brown3","white","darkgray","aliceblue",
        #"aquamarine","aquamarine3","bisque","burlywood1","lavender","khaki3","black")
        
        if(analysismode=="classification")
        {
          
          sampleclass<-{}
          patientcolors<-{}
          #
          classlabels<-as.data.frame(classlabels)
          #print(classlabels)
          
          f<-factor(classlabels[,1])
          
          for(c in 1:length(class_labels_levels)){
            
            num_samps_group_cur=length(which(ordered_labels==class_labels_levels[c]))
            
            #classlabels<-c(classlabels,rep(paste("Class",class_label_alphabets,sep=""),num_samps_group_cur))
            #,rep("ClassB",num_samps_group[[2]]),rep("ClassC",num_samps_group[[3]]))
            sampleclass<-c(sampleclass,rep(paste("Class",class_label_alphabets[c],sep=""),num_samps_group_cur))
            #sampleclass<-classlabels[,1] #c(sampleclass,rep(paste("Class",class_labels_levels[c],sep=""),num_samps_group_cur))
            
            patientcolors <-c(patientcolors,rep(col_vec[c],num_samps_group_cur))
          }
          
          
          
          
         # library(pcaMethods)
          
          #p1<-pcaMethods::pca(data_m_fc,method="rnipals",center=TRUE,scale="uv",cv="q2",nPcs=3)
          
          tempX<-t(data_m_fc)
          
          
          
          #  p1<-pcaMethods::pca(tempX,method="rnipals",center=TRUE,scale="uv",cv="q2",nPcs=10)
          
          
          
          if(output.device.type!="pdf"){
            
            temp_filename_2<-"Figures/PCAdiagnostics_allfeats.png"
            
            # png(temp_filename_2,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
          }
          
          
          
          if(output.device.type!="pdf"){
            
            # dev.off()
          }
          
         # try(detach("package:pcaMethods",unload=TRUE),silent=TRUE)
          
          
          
          if(dim(classlabels)[2]>2){
            classgroup<-paste(classlabels[,1],":",classlabels[,2],sep="") #classlabels[,1]:classlabels[,2]
          }else{
            
            classgroup<-classlabels
          }
          
          classlabels_orig<-classlabels_orig_parent
          
          if(pairedanalysis==TRUE){
            
            #classlabels_orig<-classlabels_orig[,-c(2)]
            
            
          }else{
            
            if(featselmethod=="lmreg" || featselmethod=="logitreg" ||  featselmethod=="poissonreg"){
              classlabels_orig<-classlabels_orig[,c(1:2)]
              classlabels_orig<-as.data.frame(classlabels_orig)
            }
          }
          
          if(analysismode=="classification"){
            if(dim(classlabels_orig)[2]==2){
              if(alphabetical.order==FALSE){
                classlabels_orig[,2] <- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
              }
            }
            if(dim(classlabels_orig)[2]==3){
              
              if(pairedanalysis==TRUE){
                if(alphabetical.order==FALSE){
                  classlabels_orig[,3] <- factor(classlabels_orig[,3], levels=unique(classlabels_orig[,3]))
                }
              }else{
                if(alphabetical.order==FALSE){
                  classlabels_orig[,2] <- factor(classlabels_orig[,2], levels=unique(classlabels_orig[,2]))
                  classlabels_orig[,3] <- factor(classlabels_orig[,3], levels=unique(classlabels_orig[,3]))
                }
                
              }
              
            }else{
              
              if(dim(classlabels_orig)[2]==4){
                
                if(pairedanalysis==TRUE){
                  if(alphabetical.order==FALSE){
                    classlabels_orig[,3] <- factor(classlabels_orig[,3], levels=unique(classlabels_orig[,3]))
                    
                    classlabels_orig[,4] <- factor(classlabels_orig[,4], levels=unique(classlabels_orig[,4]))
                  }
                }
                
              }
              
            }
            
          }
          if(length(which(duplicated(data_m_fc_with_names$Name)==TRUE))>0){
            
            print("Duplicate features detected")
            print("Removing duplicate entries for the following features:")
            # print(data_m_fc_with_names$Name[which(duplicated(data_m_fc_with_names$Name)==TRUE)])
            
            data_m_fc_withfeats<-data_m_fc_withfeats[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_m_fc<-data_m_fc[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_matrix<-data_matrix[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_m<-data_m[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_m_fc_with_names<-data_m_fc_with_names[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            #parent_data_m<-parent_data_m[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            
            
          }
          
          ##Perform global PCA
          if(pca.global.eval==TRUE){
          
                  if(output.device.type!="pdf"){
                    
                    temp_filename_1<-"Figures/PCAplots_allfeats.pdf"
                    
                    #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                    
                    pdf(temp_filename_1,width=plots.width,height=plots.height)
                  }
                  
                    plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
                    
                    
                    text(5, 8, "PCA using all features left after pre-processing")
                    text(5, 7, "The figures include: ")
                    text(5, 6, "a. pairwise PC score plots ")
                    text(5, 5, "b. scores for individual samples on each PC")
                    text(5, 4, "c. Lineplots using PC scores for data with repeated measurements")
                    
                      ###savelist=ls(),file="pcaplotsall.Rda")
                      
                      
                    #  save(data_m_fc_withfeats,classlabels_orig,sample.col.opt,col_vec,pairedanalysis,pca.cex.val,legendlocation,pca.ellipse,ellipse.conf.level,paireddesign,
                     #      lineplot.col.opt,lineplot.lty.option,timeseries.lineplots,pcacenter,pcascale,alphabetical.order,
                      #     analysistype,lme.modeltype,file="pcaplotsall.Rda")
                         
                    rownames(data_m_fc_withfeats)<-data_m_fc_with_names$Name
                    
                    save(data_m_fc_withfeats,data_m_fc_with_names,file="data_m_fc_withfeats.Rda")
          
                          classlabels_orig_pca<-classlabels_orig
                         
                          if(FALSE){ 
                          c1<-get_pcascoredistplots(X=data_m_fc_withfeats,Y=classlabels_orig,feature_table_file=NA,parentoutput_dir=getwd(),class_labels_file=NA,sample.col.opt=sample.col.opt,
                                                    plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3,col_vec=col_vec,pairedanalysis=pairedanalysis,pca.cex.val=pca.cex.val,legendlocation=legendlocation,
                                                    pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,
                                                    filename="all",paireddesign=paireddesign,lineplot.col.opt=lineplot.col.opt,
                                                    lineplot.lty.option=lineplot.lty.option,timeseries.lineplots=timeseries.lineplots,
                                                    pcacenter=pcacenter,pcascale=pcascale,alphabetical.order=alphabetical.order,
                                                    study.design=analysistype,lme.modeltype=lme.modeltype)
                          }
                          
                          c1=try(get_pcascoredistplots(X=data_m_fc_withfeats,Y=classlabels_orig,feature_table_file=NA,parentoutput_dir=getwd(),class_labels_file=NA,sample.col.opt=sample.col.opt,
                                                       plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3,col_vec=col_vec,pairedanalysis=pairedanalysis,pca.cex.val=pca.cex.val,legendlocation=legendlocation,
                                                       pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,
                                                       filename="all",paireddesign=paireddesign,lineplot.col.opt=lineplot.col.opt,
                                                       lineplot.lty.option=lineplot.lty.option,timeseries.lineplots=timeseries.lineplots,
                                                       pcacenter=pcacenter,pcascale=pcascale,alphabetical.order=alphabetical.order,
                                                       study.design=analysistype,lme.modeltype=lme.modeltype),silent=TRUE)
                          
                          
                          
                          
                          if(output.device.type!="pdf"){
                            
                            try(dev.off(),silent=TRUE)
                          }
                          
          }
          classlabels_orig<-classlabels_orig_parent
        }else{
          #regression
          tempgroup<-rep("A",dim(data_m_fc)[2]) #cbind(classlabels_orig[,1],
          col_vec1<-rep("black",dim(data_m_fc)[2])
          class_labels_levels_main1<-c("A")
          
          analysistype="regression"
          
          if(length(which(duplicated(data_m_fc_with_names$Name)==TRUE))>0){
            
            data_m_fc_withfeats<-data_m_fc_withfeats[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_m_fc<-data_m_fc[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_matrix<-data_matrix[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_m<-data_m[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            data_m_fc_with_names<-data_m_fc_with_names[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            # parent_data_m<-parent_data_m[-which(duplicated(data_m_fc_with_names$Name)==TRUE),]
            
            
            print("Duplicate features detected")
            print("Removing duplicate entries for the following features:")
            print(data_m_fc_with_names$Name[which(duplicated(data_m_fc_with_names$Name)==TRUE)])
       
          }
          
          rownames(data_m_fc_withfeats)<-data_m_fc_with_names$Name
          #   get_pca(X=data_m_fc,samplelabels=tempgroup,legendlocation=legendlocation,filename="all",
          #          ncomp=3,pcacenter=pcacenter,pcascale=pcascale,legendcex=0.5,outloc=getwd(),col_vec=col_vec1,
          #         sample.col.opt=sample.col.opt,alphacol=0.3,class_levels=NA,pca.cex.val=pca.cex.val,pca.ellipse=FALSE,
          #        paireddesign=paireddesign,alphabetical.order=alphabetical.order,pairedanalysis=pairedanalysis,classlabels_orig=classlabels_orig,analysistype=analysistype) #,silent=TRUE)
          
          
          if(pca.global.eval==TRUE){
                  if(output.device.type!="pdf"){
                    
                    temp_filename_1<-"Figures/PCAplots_allfeats.pdf"
                    
                    #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                    
                    pdf(temp_filename_1,width=plots.width,height=plots.height)
                  }
                  
                  
                  
                  plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
                  
                  
                  text(5, 8, "PCA using all features left after pre-processing")
                  text(5, 7, "The figures include: ")
                  text(5, 6, "a. pairwise PC score plots ")
                  text(5, 5, "b. scores for individual samples on each PC")
                  text(5, 4, "c. Lineplots using PC scores for data with repeated measurements")
                  
                  ###savelist=ls(),file="pcaplotsall.Rda")
                  
                 
                  
                  ###save(data_m_fc_withfeats,classlabels_orig,sample.col.opt,col_vec,pairedanalysis,pca.cex.val,legendlocation,pca.ellipse,ellipse.conf.level,paireddesign,lineplot.col.opt,lineplot.lty.option,timeseries.lineplots,pcacenter,pcascale,file="pcaplotsall.Rda")
                
                  c1=try(get_pcascoredistplots(X=data_m_fc_withfeats,Y=classlabels_orig,feature_table_file=NA,parentoutput_dir=getwd(),class_labels_file=NA,
                                               sample.col.opt=sample.col.opt,
                                               plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3,col_vec=col_vec,pairedanalysis=pairedanalysis,pca.cex.val=pca.cex.val,legendlocation=legendlocation,
                                               pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,filename="all",
                                               paireddesign=paireddesign,lineplot.col.opt=lineplot.col.opt,lineplot.lty.option=lineplot.lty.option,
                                               timeseries.lineplots=timeseries.lineplots,pcacenter=pcacenter,pcascale=pcascale,alphabetical.order=alphabetical.order,
                                               study.design=analysistype,lme.modeltype=lme.modeltype),silent=TRUE)
                  
                  if(output.device.type!="pdf"){
                    
                    try(dev.off(),silent=TRUE)
                  }
            }
        }
        
        
        if(featselmethod=="pamr"){
          
          #print("HERE")
          #savedata_m_fc,classlabels,file="pamdebug.Rda")
          
          if(is.na(fdrthresh)[1]==FALSE){
            if(fdrthresh>0.5){
              
              pamrthresh=pvalue.thresh
              
            }else{
              pamrthresh=fdrthresh
              
            }
          }else{
            
            pamrthresh=pvalue.thresh
            
          }
          pamr.res<-do_pamr(X=data_m_fc,Y=classlabels,fdrthresh=pamrthresh,nperms=1000,pamr.threshold.select.max=pamr.threshold.select.max,kfold=kfold)
          
          ###save(pamr.res,file="pamr.res.Rda")
          goodip<-pamr.res$feature.list
          
          if(length(goodip)<1){
            goodip=NA
          }
          pamr.threshold_value<-pamr.res$threshold_value
          
          feature_rowindex<-seq(1,nrow(data_m_fc))
          
          discore<-rep(0,nrow(data_m_fc))
          
          discore_all<-pamr.res$max.discore.allfeats
          
          if(is.na(goodip)[1]==FALSE){
            discore[goodip]<-pamr.res$max.discore.sigfeats
            
            sel.diffdrthresh<-feature_rowindex%in%goodip
            
            max_absolute_standardized_centroids_thresh0<-pamr.res$max.discore.allfeats[goodip]
            
            selected_id_withmztime<-cbind(data_m_fc_withfeats[goodip,c(1:2)],pamr.res$pam_toplist,max_absolute_standardized_centroids_thresh0)
            ###savepamr.res,file="pamr.res.Rda")
            write.csv(selected_id_withmztime,file="dscores.selectedfeats.csv",row.names=FALSE)
            
            rank_vec<-rank(-discore_all)
            
            max_absolute_standardized_centroids_thresh0<-pamr.res$max.discore.allfeats
            
            data_limma_fdrall_withfeats<-cbind(max_absolute_standardized_centroids_thresh0,data_m_fc_withfeats)
            write.table(data_limma_fdrall_withfeats,file="Tables/pamr_ranked_feature_table.txt",sep="\t",row.names=FALSE)
            
            
          }else{
            goodip<-{}
            sel.diffdrthresh<-rep(FALSE,length(feature_rowindex))
          }
          
          rank_vec<-rank(-discore_all)
          
          pamr_ythresh<-pamr.res$max.discore.all.thresh-0.00000001
          
          
          
        }
        
        
        if(featselmethod=="rfesvm"){
          
          
          svm_classlabels<-classlabels[,1]
          
          if(analysismode=="classification"){
            svm_classlabels<-as.data.frame(svm_classlabels)
          }
          
          
          # ##save(data_m_fc,svm_classlabels,svm_kernel,file="svmdebug.Rda")
          if(length(class_labels_levels)<3){
            rfesvmres = diffexpsvmrfe(x=t(data_m_fc),y=svm_classlabels,svmkernel=svm_kernel)
            
            
            featureRankedList=rfesvmres$featureRankedList
            featureWeights=rfesvmres$featureWeights 
            #best_subset<-featureRankedList$best_subset
            
          }else{
            
            rfesvmres = diffexpsvmrfemulticlass(x=t(data_m_fc),y=svm_classlabels,svmkernel=svm_kernel)
            featureRankedList=rfesvmres$featureRankedList
            featureWeights=rfesvmres$featureWeights  
            
          }
          
          #  ##save(rfesvmres,file="rfesvmres.Rda")
          rank_vec<-seq(1,dim(data_m_fc_withfeats)[1])
          goodip<-featureRankedList[1:max_varsel]
          
          #dtemp1<-data_m_fc_withfeats[goodip,]
          
          sel.diffdrthresh<-rank_vec%in%goodip
          
          
          rank_vec<-sort(featureRankedList,index.return=TRUE)$ix
          
          weight_vec<-featureWeights #[rank_vec]
          
          data_limma_fdrall_withfeats<-cbind(featureWeights,data_m_fc_withfeats)
          
          
        }
        
        
        f1={}
        corfit={}
        
        if(featselmethod=="limma" | featselmethod=="limma1way")
        {
          
        #  cat("Performing limma analysis",sep="\n")
        #  save(classlabels,classlabels_orig,classlabels_dataframe,classlabels_response_mat,file="cldebug.Rda")
          
          classlabels_temp1<-classlabels
          
          classlabels<-classlabels_dataframe #classlabels_orig
          colnames(classlabels)<-c("SampleID","Factor1")
          if(alphabetical.order==FALSE){
            classlabels$Factor1<-factor(classlabels$Factor1,levels=unique(classlabels$Factor1))
            
            Factor1<-factor(classlabels$Factor1,levels=unique(classlabels$Factor1))
            
            
          }else{
            
            Factor1<-factor(classlabels$Factor1)
            
            
          }
          
          
          
          
          if(limma.contrasts.type=="contr.sum"){
            contrasts_factor1<-contr.sum(length(levels(factor(Factor1))))
            
            rownames(contrasts_factor1)<-levels(factor(Factor1))
            
            cnames_contr_factor1<-apply(contrasts_factor1,2,function(x){paste(names(x[which(abs(x)==1)]),collapse = "-")})
            
            
            
          }else{
            
            if(limma.contrasts.type=="contr.pairs"){
              
              contr.pairs <-
                function(levels) {
                  n <- length(levels)
                  design <- matrix(0,n,choose(n,2))
                  rownames(design) <- levels
                  colnames(design) <- 1:choose(n,2)
                  k <- 0
                  for (i in 1:(n-1))
                    for (j in (i+1):n) {
                      k <- k+1
                      design[i,k] <- 1
                      design[j,k] <- -1
                      colnames(design)[k] <- paste(levels[i],"-",levels[j],sep="")
                    }
                  design
                }
              
              
              contrasts_factor1<-contr.pairs(levels(factor(Factor1)))
            
              
              rownames(contrasts_factor1)<-levels(factor(Factor1))
              
              
              cnames_contr_factor1<- colnames(contrasts_factor1) #apply(contrasts_factor1,2,function(x){paste(names(x[1]),names(x[which(abs(x)==1)]),sep = "-")})
          
              
            }else{
            contrasts_factor1<-contr.treatment(length(levels(factor(Factor1))))
            
            rownames(contrasts_factor1)<-levels(factor(Factor1))
            
            cnames_contr_factor1<-apply(contrasts_factor1,2,function(x){paste(names(x[1]),names(x[which(abs(x)==1)]),sep = "-")})
            }
            
            
          }
          
          
          
          
          colnames(contrasts_factor1)<-cnames_contr_factor1
          
          contrasts(Factor1) <- contrasts_factor1
          
          
          design <- model.matrix(~Factor1)
          
          
          classlabels<-classlabels_temp1
          
         # design <- model.matrix(~ -1+f)
          #colnames(design) <- levels(f)
          
          
          options(digit=3)
          #parameterNames<-colnames(design)
          design_mat_names=colnames(design)
          
          design_mat_names<-design_mat_names[-c(1)]
          # limma paired analysis
          if(pairedanalysis==TRUE){
            
            f1<-{}
            for(c in 1:length(class_labels_levels)){
              
              f1<-c(f1,seq(1,num_samps_group[[c]]))
              
            }
            
            #print("Paired samples order")
            
            f1<-subject_inf
          #  print(subject_inf)
         #   print("Design matrix")
           # print(design)
            
            ####savelist=ls(),file="limma.Rda")
            
            
            ##save(subject_inf,file="subject_inf.Rda")
            
            corfit<-duplicateCorrelation(data_m_fc,design=design,block=subject_inf,ndups=1)
            
            if(limmarobust==TRUE)
            {
              fit<-lmFit(data_m_fc,design,block=f1,cor=corfit$consensus,method="robust")
              
            }else{
              fit<-lmFit(data_m_fc,design,block=f1,cor=corfit$consensus)
            }
          }else{
            
            #not paired analysis
            if(limmarobust==TRUE)
            {
              fit <- lmFit(data_m_fc,design,method="robust")
              
            }else{
              fit <- lmFit(data_m_fc,design)
            }
            #fit<-treat(fit,lfc=lf)
            
          }
          
          cont.matrix=attributes(design)$contrasts
          #print(data_m_fc[1:3,])
          #fit2  <- contrasts.fit(fit, cont.matrix)
          
          #remove the intercept coefficient
          fit<-fit[,-1]
          fit2 <- eBayes(fit)
          
         
          
         # save(fit2,fit,data_m_fc,design,f1,corfit,classlabels,Factor1,cnames_contr_factor1,file="limma.eBayes.fit.Rda")
          # Various ways of summarising or plotting the results
          #topTable(fit,coef=2)
          
          
          #write.table(t1,file="topTable_limma.txt",sep="\t")
          
          
          if(dim(design)[2]>2){
            pvalues<-fit2$F.p.value
            p.value<-fit2$F.p.value
            
          }else{
            pvalues<-fit2$p.value
            p.value<-fit2$p.value
          }
          
          if(fdrmethod=="BH"){
            fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
          }else{
            if(fdrmethod=="ST"){
              
              fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
              
              if(is(fdr_adjust_pvalue,"try-error")){
                
                fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
              }
              
              fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
              
              
            }else{
              if(fdrmethod=="Strimmer"){
                pdf("fdrtool.pdf")
                fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                try(dev.off(),silent=TRUE)
              }else{
                if(fdrmethod=="none"){
                  fdr_adjust_pvalue<-pvalues
                  #fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
                }else{
                  if(fdrmethod=="BY"){
                    fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                  }else{
                    if(fdrmethod=="bonferroni"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                    }
                  }
                  
                  
                }
              }
            }
            
          }
          
          if(dim(design)[2]<3){
            
            if(fdrmethod=="none"){
              filename<-paste("Tables/",parentfeatselmethod,"_pvalall_withfeats.txt",sep="")
            }else{
              filename<-paste("Tables/",parentfeatselmethod,"_fdrall_withfeats.txt",sep="")
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
            
            
            data_limma_fdrall_withfeats<-cbind(p.value,fdr_adjust_pvalue,data_m_fc_withfeats)
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            pvalues<-p.value
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
           # write.table(data_limma_fdrall_withfeats,file=filename,sep="\t",row.names=FALSE)
            
            
            final.pvalues<-pvalues
            sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
            
            
            
            goodip<-which(sel.diffdrthresh==TRUE)
            d4<-as.data.frame(data_limma_fdrall_withfeats)
            logp<-(-1)*log((d4[,1]+(10^-20)),10)
            
            #tiff("pval_dist.tiff",compression="lzw")
            #hist(d4[,1],xlab="p",main="Distribution of p-values")
            #dev.off()
            
            
          }else{
            
            
            adjusted.P.value<-fdr_adjust_pvalue
            if(limmadecideTests==TRUE){
              posthoc.results<-decideTests(fit2,method="nestedF",adjust.method="BH",p.value=fdrthresh)
              #tiff("comparison_contrast_overlap.tiff",width=plots.width,height=plots.height,res=plots.res, compression="lzw")
              #if(length(class_labels_levels)<4){
               if(ncol(posthoc.results)<5){ 
                if(output.device.type!="pdf"){
                  
                  temp_filename_5<-"Figures/LIMMA_venn_diagram.png"
                  
                  png(temp_filename_5,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                }
                
                
                vennDiagram(posthoc.results,cex=0.8)
                
                if(output.device.type!="pdf"){
                  
                  try(dev.off(),silent=TRUE)
                }
                
              }
            }else{
              #dev.off()
              
              posthoc.results<-fit2$p.value[,-c(1)]
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab2<-colnames(posthoc.results)
            
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab2,cnames_tab)
            
            data_limma_fdrall_withfeats<-cbind(p.value,adjusted.P.value,posthoc.results,data_m_fc_withfeats)
            data_limma_fdrall_withfeats<-as.data.frame(data_limma_fdrall_withfeats)
            
            if(limmarobust==FALSE){
              filename<-"Tables/limma_posthoc1wayanova_results.txt"
            }else{
              filename<-"Tables/limmarobust_posthoc1wayanova_results.txt"
              
            }
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            
            if(length(check_names)>0){
              
              data_limma_fdrall_withfeats<-cbind(p.value,adjusted.P.value,posthoc.results,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              data_limma_fdrall_withfeats<-as.data.frame(data_limma_fdrall_withfeats)
              #data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              rem_col_ind1<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("mz"))
              
              rem_col_ind2<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("time"))
              
              rem_col_ind<-c(rem_col_ind1,rem_col_ind2)
              
            }else{
              rem_col_ind<-{}
            }
            
            if(length(rem_col_ind)>0){
              write.table(data_limma_fdrall_withfeats[,-c(rem_col_ind)], file=filename,sep="\t",row.names=FALSE)
            }else{
              
              write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            }
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            data_limma_fdrall_withfeats<-cbind(p.value,adjusted.P.value,data_m_fc_withfeats)
            
            
            if(fdrmethod=="none"){
              filename<-paste("limma_posthoc1wayanova_pval",fdrthresh,"_results.txt",sep="")
            }else{
              filename<-paste("limma_posthoc1wayanova_fdr",fdrthresh,"_results.txt",sep="")
            }
            if(length(which(data_limma_fdrall_withfeats$adjusted.P.value<fdrthresh & data_limma_fdrall_withfeats$p.value<pvalue.thresh))>0){
              data_limma_sig_withfeats<-data_limma_fdrall_withfeats[data_limma_fdrall_withfeats$adjusted.P.value<fdrthresh & data_limma_fdrall_withfeats$p.value<pvalue.thresh,]
              #write.table(data_limma_sig_withfeats, file=filename,sep="\t",row.names=FALSE)
            }
            
            # data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,data_m_fc_withfeats)
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            final.pvalues<-pvalues
            
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
          }
          
          #pvalues<-data_limma_fdrall_withfeats$p.value
          
          #final.pvalues<-pvalues
          
          # print("checking here")
          sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
          
          goodip<-which(sel.diffdrthresh==TRUE)
          d4<-as.data.frame(data_limma_fdrall_withfeats)
          logp<-(-1)*log((d4[,1]+(10^-20)),10)
          
          #tiff("pval_dist.tiff",compression="lzw")
          #hist(d4[,1],xlab="p",main="Distribution of p-values")
          #dev.off()
          
          
        
          
          if(length(goodip)<1){
            print("No features selected.")
          }
        }
        
        
        if(featselmethod=="limma2way")
        {
          
         # cat("Performing limma2way analysis",sep="\n")
          
          #design <- cbind(Grp1vs2=c(rep(1,num_samps_group[[1]]),rep(0,num_samps_group[[2]])),Grp2vs1=c(rep(0,num_samps_group[[1]]),rep(1,num_samps_group[[2]])))
         # print("here")
          if(pairedanalysis==TRUE){
         save(f,sampleclass,data_m_fc,classlabels,classlabels_orig,subject_inf,file="limma2way.Rda")
          }
          classlabels_temp<-classlabels
          
          classlabels<-cbind(rownames(classlabels_response_mat),classlabels_response_mat)
          
          classlabels<-as.data.frame(classlabels)
          
          
          colnames(classlabels)<-c("SampleID","Factor1","Factor2")
         # classlabels<- classlabels_orig #classlabels_dataframe #
          colnames(classlabels)<-c("SampleID","Factor1","Factor2")
          
          #design <- model.matrix(~ -1+f)
          
         
          
          #classlabels<-read.table("/Users/karanuppal/Documents/Emory/JonesLab/Projects/DifferentialExpression/xmsPaNDA/examples_and_manual/Example_feature_table_and_classlabels/classlabels_two_way_anova.txt",sep="\t",header=TRUE)
          #classlabels<-classlabels[order(classlabels$Factor2,decreasing = T),]
          
         if(alphabetical.order==FALSE){
          classlabels$Factor1<-factor(classlabels$Factor1,levels=unique(classlabels$Factor1))
          classlabels$Factor2<-factor(classlabels$Factor2,levels=unique(classlabels$Factor2))
          Factor1<-factor(classlabels$Factor1,levels=unique(classlabels$Factor1))
          Factor2<-factor(classlabels$Factor2,levels=unique(classlabels$Factor2))
          
         }else{
           
           Factor1<-factor(classlabels$Factor1)
           
           Factor2<-factor(classlabels$Factor2)
           
         }
         
          
         
          #this will create sum to zero parametrization. Coefficient Comparison Interpretation
          #contrasts(Strain) <- contr.sum(2)
          #contrasts(Treatment) <- contr.sum(2)
          #design <- model.matrix(~Strain*Treatment)
          #Intercept (WT.U+WT.S+Mu.U+Mu.S)/4; Grand mean
          #Strain1 (WT.U+WT.S-Mu.U-Mu.S)/4; strain main effect
          #Treatment1 (WT.U-WT.S+Mu.U-Mu.S)/4; treatment main effect
          #Strain1:Treatment1 (WT.U-WT.S-Mu.U+Mu.S)/4; Interaction
          
         
         
          
          if(limma.contrasts.type=="contr.sum"){
              contrasts_factor1<-contr.sum(length(levels(factor(Factor1))))
              
             # fact2.trt<-contr.treatment(length(levels(factor(Factor2))))*(-1)
             # fact2.trt[1,]<-1
             # colnames(fact2.trt)<-paste(levels(factor(Factor2))[1],"-",levels(factor(Factor2))[-1],sep="")
              
              fact2.sum<-contr.sum(length(levels(factor(Factor2))))
              colnames(fact2.sum)<-paste(levels(factor(Factor2))[-length(levels(factor(Factor2)))],"-",levels(factor(Factor2))[length(levels(factor(Factor2)))],sep="")
              
              
              contrasts_factor2<-fact2.sum #cbind(fact2.trt,fact2.sum)
              
              rownames(contrasts_factor1)<-levels(factor(Factor1))
              rownames(contrasts_factor2)<-levels(factor(Factor2))
              
              cnames_contr_factor1<-apply(contrasts_factor1,2,function(x){paste(names(x[which(abs(x)==1)]),collapse = "-")})
              
              cnames_contr_factor2<-apply(contrasts_factor2,2,function(x){paste(names(x[which(abs(x)==1)]),collapse = "-")})
              
              
          }else{
            
            if(limma.contrasts.type=="contr.SAS"){
              contrasts_factor1<-contr.SAS(length(levels(factor(Factor1))))
              contrasts_factor2<-contr.SAS(length(levels(factor(Factor2))))
              
              rownames(contrasts_factor1)<-levels(factor(Factor1))
              rownames(contrasts_factor2)<-levels(factor(Factor2))
              
              cnames_contr_factor1<-apply(contrasts_factor1,2,function(x){paste(names(x[which(abs(x)==1)]),collapse = "-")})
              
              cnames_contr_factor2<-apply(contrasts_factor2,2,function(x){paste(names(x[which(abs(x)==1)]),collapse = "-")})
              
              
            }else{
              
              #Changed: added the pairwise contr.pairs option on 3/2/2022 at 3:22 PM
              if(limma.contrasts.type=="contr.pairs"){
                
                contr.pairs <-
                  function(levels) {
                    n <- length(levels)
                    design <- matrix(0,n,choose(n,2))
                    rownames(design) <- levels
                    colnames(design) <- 1:choose(n,2)
                    k <- 0
                    for (i in 1:(n-1))
                      for (j in (i+1):n) {
                        k <- k+1
                        design[i,k] <- 1
                        design[j,k] <- -1
                        colnames(design)[k] <- paste(levels[i],"-",levels[j],sep="")
                      }
                    design
                  }
                
                
                contrasts_factor1<-contr.pairs(levels(factor(Factor1)))
                contrasts_factor2<-contr.pairs(levels(factor(Factor2)))
                
                rownames(contrasts_factor1)<-levels(factor(Factor1))
                rownames(contrasts_factor2)<-levels(factor(Factor2))
                
                cnames_contr_factor1<- colnames(contrasts_factor1) #apply(contrasts_factor1,2,function(x){paste(names(x[1]),names(x[which(abs(x)==1)]),sep = "-")})
                cnames_contr_factor2<- colnames(contrasts_factor2) #apply(contrasts_factor2,2,function(x){paste(names(x[1]),names(x[which(abs(x)==1)]),sep= "-")})
                
              }else{
            contrasts_factor1<-contr.treatment(length(levels(factor(Factor1))))
            contrasts_factor2<-contr.treatment(length(levels(factor(Factor2))))
            
            rownames(contrasts_factor1)<-levels(factor(Factor1))
            rownames(contrasts_factor2)<-levels(factor(Factor2))
            
            cnames_contr_factor1<-apply(contrasts_factor1,2,function(x){paste(names(x[1]),names(x[which(abs(x)==1)]),sep = "-")})
            
            cnames_contr_factor2<-apply(contrasts_factor2,2,function(x){paste(names(x[1]),names(x[which(abs(x)==1)]),sep= "-")})
              }
            }
          }
          
         
          
         
          colnames(contrasts_factor1)<-cnames_contr_factor1
          
          dup.contr.ind<-which(duplicated(cnames_contr_factor2)==TRUE)
          if(length(dup.contr.ind)>0){
            contrasts_factor2<-contrasts_factor2[,-dup.contr.ind]
            cnames_contr_factor2<-cnames_contr_factor2[-dup.contr.ind]
          }
          colnames(contrasts_factor2)<-cnames_contr_factor2
          
          contrasts(Factor1) <- contrasts_factor1
          contrasts(Factor2) <- contrasts_factor2
        
          #design <- model.matrix(~Factor1+Factor2)
          
          #Changed: added the contrasts.arg argument on 3/2/2022 at 3:10 PM
          design <- model.matrix(~Factor1*Factor2,contrasts.arg = list(Factor1=contrasts_factor1,Factor2=contrasts_factor2))
          
          
         # fit<-lmFit(data_m_fc,design=design)
          
        
          #2. this will create contrasts with respect to the reference group (first level in each factor)
        if(FALSE){
            contrasts(Factor1) <- contr.treatment(length(levels(factor(Factor1))))
          contrasts(Factor2) <- contr.treatment(length(levels(factor(Factor2))))
          design.trt <- model.matrix(~Factor1*Factor2)
          
          fit.trt<-lmFit(data_m_fc,design=design.trt)
          
          s1=apply(fit.trt$coefficients,2,function(x){
            length(which(is.na(x))==TRUE)/length(x)
          })
          
        }
          classlabels[,c(2:3)]<-apply(classlabels[,c(2:3)],2,function(x){
            
            x<-as.factor(as.character(x))
            return(x)
          })
          
   #       save(classlabels,file="classlabels012.Rda")
          #3. this will create design matrix with all factors
         #call<-lapply(classlabels[,c(2:3)],contrasts,contrasts=FALSE)
         # design.all<-model.matrix(~Factor1*Factor2,data=classlabels,contrasts.arg=call)
          
          #grand mean: mean of means (mean of each level)
          #mean_per_level<-lapply(2:ncol(design.all),function(x){mean(data_m_fc[1,which(design.all[,x]==1)])})
          #mean_per_level<-unlist(mean_per_level)
          #names(mean_per_level)<-colnames(design.all[,-1])
          #grand_mean<-mean(mean_per_level,na.rm=TRUE)
          
          #grand_mean<-with(d,tapply(data_m_fc[1,],list(Factor1,Factor2),mean))
          
          
          
          colnames(design)<-gsub(colnames(design),pattern="Factor1",replacement="")
          colnames(design)<-gsub(colnames(design),pattern="Factor2",replacement="")
          
          
        save(design,f,sampleclass,data_m_fc,classlabels,classlabels_orig,file="limma2waydesign.Rda")
          
          
          classlabels<-classlabels_temp
          
          # print(data_m_fc[1:4,])
          #colnames(design) <- levels(f)
          #colnames(design)<-levels(factor(sampleclass))
          
          
          options(digit=3)
          parameterNames<-colnames(design)
          
       #   print("Design matrix")
        #  print(design)
          
          
          
          if(pairedanalysis==TRUE)
          {
            
            
            
            
            f1<-subject_inf
            
            #print(data_m_fc[1:10,1:10])
            
            #save(design,subject_inf,file="limmadesign.Rda")
          }
          
          if(dim(design)[2]>=1){
            
           
            
            if(pairedanalysis==TRUE){
              
              #class_table_facts<-table(classlabels)
              
              #f1<-c(seq(1,num_samps_group[[1]]),seq(1,num_samps_group[[2]]),seq(1,num_samps_group[[1]]),seq(1,num_samps_group[[2]]))
              
              
              corfit<-duplicateCorrelation(data_m_fc,design=design,block=subject_inf,ndups=1)
              
              #print(f1)
              
              if(limmarobust==TRUE)
              {
                fit<-lmFit(data_m_fc,design,block=f1,cor=corfit$consensus,method="robust")
              }else
              {   
                
                fit<-lmFit(data_m_fc,design,block=f1,cor=corfit$consensus)
              }
              
              s1=apply(fit$coefficients,2,function(x){
                length(which(is.na(x))==TRUE)/length(x)
              })
              
              if(length(which(s1==1))>0){
                design<-design[,-which(s1==1)]
                #fit <- lmFit(data_m_fc,design)
                
                if(limmarobust==TRUE)
                {
                  fit<-lmFit(data_m_fc,design,block=f1,cor=corfit$consensus,method="robust")
                }else{
                  fit<-lmFit(data_m_fc,design,block=f1,cor=corfit$consensus)
              
                }  
              }
              
            }
            else{
              
              
             # fit <- lmFit(data_m_fc,design)
              
              if(limmarobust==TRUE)
              {
                fit<-lmFit(data_m_fc,design,method="robust")
              }else{
                fit <- lmFit(data_m_fc,design)
              }
                
                s1=apply(fit$coefficients,2,function(x){
                     return(length(which(is.na(x))==TRUE)/length(x))
                 })
              
                if(length(which(s1==1))>0){
                    design<-design[,-which(s1==1)]
                    
                    if(limmarobust==TRUE)
                    {
                      fit<-lmFit(data_m_fc,design,method="robust")
                      
                      
                    }else{
                      
                        fit<-lmFit(data_m_fc,design)
                    }
                        
                }
                
              
              
      
            }
            
            
          
            }
          
          

          #fit1=contrasts.fit(fit,cont.matrix)
          fit<-fit[,-1]
          fit2=eBayes(fit)
          
          
          
          results <- topTableF(fit2, n=Inf)
         # decideresults<-decideTests(fit2)
          
          
          # Ordinary fit
          
         save(fit2,fit,results,design,data_m_fc,file="limma.eBayes.fit.Rda")
          
          
          #fit2  <- contrasts.fit(fit, cont.matrix)
          
          #fit2 <- eBayes(fit2)
          #as.data.frame(fit2[1:10,])
          
          # Various ways of summarising or plotting the results
          #topTable(fit2,coef=2)
          
          #    ##save(fit2,file="fit2.Rda")
          
          if(dim(design)[2]>2){
            pvalues<-fit2$F.p.value
            p.value<-fit2$F.p.value
            
            
            
          }else{
            pvalues<-fit2$p.value
            p.value<-fit2$p.value
          }
          
          if(fdrmethod=="BH"){
            fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
          }else{
            if(fdrmethod=="ST"){
              #fdr_adjust_pvalue<-qvalue(pvalues)
              #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
              
              fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
              
              if(is(fdr_adjust_pvalue,"try-error")){
                
                fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
              }
              
              fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
              
              
            }else{
              if(fdrmethod=="Strimmer"){
                pdf("fdrtool.pdf")
                #par_rows=1
                #par(mfrow=c(par_rows,1))
                fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                try(dev.off(),silent=TRUE)
              }else{
                if(fdrmethod=="none"){
                  #	fdr_adjust_pvalue<-pvalues
                  fdr_adjust_pvalue<-p.adjust(pvalues,method="none")	
                }else{
                  if(fdrmethod=="BY"){
                    fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                  }else{
                    if(fdrmethod=="bonferroni"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                    }
                  }
                }
              }
            }
            
          }
          
          #print("Doing this:")
          
          adjusted.p.value<-fdr_adjust_pvalue
          
          data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,data_m_fc_withfeats)
          
          save(design,f,sampleclass,data_m_fc,p.value,adjusted.p.value,data_m_fc_withfeats,fdr_adjust_pvalue,classlabels,classlabels_orig,results,fit2,file="limma2wayres.Rda")
          
          
          if(limmadecideTests==TRUE){
            posthoc.results<-decideTests(fit2,adjust.method="BH",method="nestedF",p.value=fdrthresh) #
            #tiff("comparison_contrast_overlap.tiff",width=plots.width,height=plots.height,res=plots.res, compression="lzw")
            
           # save(posthoc.results,file="posthoc.results.Rda")
            
            
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab2<-colnames(posthoc.results)
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab2,cnames_tab)
            
            data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_withfeats)
            if(limmarobust==FALSE){
              filename<-"Tables/limma_2wayposthoc_decideresults.txt"
            }else{
              
              filename<-"Tables/limmarobust_2wayposthoc_decideresults.txt"
            }
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
         #   write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            #if(length(class_labels_levels)<5){
             if(ncol(posthoc.results)<6){ 
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/LIMMA_venn_diagram.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              vennDiagram(posthoc.results,cex=0.8)
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              
             }
            
            
            
          }
          else{
            #dev.off()
            #Changed: the first column is no longer dropped;  on 3/2/2022 at 3:10 PM
            posthoc.results<-fit2$p.value #[,-c(1)]
          }
          
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab2<-colnames(posthoc.results)
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab2,cnames_tab)
            
            
            #save(data_m_fc_withfeats,names)
            data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_withfeats)
            if(limmarobust==FALSE){
              filename<-"Tables/limma_2wayposthoc_pvalues.txt"
            }else{
              
              filename<-"Tables/limmarobust_2wayposthoc_pvalues.txt"
            }
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            
            if(length(check_names)>0){
            
              
              data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              rem_col_ind1<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("mz"))
              
              rem_col_ind2<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("time"))
              
              rem_col_ind<-c(rem_col_ind1,rem_col_ind2)
              
            }else{
              rem_col_ind<-{}
            }
            
            if(length(rem_col_ind)>0){
              write.table(data_limma_fdrall_withfeats[,-c(rem_col_ind)], file=filename,sep="\t",row.names=FALSE)
            }else{
              
              write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            }
            
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
           # write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
          
          #tiff("comparison_contrast_overlap.tiff",width=plots.width,height=plots.height,res=plots.res, compression="lzw")
          
          #dev.off()
          
          #posthoc.results<-fit2$p.value
          
         
          
          
          
          classlabels_orig<-as.data.frame(classlabels_orig)
          
          
          
        
          
          data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,data_m_fc_withfeats)
          
          # data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
          
          cnames_tab<-colnames(data_m_fc_withfeats)
          cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
          colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
          #write.table(data_limma_fdrall_withfeats,file="Limma_posthoc2wayanova_results.txt",sep="\t",row.names=FALSE)
          #print("checking here")
          pvalues<-p.value
          
          final.pvalues<-pvalues
          
          sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
          
          goodip<-which(sel.diffdrthresh==TRUE)
          d4<-as.data.frame(data_limma_fdrall_withfeats)
          logp<-(-1)*log((d4[,1]+(10^-20)),10)
          
          
          
          #posthoc.results<-decideTests(fit2,method="nestedF",adjust.method=fdrmethod,p.value=fdrthresh)
          
          
          
        
          
          if(length(goodip)<1){
            print("No features selected.")
          }
          }
        
        
        
        if(featselmethod=="RF")
        {
      #    cat("Performing RF analysis",sep="\n")
          maxint<-apply(data_m_fc,1,max)
          
          
          data_m_fc_withfeats<-as.data.frame(data_m_fc_withfeats)
          
          data_m_fc<-as.data.frame(data_m_fc)
          #write.table(classlabels,file="classlabels_rf.txt",sep="\t",row.names=FALSE)
          
          #save(data_m_fc,classlabels,numtrees,analysismode,file="rfdebug.Rda")
          
          
          
          
          if(rfconditional==TRUE){
            
            cat("Performing random forest analysis using the cforest",sep="\n")
            
            #rfcondres1<-do_rf_conditional(X=data_m_fc,rf_classlabels,ntrees=numtrees,analysismode) #,silent=TRUE)
            filename<-"RFconditional_VIM_allfeats.txt"
          }else{
            
            
            
            
            #varimp_res2<-do_rf(X=data_m_fc,classlabels=rf_classlabels,ntrees=numtrees,analysismode)
            
            if(analysismode=="classification"){
              rf_classlabels<-classlabels[,1]
              #print("Performing random forest analysis using the randomForest and Boruta functions")
              varimp_res2<-do_rf_boruta(X=data_m_fc,classlabels=rf_classlabels) #,ntrees=numtrees,analysismode)
              filename<-"RF_VIM_Boruta_allfeats.txt"
              
              varimp_rf_thresh=0
            }else{
              rf_classlabels<-classlabels
              #print("Performing random forest analysis using the randomForest function")
              varimp_res2<-do_rf(X=data_m_fc,classlabels=rf_classlabels,ntrees=numtrees,analysismode)
             # save(varimp_res2,data_m_fc,rf_classlabels,numtrees,analysismode,file="varimp_res2.Rda")
              filename<-"RF_VIM_regression_allfeats.txt"
              varimp_res2<-varimp_res2$rf_varimp #rf_varimp_scaled
              
              
              #find the lowest value within the top max_varsel features to use as threshold
              varimp_rf_thresh<-min(varimp_res2[order(varimp_res2,decreasing=TRUE)[1:(max_varsel+1)]],na.rm=TRUE)
              
            }
            
          }
          names(varimp_res2)<-rownames(data_m_fc)
          varimp_res3<-cbind(data_m_fc_withfeats[,c(1:2)],varimp_res2)
          
          rownames(varimp_res3)<-rownames(data_m_fc)
          filename<-paste("Tables/",filename,sep="")
          write.table(varimp_res3, file=filename,sep="\t",row.names=TRUE)
          
          
          goodip<-which(varimp_res2>varimp_rf_thresh)
          
          if(length(goodip)<1){
            print("No features were selected using the selection criteria.")
          }
          var_names<-rownames(data_m_fc) #paste(sprintf("%.3f",data_m_fc_withfeats[,1]),sprintf("%.1f",data_m_fc_withfeats[,2]),sep="_")
          
          names(varimp_res2)<-as.character(var_names)
          sel.diffdrthresh<-varimp_res2>varimp_rf_thresh
          
          if(length(which(sel.diffdrthresh==TRUE))<1){
            print("No features were selected using the selection criteria")
          }
          
          
          
          num_var_rf<-length(which(sel.diffdrthresh==TRUE))
          
          if(num_var_rf>10){
            
            num_var_rf=10
          }
          sorted_varimp_res<-varimp_res2[order(varimp_res2,decreasing=TRUE)[1:(num_var_rf)]]
          
          sorted_varimp_res<-rev(sort(sorted_varimp_res))
          
          barplot_text=paste("Variable Importance Measure (VIM) \n(top ",length(sorted_varimp_res)," shown)\n",sep="")
          
          if(output.device.type!="pdf"){
            
            temp_filename_1<-"Figures/RF_selectfeats_VIMbarplot.png"
            
            png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
          }
          
          par(mar=c(10,7,4,2))
          #    ##save(varimp_res2,data_m_fc,rf_classlabels,sorted_varimp_res,file="test_rf.Rda")
          #xaxt="n",
          x=barplot(sorted_varimp_res, xlab="", main=barplot_text,cex.axis=0.9,
                    cex.names=0.9, ylab="",las=2,ylim=range(pretty(c(0,sorted_varimp_res))))
          title(ylab = "VIM", cex.lab = 1.5,
                line = 4.5)
          
          #x <- barplot(table(mtcars$cyl), xaxt="n")
       #   labs <- names(sorted_varimp_res)
        #  text(cex=0.7, labs, xpd=FALSE, srt=45) #,x=x-.25, y=-1.25)
          
          if(output.device.type!="pdf"){
            
            try(dev.off(),silent=TRUE)
          }
          
          
          par(mfrow = c(1,1))
          
          rank_num<-rank(-varimp_res2)
          
          data_limma_fdrall_withfeats<-cbind(varimp_res2,rank_num,data_m_fc_withfeats)
          
          cnames_tab<-colnames(data_m_fc_withfeats)
          cnames_tab<-c("VIM","Rank",cnames_tab)
          
          goodip<-which(sel.diffdrthresh==TRUE)
          
          feat_sigfdrthresh[lf]<-length(which(sel.diffdrthresh==TRUE))
          
          colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
          
          #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
          #write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
          
          
        }
        
        if(featselmethod=="MARS"){
          
        #  cat("Performing MARS analysis",sep="\n")
          #print(head(classlabels))
          mars_classlabels<-classlabels #[,1]
          marsres1<-do_mars(X=data_m_fc,mars_classlabels, analysismode,kfold)
          
          #save(data_m_fc,mars_classlabels, analysismode,kfold,marsres1,file="mars.Rda")
          varimp_marsres1<-marsres1$mars_varimp
          
          rownames(varimp_marsres1)<-rownames(data_m_fc)
          mars_mznames<-rownames(varimp_marsres1)
          
          
          #all_names<-paste("mz",seq(1,dim(data_m_fc)[1]),sep="")
          
          #com1<-match(all_names,mars_mznames)
          
          
          filename<-"MARS_variable_importance.txt"
          
          
          if(is.na(max_varsel)==FALSE){
            
            if(max_varsel>dim(data_m_fc)[1]){
              max_varsel=dim(data_m_fc)[1]
            }
            varimp_res2<-varimp_marsres1[,4]
            
            #sort by VIM; and keep the top max_varsel scores
            sorted_varimp_res<-varimp_res2[order(varimp_res2,decreasing=TRUE)[1:(max_varsel)]]
            
            #get the minimum VIM from the top max_varsel scores
            min_thresh<-min(sorted_varimp_res[which(sorted_varimp_res>=mars.gcv.thresh)],na.rm=TRUE)
            
            
            row_num_vec<-seq(1,length(varimp_res2))
            
            #only use the top max_varsel scores
            #goodip<-order(varimp_res2,decreasing=TRUE)[1:(max_varsel)]
            #sel.diffdrthresh<-row_num_vec%in%goodip
            
            #use a threshold of mars.gcv.thresh
            sel.diffdrthresh<-varimp_marsres1[,4]>=min_thresh
            
            goodip<-which(sel.diffdrthresh==TRUE)
            
            
            
          }else{
            
            #use a threshold of mars.gcv.thresh
            sel.diffdrthresh<-varimp_marsres1[,4]>=mars.gcv.thresh
            
            goodip<-which(sel.diffdrthresh==TRUE)
          }
          
          
          num_var_rf<-length(which(sel.diffdrthresh==TRUE))
          
          if(num_var_rf>10){
            
            num_var_rf=10
          }
          sorted_varimp_res<-varimp_res2[order(varimp_res2,decreasing=TRUE)[1:(num_var_rf)]]
          
          sorted_varimp_res<-sort(sorted_varimp_res)
          
          barplot_text=paste("Generalized cross validation (top ",length(sorted_varimp_res)," shown)\n",sep="")
          
          if(output.device.type!="pdf"){
            
            temp_filename_1<-"Figures/MARS_selectfeats_GCVbarplot.png"
            
            png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
          }
          
          
         # barplot(sorted_varimp_res, xlab="Selected features", main=barplot_text,cex.axis=0.5,cex.names=0.4, ylab="GCV",range(pretty(c(0,sorted_varimp_res))),space=0.1)
          par(mar=c(10,7,4,2))
          #    ##save(varimp_res2,data_m_fc,rf_classlabels,sorted_varimp_res,file="test_rf.Rda")
          #xaxt="n",
          x=barplot(sorted_varimp_res, xlab="", main=barplot_text,cex.axis=0.9,
                    cex.names=0.9, ylab="",las=2,ylim=range(pretty(c(0,sorted_varimp_res))))
          title(ylab = "GCV", cex.lab = 1.5,
                line = 4.5)
          
          
          if(output.device.type!="pdf"){
            
            try(dev.off(),silent=TRUE)
          }
          
          
          data_limma_fdrall_withfeats<-cbind(varimp_marsres1[,c(4,6)],data_m_fc_withfeats)
          
          cnames_tab<-colnames(data_m_fc_withfeats)
          cnames_tab<-c("GCV importance","RSS importance",cnames_tab)
          feat_sigfdrthresh[lf]<-length(which(sel.diffdrthresh==TRUE))
          
          colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
          
          
          goodip<-which(sel.diffdrthresh==TRUE)
          
          
          
        }
        
        if(featselmethod=="pls" | featselmethod=="o1pls" | featselmethod=="o2pls" | featselmethod=="spls" | featselmethod=="o1spls" | featselmethod=="o2spls")
        {
          
          cat(paste("Performing ",featselmethod," analysis",sep=""),sep="\n")
          
          classlabels<-as.data.frame(classlabels)
          
          
          if(is.na(max_comp_sel)==TRUE){
            max_comp_sel=pls_ncomp
          }
          
          rand_pls_sel<-{} #new("list")
          if(featselmethod=="spls" | featselmethod=="o1spls" | featselmethod=="o2spls"){
            
            
            if(featselmethod=="o1spls"){
              
              featselmethod="o1pls"
              
            }else{
              
              if(featselmethod=="o2spls"){
                featselmethod="o2pls"
              }
              
            }
            
            if(pairedanalysis==TRUE){
              
              classlabels_temp<-cbind(classlabels_sub[,2],classlabels)
              
              
              set.seed(999)
              
              plsres1<-do_plsda(X=data_m_fc,Y=classlabels_sub,oscmode=featselmethod,numcomp=pls_ncomp,kfold=kfold,evalmethod=pred.eval.method,keepX=max_varsel,sparseselect=TRUE,
                                analysismode,sample.col.opt=sample.col.opt,sample.col.vec=col_vec,scoreplot_legend=scoreplot_legend,pairedanalysis=pairedanalysis,
                                optselect=optselect,class_labels_levels_main=class_labels_levels_main,legendlocation=legendlocation,output.device.type=output.device.type,
                                plots.res=plots.res,plots.width=plots.width,plots.height=plots.height,plots.type=plots.type,pls.ellipse=pca.ellipse,alphabetical.order=alphabetical.order)
              
              if (is(plsres1, "try-error")){
                print(paste("sPLS could not be performed at RSD threshold: ",log2.fold.change.thresh,sep=""))
                #break;
              }
              
              opt_comp<-plsres1$opt_comp
              #for(randindex in 1:100)
              #save(plsres1,file="plsres1.Rda")
              
              if(is.na(pls.permut.count)==FALSE){
                set.seed(999)
                seedvec<-runif(pls.permut.count,10,10*pls.permut.count)
                
                
                
                if(pls.permut.count>0){
                  
                  cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
                  clusterEvalQ(cl,library(plsgenomics))
                  clusterEvalQ(cl,library(dplyr))
                  
                  clusterEvalQ(cl,library(plyr))
                  clusterExport(cl,"pls.lda.cv",envir = .GlobalEnv)
                  clusterExport(cl,"plsda_cv",envir = .GlobalEnv)
                  #clusterExport(cl,"%>%",envir = .GlobalEnv) #%>%
                  clusterExport(cl,"do_plsda_rand",envir = .GlobalEnv)
                  clusterEvalQ(cl,library(mixOmics))
                  clusterEvalQ(cl,library(pls))
                  
                  
                  rand_pls_sel<-parLapply(cl,1:pls.permut.count,function(x)
                  {
                    
                    set.seed(seedvec[x])
                    
                    
                    plsresrand<-do_plsda_rand(X=data_m_fc,Y=classlabels_sub[sample(x=seq(1,dim(classlabels_sub)[1]),
                                                                                   size=dim(classlabels_sub)[1]),],oscmode=featselmethod,
                                              numcomp=opt_comp,kfold=kfold,evalmethod=pred.eval.method,keepX=max_varsel,sparseselect=TRUE,
                                              analysismode,sample.col.vec=col_vec,scoreplot_legend=scoreplot_legend,pairedanalysis=pairedanalysis,
                                              optselect=FALSE,class_labels_levels_main=class_labels_levels_main,legendlocation=legendlocation,plotindiv=FALSE,alphabetical.order=alphabetical.order) #,silent=TRUE)
                    
                    #rand_pls_sel<-cbind(rand_pls_sel,plsresrand$vip_res[,1])
                    if (is(plsresrand, "try-error")){
                      
                      return(rep(0,dim(data_m_fc)[1]))
                    }else{
                      return(plsresrand$vip_res[,1])
                    }
                  })
                  
                  stopCluster(cl)
                }
              }
              
              
              
            }else{	
              #plsres1<-try(do_plsda(X=data_m_fc,Y=classlabels,oscmode=featselmethod,numcomp=pls_ncomp,kfold=kfold,evalmethod=pred.eval.method,keepX=max_varsel,sparseselect=TRUE,analysismode,sample.col.vec=col_vec,scoreplot_legend=scoreplot_legend,pairedanalysis=pairedanalysis,optselect=optselect,class_labels_levels_main=class_labels_levels_main,legendlocation=legendlocation,pls.vip.selection=pls.vip.selection),silent=TRUE)
              
              #  ##save(data_m_fc,classlabels,pls_ncomp,kfold,file="pls1.Rda")
              set.seed(999)
              plsres1<-do_plsda(X=data_m_fc,Y=classlabels,oscmode=featselmethod,numcomp=pls_ncomp,kfold=kfold,evalmethod=pred.eval.method,
                                keepX=max_varsel,sparseselect=TRUE,analysismode,sample.col.opt=sample.col.opt,sample.col.vec=col_vec,
                                scoreplot_legend=scoreplot_legend,pairedanalysis=pairedanalysis,optselect=optselect,
                                class_labels_levels_main=class_labels_levels_main,legendlocation=legendlocation,
                                pls.vip.selection=pls.vip.selection,output.device.type=output.device.type,
                                plots.res=plots.res,plots.width=plots.width,plots.height=plots.height,plots.type=plots.type,pls.ellipse=pca.ellipse,alphabetical.order=alphabetical.order)
              
              opt_comp<-plsres1$opt_comp
              
              if (is(plsres1, "try-error")){
                print(paste("sPLS could not be performed at RSD threshold: ",log2.fold.change.thresh,sep=""))
                break;
              }
              #for(randindex in 1:100)
              if(is.na(pls.permut.count)==FALSE){
                
                set.seed(999)
                seedvec<-runif(pls.permut.count,10,10*pls.permut.count)
                
                
                
                if(pls.permut.count>0){
                  
                  cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
                  clusterEvalQ(cl,library(plsgenomics))
                  clusterEvalQ(cl,library(dplyr))
                  
                  clusterEvalQ(cl,library(plyr))
                  clusterExport(cl,"pls.lda.cv",envir = .GlobalEnv)
                  clusterExport(cl,"plsda_cv",envir = .GlobalEnv)
                  #clusterExport(cl,"%>%",envir = .GlobalEnv) #%>%
                  clusterExport(cl,"do_plsda_rand",envir = .GlobalEnv)
                  clusterEvalQ(cl,library(mixOmics))
                  clusterEvalQ(cl,library(pls))
                  
                  
                  rand_pls_sel<-parLapply(cl,1:pls.permut.count,function(x)
                  {
                    
                    set.seed(seedvec[x])
                    
                    
                    plsresrand<-do_plsda_rand(X=data_m_fc,Y=classlabels[sample(x=seq(1,dim(classlabels)[1]),size=dim(classlabels)[1]),],oscmode=featselmethod,numcomp=opt_comp,kfold=kfold,
                                              evalmethod=pred.eval.method,keepX=max_varsel,sparseselect=TRUE,analysismode,sample.col.vec=col_vec,scoreplot_legend=scoreplot_legend,
                                              pairedanalysis=pairedanalysis,optselect=FALSE,class_labels_levels_main=class_labels_levels_main,
                                              legendlocation=legendlocation,plotindiv=FALSE,alphabetical.order=alphabetical.order)
                    
                    #rand_pls_sel<-cbind(rand_pls_sel,plsresrand$vip_res[,1])
                    #return(plsresrand$vip_res[,1])		
                    if (is(plsresrand, "try-error")){
                      
                      return(rep(0,dim(data_m_fc)[1]))
                    }else{
                      return(plsresrand$vip_res[,1])
                    }
                  })
                  
                  stopCluster(cl)
                  
                }
              }
              
            }
            pls_vip_thresh<-0
            
            if (is(plsres1, "try-error")){
              print(paste("sPLS could not be performed at RSD threshold: ",log2.fold.change.thresh,sep=""))
              break;
            }else{	
              opt_comp<-plsres1$opt_comp
            }
            
          }else{
            #PLS
            if(pairedanalysis==TRUE){
              classlabels_temp<-cbind(classlabels_sub[,2],classlabels)
              plsres1<-do_plsda(X=data_m_fc,Y=classlabels_temp,oscmode=featselmethod,numcomp=pls_ncomp,kfold=kfold,evalmethod=pred.eval.method,
                                keepX=max_varsel,sparseselect=FALSE,analysismode=analysismode,vip.thresh=pls_vip_thresh,sample.col.opt=sample.col.opt,
                                sample.col.vec=col_vec,scoreplot_legend=scoreplot_legend,pairedanalysis=pairedanalysis,optselect=optselect,
                                class_labels_levels_main=class_labels_levels_main,legendlocation=legendlocation,pls.vip.selection=pls.vip.selection,
                                output.device.type=output.device.type,plots.res=plots.res,plots.width=plots.width,
                                plots.height=plots.height,plots.type=plots.type,pls.ellipse=pca.ellipse,alphabetical.order=alphabetical.order)
              
              if (is(plsres1, "try-error")){
                print(paste("PLS could not be performed at RSD threshold: ",log2.fold.change.thresh,sep=""))
                break;
              }else{
                opt_comp<-plsres1$opt_comp
              }
              
            }else{
              
              plsres1<-do_plsda(X=data_m_fc,Y=classlabels,oscmode=featselmethod,numcomp=pls_ncomp,kfold=kfold,evalmethod=pred.eval.method,keepX=max_varsel,
                                sparseselect=FALSE,analysismode=analysismode,vip.thresh=pls_vip_thresh,sample.col.opt=sample.col.opt,
                                sample.col.vec=col_vec,scoreplot_legend=scoreplot_legend,pairedanalysis=pairedanalysis,optselect=optselect,
                                class_labels_levels_main=class_labels_levels_main,legendlocation=legendlocation,pls.vip.selection=pls.vip.selection,
                                output.device.type=output.device.type,plots.res=plots.res,plots.width=plots.width,plots.height=plots.height,
                                plots.type=plots.type,pls.ellipse=pca.ellipse,alphabetical.order=alphabetical.order)
              
              if (is(plsres1, "try-error")){
                print(paste("PLS could not be performed at RSD threshold: ",log2.fold.change.thresh,sep=""))
                break;
              }else{
                opt_comp<-plsres1$opt_comp
              }
              #for(randindex in 1:100){
              if(is.na(pls.permut.count)==FALSE){
                
                
                set.seed(999)
                seedvec<-runif(pls.permut.count,10,10*pls.permut.count)
                
                
                
                if(pls.permut.count>0){
                  
                  cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
                  clusterEvalQ(cl,library(plsgenomics))
                  clusterEvalQ(cl,library(dplyr))
                  
                  clusterEvalQ(cl,library(plyr))
                  clusterExport(cl,"pls.lda.cv",envir = .GlobalEnv)
                  clusterExport(cl,"plsda_cv",envir = .GlobalEnv)
                  #clusterExport(cl,"%>%",envir = .GlobalEnv) #%>%
                  clusterExport(cl,"do_plsda_rand",envir = .GlobalEnv)
                  clusterEvalQ(cl,library(mixOmics))
                  clusterEvalQ(cl,library(pls))
                  
                  #here
                  rand_pls_sel<-parLapply(cl,1:pls.permut.count,function(x)
                  {
                    
                    set.seed(seedvec[x])
                    #t1fname<-paste("ranpls",x,".Rda",sep="")
                    ####savelist=ls(),file=t1fname)
                    print(paste("PLSDA permutation number: ",x,sep=""))
                    
                    plsresrand<-do_plsda_rand(X=data_m_fc,Y=classlabels[sample(x=seq(1,dim(classlabels)[1]),size=dim(classlabels)[1]),],
                                              oscmode=featselmethod,numcomp=opt_comp,kfold=kfold,evalmethod=pred.eval.method,
                                              keepX=max_varsel,sparseselect=FALSE,analysismode,sample.col.vec=col_vec,
                                              scoreplot_legend=scoreplot_legend,pairedanalysis=pairedanalysis,optselect=FALSE,
                                              class_labels_levels_main=class_labels_levels_main,legendlocation=legendlocation,plotindiv=FALSE,alphabetical.order=alphabetical.order) #,silent=TRUE)
                    
                    if (is(plsresrand, "try-error")){
                      
                      
                      return(1)
                    }else{
                      return(plsresrand$vip_res[,1])
                      
                    }
                    
                    
                  })
                  
                  stopCluster(cl)
                }
                ####saverand_pls_sel,file="rand_pls_sel1.Rda")
                
              }
              
            }
            opt_comp<-plsres1$opt_comp
          }
          
          if(length(plsres1$bad_variables)>0){
            
            data_m_fc_withfeats<-data_m_fc_withfeats[-c(plsres1$bad_variables),]
            data_m_fc<-data_m_fc[-c(plsres1$bad_variables),]
          }
          
          
          
          if(is.na(pls.permut.count)==FALSE){
            
            if(pls.permut.count>0){
              
              ###saverand_pls_sel,file="rand_pls_sel.Rda")
              
              #rand_pls_sel<-ldply(rand_pls_sel,rbind)  #unlist(rand_pls_sel)
              rand_pls_sel<-as.data.frame(rand_pls_sel)
              rand_pls_sel<-t(rand_pls_sel)
              rand_pls_sel<-as.data.frame(rand_pls_sel)
              
              if(featselmethod=="spls"){
                
                rand_pls_sel[rand_pls_sel!=0]<-1
              }else{
                
                rand_pls_sel[rand_pls_sel<pls_vip_thresh]<-0
                rand_pls_sel[rand_pls_sel>=pls_vip_thresh]<-1
                
              }
              
              ####saverand_pls_sel,file="rand_pls_sel2.Rda")
              rand_pls_sel_prob<-apply(rand_pls_sel,2,sum)/pls.permut.count
              #rand_pls_sel_fdr<-p.adjust(rand_pls_sel_prob,method=fdrmethod)
              pvalues<-rand_pls_sel_prob
              if(fdrmethod=="BH"){
                fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
              }else{
                if(fdrmethod=="ST"){
                  #fdr_adjust_pvalue<-qvalue(pvalues)
                  #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                  
                  fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
                  
                  if(is(fdr_adjust_pvalue,"try-error")){
                    
                    fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
                  }
                  
                  fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                  
                  
                }else{
                  if(fdrmethod=="Strimmer"){
                    pdf("fdrtool.pdf")
                    #par_rows=1
                    #par(mfrow=c(par_rows,1))
                    fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                    fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                    try(dev.off(),silent=TRUE)
                  }else{
                    if(fdrmethod=="none"){
                      fdr_adjust_pvalue<-pvalues
                      #fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
                    }else{
                      if(fdrmethod=="BY"){
                        fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                      }else{
                        if(fdrmethod=="bonferroni"){
                          fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                        }
                      }
                      
                    }
                  }
                }
                
              }
              
              rand_pls_sel_fdr<-fdr_adjust_pvalue
              
              
              vip_res<-cbind(data_m_fc_withfeats[,c(1:2)],plsres1$vip_res,rand_pls_sel_prob,rand_pls_sel_fdr)
              
            }else{
              vip_res<-cbind(data_m_fc_withfeats[,c(1:2)],plsres1$vip_res)
              rand_pls_sel_fdr<-rep(0,dim(data_m_fc_withfeats[,c(1:2)])[1])
              rand_pls_sel_prob<-rep(0,dim(data_m_fc_withfeats[,c(1:2)])[1])
            }
          }else{
            vip_res<-cbind(data_m_fc_withfeats[,c(1:2)],plsres1$vip_res)
            rand_pls_sel_fdr<-rep(0,dim(data_m_fc_withfeats[,c(1:2)])[1])
            rand_pls_sel_prob<-rep(0,dim(data_m_fc_withfeats[,c(1:2)])[1])
          }
          
          write.table(vip_res,file="Tables/vip_res.txt",sep="\t",row.names=FALSE)
          
          
          #				write.table(r2_q2_valid_res,file="pls_r2_q2_res.txt",sep="\t",row.names=TRUE)
          
          
          varimp_plsres1<-plsres1$selected_variables
          
          opt_comp<-plsres1$opt_comp				
          if(max_comp_sel>opt_comp){
            
            max_comp_sel<-opt_comp
          }
          
          #	print("opt comp is")
          #print(opt_comp)
          if(featselmethod=="spls"){
            
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab<-c("Loading (absolute)","Rank",cnames_tab)
            
            #
            if(opt_comp>1){
              
              #abs
              vip_res1<-abs(plsres1$vip_res)
              
              if(max_comp_sel>1){
                vip_res1<-apply(vip_res1[,c(1:max_comp_sel)],1,max)
                
              }else{
                
                vip_res1<-vip_res1[,c(1)]
              }		
            }else{
              
              vip_res1<-abs(plsres1$vip_res)
            }	
            
            pls_vip<-vip_res1 #(plsres1$vip_res)
            
            
            if(is.na(pls.permut.count)==FALSE){
            #based on loadings for sPLS
            sel.diffdrthresh<-pls_vip!=0 & rand_pls_sel_fdr<fdrthresh & rand_pls_sel_prob<pvalue.thresh
            }else{
              
             # print("DOING SPLS #here999")
              sel.diffdrthresh<-pls_vip!=0
            }
            
            goodip<-which(sel.diffdrthresh==TRUE)
            
           # save(goodip,pls_vip,rand_pls_sel_fdr,rand_pls_sel_prob,sel.diffdrthresh,file="splsdebug1.Rda")
            
            
            
            
          }else{
            
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab<-c("VIP","Rank",cnames_tab)
            
            
            if(max_comp_sel>opt_comp){
              
              max_comp_sel<-opt_comp
            }
            
            
            #pls_vip<-plsres1$vip_res[,c(1:max_comp_sel)]
            
            
            if(opt_comp>1){
              vip_res1<-(plsres1$vip_res)
              if(max_comp_sel>1){
                
                if(pls.vip.selection=="mean"){
                  vip_res1<-apply(vip_res1[,c(1:max_comp_sel)],1,mean)
                  
                }else{
                  
                  vip_res1<-apply(vip_res1[,c(1:max_comp_sel)],1,max)
                }
              }else{
                
                vip_res1<-vip_res1[,c(1)]
              }
            }else{
              
              vip_res1<-plsres1$vip_res
            }
            
            
            
            #vip_res1<-plsres1$vip_res
            pls_vip<-vip_res1
            
            
            
            
            #pls
            sel.diffdrthresh<-pls_vip>=pls_vip_thresh & rand_pls_sel_fdr<fdrthresh & rand_pls_sel_prob<pvalue.thresh
            
            goodip<-which(sel.diffdrthresh==TRUE)
            
          }
          
          rank_vec<-order(pls_vip,decreasing=TRUE)
          rank_vec2<-seq(1,length(rank_vec))
          
          ranked_vec<-pls_vip[rank_vec]
          rank_num<-match(pls_vip,ranked_vec)
          
          
          
          data_limma_fdrall_withfeats<-cbind(pls_vip,rank_num,data_m_fc_withfeats)
          
          
          feat_sigfdrthresh[lf]<-length(which(sel.diffdrthresh==TRUE)) #length(plsres1$selected_variables) #length(which(sel.diffdrthresh==TRUE))
          
          filename<-paste("Tables/",parentfeatselmethod,"_variable_importance.txt",sep="")
          
          colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
          
          #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
          write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
          
          
          
          
        }
        
        #stop("Please choose limma, RF, RFcond, or MARS for featselmethod.")
        if(featselmethod=="lmreg" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat"| featselmethod=="logitreg" | featselmethod=="wilcox" | featselmethod=="ttest" | 
           featselmethod=="ttestrepeat" |  featselmethod=="poissonreg" | featselmethod=="wilcoxrepeat" | featselmethod=="lmregrepeat")
        {
          pvalues<-{}
          
          classlabels_response_mat<-as.data.frame(classlabels_response_mat)
          
          if(featselmethod=="ttestrepeat"){
            featselmethod="ttest"
            pairedanalysis=TRUE
          }
          
          if(featselmethod=="wilcoxrepeat"){
            
            featselmethod="wilcox"
            pairedanalysis=TRUE
          }
          
          if(featselmethod=="lm1wayanova")
          {
            
          #  cat("Performing one-way ANOVA analysis",sep="\n")
            
            #print(dim(data_m_fc))
            #print(dim(classlabels_response_mat))
            #print(dim(classlabels))
            
            #data_mat_anova<-cbind(t(data_m_fc),classlabels_response_mat)
            
            
            numcores<-round(detectCores()*0.6)
            
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            
            clusterExport(cl,"diffexponewayanova",envir = .GlobalEnv)
            
            clusterExport(cl,"anova",envir = .GlobalEnv)
            
            
            clusterExport(cl,"TukeyHSD",envir = .GlobalEnv)
            
            clusterExport(cl,"aov",envir = .GlobalEnv)
            
            
            
            res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat){
              xvec<-x	
              
              
              data_mat_anova<-cbind(xvec,classlabels_response_mat)
              
              data_mat_anova<-as.data.frame(data_mat_anova)
              cnames<-colnames(data_mat_anova)
              
              cnames[1]<-"Response"
              
              colnames(data_mat_anova)<-c("Response","Factor1")
              
              
              
              data_mat_anova$Factor1<-as.factor(data_mat_anova$Factor1)
              
              anova_res<-diffexponewayanova(dataA=data_mat_anova)
              
              
              
              return(anova_res)
            },classlabels_response_mat)
            
            stopCluster(cl)
            main_pval_mat<-{}
            
            posthoc_pval_mat<-{}
            pvalues<-{}
            
            
            #print(head(res1))
            
            for(i in 1:length(res1)){
              
              
              main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
              pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
              posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthocfactor1)
              
              
            }
            pvalues<-unlist(pvalues)
            
            #print(summary(pvalues))
            
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
            }else{
              if(fdrmethod=="ST"){
                #fdr_adjust_pvalue<-qvalue(pvalues)
                #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
                
                if(is(fdr_adjust_pvalue,"try-error")){
                  
                  fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                  fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    #fdr_adjust_pvalue<-pvalues
                    fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                    }else{
                      if(fdrmethod=="bonferroni"){
                        fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                      }
                    }
                  }
                }
              }
              
            }
            
            if(fdrmethod=="none"){
              filename<-"lm1wayanova_pvalall_posthoc.txt"
            }else{
              filename<-"lm1wayanova_fdrall_posthoc.txt"
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            
            posthoc_names<-colnames(posthoc_pval_mat)
            if(length(posthoc_names)<1){
              
              posthoc_names<-c("Factor1vs2")
            }																
            
            cnames_tab<-c("P.value","adjusted.P.value",posthoc_names,cnames_tab)
            
            #cnames_tab<-c("P.value","adjusted.P.value","posthoc.pvalue",cnames_tab)
            
            pvalues<-as.data.frame(pvalues)
            
            #pvalues<-t(pvalues)
            
            pvalues<-as.data.frame(pvalues)
            
            final.pvalues<-pvalues
            #final.pvalues<-pvalues
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,posthoc_pval_mat,data_m_fc_withfeats)
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #gohere
            
            if(length(check_names)>0){
              
             # data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,pvalues2,fdr_adjust_pvalue2,pvalues3,fdr_adjust_pvalue3,posthoc_pval_mat,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              #colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
              
              data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,posthoc_pval_mat,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
              
              
              data_limma_fdrall_withfeats<-as.data.frame(data_limma_fdrall_withfeats)
              #data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              rem_col_ind1<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("mz"))
              
              rem_col_ind2<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("time"))
              
              rem_col_ind<-c(rem_col_ind1,rem_col_ind2)
              
            }else{
              rem_col_ind<-{}
            }
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            filename<-paste("Tables/",filename,sep="")
            
            
            
            if(length(rem_col_ind)>0){
              #write.table(data_limma_fdrall_withfeats[,-c(rem_col_ind)], file="Tables/twowayanova_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
              
              write.table(data_limma_fdrall_withfeats[,-c(rem_col_ind)], file=filename,sep="\t",row.names=FALSE)
            }else{
              
              
              #write.table(data_limma_fdrall_withfeats,file="Tables/twowayanova_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
              
              write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
              
            }
            
           
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
          }
          
          
          
          if(featselmethod=="ttest" && pairedanalysis==TRUE)
          {
            
           cat("Performing paired t-test analysis",sep="\n")
            
            #print(dim(data_m_fc))
            #print(dim(classlabels_response_mat))
            #print(dim(classlabels))
            
            #data_mat_anova<-cbind(t(data_m_fc),classlabels_response_mat)
            
            numcores<-round(detectCores()*0.5)
            
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            
            clusterExport(cl,"t.test",envir = .GlobalEnv)
            
            
            res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat){
              
              xvec<-x
              
              
              data_mat_anova<-cbind(xvec,classlabels_response_mat)
              
              data_mat_anova<-as.data.frame(data_mat_anova)
              cnames<-colnames(data_mat_anova)
              
              cnames[1]<-"Response"
              
              colnames(data_mat_anova)<-c("Response","Factor1")
              
              #print(data_mat_anova)
              
              data_mat_anova$Factor1<-as.factor(data_mat_anova$Factor1)
              
              #anova_res<-diffexponewayanova(dataA=data_mat_anova)
              
              x1<-data_mat_anova$Response[which(data_mat_anova$Factor1==class_labels_levels[1])]
              
              y1<-data_mat_anova$Response[which(data_mat_anova$Factor1==class_labels_levels[2])]
              
              w1<-t.test(x=x1,y=y1,alternative="two.sided",paired=TRUE)
              
              return(w1$p.value)
            },classlabels_response_mat)
            
            stopCluster(cl)
            
            main_pval_mat<-{}
            
            posthoc_pval_mat<-{}
            pvalues<-{}
            
            
            
            pvalues<-unlist(res1)
            
            
            #print(summary(pvalues))
            
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
            }else{
              if(fdrmethod=="ST"){
                #fdr_adjust_pvalue<-qvalue(pvalues)
                #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
                
                if(is(fdr_adjust_pvalue,"try-error")){
                  
                  fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                  fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    #fdr_adjust_pvalue<-pvalues
                    fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                    }else{
                      if(fdrmethod=="bonferroni"){
                        fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                      }
                    }
                  }
                }
              }
              
            }
            
            if(fdrmethod=="none"){
              filename<-"pairedttest_pvalall_withfeats.txt"
            }else{
              filename<-"pairedttest_fdrall_withfeats.txt"
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            
            posthoc_names<-colnames(posthoc_pval_mat)
            if(length(posthoc_names)<1){
              
              posthoc_names<-c("Factor1vs2")
            }
            
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
            
            #cnames_tab<-c("P.value","adjusted.P.value","posthoc.pvalue",cnames_tab)
            
            pvalues<-as.data.frame(pvalues)
            
            #pvalues<-t(pvalues)
            # print(dim(pvalues))
            #print(dim(data_m_fc_withfeats))
            
            final.pvalues<-pvalues
            sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            #  write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
          }
          
          if(featselmethod=="ttest" && pairedanalysis==FALSE)
          {
            
            cat("Performing t-test analysis",sep="\n")
            
            #print(dim(data_m_fc))
            #print(dim(classlabels_response_mat))
            #print(dim(classlabels))
            
            #data_mat_anova<-cbind(t(data_m_fc),classlabels_response_mat)
            
            numcores<-round(detectCores()*0.5)
            
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            
            clusterExport(cl,"t.test",envir = .GlobalEnv)
            
            
            res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat){
              
              xvec<-x
              
              
              data_mat_anova<-cbind(xvec,classlabels_response_mat)
              
              data_mat_anova<-as.data.frame(data_mat_anova)
              cnames<-colnames(data_mat_anova)
              
              cnames[1]<-"Response"
              
              colnames(data_mat_anova)<-c("Response","Factor1")
              
              #print(data_mat_anova)
              
              data_mat_anova$Factor1<-as.factor(data_mat_anova$Factor1)
              
              #anova_res<-diffexponewayanova(dataA=data_mat_anova)
              
              x1<-data_mat_anova$Response[which(data_mat_anova$Factor1==class_labels_levels[1])]
              
              y1<-data_mat_anova$Response[which(data_mat_anova$Factor1==class_labels_levels[2])]
              
              w1<-t.test(x=x1,y=y1,alternative="two.sided")
              
              return(w1$p.value)
            },classlabels_response_mat)
            
            stopCluster(cl)
            
            main_pval_mat<-{}
            
            posthoc_pval_mat<-{}
            pvalues<-{}
            
            
            
            pvalues<-unlist(res1)
            
            
            #print(summary(pvalues))
            
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
            }else{
              if(fdrmethod=="ST"){
                #fdr_adjust_pvalue<-qvalue(pvalues)
                #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
                
                if(is(fdr_adjust_pvalue,"try-error")){
                  
                  fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                  fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    #fdr_adjust_pvalue<-pvalues
                    fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                    }else{
                      if(fdrmethod=="bonferroni"){
                        fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                      }
                    }
                  }
                }
              }
              
            }
            
            if(fdrmethod=="none"){
              filename<-"ttest_pvalall_withfeats.txt"
            }else{
              filename<-"ttest_fdrall_withfeats.txt"
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            
            posthoc_names<-colnames(posthoc_pval_mat)
            if(length(posthoc_names)<1){
              
              posthoc_names<-c("Factor1vs2")
            }
            
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
            
            #cnames_tab<-c("P.value","adjusted.P.value","posthoc.pvalue",cnames_tab)
            
            pvalues<-as.data.frame(pvalues)
            
            #pvalues<-t(pvalues)
            # print(dim(pvalues))
            #print(dim(data_m_fc_withfeats))
            
            final.pvalues<-pvalues
            sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            #  write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
          }
          
          
          if(featselmethod=="wilcox")
          {
            
         #   cat("Performing Wilcox rank-sum analysis",sep="\n")
            
            #print(dim(data_m_fc))
            #print(dim(classlabels_response_mat))
            #print(dim(classlabels))
            
            #data_mat_anova<-cbind(t(data_m_fc),classlabels_response_mat)
            
            numcores<-round(detectCores()*0.5)
            
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            
            clusterExport(cl,"wilcox.test",envir = .GlobalEnv)
            
            
            res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat){
              
              xvec<-x
              
              
              data_mat_anova<-cbind(xvec,classlabels_response_mat)
              
              data_mat_anova<-as.data.frame(data_mat_anova)
              cnames<-colnames(data_mat_anova)
              
              cnames[1]<-"Response"
              
              colnames(data_mat_anova)<-c("Response","Factor1")
              
              #print(data_mat_anova)
              
              data_mat_anova$Factor1<-as.factor(data_mat_anova$Factor1)
              
              #anova_res<-diffexponewayanova(dataA=data_mat_anova)
              
              x1<-data_mat_anova$Response[which(data_mat_anova$Factor1==class_labels_levels[1])]
              
              y1<-data_mat_anova$Response[which(data_mat_anova$Factor1==class_labels_levels[2])]
              
              w1<-wilcox.test(x=x1,y=y1,alternative="two.sided")
              
              return(w1$p.value)
            },classlabels_response_mat)
            
            stopCluster(cl)
            
            main_pval_mat<-{}
            
            posthoc_pval_mat<-{}
            pvalues<-{}
            
            
            
            pvalues<-unlist(res1)
            
            
            #print(summary(pvalues))
            
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
            }else{
              if(fdrmethod=="ST"){
                #fdr_adjust_pvalue<-qvalue(pvalues)
                #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
                
                if(is(fdr_adjust_pvalue,"try-error")){
                  
                  fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                  fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    #fdr_adjust_pvalue<-pvalues
                    fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                    }else{
                      if(fdrmethod=="bonferroni"){
                        fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                      }
                    }
                  }
                }
              }
              
            }
            
            if(fdrmethod=="none"){
              filename<-"wilcox_pvalall_withfeats.txt"
            }else{
              filename<-"wilcox_fdrall_withfeats.txt"
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            
            posthoc_names<-colnames(posthoc_pval_mat)
            if(length(posthoc_names)<1){
              
              posthoc_names<-c("Factor1vs2")
            }																
            
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
            
            #cnames_tab<-c("P.value","adjusted.P.value","posthoc.pvalue",cnames_tab)
            
            pvalues<-as.data.frame(pvalues)
            
            
            final.pvalues<-pvalues
            sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            #  write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
          }
          
          #lmreg:feature selections
          if(featselmethod=="lmreg")
          {
            
            if(logistic_reg==TRUE){
              
              
              if(length(levels(classlabels_response_mat[,1]))>2){
                
                print("More than 2 classes found. Skipping logistic regression analysis.")
                next;
              }
              
             # cat("Performing logistic regression analysis",sep="\n")
              
              classlabels_response_mat[,1]<-as.numeric((classlabels_response_mat[,1]))-1
              
              fileheader="logitreg"
              
              
            }else{
              
              if(poisson_reg==TRUE){
                
                
             #   cat("Performing poisson regression analysis",sep="\n")
                fileheader="poissonreg"
                classlabels_response_mat[,1]<-as.numeric((classlabels_response_mat[,1]))
                
              }else{
           #    cat("Performing linear regression analysis",sep="\n")
                fileheader="lmreg"
              }
            }
            
            
            
            numcores<-num_nodes #round(detectCores()*0.5)
            
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            
            clusterExport(cl,"diffexplmreg",envir = .GlobalEnv)
            clusterExport(cl,"lm",envir = .GlobalEnv)
            clusterExport(cl,"glm",envir = .GlobalEnv)
            clusterExport(cl,"summary",envir = .GlobalEnv)
            clusterExport(cl,"anova",envir = .GlobalEnv)
            clusterEvalQ(cl,library(sandwich))
            
            
            #data_mat_anova<-cbind(t(data_m_fc),classlabels_response_mat)
            res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat,logistic_reg,poisson_reg,robust.estimate,vcovHC.type){
              
              xvec<-x
              
              
              
              data_mat_anova<-cbind(xvec,classlabels_response_mat)
              
              cnames<-colnames(data_mat_anova)
              cnames[1]<-"Response"
              
              colnames(data_mat_anova)<-cnames
              
              #lmreg feature selection
              anova_res<-diffexplmreg(dataA=data_mat_anova,logistic_reg,poisson_reg,robust.estimate,vcovHC.type)
              
              return(anova_res)
            },classlabels_response_mat,logistic_reg,poisson_reg,robust.estimate,vcovHC.type)
            
            stopCluster(cl)
            main_pval_mat<-{}
            
            posthoc_pval_mat<-{}
            pvalues<-{}
            
            #save(res1,file="res1.Rda")
            
            all_inf_mat<-{}
            
            for(i in 1:length(res1)){
              
              main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
              pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
              #posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthocfactor1)
              
              cur_pvals<-t(res1[[i]]$mainpvalues)
              cur_est<-t(res1[[i]]$estimates)
              cur_stderr<-t(res1[[i]]$stderr)
              cur_tstat<-t(res1[[i]]$statistic)
              
              #cur_pvals<-as.data.frame(cur_pvals)
              
              cur_res<-cbind(cur_pvals,cur_est,cur_stderr,cur_tstat)
              
              all_inf_mat<-rbind(all_inf_mat,cur_res)
              
              
            }
            
            
            
            cnames_1<-c(paste("P.value_",colnames(cur_pvals),sep=""),paste("Estimate_",colnames(cur_pvals),sep=""),paste("StdError_var_",colnames(cur_pvals),sep=""),paste("t-statistic_",colnames(cur_pvals),sep=""))
            
            
            
            #	print("here after lm reg")
            
            #print(summary(pvalues))
            
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
            }else{
              if(fdrmethod=="ST"){
                #fdr_adjust_pvalue<-qvalue(pvalues)
                #fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
                
                if(is(fdr_adjust_pvalue,"try-error")){
                  
                  fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                  fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    #fdr_adjust_pvalue<-pvalues
                    fdr_adjust_pvalue<-p.adjust(pvalues,method="none")
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                    }else{
                      if(fdrmethod=="bonferroni"){
                        fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                      }
                    }
                  }
                }
              }
              
              
              
            }
            
            
            if(fdrmethod=="none"){
              filename<-paste(fileheader,"_pvalall_withfeats.txt",sep="")
              
            }else{
              filename<-paste(fileheader,"_fdrall_withfeats.txt",sep="")
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab<-c("P.value","adjusted.P.value",cnames_tab)
            
            pvalues<-as.data.frame(pvalues)
            
            
            
            
            final.pvalues<-pvalues
            sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            #write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            if(analysismode=="regression"){
              
              filename<-paste(fileheader,"_results_allfeatures.txt",sep="")
              filename<-paste("Tables/",filename,sep="")
              
              #                  write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            }
            
            filename<-paste(fileheader,"_pval_coef_stderr.txt",sep="")
            
            
            
            data_allinf_withfeats<-cbind(all_inf_mat,data_m_fc_withfeats)
            filename<-paste("Tables/",filename,sep="")
            #     write.table(data_allinf_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            
            cnames_tab<-c(cnames_1,cnames_tab)
            
            class_column_names<-colnames(classlabels_response_mat)
            
            
            colnames(data_allinf_withfeats)<-as.character(cnames_tab)
            
            ###save(data_allinf_withfeats,cnames_tab,cnames_1,file="data_allinf_withfeats.Rda")
            
            
            pval_columns<-grep(colnames(data_allinf_withfeats),pattern="P.value")
            
            fdr_adjusted_pvalue<-get_fdr_adjusted_pvalue(data_matrix=data_allinf_withfeats,fdrmethod=fdrmethod)
            
            #   data_allinf_withfeats1<-cbind(data_allinf_withfeats[,pval_columns],fdr_adjusted_pvalue,data_allinf_withfeats[,-c(pval_columns)])
            
            cnames_tab1<-c(cnames_tab[pval_columns],colnames(fdr_adjusted_pvalue),cnames_tab[-pval_columns])
            pval_columns<-grep(colnames(data_allinf_withfeats),pattern="P.value")
            
            fdr_adjusted_pvalue<-get_fdr_adjusted_pvalue(data_matrix=data_allinf_withfeats,fdrmethod=fdrmethod)
            
            data_allinf_withfeats<-cbind(data_allinf_withfeats[,pval_columns],fdr_adjusted_pvalue,data_allinf_withfeats[,-c(pval_columns)])
            
            cnames_tab1<-c(cnames_tab[pval_columns],colnames(fdr_adjusted_pvalue),cnames_tab[-pval_columns])
            
            
            filename<-paste(fileheader,"_pval_coef_stderr.txt",sep="")
            filename<-paste("Tables/",filename,sep="")
            colnames(data_allinf_withfeats)<-cnames_tab1
            
            ###save(data_allinf_withfeats,file="d2.Rda")
            write.table(data_allinf_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            
            
            
            
          }
          
          
          
          if(featselmethod=="lm2wayanova")
          {
            
            cat("Performing two-way ANOVA analysis with Tukey post hoc comparisons",sep="\n")
            
            #print(dim(data_m_fc))
            #			print(dim(classlabels_response_mat))
            
           
            numcores<-num_nodes #round(detectCores()*0.5)
            
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            
            
            clusterExport(cl,"diffexplmtwowayanova",envir = .GlobalEnv)
            
            clusterExport(cl,"TukeyHSD",envir = .GlobalEnv)
            clusterExport(cl,"plotTukeyHSD1",envir = .GlobalEnv)
            
            clusterExport(cl,"aov",envir = .GlobalEnv)
            clusterExport(cl,"anova",envir = .GlobalEnv)
            clusterEvalQ(cl,library(ggpubr))
            clusterEvalQ(cl,library(ggplot2))
           # clusterEvalQ(cl,library(cowplot))
            
            
            #res1<-apply(data_m_fc,1,function(x){
            
            res1<-parRapply(cl,data_m_fc,function(x,classlabels_response_mat){
              
              xvec<-x
              
              colnames(classlabels_response_mat)<-paste("Factor",seq(1,dim(classlabels_response_mat)[2]),sep="")
              
              data_mat_anova<-cbind(xvec,classlabels_response_mat)
              #print("2way anova")
              #	print(data_mat_anova[1:2,])
              cnames<-colnames(data_mat_anova)
              cnames[1]<-"Response"
              
              colnames(data_mat_anova)<-cnames
              
              ####savedata_mat_anova,file="data_mat_anova.Rda")
              
              #diffexplmtwowayanova
              anova_res<-diffexplmtwowayanova(dataA=data_mat_anova)
              
              
              return(anova_res)
            },classlabels_response_mat)
            
            
            stopCluster(cl)
            #	print("done")
            
            ####saveres1,file="res1.Rda")
            
            main_pval_mat<-{}
            posthoc_pval_mat<-{}
            pvalues1<-{}
            pvalues2<-{}
            pvalues3<-{}
            
            save(res1,file="tukeyhsd_plots.Rda")
            
            for(i in 1:length(res1)){
              
              #print(i)
              #print(res1[[i]]$mainpvalues)
              #print(res1[[i]]$posthoc)
              main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
              pvalues1<-c(pvalues1,as.vector(res1[[i]]$mainpvalues[1]))
              pvalues2<-c(pvalues2,as.vector(res1[[i]]$mainpvalues[2]))
              pvalues3<-c(pvalues3,as.vector(res1[[i]]$mainpvalues[3]))
              posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthoc)
              
              
            }
            twoanova_res<-cbind(data_m_fc_withfeats[,c(1:2)],main_pval_mat,posthoc_pval_mat)
            
            #write.table(twoanova_res,file="Tables/twoanova_with_posthoc_pvalues.txt",sep="\t",row.names=FALSE)
            pvalues1<-main_pval_mat[,1]
            pvalues2<-main_pval_mat[,2]
            pvalues3<-main_pval_mat[,3]
            
            if(fdrmethod=="none"){
              fdr_adjust_pvalue1<-p.adjust(pvalues1,method="none")
              fdr_adjust_pvalue2<-p.adjust(pvalues2,method="none")
              fdr_adjust_pvalue3<-p.adjust(pvalues3,method="none")
            }
            
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BH")
              fdr_adjust_pvalue2<-p.adjust(pvalues2,method="BH")
              fdr_adjust_pvalue3<-p.adjust(pvalues3,method="BH")
            }else{
              if(fdrmethod=="ST"){
                
                
                fdr_adjust_pvalue1<-try(qvalue(pvalues1),silent=TRUE)
                
                if(is(fdr_adjust_pvalue1,"try-error")){
                  
                  fdr_adjust_pvalue1<-qvalue(pvalues1,lambda=max(pvalues1,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qvalues
                
                fdr_adjust_pvalue2<-try(qvalue(pvalues2),silent=TRUE)
                
                if(is(fdr_adjust_pvalue2,"try-error")){
                  
                  fdr_adjust_pvalue2<-qvalue(pvalues2,lambda=max(pvalues2,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue2<-fdr_adjust_pvalue2$qvalues
                
                fdr_adjust_pvalue3<-try(qvalue(pvalues3),silent=TRUE)
                
                if(is(fdr_adjust_pvalue3,"try-error")){
                  
                  fdr_adjust_pvalue3<-qvalue(pvalues3,lambda=max(pvalues3,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue3<-fdr_adjust_pvalue3$qvalues
                
                
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue1<-fdrtool(as.vector(pvalues1),statistic="pvalue",verbose=FALSE)
                  fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qval
                  
                  fdr_adjust_pvalue2<-fdrtool(as.vector(pvalues2),statistic="pvalue",verbose=FALSE)
                  fdr_adjust_pvalue2<-fdr_adjust_pvalue2$qval
                  
                  fdr_adjust_pvalue3<-fdrtool(as.vector(pvalues3),statistic="pvalue",verbose=FALSE)
                  fdr_adjust_pvalue3<-fdr_adjust_pvalue3$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    fdr_adjust_pvalue1<-p.adjust(pvalues1,method="none")
                    fdr_adjust_pvalue2<-p.adjust(pvalues2,method="none")
                    fdr_adjust_pvalue3<-p.adjust(pvalues3,method="none")
                    
                    
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BY")
                      fdr_adjust_pvalue2<-p.adjust(pvalues2,method="BY")
                      fdr_adjust_pvalue3<-p.adjust(pvalues3,method="BY")
                      
                      
                    }else{
                      if(fdrmethod=="bonferroni"){
                        # fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                        fdr_adjust_pvalue1<-p.adjust(pvalues1,method="bonferroni")
                        fdr_adjust_pvalue2<-p.adjust(pvalues2,method="bonferroni")
                        fdr_adjust_pvalue3<-p.adjust(pvalues3,method="bonferroni")
                      }
                    }
                    
                  }
                }
              }
              
              
              
            }
            
            if(fdrmethod=="none"){
              filename<-paste(featselmethod,"_pvalall_withfeats.txt",sep="")
            }else{
              filename<-paste(featselmethod,"_fdrall_withfeats.txt",sep="")
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            posthoc_names<-colnames(posthoc_pval_mat)
            
            cnames_tab<-c("Factor1.P.value","Factor1.adjusted.P.value","Factor2.P.value","Factor2.adjusted.P.value","Interact.P.value","Interact.adjusted.P.value",posthoc_names,cnames_tab)
            
            if(FALSE)
            {
              pvalues1<-as.data.frame(pvalues1)
              pvalues1<-t(pvalues1)
              fdr_adjust_pvalue1<-as.data.frame(fdr_adjust_pvalue1)
              pvalues2<-as.data.frame(pvalues2)
              pvalues2<-t(pvalues2)
              fdr_adjust_pvalue2<-as.data.frame(fdr_adjust_pvalue2)
              pvalues3<-as.data.frame(pvalues3)
              pvalues3<-t(pvalues3)
              fdr_adjust_pvalue3<-as.data.frame(fdr_adjust_pvalue3)
              posthoc_pval_mat<-as.data.frame(posthoc_pval_mat)
            }
            
            # ###savedata_m_fc_withfeats,file="data_m_fc_withfeats.Rda")
            data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,pvalues2,fdr_adjust_pvalue2,pvalues3,fdr_adjust_pvalue3,posthoc_pval_mat,data_m_fc_withfeats)
            
            fdr_adjust_pvalue<-cbind(fdr_adjust_pvalue1,fdr_adjust_pvalue2,fdr_adjust_pvalue3)
            fdr_adjust_pvalue<-apply(fdr_adjust_pvalue,1,function(x){min(x,na.rm=TRUE)})
            
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            
            if(length(check_names)>0){
              
              data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,pvalues2,fdr_adjust_pvalue2,pvalues3,fdr_adjust_pvalue3,posthoc_pval_mat,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
              
              data_limma_fdrall_withfeats<-as.data.frame(data_limma_fdrall_withfeats)
              #data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              rem_col_ind1<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("mz"))
              
              rem_col_ind2<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("time"))
              
              rem_col_ind<-c(rem_col_ind1,rem_col_ind2)
              
            }else{
              rem_col_ind<-{}
            }
            
            if(length(rem_col_ind)>0){
              write.table(data_limma_fdrall_withfeats[,-c(rem_col_ind)], file="Tables/twowayanova_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
            }else{
              
              
              write.table(data_limma_fdrall_withfeats,file="Tables/twowayanova_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
              
            }
            
            
            filename<-paste("Tables/",filename,sep="")
            
            #write.table(data_limma_fdrall_withfeats,file="Tables/twowayanova_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
            
            #write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            
            fdr_matrix<-cbind(fdr_adjust_pvalue1,fdr_adjust_pvalue2,fdr_adjust_pvalue3)
            
            fdr_matrix<-as.data.frame(fdr_matrix)
            
            fdr_adjust_pvalue_all<-apply(fdr_matrix,1,function(x){return(min(x,na.rm=TRUE)[1])})
            
            pvalues<-cbind(pvalues1,pvalues2,pvalues3)
            pvalues<-apply(pvalues,1,function(x){min(x,na.rm=TRUE)[1]})
            
            #pvalues1<-t(pvalues1)
            
            #print("here")
            pvalues1<-as.data.frame(pvalues1)
            pvalues1<-t(pvalues1)
            #print(dim(pvalues1))
            
            #pvalues2<-t(pvalues2)
            pvalues2<-as.data.frame(pvalues2)
            pvalues2<-t(pvalues2)
            
            #pvalues3<-t(pvalues3)
            pvalues3<-as.data.frame(pvalues3)
            pvalues3<-t(pvalues3)
            
          
            
            final.pvalues<-pvalues
            
            
            
            sel.diffdrthresh<-fdr_adjust_pvalue_all<fdrthresh & final.pvalues<pvalue.thresh
            
            if(length(which(fdr_adjust_pvalue1<fdrthresh))>0){
              
              
              
              
              X1=data_m_fc_withfeats[which(fdr_adjust_pvalue1<fdrthresh),]
              Y1=cbind(classlabels_orig[,1],as.character(classlabels_response_mat[,1]))
              Y1<-as.data.frame(Y1)
              
             
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/HCA_Factor1selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              hca_f1<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=X1,Y=Y1,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,
                              analysismode="classification",
                      sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300,
                      alphacol=0.3, hca_type=hca_type,newdevice=FALSE,input.type="intensity",mainlab="Factor1",
                      alphabetical.order=alphabetical.order,study.design=analysistype,labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,
                      cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
            }else{
              
              print("No significant features for Factor 1.")
            }
            
            if(length(which(fdr_adjust_pvalue2<fdrthresh))>0){
              X2=data_m_fc_withfeats[which(fdr_adjust_pvalue2<fdrthresh),]
              
              
              Y2=cbind(classlabels_orig[,1],as.character(classlabels_response_mat[,2]))
              Y2<-as.data.frame(Y2)
              
             
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/HCA_Factor2selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              
             hca_f2<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=X2,Y=Y2,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                      sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3,
                      hca_type=hca_type,newdevice=FALSE,input.type="intensity",mainlab="Factor2",
                      alphabetical.order=alphabetical.order,study.design=analysistype,labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,
                      cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
            }else{
              
              print("No significant features for Factor 2.")
            }
            class_interact<-paste(classlabels_response_mat[,1],":",classlabels_response_mat[,2],sep="")
            #classlabels_response_mat[,1]:classlabels_response_mat[,2]
            
            if(length(which(fdr_adjust_pvalue3<fdrthresh))>0){
              X3=data_m_fc_withfeats[which(fdr_adjust_pvalue3<fdrthresh),]
              Y3=cbind(classlabels_orig[,1],class_interact)
              Y3<-as.data.frame(Y3)
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/HCA_Factor1xFactor2selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              hca_f3<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=X3,Y=Y3,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                      sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3,
                      hca_type=hca_type,newdevice=FALSE,input.type="intensity",mainlab="Factor1 x Factor2",
                      alphabetical.order=alphabetical.order,study.design=analysistype,labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,
                      cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              
            }else{
              
              print("No significant features for the interaction.")
            }
            
            
            
            data_limma_fdrall_withfeats<-cbind(final.pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab<-c("P.value.Min(Factor1,Factor2,Interaction)","adjusted.P.value.Min(Factor1,Factor2,Interaction)",cnames_tab)
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            
            
            #filename2<-"test2.txt"
            #data_limma_fdrsig_withfeats<-data_limma_fdrall_withfeats[sel.diffdrthresh==TRUE,]
            #write.table(data_limma_fdrsig_withfeats, file=filename2,sep="\t",row.names=FALSE)
            
            fdr_adjust_pvalue<-fdr_adjust_pvalue_all
            
          }
          
          if(featselmethod=="lm1wayanovarepeat"| featselmethod=="lmregrepeat"){
            
            
            
            
            
           # save(data_m_fc,classlabels_response_mat,subject_inf,modeltype,file="1waydebug.Rda")
            
            #clusterExport(cl,"classlabels_response_mat",envir = .GlobalEnv)
            #clusterExport(cl,"subject_inf",envir = .GlobalEnv)
            
            #res1<-apply(data_m_fc,1,function(x){
            
            if(featselmethod=="lm1wayanovarepeat"){
              
              cat("Performing one-way ANOVA with repeated measurements analysis using nlme::lme()",sep="\n")
              
              numcores<-num_nodes #round(detectCores()*0.5)
              
              cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
              
              clusterExport(cl,"diffexplmonewayanovarepeat",envir = .GlobalEnv)
              clusterEvalQ(cl,library(nlme))
              clusterEvalQ(cl,library(multcomp))
              clusterEvalQ(cl,library(lsmeans))
              clusterExport(cl,"lme",envir = .GlobalEnv)
              clusterExport(cl,"interaction",envir = .GlobalEnv)
              clusterExport(cl,"anova",envir = .GlobalEnv)
              res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat,subject_inf,modeltype){
                
                #res1<-apply(data_m_fc,1,function(x){
                
                xvec<-x
                
                colnames(classlabels_response_mat)<-paste("Factor",seq(1,dim(classlabels_response_mat)[2]),sep="")
                
                data_mat_anova<-cbind(xvec,classlabels_response_mat)
                
                cnames<-colnames(data_mat_anova)
                cnames[1]<-"Response"
                
                colnames(data_mat_anova)<-cnames
                
                anova_res<-diffexplmonewayanovarepeat(dataA=data_mat_anova,subject_inf=subject_inf,modeltype=modeltype)
                
                return(anova_res)
                
                
              },classlabels_response_mat,subject_inf,modeltype)
              
              main_pval_mat<-{}
              
              posthoc_pval_mat<-{}
              pvalues<-{}
             
              
              bad_lm1feats<-{}
              
              ###saveres1,file="res1.Rda")
              for(i in 1:length(res1)){
                
                if(is.na(res1[[i]]$mainpvalues)==FALSE){
                  main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
                  pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
                  posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthoc)
                }else{
                  
                  bad_lm1feats<-c(bad_lm1feats,i)
                  
                  
                }
              }
              
              if(length(bad_lm1feats)>0){
                
                data_m_fc_withfeats<-data_m_fc_withfeats[-c(bad_lm1feats),]
                
                data_m_fc<-data_m_fc[-c(bad_lm1feats),]
              }
              #twoanovarepeat_res<-cbind(data_m_fc_withfeats[,c(1:2)],main_pval_mat,posthoc_pval_mat)
              
              #write.table(twoanovarepeat_res,file="Tables/lm2wayanovarepeat_with_posthoc_pvalues.txt",sep="\t",row.names=FALSE)
              
              
              pvalues1<-main_pval_mat[,1]
             
              
              onewayanova_res<-cbind(data_m_fc_withfeats[,c(1:2)],main_pval_mat,posthoc_pval_mat)
              
              # write.table(twoanova_res,file="twoanova_with_posthoc_pvalues.txt",sep="\t",row.names=FALSE)
              
              if(fdrmethod=="none"){
                fdr_adjust_pvalue1<-p.adjust(pvalues1,method="none")
               
              }
              
              if(fdrmethod=="BH"){
                fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BH")
               
              }else{
                if(fdrmethod=="ST"){
                  #print(head(pvalues1))
                  #print(head(pvalues2))
                  #print(head(pvalues3))
                  #print(summary(pvalues1))
                  #print(summary(pvalues2))
                  #print(summary(pvalues3))
                  fdr_adjust_pvalue1<-try(qvalue(pvalues1),silent=TRUE)
                  
                  if(is(fdr_adjust_pvalue1,"try-error")){
                    
                    fdr_adjust_pvalue1<-qvalue(pvalues1,lambda=max(pvalues1,na.rm=TRUE))
                  }
                  
                  
                  
                  
                  fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qvalues
                  
                 
                }else{
                  if(fdrmethod=="Strimmer"){
                    pdf("fdrtool.pdf")
                    #par_rows=1
                    #par(mfrow=c(par_rows,1))
                    fdr_adjust_pvalue1<-fdrtool(as.vector(pvalues1),statistic="pvalue",verbose=FALSE)
                    fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qval
                    
                    
                    try(dev.off(),silent=TRUE)
                  }else{
                    if(fdrmethod=="none"){
                      fdr_adjust_pvalue1<-p.adjust(pvalues1,method="none")
                     
                      
                      
                    }else{
                      if(fdrmethod=="BY"){
                        fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BY")
                     
                        
                      }else{
                        if(fdrmethod=="bonferroni"){
                          # fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                          fdr_adjust_pvalue1<-p.adjust(pvalues1,method="bonferroni")
                          
                        }
                      }
                    }
                  }
                }
                
                
                
              }
              
              if(fdrmethod=="none"){
                
                filename<-paste("Tables/",featselmethod,"_pvalall_withfeats.txt",sep="")
              }else{
                filename<-paste("Tables/",featselmethod,"_fdrall_withfeats.txt",sep="")
              }
              cnames_tab<-colnames(data_m_fc_withfeats)
              
              posthoc_names<-colnames(posthoc_pval_mat)
              
              cnames_tab1<-c(cnames_tab[1:2],"Name",cnames_tab[-c(1:2)])
              cnames_tab1<-c("Factor1.P.value","Factor1.adjusted.P.value",posthoc_names,cnames_tab1)
              
              cnames_tab1<-c("Factor1.P.value","Factor1.adjusted.P.value",posthoc_names,cnames_tab)
              data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,posthoc_pval_mat,data_m_fc_withfeats)
              
              
              
              data_limma_fdrall_withfeats_parent<- data_limma_fdrall_withfeats
              colnames(data_limma_fdrall_withfeats_parent)<-as.character(cnames_tab1)
              colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab1)
              #gohere
              
              if(length(check_names)>0){
                
                
                data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,posthoc_pval_mat,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
                 
                colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab1)
                
                data_limma_fdrall_withfeats<-as.data.frame(data_limma_fdrall_withfeats)
                #data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
                
                rem_col_ind1<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("mz"))
                
                rem_col_ind2<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("time"))
                
                rem_col_ind<-{} #c(rem_col_ind1,rem_col_ind2)
                
              }else{
                rem_col_ind<-{}
              }
              
              if(length(rem_col_ind)>0){
                
                write.table(data_limma_fdrall_withfeats[,-c(rem_col_ind)],file="Tables/onewayanovarepeat_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
                
              }else{
               # colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
                write.table(data_limma_fdrall_withfeats,file="Tables/onewayanovarepeat_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
                
                
              }
              
              #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
              
              filename<-paste("Tables/",filename,sep="")
              
              
              
              data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats_parent
             
            
              fdr_adjust_pvalue<-fdr_adjust_pvalue1
              
              final.pvalues<-pvalues1
              
              sel.diffdrthresh<-fdr_adjust_pvalue1<fdrthresh & final.pvalues<pvalue.thresh
              
              
              
            }else{
              
              cat("Performing linear regression with repeated measurements analysis using nlme::lme()",sep="\n")
              numcores<-num_nodes #round(detectCores()*0.5)
              
              cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
              
              clusterExport(cl,"diffexplmregrepeat",envir = .GlobalEnv)
              clusterEvalQ(cl,library(nlme))
              clusterEvalQ(cl,library(multcomp))
              clusterEvalQ(cl,library(lsmeans))
              clusterExport(cl,"lme",envir = .GlobalEnv)
              clusterExport(cl,"interaction",envir = .GlobalEnv)
              clusterExport(cl,"anova",envir = .GlobalEnv)
              res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat,subject_inf,modeltype){
                
                #res1<-apply(data_m_fc,1,function(x){
                
                xvec<-x
                
                colnames(classlabels_response_mat)<-paste("Factor",seq(1,dim(classlabels_response_mat)[2]),sep="")
                data_mat_anova<-cbind(xvec,classlabels_response_mat)
                
                cnames<-colnames(data_mat_anova)
                cnames[1]<-"Response"
                
                colnames(data_mat_anova)<-cnames
                
                 
                if(ncol(data_mat_anova)>2){
                  
                  covar.matrix=classlabels_response_mat[,-c(1)]
                  
                }else{
                  covar.matrix=NA 
                }
                
                save(data_mat_anova,subject_inf,modeltype,classlabels_response_mat,covar.matrix,file="lmregrepdebug.Rda")
                
                
                anova_res<-diffexplmregrepeat(dataA=data_mat_anova,subject_inf=subject_inf,modeltype=modeltype,covar.matrix = covar.matrix)
                
                return(anova_res)
                
                
              },classlabels_response_mat,subject_inf,modeltype)
              
            
            stopCluster(cl)
            
            main_pval_mat<-{}
            pvalues<-{}
            
           # save(res1,file="lmres1.Rda")
            
            posthoc_pval_mat<-{}
            
            bad_lm1feats<-{}
            
            res2<-t(res1)
            
            res2<-as.data.frame(res2)
            colnames(res2)<-c("pvalue","coefficient","std.error","t.value")
            pvalues<-res2$pvalue
            
            pvalues<-unlist(pvalues)
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue<-p.adjust(pvalues,method="BH")
            }else{
              if(fdrmethod=="ST"){
                
                fdr_adjust_pvalue<-try(qvalue(pvalues),silent=TRUE)
                
                if(is(fdr_adjust_pvalue,"try-error")){
                  
                  fdr_adjust_pvalue<-qvalue(pvalues,lambda=max(pvalues,na.rm=TRUE))
                }
                
                fdr_adjust_pvalue<-fdr_adjust_pvalue$qvalues
                
                
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue<-suppressWarnings(fdrtool(as.vector(pvalues),statistic="pvalue",verbose=FALSE))
                  fdr_adjust_pvalue<-fdr_adjust_pvalue$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    fdr_adjust_pvalue<-pvalues
                    
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue<-p.adjust(pvalues,method="BY")
                    }else{
                      if(fdrmethod=="bonferroni"){
                        fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                        
                      }
                    }
                  }
                }
              }
              
              
              
            }
            if(fdrmethod=="none"){
              filename<-paste(featselmethod,"_pvalall_withfeats.txt",sep="")
            }else{
              filename<-paste(featselmethod,"_fdrall_withfeats.txt",sep="")
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            
            
            cnames_tab<-c("P.value","adjusted.P.value",c("coefficient","std.error","t.value"),cnames_tab)
            
            
            pvalues<-as.data.frame(pvalues)
            
            final.pvalues<-pvalues
            sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
            #pvalues<-t(pvalues)
            #print(dim(pvalues))
            #print(dim(data_m_fc_withfeats))
            
            if(length(bad_lm1feats)>0){
              data_m_fc_withfeats<-data_m_fc_withfeats[-c(bad_lm1feats),]
              
              data_m_fc<-data_m_fc[-c(bad_lm1feats),]
            }
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,res2[,-c(1)],data_m_fc_withfeats)
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            
            filename<-paste("Tables/",filename,sep="")
          #  write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
          }
            
          }
          
          if(featselmethod=="lm2wayanovarepeat"){
            
            cat("Performing two-way ANOVA with repeated measurements analysis using nlme::lme()",sep="\n")
            
            
            numcores<-num_nodes #round(detectCores()*0.5)
            
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            
            clusterExport(cl,"diffexplmtwowayanovarepeat",envir = .GlobalEnv)
            clusterEvalQ(cl,library(nlme))
            clusterEvalQ(cl,library(multcomp))
            clusterEvalQ(cl,library(lsmeans))
            clusterExport(cl,"lme",envir = .GlobalEnv)
            clusterExport(cl,"interaction",envir = .GlobalEnv)
            clusterExport(cl,"anova",envir = .GlobalEnv)
            
            #clusterExport(cl,"classlabels_response_mat",envir = .GlobalEnv)
            #clusterExport(cl,"subject_inf",envir = .GlobalEnv)
            
            #res1<-apply(data_m_fc,1,function(x){
            
            #	print(dim(data_m_fc))
            #	print(dim(classlabels_response_mat))
            
            res1<-parApply(cl,data_m_fc,1,function(x,classlabels_response_mat,subject_inf,modeltype){
              
              #  res1<-apply(data_m_fc,1,function(x){
              
              # ###saveclasslabels_response_mat,file="classlabels_response_mat.Rda")
              
              #       ###savesubject_inf,file="subject_inf.Rda")
              
              xvec<-x
              
              ####savexvec,file="xvec.Rda")
              colnames(classlabels_response_mat)<-paste("Factor",seq(1,dim(classlabels_response_mat)[2]),sep="")
              
              data_mat_anova<-cbind(xvec,classlabels_response_mat)
              
              cnames<-colnames(data_mat_anova)
              cnames[1]<-"Response"
              
              colnames(data_mat_anova)<-cnames
              
              #print(subject_inf)
              #print(dim(data_mat_anova))
              
              
              subject_inf<-as.data.frame(subject_inf)
              #print(dim(subject_inf))
              
              save(subject_inf,data_mat_anova,modeltype,classlabels_response_mat,file="lm2wayrepdebug.Rda")
              
              anova_res<-diffexplmtwowayanovarepeat(dataA=data_mat_anova,subject_inf=subject_inf[,1],modeltype=modeltype)
              
              return(anova_res)
            },classlabels_response_mat,subject_inf,modeltype)
            
            
            main_pval_mat<-{}
            
            stopCluster(cl)
            posthoc_pval_mat<-{}
            
            #print(head(res1))
            #	print("here")
            
            pvalues<-{}
            
            
            bad_lm1feats<-{}
            
            ###saveres1,file="res1.Rda")
            for(i in 1:length(res1)){
              
              if(is.na(res1[[i]]$mainpvalues)==FALSE){
                main_pval_mat<-rbind(main_pval_mat,res1[[i]]$mainpvalues)
                pvalues<-c(pvalues,res1[[i]]$mainpvalues[1])
                posthoc_pval_mat<-rbind(posthoc_pval_mat,res1[[i]]$posthoc)
              }else{
                
                bad_lm1feats<-c(bad_lm1feats,i)
                
                
              }
            }
            
            if(length(bad_lm1feats)>0){
              
              data_m_fc_withfeats<-data_m_fc_withfeats[-c(bad_lm1feats),]
              
              data_m_fc<-data_m_fc[-c(bad_lm1feats),]
            }
            twoanovarepeat_res<-cbind(data_m_fc_withfeats[,c(1:2)],main_pval_mat,posthoc_pval_mat)
            
            #write.table(twoanovarepeat_res,file="Tables/lm2wayanovarepeat_with_posthoc_pvalues.txt",sep="\t",row.names=FALSE)
            
            
            pvalues1<-main_pval_mat[,1]
            pvalues2<-main_pval_mat[,2]
            pvalues3<-main_pval_mat[,3]
            
            twoanova_res<-cbind(data_m_fc_withfeats[,c(1:2)],main_pval_mat,posthoc_pval_mat)
            
            # write.table(twoanova_res,file="twoanova_with_posthoc_pvalues.txt",sep="\t",row.names=FALSE)
            
            if(fdrmethod=="none"){
              fdr_adjust_pvalue1<-p.adjust(pvalues1,method="none")
              fdr_adjust_pvalue2<-p.adjust(pvalues2,method="none")
              fdr_adjust_pvalue3<-p.adjust(pvalues3,method="none")
            }
            
            if(fdrmethod=="BH"){
              fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BH")
              fdr_adjust_pvalue2<-p.adjust(pvalues2,method="BH")
              fdr_adjust_pvalue3<-p.adjust(pvalues3,method="BH")
            }else{
              if(fdrmethod=="ST"){
                #print(head(pvalues1))
                #print(head(pvalues2))
                #print(head(pvalues3))
                #print(summary(pvalues1))
                #print(summary(pvalues2))
                #print(summary(pvalues3))
                fdr_adjust_pvalue1<-try(qvalue(pvalues1),silent=TRUE)
                fdr_adjust_pvalue2<-try(qvalue(pvalues2),silent=TRUE)
                fdr_adjust_pvalue3<-try(qvalue(pvalues3),silent=TRUE)
                
                if(is(fdr_adjust_pvalue1,"try-error")){
                  
                  fdr_adjust_pvalue1<-qvalue(pvalues1,lambda=max(pvalues1,na.rm=TRUE))
                }
                
                if(is(fdr_adjust_pvalue2,"try-error")){
                  fdr_adjust_pvalue2<-qvalue(pvalues2,lambda=max(pvalues2,na.rm=TRUE))
                }
                
                if(is(fdr_adjust_pvalue3,"try-error")){
                  fdr_adjust_pvalue3<-qvalue(pvalues3,lambda=max(pvalues3,na.rm=TRUE))
                }
                
                
                fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qvalues
                
                fdr_adjust_pvalue2<-fdr_adjust_pvalue2$qvalues
                
                fdr_adjust_pvalue3<-fdr_adjust_pvalue3$qvalues
              }else{
                if(fdrmethod=="Strimmer"){
                  pdf("fdrtool.pdf")
                  #par_rows=1
                  #par(mfrow=c(par_rows,1))
                  fdr_adjust_pvalue1<-fdrtool(as.vector(pvalues1),statistic="pvalue",verbose=FALSE)
                  fdr_adjust_pvalue1<-fdr_adjust_pvalue1$qval
                  
                  fdr_adjust_pvalue2<-fdrtool(as.vector(pvalues2),statistic="pvalue",verbose=FALSE)
                  fdr_adjust_pvalue2<-fdr_adjust_pvalue2$qval
                  
                  fdr_adjust_pvalue3<-fdrtool(as.vector(pvalues3),statistic="pvalue",verbose=FALSE)
                  fdr_adjust_pvalue3<-fdr_adjust_pvalue3$qval
                  try(dev.off(),silent=TRUE)
                }else{
                  if(fdrmethod=="none"){
                    fdr_adjust_pvalue1<-p.adjust(pvalues1,method="none")
                    fdr_adjust_pvalue2<-p.adjust(pvalues2,method="none")
                    fdr_adjust_pvalue3<-p.adjust(pvalues3,method="none")
                    
                    
                  }else{
                    if(fdrmethod=="BY"){
                      fdr_adjust_pvalue1<-p.adjust(pvalues1,method="BY")
                      fdr_adjust_pvalue2<-p.adjust(pvalues2,method="BY")
                      fdr_adjust_pvalue3<-p.adjust(pvalues3,method="BY")
                      
                      
                    }else{
                      if(fdrmethod=="bonferroni"){
                        # fdr_adjust_pvalue<-p.adjust(pvalues,method="bonferroni")
                        fdr_adjust_pvalue1<-p.adjust(pvalues1,method="bonferroni")
                        fdr_adjust_pvalue2<-p.adjust(pvalues2,method="bonferroni")
                        fdr_adjust_pvalue3<-p.adjust(pvalues3,method="bonferroni")
                      }
                    }
                  }
                }
              }
              
              
              
            }
            
            if(fdrmethod=="none"){
              
              filename<-paste("Tables/",featselmethod,"_pvalall_withfeats.txt",sep="")
            }else{
              filename<-paste("Tables/",featselmethod,"_fdrall_withfeats.txt",sep="")
            }
            cnames_tab<-colnames(data_m_fc_withfeats)
            
            posthoc_names<-colnames(posthoc_pval_mat)
            
            #
            cnames_tab<-c("Factor1.P.value","Factor1.adjusted.P.value","Factor2.P.value","Factor2.adjusted.P.value","Interact.P.value","Interact.adjusted.P.value",posthoc_names,cnames_tab)
            
            
            data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,pvalues2,fdr_adjust_pvalue2,pvalues3,fdr_adjust_pvalue3,posthoc_pval_mat,data_m_fc_withfeats)
            
            
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            
            if(length(check_names)>0){
              
              data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,pvalues2,fdr_adjust_pvalue2,pvalues3,fdr_adjust_pvalue3,posthoc_pval_mat,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
              data_limma_fdrall_withfeats<-as.data.frame(data_limma_fdrall_withfeats)
              #data_limma_fdrall_withfeats<-cbind(p.value,adjusted.p.value,posthoc.results,data_m_fc_with_names,data_m_fc_withfeats[,-c(1:2)])
              
              rem_col_ind1<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("mz"))
              
              rem_col_ind2<-grep(colnames(data_limma_fdrall_withfeats),pattern=c("time"))
              
              rem_col_ind<-c(rem_col_ind1,rem_col_ind2)
              
            }else{
              rem_col_ind<-{}
            }
            
            if(length(rem_col_ind)>0){
              write.table(data_limma_fdrall_withfeats[,-c(rem_col_ind)], file="Tables/twowayanovarepeat_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
            }else{
              
              
              #write.table(data_limma_fdrall_withfeats,file="Tables/twowayanova_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
              
              write.table(data_limma_fdrall_withfeats,file="Tables/twowayanovarepeat_with_posthoc_comparisons.txt",sep="\t",row.names=FALSE)
              
            }
            
            #filename<-paste("Tables/",filename,sep="")
            
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            
            filename<-paste("Tables/",filename,sep="")
            
            
            
            fdr_matrix<-cbind(fdr_adjust_pvalue1,fdr_adjust_pvalue2,fdr_adjust_pvalue3)
            
            fdr_matrix<-as.data.frame(fdr_matrix)
            
            fdr_adjust_pvalue_all<-apply(fdr_matrix,1,function(x){return(min(x,na.rm=TRUE))})
            
            pvalues_all<-cbind(pvalues1,pvalues2,pvalues3)
            pvalue_matrix<-as.data.frame(pvalues_all)
            
            pvalue_all<-apply(pvalue_matrix,1,function(x){return(min(x,na.rm=TRUE)[1])})
            
            
            #pvalues1<-t(pvalues1)
            
            #print("here")
            #pvalues1<-as.data.frame(pvalues1)
            #pvalues1<-t(pvalues1)
            #print(dim(pvalues1))
            
            #pvalues2<-t(pvalues2)
            #pvalues2<-as.data.frame(pvalues2)
            #pvalues2<-t(pvalues2)
            
            #pvalues3<-t(pvalues3)
            #pvalues3<-as.data.frame(pvalues3)
            #pvalues3<-t(pvalues3)
            
            #pvalues<-t(pvalues)
            #print(dim(pvalues1))
            #print(dim(pvalues2))
            #print(dim(pvalues3))
            #print(dim(data_m_fc_withfeats))
            
            pvalues<-pvalue_all
            
            final.pvalues<-pvalues
            sel.diffdrthresh<-fdr_adjust_pvalue_all<fdrthresh & final.pvalues<pvalue.thresh
            
            
            if(length(which(fdr_adjust_pvalue1<fdrthresh))>0){
              X1=data_m_fc_withfeats[which(fdr_adjust_pvalue1<fdrthresh),]
              Y1=cbind(classlabels_orig[,1],as.character(classlabels_response_mat[,1]))
              Y1<-as.data.frame(Y1)
              
              ###saveclasslabels_orig,file="classlabels_orig.Rda")
              ###saveclasslabels_response_mat,file="classlabels_response_mat.Rda")
              
              #print("Performing HCA using features selected for Factor1")
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/HCA_Factor1selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              
              hca_f1<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=X1,Y=Y1,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                      sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300, 
                      alphacol=0.3, hca_type=hca_type,newdevice=FALSE,input.type="intensity",mainlab="Factor 1",
                      alphabetical.order=alphabetical.order,study.design="oneway",labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,
                      cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
            }else{
              print("No significant features for Factor 1.")
              
            }
            
            if(length(which(fdr_adjust_pvalue2<fdrthresh))>0){
              
              X2=data_m_fc_withfeats[which(fdr_adjust_pvalue2<fdrthresh),]
              Y2=cbind(classlabels_orig[,1],as.character(classlabels_response_mat[,2]))
              Y2<-as.data.frame(Y2)
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/HCA_Factor2selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
             # print("Performing HCA using features selected for Factor2")
              hca_f2<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=X2,Y=Y2,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                      sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300, 
                      alphacol=alphacol, hca_type=hca_type,newdevice=FALSE,input.type="intensity",mainlab="Factor 2",
                      alphabetical.order=alphabetical.order,study.design="oneway",labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,
                      cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
            }else{
              
              print("No significant features for Factor 2.")
            }
            
            class_interact<-paste(classlabels_response_mat[,1],":",classlabels_response_mat[,2],sep="") #classlabels_response_mat[,1]:classlabels_response_mat[,2]
            
            if(length(which(fdr_adjust_pvalue3<fdrthresh))>0){
              
              X3=data_m_fc_withfeats[which(fdr_adjust_pvalue3<fdrthresh),]
              Y3=cbind(classlabels_orig[,1],class_interact)
              Y3<-as.data.frame(Y3)
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/HCA_Factor1xFactor2selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              #print("Performing HCA using features selected for Factor1x2")
              hca_f3<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=X3,Y=Y3,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                      sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300,
                      alphacol=0.3, hca_type=hca_type,newdevice=FALSE,input.type="intensity",mainlab="Factor 1 x Factor 2",
                      alphabetical.order=alphabetical.order,study.design="oneway",labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,
                      cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
            }else{
              print("No significant features for Factor 1x2 interaction.")
            }
            
            
            #data_limma_fdrall_withfeats<-cbind(pvalues,fdr_adjust_pvalue,posthoc_pval_mat,data_m_fc_withfeats)
            
            
            #
            data_limma_fdrall_withfeats<-cbind(pvalues1,fdr_adjust_pvalue1,pvalues2,fdr_adjust_pvalue2,pvalues3,fdr_adjust_pvalue3,posthoc_pval_mat,data_m_fc_withfeats)
            
            fdr_adjust_pvalue<-cbind(fdr_adjust_pvalue1,fdr_adjust_pvalue2,fdr_adjust_pvalue3)
            fdr_adjust_pvalue<-apply(fdr_adjust_pvalue,1,function(x){min(x,na.rm=TRUE)})
            
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats[order(fdr_adjust_fpvalue),]
            #write.table(data_limma_fdrall_withfeats, file=filename,sep="\t",row.names=FALSE)
            
            data_limma_fdrall_withfeats<-cbind(final.pvalues,fdr_adjust_pvalue,data_m_fc_withfeats)
            
            cnames_tab<-colnames(data_m_fc_withfeats)
            cnames_tab<-c("P.value.Min(Factor1,Factor2,Interaction)","adjusted.P.value.Min(Factor1,Factor2,Interaction)",cnames_tab)
            colnames(data_limma_fdrall_withfeats)<-as.character(cnames_tab)
            
            #filename2<-"test2.txt"
            #data_limma_fdrsig_withfeats<-data_limma_fdrall_withfeats[sel.diffdrthresh==TRUE,]
            #write.table(data_limma_fdrsig_withfeats, file=filename2,sep="\t",row.names=FALSE)
            
            fdr_adjust_pvalue<-fdr_adjust_pvalue_all
            
          }
          
          
          
          
          
          
          
        }
        
        
        
        
        
        #end of feature selection methods
        
        
        
        
        
        
        
        
        if(featselmethod=="lmreg" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat"
           | featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="logitreg" | featselmethod=="limma2wayrepeat" | featselmethod=="wilcox" | featselmethod=="ttest" |  featselmethod=="poissonreg" | featselmethod=="lmregrepeat")
        {
          
          
          
          sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
          
          
          
          goodip<-which(sel.diffdrthresh==TRUE)
          
          
          classlabels<-as.data.frame(classlabels)
          
          
          
          
        #  if(featselmethod=="limma2way"){
         #   vennDiagram(posthoc.results,cex=0.8)
        #  }
          
          #print(summary(fdr_adjust_pvalue))
          #pheadrint(summary(final.pvalues))
          
        }
        
        pred_acc<-0 #("NA")
        
        
        
        #print("here")
        feat_sigfdrthresh[lf]<-length(goodip) #which(sel.diffdrthresh==TRUE))
        if(kfold>dim(data_m_fc)[2]){
          kfold=dim(data_m_fc)[2]
        }
        if(analysismode=="classification"){
          
          
          
          #print("classification")
          
          if(length(goodip)>0 & dim(data_m_fc)[2]>=kfold){
            
            #save(classlabels,classlabels_orig, data_m_fc,file="debug2.rda")
                 
                 
            if(alphabetical.order==FALSE){
              Targetvar <- factor(classlabels[,1], levels=unique(classlabels[,1]))
            }else{
              
              Targetvar<-factor(classlabels[,1])
            }
            
            
            dataA<-cbind(Targetvar,t(data_m_fc))
            
            dataA<-as.data.frame(dataA)
            
           
            
            dataA$Targetvar<-factor(Targetvar)
            
            
            #df.summary <- dataA %>% group_by(Targetvar) %>%  summarize_all(funs(mean))
            
            # df.summary <- dataA %>% group_by(Targetvar) %>%  summarize_all(funs(mean))
            
            dataA[,-c(1)]<-apply(dataA[,-c(1)],2,function(x){as.numeric(as.character(x))})
            
            if(alphabetical.order==FALSE){
              dataA$Targetvar <- factor(dataA$Targetvar, levels=unique(dataA$Targetvar))
            }
            df.summary <-aggregate(x=dataA,by=list(as.factor(dataA$Targetvar)),function(x){mean(x,na.rm=TRUE)})
            
            #save(dataA,file="errordataA.Rda")
            df.summary.sd <-aggregate(x=dataA[,-c(1)],by=list(as.factor(dataA$Targetvar)),function(x){sd(x,na.rm=TRUE)})
            
            df2<-as.data.frame(df.summary[,-c(1:2)])
            
            group_means<-t(df.summary)
            
           # save(classlabels,classlabels_orig, classlabels_class,Targetvar,dataA,data_m_fc,df.summary,df2,group_means,file="debugfoldchange.Rda")
            
            colnames(group_means)<-paste("mean",levels(as.factor(dataA$Targetvar)),sep="") #paste("Group",seq(1,length(unique(dataA$Targetvar))),sep="")
            
            group_means<-cbind(data_m_fc_withfeats[,c(1:2)],group_means[-c(1:2),])
            
            group_sd<-t(df.summary.sd)
            
            colnames(group_sd)<-paste("std.dev",levels(as.factor(dataA$Targetvar)),sep="") #paste("Group",seq(1,length(unique(dataA$Targetvar))),sep="")
            
            group_sd<-cbind(data_m_fc_withfeats[,c(1:2)],group_sd[-c(1),])
            
            # write.table(group_means,file="group_means.txt",sep="\t",row.names=FALSE)
            
            
            #  ###savedf2,file="df2.Rda")
            #    ###savedataA,file="dataA.Rda")
            #   ###saveTargetvar,file="Targetvar.Rda")
            
            if(log2transform==TRUE || input.intensity.scale=="log2"){
              
              
              cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
              foldchangeres<-parApply(cl,df2,2,function(x){
                
                
                res<-lapply(1:length(x),function(i){
                  return((x[i]-x[-i]))
                  
                })
                res<-unlist(res)
                
                tempres<-abs(res)
                res_ind<-which(tempres==max(tempres,na.rm=TRUE))
                return(res[res_ind[1]])
                
              })
              
              stopCluster(cl)
              
              
             # print("Using log2 fold change threshold of")
             # print(foldchangethresh)
              
              
            }else{
              
              #raw intensities
              if(znormtransform==FALSE)
              {
                #   foldchangeres<-apply(log2(df2+1),2,function(x){res<-{};for(i in 1:length(x)){res<-c(res,(x[i]-x[-i]));};tempres<-abs(res);res_ind<-which(tempres==max(tempres,na.rm=TRUE));return(res[res_ind[1]]);})
                
                if(FALSE){
                  foldchangeres<-apply(log2(df2+log2.transform.constant),2,dist)
                  
                  if(length(nrow(foldchangeres))>0){
                    
                    foldchangeres<-apply(foldchangeres,2,function(x)
                    {
                      
                      max_ind<-which(x==max(abs(x)))[1];
                      return(x[max_ind])
                      
                    }
                    )
                    
                  }
                  
                }
                
                cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
                foldchangeres<-parApply(cl,log2(df2+0.0000001),2,function(x){
                  
                  
                  res<-lapply(1:length(x),function(i){
                    return((x[i]-x[-i]))
                    
                  })
                  res<-unlist(res)
                  
                  tempres<-abs(res)
                  res_ind<-which(tempres==max(tempres,na.rm=TRUE))
                  return(res[res_ind[1]])
                  
                })
                
                stopCluster(cl)
                
                
                foldchangethresh=foldchangethresh
               # print("Using raw fold change threshold of")
              #  print(foldchangethresh)
                
              }else{
                
                #  foldchangeres<-apply(df2,2,function(x){res<-{};for(i in 1:length(x)){res<-c(res,(x[i]-(x[-i])));};tempres<-abs(res);res_ind<-which(tempres==max(tempres,na.rm=TRUE));return(res[res_ind[1]]);})
                
                if(FALSE){
                  foldchangeres<-apply(df2,2,dist)
                  
                  if(length(nrow(foldchangeres))>0){
                    
                    foldchangeres<-apply(foldchangeres,2,function(x)
                    {
                      
                      max_ind<-which(x==max(abs(x)))[1];
                      return(x[max_ind])
                      
                    }
                    )
                    
                  }
                  
                }
                
                save(df2,file="foldchangedf2.Rda")
                
                cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
                foldchangeres<-parApply(cl,df2,2,function(x){
                  
                  
                  res<-lapply(1:length(x),function(i){
                    return((x[i]/x[-i]))
                    
                  })
                  res<-unlist(res)
                  
                  tempres<-abs(res)
                  res_ind<-which(tempres==max(tempres,na.rm=TRUE))
                  return(res[res_ind[1]])
                  
                })
                
                stopCluster(cl)
                
                #print(summary(foldchangeres))
                
                
                #foldchangethresh=2^foldchangethresh
                print("Using Z-score change threshold of")
                print(foldchangethresh)
                
              }
              
              
            }
            
            
            
            
            if(length(class_labels_levels)==2){
              
              
              zvec=foldchangeres
            }else{
              
              zvec=NA
              
              if(featselmethod=="lmreg" && analysismode=="regression"){
                
                cnames_matrix<-colnames(data_limma_fdrall_withfeats)
                cnames_colindex<-grep("Estimate_",cnames_matrix)
                
                
                
                zvec<-data_limma_fdrall_withfeats[,c(cnames_colindex[1])]
              }
              
              
            }
            
            
            maxfoldchange<-foldchangeres
            
            if(is.na(foldchangethresh)==FALSE){
            goodipfoldchange<-which(abs(maxfoldchange)>foldchangethresh)
            }else{
              
              goodipfoldchange<-seq(1,length(maxfoldchange))
            }
            #if(FALSE)
            {
              if(input.intensity.scale=="raw" && log2transform==FALSE && znormtransform==FALSE){
                
                foldchangeres<-2^((foldchangeres))
                
                
                
                
                
              }
            }
            
            maxfoldchange1<-foldchangeres
            
            roundUpNice <- function(x, nice=c(1,2,4,5,6,8,10))
            {
              if(length(x) != 1) stop("'x' must be of length 1")
              10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
            }
            
            d4<-as.data.frame(data_limma_fdrall_withfeats)
            
            print("Nrow d4")
            print(nrow(d4))
            save(d4,file="d4.Rda")
            max_mz_val<-roundUpNice(max(as.numeric(as.character(d4$mz)))[1])
            max_time_val<-roundUpNice(max(as.numeric(as.character(d4$time)))[1])
            
            x1increment=round_any(max_mz_val/10,10,f=floor)
            
            
            x2increment=round_any(max_time_val/10,10,f=floor)
            
            if(x2increment<1){
              x2increment=0.5
              
            }
            
            if(x1increment<1){
              x1increment=0.5
              
            }
            
            
            if(featselmethod=="lmreg" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat"
               | featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="logitreg" | featselmethod=="limma2wayrepeat" | featselmethod=="wilcox" | featselmethod=="ttest" |  featselmethod=="poissonreg" | featselmethod=="lmregrepeat")
            {
              
              
              
              # print("Plotting manhattan plots")
              
              sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
              
              
              goodip<-which(sel.diffdrthresh==TRUE)
              
              
              classlabels<-as.data.frame(classlabels)
              
              
              
              logp<-(-1)*log((d4[,1]+(10^-20)),10)
              
              
              if(fdrmethod=="none"){
                ythresh<-(-1)*log10(pvalue.thresh)
              }else{
                
                ythresh<-min(logp[goodip],na.rm=TRUE)
              }
              maintext1="Type 1 manhattan plot (-logp vs feature index) \n features above the dashed horizontal line meet the selection criteria"
              maintext2="Type 2 manhattan plot (-logp vs feature index) \n features above the dashed horizontal line meet the selection criteria"
              
              
              
              if(is.na(zvec[1])==FALSE){
                maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
              }
              
              yvec_val=logp
              ylabel="(-)log10p"
              yincrement=1
              y2thresh=(-1)*log10(pvalue.thresh)
              
              
           # save(list=c("d4","logp","yvec_val","ythresh","zvec","x1increment","yincrement","maintext1","x2increment","maintext2","ylabel","y2thresh"),file="manhattanplot_objects.Rda")
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/ManhattanPlot_Type1.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              # get_manhattanplots(xvec=d4$mz,yvec=logp,ythresh=ythresh,up_or_down=zvec,xlab="mass-to-charge (m/z)",ylab=ylabel,xincrement=x1increment,yincrement=yincrement,maintext=maintext1,col_seq=c("black"),y2thresh=y2thresh,colorvec=manhattanplot.col.opt)
              
              ####savelist=ls(),file="m1.Rda")
              try(get_manhattanplots(xvec=d4$mz,yvec=logp,ythresh=ythresh,up_or_down=zvec,xlab="Feature Index",ylab=ylabel,
                                     xincrement=x1increment,yincrement=yincrement,maintext=maintext1,col_seq=c("black"),y2thresh=y2thresh,colorvec=manhattanplot.col.opt),silent=TRUE)
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/ManhattanPlot_Type2.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              try(get_manhattanplots(xvec=d4$time,yvec=logp,ythresh=ythresh,up_or_down=zvec,xlab="Feature Index",ylab="-log10p",xincrement=x2increment,yincrement=1,maintext=maintext2,col_seq=c("black"),y2thresh=y2thresh,colorvec=manhattanplot.col.opt),silent=TRUE)
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              if(length(class_labels_levels)==2){
                if(output.device.type!="pdf"){
                  
                  temp_filename_1<-"Figures/VolcanoPlot.png"
                  
                  png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                }
                
                maintext1="Volcano plot (-logp vs log2(fold change)) \n colored m/z features meet the selection criteria"
                if(is.na(zvec[1])==FALSE){
                  maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                  maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                }
                
                
                ##save(maxfoldchange,logp,zvec,ythresh,y2thresh,foldchangethresh,manhattanplot.col.opt,d4,file="debugvolcano.Rda")
                try(get_volcanoplots(xvec=maxfoldchange,yvec=logp,up_or_down=zvec,ythresh=ythresh,y2thresh=y2thresh,xthresh=foldchangethresh,maintext=maintext1,ylab="-log10(p-value)",xlab="log2(fold change)",colorvec=manhattanplot.col.opt),silent=TRUE)
                
                if(output.device.type!="pdf"){
                  
                  try(dev.off(),silent=TRUE)
                }
              }
              
            }else{
              
              if(featselmethod=="pls" | featselmethod=="o1pls"){
                
                
                # print("Time 2")
                #print(Sys.time())
                
                maintext1="Type 1 manhattan plot (VIP vs feature index) \n features above the dashed horizontal line meet the selection criteria"
                maintext2="Type 2 manhattan plot (VIP vs feature index) \n features above the dashed horizontal line meet the selection criteria"
                
                if(is.na(zvec[1])==FALSE){
                  maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                  maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                }
                
                
                yvec_val<-data_limma_fdrall_withfeats[,1]
                ythresh=pls_vip_thresh
                vip_res<-as.data.frame(vip_res)
                bad.feature.index={}
                if(is.na(pls.permut.count)==FALSE){
                  #yvec_val[which(vip_res$rand_pls_sel_prob>=pvalue.thresh | vip_res$rand_pls_sel_fdr>=fdrthresh)]<-0 #(ythresh)*0.5
                  bad.feature.index=which(vip_res$rand_pls_sel_prob>=pvalue.thresh | vip_res$rand_pls_sel_fdr>=fdrthresh)
                }
                ylabel="VIP"
                yincrement=0.5
                y2thresh=NA
                
                # ###savelist=ls(),file="manhattandebug.Rda")
                
                if(output.device.type!="pdf"){
                  
                  temp_filename_1<-"Figures/ManhattanPlot_Type1.png"
                  png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                  
                }
                
                try(get_manhattanplots(xvec=d4$mz,yvec=yvec_val,ythresh=pls_vip_thresh,up_or_down=zvec,xlab="Feature Index",ylab="VIP",xincrement=x1increment,yincrement=0.5,maintext=maintext1,col_seq=c("black"),colorvec=manhattanplot.col.opt,bad.feature.index=bad.feature.index),silent=TRUE)
                
                if(output.device.type!="pdf"){
                  
                  try(dev.off(),silent=TRUE)
                }
                
                if(output.device.type!="pdf"){
                  
                  temp_filename_1<-"Figures/ManhattanPlot_Type2.png"
                  png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                }
                
                try(get_manhattanplots(xvec=d4$time,yvec=yvec_val,ythresh=pls_vip_thresh,up_or_down=zvec,xlab="Feature Index",ylab="VIP",xincrement=x2increment,yincrement=0.5,maintext=maintext2,col_seq=c("black"),colorvec=manhattanplot.col.opt,bad.feature.index=bad.feature.index),silent=TRUE)
                
                if(output.device.type!="pdf"){
                  
                  try(dev.off(),silent=TRUE)
                }
                
                if(length(class_labels_levels)==2){
                  
                  if(output.device.type!="pdf"){
                    temp_filename_1<-"Figures/VolcanoPlot_VIP_vs_foldchange.png"
                    
                    png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                  }
                  
                  maintext1="Volcano plot (VIP vs log2(fold change)) \n colored m/z features meet the selection criteria"
                  
                  maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                  
                  maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                  
                  #  ###savelist=ls(),file="volcanodebug.Rda")
                  try(get_volcanoplots(xvec=maxfoldchange,yvec=yvec_val,up_or_down=maxfoldchange,ythresh=ythresh,xthresh=foldchangethresh,maintext=maintext1,ylab="VIP",xlab="log2(fold change)",bad.feature.index=bad.feature.index,colorvec=manhattanplot.col.opt),silent=TRUE)
                  
                  if(output.device.type!="pdf"){
                    
                    try(dev.off(),silent=TRUE)
                  }
                }
                
                
              }else{
                if(featselmethod=="spls" | featselmethod=="o1spls"){
                  
                  
                  maintext1="Type 1 manhattan plot (|loading| vs feature index) \n features with non-zero loadings meet the selection criteria"
                  maintext2="Type 2 manhattan plot (|loading| vs feature index) \n features with non-zero loadings meet the selection criteria"
                  if(is.na(zvec[1])==FALSE){
                    maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                    maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                  }					
                  yvec_val<-data_limma_fdrall_withfeats[,1]
                  vip_res<-as.data.frame(vip_res)
                  
                  bad.feature.index={}
                  if(is.na(pls.permut.count)==FALSE){
                    # yvec_val[which(vip_res$rand_pls_sel_prob>=pvalue.thresh | vip_res$rand_pls_sel_fdr>=fdrthresh)]<-0
                    bad.feature.index=which(vip_res$rand_pls_sel_prob>=pvalue.thresh | vip_res$rand_pls_sel_fdr>=fdrthresh)
                  }
                  ythresh=0
                  ylabel="Loading (absolute)"
                  yincrement=0.1
                  y2thresh=NA
                  ####savelist=c("d4","yvec_val","ythresh","zvec","x1increment","yincrement","maintext1","x2increment","maintext2","ylabel","y2thresh"),file="manhattanplot_objects.Rda")
                  
                  if(output.device.type!="pdf"){
                    
                    temp_filename_1<-"Figures/ManhattanPlot_Type1.png"
                    
                    png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                  }
                  
                  try(get_manhattanplots(xvec=d4$mz,yvec=yvec_val,ythresh=0,up_or_down=zvec,xlab="Feature Index",ylab="Loading (absolute)",xincrement=x1increment,yincrement=0.1,maintext=maintext1,col_seq=c("black"),colorvec=manhattanplot.col.opt,bad.feature.index=bad.feature.index),silent=TRUE)
                  
                  if(output.device.type!="pdf"){
                    
                    try(dev.off(),silent=TRUE)
                  }
                  
                  if(output.device.type!="pdf"){
                    
                    temp_filename_1<-"Figures/ManhattanPlot_Type2.png"
                    
                    png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                  }
                  
                  
                  try(get_manhattanplots(xvec=d4$time,yvec=yvec_val,ythresh=0,up_or_down=zvec,xlab="Feature Index",ylab="Loading (absolute)",xincrement=x2increment,yincrement=0.1,maintext=maintext2,col_seq=c("black"),colorvec=manhattanplot.col.opt,bad.feature.index=bad.feature.index),silent=TRUE)
                  
                  
                  if(output.device.type!="pdf"){
                    
                    try(dev.off(),silent=TRUE)
                  }
                  
                  #volcanoplot
                  if(length(class_labels_levels)==2){
                    if(output.device.type!="pdf"){
                      
                      temp_filename_1<-"Figures/VolcanoPlot_Loading_vs_foldchange.png"
                      
                      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                    }
                    
                    maintext1="Volcano plot (absolute) Loading vs log2(fold change)) \n colored features meet the selection criteria"
                    
                    maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                    maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                    
                    
                    
                    try(get_volcanoplots(xvec=maxfoldchange,yvec=yvec_val,up_or_down=maxfoldchange,ythresh=ythresh,xthresh=foldchangethresh,maintext=maintext1,ylab="(absolute) Loading",xlab="log2(fold change)",yincrement=0.1,bad.feature.index=bad.feature.index,colorvec=manhattanplot.col.opt),silent=TRUE)
                    
                    if(output.device.type!="pdf"){
                      
                      try(dev.off(),silent=TRUE)
                    }
                  }
                  
                  
                }else{
                  
                  if(featselmethod=="pamr"){
                    
                    
                    
                    
                    maintext1="Type 1 manhattan plot (max |standardized centroids (d-statistic)| vs feature index) \n features with above the horizontal line meet the selection criteria"
                    maintext2="Type 2 manhattan plot (max |standardized centroids (d-statistic)| vs feature index) \n features with above the horizontal line meet the selection criteria"
                    if(is.na(zvec[1])==FALSE){
                      maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                      maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                    }
                    
                    
                    yvec_val<-data_limma_fdrall_withfeats[,1]
                    
                    ##error point
                    #vip_res<-as.data.frame(vip_res)
                    
                    discore<-as.data.frame(discore)
                    
                    bad.feature.index={}
                    if(is.na(pls.permut.count)==FALSE){
                      # yvec_val[which(vip_res$rand_pls_sel_prob>=pvalue.thresh | vip_res$rand_pls_sel_fdr>=fdrthresh)]<-0
                      #   bad.feature.index=which(vip_res$rand_pls_sel_prob>=pvalue.thresh | vip_res$rand_pls_sel_fdr>=fdrthresh)
                    }
                    ythresh=pamr_ythresh
                    ylabel="d-statistic (absolute)"
                    yincrement=0.1
                    y2thresh=NA
                    ####savelist=c("d4","yvec_val","ythresh","zvec","x1increment","yincrement","maintext1","x2increment","maintext2","ylabel","y2thresh"),file="manhattanplot_objects.Rda")
                    
                    if(output.device.type!="pdf"){
                      
                      temp_filename_1<-"Figures/ManhattanPlot_Type1.png"
                      
                      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                    }
                    
                    try(get_manhattanplots(xvec=d4$mz,yvec=yvec_val,ythresh=pamr_ythresh,up_or_down=zvec,xlab="Feature index",ylab="d-statistic (absolute) at threshold=0",xincrement=x1increment,yincrement=0.1,maintext=maintext1,col_seq=c("black"),colorvec=manhattanplot.col.opt,bad.feature.index=NA),silent=TRUE)
                    
                    if(output.device.type!="pdf"){
                      
                      try(dev.off(),silent=TRUE)
                    }
                    
                    if(output.device.type!="pdf"){
                      
                      temp_filename_1<-"Figures/ManhattanPlot_Type2.png"
                      
                      png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                    }
                    
                    
                    try(get_manhattanplots(xvec=d4$time,yvec=yvec_val,ythresh=pamr_ythresh,up_or_down=zvec,xlab="Feature index",ylab="d-statistic (absolute) at threshold=0",xincrement=x2increment,yincrement=0.1,maintext=maintext2,col_seq=c("black"),colorvec=manhattanplot.col.opt,bad.feature.index=NA),silent=TRUE)
                    
                    
                    if(output.device.type!="pdf"){
                      
                      try(dev.off(),silent=TRUE)
                    }
                    
                    #volcanoplot
                    if(length(class_labels_levels)==2){
                      if(output.device.type!="pdf"){
                        
                        temp_filename_1<-"Figures/VolcanoPlot_Dstatistic_vs_foldchange.png"
                        
                        png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                      }
                      
                      maintext1="Volcano plot (absolute) max standardized centroid (d-statistic) vs log2(fold change)) \n colored features meet the selection criteria"
                      
                      maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                      maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": lower in class ",class_labels_levels_main[1]," & ",manhattanplot.col.opt[1],": higher in class ",class_labels_levels_main[1],sep="")
                      
                      
                      
                      try(get_volcanoplots(xvec=maxfoldchange,yvec=yvec_val,up_or_down=maxfoldchange,ythresh=pamr_ythresh,xthresh=foldchangethresh,maintext=maintext1,ylab="(absolute) d-statistic at threshold=0",xlab="log2(fold change)",yincrement=0.1,bad.feature.index=NA,colorvec=manhattanplot.col.opt),silent=TRUE)
                      
                      if(output.device.type!="pdf"){
                        
                        try(dev.off(),silent=TRUE)
                      }
                    }
                    
                    
                  }
                  
                }
              }
              
            }
            
            
            
            
            goodip<-intersect(goodip,goodipfoldchange)
            
            
            dataA<-cbind(maxfoldchange,data_m_fc_withfeats)
            #write.table(dataA,file="foldchange.txt",sep="\t",row.names=FALSE)
            
            goodfeats_allfields<-{}
            
            
            if(length(goodip)>0){
              feat_sigfdrthresh[lf]<-length(goodip)
              subdata<-t(data_m_fc[goodip,])
              
              #save(parent_data_m,file="parent_data_m.Rda")
              
              data_minval<-min(parent_data_m[,-c(1:2)],na.rm=TRUE)*0.5
              
              #svm_model<-svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95)
              
              
              exp_fp<-1
              
              best_feats<-goodip
              
             
              
            }else{
              
              print("No features meet the fold change criteria.")
              
             
              
              
            }
            
          }else{
            
            if(dim(data_m_fc)[2]<kfold){
              print("Number of samples is too small to calculate cross-validation accuracy.")
            }
            
          }
          #feat_sigfdrthresh_cv<-c(feat_sigfdrthresh_cv,pred_acc)
          
          
          
         
          
          if(length(goodip)<1){
            
           # print("########################################")
           # print(paste("Relative standard deviation (RSD) threshold: ", log2.fold.change.thresh," %",sep=""))
            #print(paste("FDR threshold: ", fdrthresh,sep=""))
            print(paste("Number of features left after RSD filtering: ", dim(data_m_fc)[1],sep=""))
            print(paste("Number of selected features: ", length(goodip),sep=""))
            try(dev.off(),silent=TRUE)
            
            next
            
          }
          
          
          
          
         
          # save(data_m_fc_withfeats,data_matrix,data_m,goodip,names_with_mz_time,file="gdebug.Rda")
          
          
          #print("######################################")
          suppressMessages(library(cluster))
          
          t1<-table(classlabels)
          
          
          if(is.na(names_with_mz_time)[1]==FALSE){
            data_m_fc_withfeats_A1<-merge(names_with_mz_time,data_m_fc_withfeats,by=c("mz","time"))
            
            rownames(data_m_fc_withfeats)<-as.character(data_m_fc_withfeats_A1$Name)
            
            
          }else{
            
            rownames(data_m_fc_withfeats)<-as.character(paste(data_m_fc_withfeats[,1],data_m_fc_withfeats[,2],sep="_"))
          }
          
          
          #patientcolors <- unlist(lapply(sampleclass, color.map))
          if(length(goodip)>2){
            
            goodfeats<-as.data.frame(data_m_fc_withfeats[goodip,]) #[sel.diffdrthresh==TRUE,])
            
            goodfeats<-unique(goodfeats)
            
            
            rnames_goodfeats<-rownames(goodfeats) #as.character(paste(goodfeats[,1],goodfeats[,2],sep="_"))
            
            if(length(which(duplicated(rnames_goodfeats)==TRUE))>0){
              
              print("WARNING: Duplicated features found. Removing duplicate entries.")
              goodfeats<-goodfeats[-which(duplicated(rnames_goodfeats)==TRUE),]
              rnames_goodfeats<-rnames_goodfeats[-which(duplicated(rnames_goodfeats)==TRUE)]
            }
            
            
            #rownames(goodfeats)<-as.character(paste(goodfeats[,1],goodfeats[,2],sep="_"))
            
            
            
            data_m<-as.matrix(goodfeats[,-c(1:2)])
            
            
            rownames(data_m)<-rownames(goodfeats) #as.character(paste(goodfeats[,1],goodfeats[,2],sep="_"))
            
          
            
            
            data_m<-unique(data_m)			
            
            X<-t(data_m)
            
       
              {
              
              heatmap_file<-paste("heatmap_",featselmethod,".tiff",sep="")
              
              heatmap_mainlabel="" #2-way HCA using all significant features"
              
            if(FALSE)
              {
               # print("this step")
              #  save(hc,file="hc.Rda")
               # save(hr,file="hr.Rda")
                #save(distc,file="distc.Rda")
                #save(distr,file="distr.Rda")
              #  save(data_m,heatmap.col.opt,hca_type,classlabels,classlabels_orig,outloc,goodfeats,data_m_fc_withfeats,goodip,names_with_mz_time,plots.height,plots.width,plots.res,file="hcadata_m.Rda")
                #save(classlabels,file="classlabels.Rda")
              }
              
             
             # pdf("Testhca.pdf")
              
              #try(
               # 
              #dev.off()
              
              
              if(is.na(names_with_mz_time)[1]==FALSE){
              
                goodfeats_with_names<-merge(names_with_mz_time,goodfeats,by=c("mz","time"))
                
                goodfeats_with_names<-goodfeats_with_names[match(paste(goodfeats$mz,"_",goodfeats$time,sep=""),paste(goodfeats_with_names$mz,"_",goodfeats_with_names$time,sep="")),]
                
            #    save(names_with_mz_time,goodfeats,goodfeats_with_names,file="goodfeats_with_names.Rda")
                
                goodfeats_name<-goodfeats_with_names$Name
                
                rownames(goodfeats)<-goodfeats_name
                
              }else{
                
                #print(head(names_with_mz_time))
               # print(head(goodfeats))
                #goodfeats_name<-NA
              }
              
              save(data_m,heatmap.col.opt,hca_type,classlabels,classlabels_orig,output_dir,goodfeats,names_with_mz_time,data_m_fc_withfeats,goodip,goodfeats_name,names_with_mz_time,
                   plots.height,plots.width,plots.res,alphabetical.order,analysistype,labRow.value, labCol.value,hca.cex.legend,file="hcadata_mD.Rda")
          
              if(output.device.type!="pdf"){
                
              #  print(getwd())
                
         
                
              
                temp_filename_1<-"Figures/HCA_All_selectedfeats.png"
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type="cairo",units="in")
                
                
                #Generate HCA for selected features
                hca_res<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=goodfeats,Y=classlabels_orig,heatmap.col.opt=heatmap.col.opt,
                                 cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                                 sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3, hca_type=hca_type,newdevice=FALSE,
                                 input.type="intensity",mainlab="",alphabetical.order=alphabetical.order,study.design=analysistype,
                                 labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
                
                dev.off()
                
              }else{
                
                #Generate HCA for selected features
                hca_res<-get_hca(feature_table_file=NA,parentoutput_dir=output_dir,class_labels_file=NA,X=goodfeats,Y=classlabels_orig,heatmap.col.opt=heatmap.col.opt,cor.method=cor.method,is.data.znorm=FALSE,analysismode="classification",
                                 sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3, hca_type=hca_type,newdevice=FALSE,
                                 input.type="intensity",mainlab="",alphabetical.order=alphabetical.order,study.design=analysistype,
                                 labRow.value = labRow.value, labCol.value = labCol.value,similarity.matrix=similarity.matrix,cexLegend=hca.cex.legend,cexRow=cex.plots,cexCol=cex.plots)
                
                  
                 # get_hca(parentoutput_dir=getwd(),X=goodfeats,Y=classlabels_orig,heatmap.col.opt=heatmap.col.opt,cor.method="spearman",is.data.znorm=FALSE,analysismode="classification",
                       # sample.col.opt="rainbow",plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3, hca_type=hca_type,newdevice=FALSE) #,silent=TRUE)
                
              }
              
             
              
         
              
             
            }
            
            
           # print("Done with HCA.")
            
          }
         
          
          
        }
        
        else
        {
          
          
          #print("regression")
          
         # print("########################################")
         # print(paste("RSD threshold: ", log2.fold.change.thresh,sep=""))
          #print(paste("FDR threshold: ", fdrthresh,sep=""))
          #print(paste("Number of metabolites left after RSD filtering: ", dim(data_m_fc)[1],sep=""))
          #print(paste("Number of sig metabolites: ", length(goodip),sep=""))
          
          #print for regression
          #print(paste("Summary for method: ",featselmethod,sep=""))
          #print(paste("Relative standard deviation (RSD) threshold: ", log2.fold.change.thresh," %",sep=""))
          cat("Analysis summary:",sep="\n")
          cat(paste("Number of samples: ", dim(data_m_fc)[2],sep=""),sep="\n")
          
          cat(paste("Number of features in the original dataset: ", num_features_total,sep=""),sep="\n")
         # cat(rsd_filt_msg,sep="\n")
          cat(paste("Number of features left after preprocessing: ", dim(data_m_fc)[1],sep=""),sep="\n")
          cat(paste("Number of selected features: ", length(goodip),sep=""),sep="\n")
          
          #cat("", sep="\n")
          
          
          if(featselmethod=="lmreg"){
            #d4<-read.table(paste(parentoutput_dir,"/Stage2/lmreg_pval_coef_stderr.txt",sep=""),sep="\t",header=TRUE,quote = "")
            
            d4<-read.table("Tables/lmreg_pval_coef_stderr.txt",sep="\t",header=TRUE)
            
          }
          
          
          
          if(length(goodip)>=1){
            
            
            subdata<-t(data_m_fc[goodip,])
            
            
            if(length(class_labels_levels)==2){
              
              
              #zvec=foldchangeres
            }else{
              
              zvec=NA
              
              if(featselmethod=="lmreg" && analysismode=="regression"){
                
                cnames_matrix<-colnames(d4)
                
                
                
                cnames_colindex<-grep("Estimate_",cnames_matrix)
                
                
                zvec<-d4[,c(cnames_colindex[1])]
                #zvec<-d4$Estimate_var1
                
                #if(length(zvec)<1){
                #   zvec<-d4$X.Estimate_var1.
                
                #}
              }
              
              
            }
            
            
            
            
            
            
            roundUpNice <- function(x, nice=c(1,2,4,5,6,8,10)) {
              if(length(x) != 1) stop("'x' must be of length 1")
              10^floor(log10(x)) * nice[[which(x <= 10^floor(log10(x)) * nice)[[1]]]]
            }
            
            d4<-as.data.frame(data_limma_fdrall_withfeats)
            # d4<-as.data.frame(d1)
            
            
           # save(d4,file="mtype1.rda")
            x1increment=round_any(max(d4$mz)/10,10,f=floor)
            x2increment=round_any(max(d4$time)/10,10,f=floor)
            
            #manplots
            
            if(featselmethod=="lmreg" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat"
               | featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="logitreg" | featselmethod=="limma2wayrepeat" | featselmethod=="wilcox" | featselmethod=="ttest" | featselmethod=="poissonreg" | featselmethod=="lmregrepeat")
            {
              
              
              
              #print("Plotting manhattan plots")
              
              sel.diffdrthresh<-fdr_adjust_pvalue<fdrthresh & final.pvalues<pvalue.thresh
              
              
              
              goodip<-which(sel.diffdrthresh==TRUE)
              
              
              
              
              classlabels<-as.data.frame(classlabels)
              
              
              
              logp<-(-1)*log((d4[,1]+(10^-20)),10)
              ythresh<-min(logp[goodip],na.rm=TRUE)
              
              maintext1="Type 1 manhattan plot (-logp vs feature index) \n features above the dashed horizontal line meet the selection criteria"
              maintext2="Type 2 manhattan plot (-logp vs feature index) \n features above the dashed horizontal line meet the selection criteria"
              
              
              # print("here1 A")
              #print(zvec)
              
              if(is.na(zvec[1])==FALSE){
                maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": negative association "," & ",manhattanplot.col.opt[1],": positive association ",sep="")
                maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": negative association "," & ",manhattanplot.col.opt[1],": positive association ",sep="")
              }
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/ManhattanPlot_Type1.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
             
              try(get_manhattanplots(xvec=d4$mz,yvec=logp,ythresh=ythresh,up_or_down=zvec,xlab="Feature index",ylab="-logP",xincrement=x1increment,yincrement=1,
                                     maintext=maintext1,col_seq=c("black"),y2thresh=(-1)*log10(pvalue.thresh),colorvec=manhattanplot.col.opt),silent=TRUE)
              
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/ManhattanPlot_Type2.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              
              
              try(get_manhattanplots(xvec=d4$time,yvec=logp,ythresh=ythresh,up_or_down=zvec,xlab="Feature index",ylab="-logP",xincrement=x2increment,yincrement=1,
                                     maintext=maintext2,col_seq=c("black"),y2thresh=(-1)*log10(pvalue.thresh),colorvec=manhattanplot.col.opt),silent=TRUE)
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              
              #print("Plotting manhattan plots")
              #get_manhattanplots(xvec=d4$mz,yvec=logp,ythresh=ythresh,up_or_down=zvec,xlab="mass-to-charge (m/z)",ylab="-logP",xincrement=x1increment,yincrement=1,maintext=maintext1)
              #get_manhattanplots(xvec=d4$time,yvec=logp,ythresh=ythresh,up_or_down=zvec,xlab="Retention time",ylab="-logP",xincrement=x2increment,yincrement=1,maintext=maintext2)
              
            }else{
              
              if(featselmethod=="pls" | featselmethod=="o1pls"){
                
                maintext1="Type 1 manhattan plot (VIP vs feature index) \n features above the dashed horizontal line meet the selection criteria"
                maintext2="Type 2 manhattan plot (VIP vs feature index) \n features above the dashed horizontal line meet the selection criteria"
                
                if(is.na(zvec[1])==FALSE){
                  maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": negative association "," & ",manhattanplot.col.opt[1],": positive association ",sep="")
                  maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": negative association "," & ",manhattanplot.col.opt[1],": positive association ",sep="")
                }
                
                
                if(output.device.type!="pdf"){
                  
                  temp_filename_1<-"Figures/ManhattanPlot_Type1.png"
                  
                  png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                }
                
                
                
                
                try(get_manhattanplots(xvec=d4$mz,yvec=data_limma_fdrall_withfeats[,1],ythresh=pls_vip_thresh,up_or_down=zvec,xlab="mass-to-charge (m/z)",ylab="VIP",xincrement=x1increment,yincrement=0.5,maintext=maintext1,col_seq=c("black"),colorvec=manhattanplot.col.opt),silent=TRUE)
                
                
                
                if(output.device.type!="pdf"){
                  
                  try(dev.off(),silent=TRUE)
                }
                
                
                if(output.device.type!="pdf"){
                  
                  temp_filename_1<-"Figures/ManhattanPlot_Type2.png"
                  
                  png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                }
                
                
                
                try(get_manhattanplots(xvec=d4$time,yvec=data_limma_fdrall_withfeats[,1],ythresh=pls_vip_thresh,up_or_down=zvec,xlab="Feature index",ylab="VIP",xincrement=x2increment,yincrement=0.5,maintext=maintext2,col_seq=c("black"),colorvec=manhattanplot.col.opt),silent=TRUE)
                
                
                
                if(output.device.type!="pdf"){
                  
                  try(dev.off(),silent=TRUE)
                }
                
              }
              else{
                if(featselmethod=="spls" | featselmethod=="o1spls"){
                  
                  
                  maintext1="Type 1 manhattan plot (|loading| vs mz) \n m/z features with non-zero loadings meet the selection criteria"
                  maintext2="Type 2 manhattan plot (|loading| vs time) \n m/z features with non-zero loadings meet the selection criteria"
                  if(is.na(zvec[1])==FALSE){
                    maintext1=paste(maintext1,"\n",manhattanplot.col.opt[2],": negative association "," & ",manhattanplot.col.opt[1],": positive association ",sep="")
                    maintext2=paste(maintext2,"\n",manhattanplot.col.opt[2],": negative association "," & ",manhattanplot.col.opt[1],": positive association ",sep="")
                  }
                  
                  
                  if(output.device.type!="pdf"){
                    
                    temp_filename_1<-"Figures/ManhattanPlot_Type1.png"
                    
                    png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                  }
                  
                  
                  try(get_manhattanplots(xvec=d4$mz,yvec=data_limma_fdrall_withfeats[,1],ythresh=0,up_or_down=zvec,xlab="Feature index",ylab="Loading",xincrement=x1increment,yincrement=0.1,maintext=maintext1,col_seq=c("black"),colorvec=manhattanplot.col.opt),silent=TRUE)
                  
                  
                  if(output.device.type!="pdf"){
                    
                    try(dev.off(),silent=TRUE)
                  }
                  
                  
                  if(output.device.type!="pdf"){
                    
                    temp_filename_1<-"Figures/ManhattanPlot_Type2.png"
                    
                    png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                  }
                  
                  
                  
                  try(get_manhattanplots(xvec=d4$time,yvec=data_limma_fdrall_withfeats[,1],ythresh=0,up_or_down=zvec,xlab="Feature index",ylab="Loading",xincrement=x2increment,yincrement=0.1,maintext=maintext2,col_seq=c("black"),colorvec=manhattanplot.col.opt),silent=TRUE)
                  
                  
                  if(output.device.type!="pdf"){
                    
                    try(dev.off(),silent=TRUE)
                  }
                  
                }
              }
              
            }
            
            
            data_minval<-min(parent_data_m[,-c(1:2)],na.rm=TRUE)*0.5
            #subdata<-apply(subdata,2,function(x){naind<-which(is.na(x)==TRUE);if(length(naind)>0){ x[naind]<-median(x,na.rm=TRUE)};return(x)})
            subdata<-apply(subdata,2,function(x){naind<-which(is.na(x)==TRUE);if(length(naind)>0){ x[naind]<-data_minval};return(x)})
            
            
            #print(head(subdata))
            #print(dim(subdata))
            #print(dim(classlabels))
            
            #print(dim(classlabels))
            
            classlabels_response_mat<-as.data.frame(classlabels_response_mat)
            
            if(length(classlabels)>dim(parent_data_m)[2]){
              #classlabels<-as.data.frame(classlabels[,1])
              classlabels_response_mat<-as.data.frame(classlabels_response_mat[,1])
            }
            
            if(FALSE){
                  svm_model_reg<-try(svm(x=subdata,y=(classlabels_response_mat[,1]),type="eps",cross=kfold),silent=TRUE)
                  
                  if(is(svm_model_reg,"try-error")){
                    print("SVM could not be performed. Skipping to the next step.")
                    termA<-(-1)
                    pred_acc<-termA
                  }else{
                    termA<-svm_model_reg$tot.MSE
                    
                    pred_acc<-termA
                    print(paste(kfold,"-fold mean squared error: ", pred_acc,sep=""))
                    
                  }
            }
            termA<-(-1)
            pred_acc<-termA
            
            
          #  print("######################################")
          }else{
            #print("Number of selected variables is too small to perform CV.")
            
          }
          
          #print("termA is ")
          #print(termA)
          
          # print("dim of goodfeats")
          goodfeats<-as.data.frame(data_m_fc_withfeats[sel.diffdrthresh==TRUE,])
          
          goodip<-which(sel.diffdrthresh==TRUE)
          
          #print(length(goodip))
          
          res_score<-termA
          
          #if(res_score<best_cv_res){
          
          if(length(which(sel.diffdrthresh==TRUE))>0){
            if(res_score<best_cv_res){
              
              
              best_logfc_ind<-lf
              
              best_feats<-goodip
              best_cv_res<-res_score
              best_acc<-pred_acc
              best_limma_res<-data_limma_fdrall_withfeats[sel.diffdrthresh==TRUE,]
              
            }
          }else{
            res_score<-(9999999)
          }
          res_score_vec[lf]<-res_score
   
          goodfeats<-unique(goodfeats)
          
        #  save(names_with_mz_time,goodfeats,file="goodfeats_1.Rda")
          
          if(length(which(is.na(goodfeats$mz)==TRUE))>0){
            
            goodfeats<-goodfeats[-which(is.na(goodfeats$mz)==TRUE),]
          }
          if(is.na(names_with_mz_time)[1]==FALSE){
            
            goodfeats_with_names<-merge(names_with_mz_time,goodfeats,by=c("mz","time"))
            goodfeats_with_names<-goodfeats_with_names[match(goodfeats$mz,goodfeats_with_names$mz),]
            
            #
            
            goodfeats_name<-goodfeats_with_names$Name
            #}
          }else{
            
            
            goodfeats_name<-as.character(paste(goodfeats[,1],goodfeats[,2],sep="_"))
          }
          
          
          if(length(which(sel.diffdrthresh==TRUE))>2){
            
            
            
            
            ##save(goodfeats,file="goodfeats.Rda")
            #rownames(goodfeats)<-as.character(goodfeats[,1])
            rownames(goodfeats)<-goodfeats_name #as.character(paste(goodfeats[,1],goodfeats[,2],sep="_"))
            
            
            data_m<-as.matrix(goodfeats[,-c(1:2)])
            
            rownames(data_m)<-rownames(goodfeats) #as.character(paste(goodfeats[,1],goodfeats[,2],sep="_"))
            
            
            X<-t(data_m)
            
            pca_comp<-min(dim(X)[1],dim(X)[2])
            
            t1<-seq(1,dim(data_m)[2])
            
            col <-col_vec[1:length(t1)]
            
            
            
            hr <- try(hclust(as.dist(1-cor(t(data_m),method=cor.method,use="pairwise.complete.obs"))),silent=TRUE) #metabolites
            hc <- try(hclust(as.dist(1-cor(data_m,method=cor.method,use="pairwise.complete.obs"))),silent=TRUE) #samples
            
            
            if(heatmap.col.opt=="RdBu"){
              
              heatmap.col.opt="redblue"
            }
            
            heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
            heatmap_cols<-rev(heatmap_cols)
            
            if(heatmap.col.opt=="topo"){
              heatmap_cols<-topo.colors(256)
              heatmap_cols<-rev(heatmap_cols)
            }else{
              if(heatmap.col.opt=="heat"){
                heatmap_cols<-heat.colors(256)
                heatmap_cols<-rev(heatmap_cols)
              }else{
                
                if(heatmap.col.opt=="yellowblue"){
                  
                  heatmap_cols<-colorRampPalette(c("yellow","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
                  #heatmap_cols<-blue2yellow(256) #colorRampPalette(c("yellow","blue"))(256)
                  heatmap_cols<-rev(heatmap_cols)
                }else{
                  
                  if(heatmap.col.opt=="redblue"){
                    
                    heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
                    heatmap_cols<-rev(heatmap_cols)
                  }else{
                    
                    #my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
                    if(heatmap.col.opt=="redyellowgreen"){
                      
                      heatmap_cols <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
                      heatmap_cols<-rev(heatmap_cols)
                    }else{
                      if(heatmap.col.opt=="yellowwhiteblue"){
                        
                        heatmap_cols<-colorRampPalette(c("yellow2","white","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
                        heatmap_cols<-rev(heatmap_cols)
                      }else{
                        
                        if(heatmap.col.opt=="redwhiteblue"){
                          
                          heatmap_cols<-colorRampPalette(c("red","white","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
                          heatmap_cols<-rev(heatmap_cols)
                        }else{
                          
                          
                          
                          heatmap_cols <- colorRampPalette(brewer.pal(10, heatmap.col.opt))(256)
                          heatmap_cols<-rev(heatmap_cols)
                          
                        }
                        
                      }
                      
                    }
                    
                  }
                  
                }
              }
              
            }
            
            
            
            if(is(hr,"try-error") || is(hc,"try-error")){
              
              print("Hierarchical clustering can not be performed. ")
            }else{
              
              
              mycl_samples <- cutree(hc, h=max(hc$height)/2)
              t1<-table(mycl_samples)
              col_clust<-topo.colors(length(t1))
              patientcolors=rep(col_clust,t1) #mycl_samples[col_clust]
              heatmap_file<-paste("heatmap_",featselmethod,"_imp_features.tiff",sep="")
              
              #tiff(heatmap_file,width=plots.width,height=plots.height,res=plots.res, compression="lzw")
              
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/HCA_all_selectedfeats.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              
              
              
              if(znormtransform==FALSE){
                h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="row",key=TRUE, symkey=FALSE, 
                               density.info="none", trace="none", cexRow=1, cexCol=1,xlab="",ylab="", main="Using all selected features",labRow = hca.labRow.value, labCol = hca.labCol.value)
              }else{
                h73<-heatmap.2(data_m, Rowv=as.dendrogram(hr), Colv=as.dendrogram(hc),  col=heatmap_cols, scale="none",key=TRUE, 
                               symkey=FALSE, density.info="none", trace="none", cexRow=1, cexCol=1,xlab="",ylab="", main="Using all selected features",labRow = hca.labRow.value, labCol = hca.labCol.value)
              }
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              
              
              mycl_samples <- cutree(hc, h=max(hc$height)/2)
              mycl_metabs <- cutree(hr, h=max(hr$height)/2)
              
              ord_data<-cbind(mycl_metabs[rev(h73$rowInd)],goodfeats[rev(h73$rowInd),c(1:2)],data_m[rev(h73$rowInd),h73$colInd])
              
              cnames1<-colnames(ord_data)
              cnames1[1]<-"mz_cluster_label"
              colnames(ord_data)<-cnames1
              fname1<-paste("Tables/Clustering_based_sorted_intensity_data.txt",sep="")
              write.table(ord_data,file=fname1,sep="\t",row.names=FALSE)
              
              fname2<-paste("Tables/Sample_clusterlabels.txt",sep="")
              
              sample_clust_num<-mycl_samples[h73$colInd]
              
              
              
              classlabels<-as.data.frame(classlabels)
              
              
              temp1<-classlabels[h73$colInd,]
              
              temp3<-cbind(temp1,sample_clust_num)
              
              rnames1<-rownames(temp3)
              temp4<-cbind(rnames1,temp3)
              temp4<-as.data.frame(temp4)
              
              
              if(analysismode=="regression"){
                
                
                #names(temp3[,1)<-as.character(temp4[,1])
                
                
                
                temp3<-temp4[,-c(1)]
                temp3<-as.data.frame(temp3)
                temp3<-apply(temp3,2,as.numeric)
                
                
                temp_vec<-as.vector(temp3[,1])
                
                
                
                names(temp_vec)<-as.character(temp4[,1])
                
                
                if(output.device.type!="pdf"){
                  
                  temp_filename_1<-"Figures/Barplot_dependent_variable_ordered_by_HCA.png"
                  
                  png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                }
                
                
                
                #tiff("Barplot_sample_cluster_ymat.tiff", width=plots.width,height=plots.height,res=plots.res, compression="lzw")
                barplot(temp_vec,col="brown",ylab="Y",cex.axis=0.5,cex.names=0.5,main="Dependent variable levels in samples; \n ordered based on hierarchical clustering")
                #dev.off()
                
                
                if(output.device.type!="pdf"){
                  
                  try(dev.off(),silent=TRUE)
                }
                
                
                
              }
              
              #	print(head(temp_vec))
              #temp4<-temp4[,-c(2)]
              write.table(temp4,file=fname2,sep="\t",row.names=FALSE)
              
              
              
              fname3<-paste("Metabolite_clusterlabels.txt",sep="")
              
              mycl_metabs_ord<-mycl_metabs[rev(h73$rowInd)]
              
            }
          }
          
          
          
          
          
        }
        
        classlabels_orig<-classlabels_orig_parent
        if(pairedanalysis==TRUE){
          
          classlabels_orig<-classlabels_orig[,-c(2)]
          
          
        }else{
          
          if(featselmethod=="lmreg" || featselmethod=="logitreg" || featselmethod=="poissonreg"){
            classlabels_orig<-classlabels_orig[,c(1:2)]
            classlabels_orig<-as.data.frame(classlabels_orig)
          }
        }
        
        
        node_names=rownames(data_m_fc_withfeats)
        #save(data_limma_fdrall_withfeats,goodip,data_m_fc_withfeats,data_matrix,names_with_mz_time,file="data_limma_fdrall_withfeats1.Rda")
       
        classlabels_orig_wgcna<-classlabels_orig
        
        if(analysismode=="classification"){
          
          classlabels_temp<-classlabels_orig_wgcna #cbind(classlabels_sub[,1],classlabels)
          
          sigfeats=data_m_fc_withfeats[goodip,c(1:2)]
         
          # save(data_m_fc_withfeats,classlabels_temp,sigfeats,goodip,num_nodes,abs.cor.thresh,cor.fdrthresh,alphabetical.order,
           #    plot_DiNa_graph,degree.centrality.method,node_names,networktype,file="debugdiffrank_eval.Rda")
          
          if(degree_rank_method=="diffrank"){
           # degree_eval_res<-try(diffrank_eval(X=data_m_fc_withfeats,Y=classlabels_temp,sigfeats=data_m_fc_withfeats[goodip,c(1:2)],sigfeatsind=goodip,
            #                                   num_nodes=num_nodes,abs.cor.thresh=abs.cor.thresh,cor.fdrthresh=cor.fdrthresh,alphabetical.order=alphabetical.order),silent=TRUE)
        
            degree_eval_res<-diffrank_eval(X=data_m_fc_withfeats,Y=classlabels_temp,sigfeats=sigfeats,sigfeatsind=goodip,
                                               num_nodes=num_nodes,abs.cor.thresh=abs.cor.thresh,cor.fdrthresh=cor.fdrthresh,alphabetical.order=alphabetical.order,
                                           node_names=node_names,plot_graph_bool=plot_DiNa_graph,
                                           degree.centrality.method = degree.centrality.method,networktype=networktype) #,silent=TRUE)
            
            
            
          }else{
            
            degree_eval_res<-{}
          }
          
        }
        
       
        
        sample_names_vec<-colnames(data_m_fc_withfeats[,-c(1:2)])
        
      #  save(degree_eval_res,file="DiNa_results.Rda")
        
       # save(data_limma_fdrall_withfeats,goodip,sample_names_vec,data_m_fc_withfeats,data_matrix,names_with_mz_time,file="data_limma_fdrall_withfeats.Rda")
        
        if(analysismode=="classification")
        {
          
          degree_rank<-rep(1,dim(data_m_fc_withfeats)[1])
          
          if(is(degree_eval_res,"try-error")){
            
            degree_rank<-rep(1,dim(data_m_fc_withfeats)[1])
            
            
          }else{
            if(degree_rank_method=="diffrank"){
              
              diff_degree_measure<-degree_eval_res$all
              
              degree_rank<-diff_degree_measure$DiffRank #rank((1)*diff_degree_measure)
            }
            
            
          }
          
        #  save(degree_rank,file="degree_rank.Rda")
          
          
          if(featselmethod=="lmreg" | featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="limma1way" | featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="limma1wayrepeat" | featselmethod=="limma2wayrepeat" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="wilcox" | featselmethod=="ttest" | featselmethod=="poissonreg" | featselmethod=="lmregrepeat")
          {
            diffexp_rank<-rank(data_limma_fdrall_withfeats[,2]) #order(data_limma_fdrall_withfeats[,2],decreasing=FALSE)
            
            
            type.statistic="pvalue"
            
            if(pvalue.dist.plot==TRUE){
            x1=Sys.time()
            stat_val<-(-1)*log10(data_limma_fdrall_withfeats[,2])
            
            if(output.device.type!="pdf"){
              pdf("Figures/pvalue.distribution.pdf",width=10,height=8)
            }
            par(mfrow=c(1,2))
            kstest_res<-ks.test(data_limma_fdrall_withfeats[,2],"punif",0,1)
            kstest_res<-round(kstest_res$p.value,3)
            
            hist(as.numeric(data_limma_fdrall_withfeats[,2]),main=paste("Distribution of pvalues\n","Kolmogorov-Smirnov test for uniform distribution, p=",kstest_res,sep=""),cex.main=0.75,xlab="pvalues")
           
              simpleQQPlot = function (observedPValues,mainlab) {
                plot(-log10(1:length(observedPValues)/length(observedPValues)),
                     -log10(sort(observedPValues)),main=mainlab,xlab=paste("Expected -log10pvalue",sep=""),ylab=paste("Observed -logpvalue",sep=""),cex.main=0.75)
                abline(0, 1, col = "brown")
              }
              
              inflation <- function(pvalue) {
                chisq <- qchisq(1 - pvalue, 1)
                lambda <- median(chisq) / qchisq(0.5, 1)
                lambda
              }
              inflation_res<-round(inflation(data_limma_fdrall_withfeats[,2]),2)
              
              simpleQQPlot(data_limma_fdrall_withfeats[,2],mainlab=paste("QQplot pvalues","\np-value inflation factor: ",inflation_res," (no inflation: close to 1; bias: greater than 1)",sep=""))
              
              x2=Sys.time()
              #print(x2-x1)
            
            
            
            if(output.device.type!="pdf"){
              dev.off()
            }
          }
            par(mfrow=c(1,1))
            
            
            
          }else{
            
            
            if(featselmethod=="rfesvm"){
              
              
              diffexp_rank<-rank((1)*abs(data_limma_fdrall_withfeats[,2]))
              #diffexp_rank<-rank_vec
              #data_limma_fdrall_withfeats<-cbind(rank_vec,data_limma_fdrall_withfeats)
              
              
            }else{
              
              
              if(featselmethod=="pamr"){
                
                diffexp_rank<-rank_vec
                #data_limma_fdrall_withfeats<-cbind(rank_vec,data_limma_fdrall_withfeats[,-c(1)])
                
                
              }else{
                
                if(featselmethod=="MARS"){
                  
                  diffexp_rank<-rank((-1)*data_limma_fdrall_withfeats[,2])
                  
                }else{
                  diffexp_rank<-rank((1)*data_limma_fdrall_withfeats[,2])
                }
              }
            }
          }
          
          if(input.intensity.scale=="raw" && log2transform==FALSE){
            
            
            
            fold.change.value<-maxfoldchange
            data_limma_fdrall_withfeats_2<-cbind(fold.change.value,degree_rank,diffexp_rank,data_limma_fdrall_withfeats)
            
            
          }else{
            
            if(input.intensity.scale=="log2" || log2transform==TRUE){
              
              fold.change.value<-maxfoldchange
              data_limma_fdrall_withfeats_2<-cbind(fold.change.value,degree_rank,diffexp_rank,data_limma_fdrall_withfeats)
            }
            
            
          }
          
       #   save(data_limma_fdrall_withfeats_2,file="data_limma_fdrall_withfeats_2.Rda")
          
         
          
          
          allmetabs_res<-data_limma_fdrall_withfeats_2
          
    
          
       
            
          if(analysismode=="classification"){
            
            if(logistic_reg==TRUE){
              
              fname4<-paste("logitreg","results_allfeatures.txt",sep="")
            }else{
              
              
              if(poisson_reg==TRUE){
                fname4<-paste("poissonreg","results_allfeatures.txt",sep="")
              }else{
                fname4<-paste(parentfeatselmethod,"results_allfeatures.txt",sep="")
              }
            }
            
            fname4<-paste("Tables/",fname4,sep="")
            
            
            
            if(is.na(names_with_mz_time)[1]==FALSE){
              
              
              group_means1<-merge(group_means,group_sd,by=c("mz","time"))
              
              allmetabs_res_temp<-merge(group_means1,allmetabs_res,by=c("mz","time"))
              
              save(group_means1,file="group_means1.Rda")
              
              save(allmetabs_res_temp,file="allmetabs_res_temp.Rda")
              
              save(names_with_mz_time,file="names_with_mz_time.Rda")
              
              cnames_cur<-colnames(allmetabs_res_temp)
              
              check_namey<-grep(cnames_cur,pattern="Name")
              if(length(check_namey)>0){
                
                Name<-allmetabs_res_temp[,c(check_namey)]
                allmetabs_res_temp<-cbind(Name,allmetabs_res_temp[,-c(check_namey)])
                #cnames_cur[1]<-"Name"
                #cnames_cur<-cnames_cur[-c(check_namey)]
                #colnames(allmetabs_res_temp)<-cnames_cur
              }
              
              
              allmetabs_res_withnames<-merge(names_with_mz_time,allmetabs_res_temp,by=c("mz","time"))
              
            #  allmetabs_res_withnames<-merge(diff_degree_measure[,c("mz","time","DiffRank")],allmetabs_res_withnames,by=c("mz","time"))
              #allmetabs_res_withnames<-cbind(degree_rank,diffexp_rank,allmetabs_res_withnames)
             # allmetabs_res_withnames<-allmetabs_res_withnames[,c("DiffRank")]
              
              save(allmetabs_res_withnames,file="allmetabs_res_withnames.Rda")
              
             # allmetabs_res_withnames<-allmetabs_res_withnames[order(allmetabs_res_withnames$mz,allmetabs_res_withnames$time),]
              allmetabs_res_withnames<-allmetabs_res_withnames[order(as.numeric(as.character(allmetabs_res_withnames$mz)),as.numeric(as.character(allmetabs_res_withnames$time))),]
              
             
              if(length(check_names)>0){
              rem_col_ind1<-grep(colnames(allmetabs_res_withnames),pattern=c("mz"))
              
              rem_col_ind2<-grep(colnames(allmetabs_res_withnames),pattern=c("time"))
              
              rem_col_ind<-c(rem_col_ind1,rem_col_ind2)
              }else{
                rem_col_ind<-{}
                
              }
              if(length(rem_col_ind)>0){
              write.table(allmetabs_res_withnames[,-c(rem_col_ind)], file=fname4,sep="\t",row.names=FALSE)
              }else{
                
                write.table(allmetabs_res_withnames, file=fname4,sep="\t",row.names=FALSE)
              }
              #rm(data_allinf_withfeats_withnames)
              #}
            }else{
              
              group_means1<-merge(group_means,group_sd,by=c("mz","time"))
              
              allmetabs_res_temp<-merge(group_means1,allmetabs_res,by=c("mz","time"))
              
              #allmetabs_res_temp<-merge(group_means,allmetabs_res,by=c("mz","time"))
              
             # allmetabs_res_temp<-cbind(degree_rank,diffexp_rank,allmetabs_res_temp)
              
              Name<-paste(allmetabs_res_temp$mz,allmetabs_res_temp$time,sep="_")
              allmetabs_res_withnames<-cbind(Name,allmetabs_res_temp)
              allmetabs_res_withnames<-as.data.frame(allmetabs_res_withnames)
             # allmetabs_res_withnames<-allmetabs_res_withnames[order(allmetabs_res_withnames$mz,allmetabs_res_withnames$time),]
              allmetabs_res_withnames<-allmetabs_res_withnames[order(as.numeric(as.character(allmetabs_res_withnames$mz)),as.numeric(as.character(allmetabs_res_withnames$time))),]
              
              write.table(allmetabs_res_withnames,file=fname4,sep="\t",row.names=FALSE)
            }
            
            rm(allmetabs_res_temp)
          }else{
            
            
          }
          
          #rm(allmetabs_res)
          
          if(length(goodip)>=1){
            
           # data_limma_fdrall_withfeats_2<-data_limma_fdrall_withfeats_2[goodip,]
            
            #data_limma_fdrall_withfeats_2<-as.data.frame(data_limma_fdrall_withfeats_2)
           # save(allmetabs_res_withnames,goodip,file="allmetabs_res_withnames.Rda")
            allmetabs_res_withnames<-allmetabs_res_withnames[order(as.numeric(as.character(allmetabs_res_withnames$mz)),as.numeric(as.character(allmetabs_res_withnames$time))),]
            goodfeats<-as.data.frame(allmetabs_res_withnames[goodip,]) #data_limma_fdrall_withfeats_2)
            
            goodfeats_allfields<-goodfeats
          #  write.table(allmetabs_res_withnames,file=fname4,sep="\t",row.names=FALSE)
          
            if(logistic_reg==TRUE){
              
              fname4<-paste("logitreg","results_selectedfeatures.txt",sep="")
              
            }else{
              
              if(poisson_reg==TRUE){
                
                fname4<-paste("poissonreg","results_selectedfeatures.txt",sep="")
                
              }else{
                fname4<-paste(featselmethod,"results_selectedfeatures.txt",sep="")
              }
            }
            
            #fname4<-paste("Tables/",fname4,sep="")
            
            write.table(goodfeats,file=fname4,sep="\t",row.names=FALSE)
            
            if(length(rocfeatlist)>length(goodip)){
              
              rocfeatlist<-rocfeatlist[-which(rocfeatlist>length(goodip))] #seq(1,(length(goodip)))
              numselect<-length(goodip)
              #rocfeatlist<-rocfeatlist+1
            }else{
              
              numselect<-length(rocfeatlist)
            }
            
            
          }
          
        }else{
          
          #analysismode=="regression"
          if(featselmethod=="lmreg" | featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="limma1way" | featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="limma1wayrepeat" | featselmethod=="limma2wayrepeat" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="wilcox" | featselmethod=="ttest" | featselmethod=="poissonreg" | featselmethod=="lmregrepeat")
          {
            diffexp_rank<-rank(data_limma_fdrall_withfeats[,1]) #order(data_limma_fdrall_withfeats[,2],decreasing=FALSE)
          }else{
            
            
            if(featselmethod=="rfesvm"){
              
              
              diffexp_rank<-rank_vec
              data_limma_fdrall_withfeats<-data_limma_fdrall_withfeats
              
              
            }else{
              
              
              if(featselmethod=="pamr"){
                
                diffexp_rank<-rank_vec
              #  data_limma_fdrall_withfeats<-cbind(rank_vec,data_limma_fdrall_withfeats)
                
                
              }else{
                
                if(featselmethod=="MARS"){
                  
                  diffexp_rank<-rank((-1)*data_limma_fdrall_withfeats[,1])
                  
                }else{
                  diffexp_rank<-rank((1)*data_limma_fdrall_withfeats[,2])
                }
              }
            }
            
          }
          
        
          #save(goodfeats,diffexp_rank,data_limma_fdrall_withfeats,file="t3.Rda")
          
          data_limma_fdrall_withfeats_2<-cbind(diffexp_rank,data_limma_fdrall_withfeats)
          
          
          # fname4<-paste(featselmethod,"_sigfeats.txt",sep="")
          
          if(logistic_reg==TRUE){
            
            fname4<-paste("logitreg","results_allfeatures.txt",sep="")
            
            
          }else{
            
            
            if(poisson_reg==TRUE){
              fname4<-paste("poissonreg","results_allfeatures.txt",sep="")
            }else{
              fname4<-paste(parentfeatselmethod,"results_allfeatures.txt",sep="")
            }
          }
          
          fname4<-paste("Tables/",fname4,sep="")
          
          allmetabs_res<-data_limma_fdrall_withfeats_2
         
          
          if(is.na(names_with_mz_time)[1]==FALSE){
            
            
            allmetabs_res_withnames<-merge(names_with_mz_time,data_limma_fdrall_withfeats_2,by=c("mz","time"))
            
            # allmetabs_res_withnames<-cbind(degree_rank,diffexp_rank,allmetabs_res_withnames)
            allmetabs_res_withnames<-allmetabs_res_withnames[order(as.numeric(as.character(allmetabs_res_withnames$mz)),as.numeric(as.character(allmetabs_res_withnames$time))),]
            
           # allmetabs_res_withnames<-allmetabs_res_withnames[order(allmetabs_res_withnames$mz,allmetabs_res_withnames$time),]
            
            #write.table(allmetabs_res_withnames[,-c("mz","time")], file=fname4,sep="\t",row.names=FALSE)
           # save(allmetabs_res_withnames,file="allmetabs_res_withnames.Rda")
            #rem_col_ind<-grep(colnames(allmetabs_res_withnames),pattern=c("mz","time"))
            
            if(length(check_names)>0){
            rem_col_ind1<-grep(colnames(allmetabs_res_withnames),pattern=c("mz"))
            
            rem_col_ind2<-grep(colnames(allmetabs_res_withnames),pattern=c("time"))
            
            rem_col_ind<-c(rem_col_ind1,rem_col_ind2)
            }else{
              rem_col_ind<-{}
            }
            
            if(length(rem_col_ind)>0){
              write.table(allmetabs_res_withnames[,-c(rem_col_ind)], file=fname4,sep="\t",row.names=FALSE)
            }else{
              
              write.table(allmetabs_res_withnames, file=fname4,sep="\t",row.names=FALSE)
            }
            
            
           # rm(data_allinf_withfeats_withnames)
            
          }else{
            
            # allmetabs_res_temp<-cbind(degree_rank,diffexp_rank,allmetabs_res)
            
            allmetabs_res_withnames<-allmetabs_res
            write.table(allmetabs_res,file=fname4,sep="\t",row.names=FALSE)
          }
          goodfeats<-allmetabs_res_withnames[goodip,] #data_limma_fdrall_withfeats_2[goodip,] #[sel.diffdrthresh==TRUE,]
         # save(allmetabs_res_withnames,goodip,file="allmetabs_res_withnames.Rda")
          goodfeats<-as.data.frame(allmetabs_res_withnames[goodip,]) #data_limma_fdrall_withfeats_2)
          
          goodfeats_allfields<-goodfeats
          
          if(logistic_reg==TRUE){
            
            fname4<-paste("logitreg","results_selectedfeatures.txt",sep="")
            
          }else{
            
            if(poisson_reg==TRUE){
              
              fname4<-paste("poissonreg","results_selectedfeatures.txt",sep="")
              
            }else{
              fname4<-paste(featselmethod,"results_selectedfeatures.txt",sep="")
            }
          }
          
         # fname4<-paste("Tables/",fname4,sep="")
          
          write.table(goodfeats,file=fname4,sep="\t",row.names=FALSE)
          
          
          
          fname4<-paste("Tables/",parentfeatselmethod,"results_allfeatures.txt",sep="")
          
          #allmetabs_res<-goodfeats #data_limma_fdrall_withfeats_2
         
        }
        
        
      }
      
      
  #   save(goodfeats,file="goodfeats455.Rda")
      
      if(length(goodip)>1){
        goodfeats_by_DICErank<-{}
        
        if(analysismode=="classification"){
          if(featselmethod=="lmreg" | featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="limma1way" | featselmethod=="lmreg" | featselmethod=="logitreg" | featselmethod=="limma1wayrepeat" | featselmethod=="limma2wayrepeat" | featselmethod=="lm1wayanova" | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="wilcox" | featselmethod=="ttest" | featselmethod=="poissonreg")
          {
            goodfeats<-goodfeats[order(goodfeats$diffexp_rank,decreasing=FALSE),]
            
            if(length(goodip)>1){
              # goodfeats_by_DICErank<-data_limma_fdrall_withfeats_2[r1$top.list,]
            }
          }else{
            
            goodfeats<-goodfeats[order(goodfeats$diffexp_rank,decreasing=FALSE),]
            
            if(length(goodip)>1){
              #goodfeats_by_DICErank<-data_limma_fdrall_withfeats_2[r1$top.list,]
              
            }
          }
          
          cnamesd1<-colnames(goodfeats)
          time_ind<-which(cnamesd1=="time")
          
          
          mz_ind<-which(cnamesd1=="mz")
          
          
          goodfeats_name<-goodfeats$Name
          
          
          goodfeats_temp<-cbind(goodfeats[,mz_ind],goodfeats[,time_ind],goodfeats[,which(colnames(goodfeats)%in%sample_names_vec)]) #goodfeats[,-c(1:time_ind)])
          
         # save(goodfeats_temp,file="goodfeats_temp.Rda")
          
          cnames_temp<-colnames(goodfeats_temp)
          cnames_temp<-c("mz","time",cnames_temp[-c(1:2)])
          colnames(goodfeats_temp)<-cnames_temp
          
          goodfeats<-goodfeats_temp
          
          
        }else{
          if(analysismode=="regression"){
            
           # save(goodfeats,file="goodfeats455.Rda")
            
            try(dev.off(),silent=TRUE)
            
            if(featselmethod=="lmreg" | featselmethod=="pls" | featselmethod=="spls" |      featselmethod=="o1pls" | featselmethod=="RF" | featselmethod=="MARS"){
              
              ####savegoodfeats,file="goodfeats.Rda")
              goodfeats<-goodfeats[order(goodfeats$diffexp_rank,decreasing=FALSE),]
              
            }else{
              
              
              #goodfeats<-goodfeats[order(goodfeats[,1],decreasing=TRUE),]
              
            }
            
            goodfeats<-as.data.frame(goodfeats)
            
            cnamesd1<-colnames(goodfeats)
            time_ind<-which(cnamesd1=="time")
            
            
            mz_ind<-which(cnamesd1=="mz")
            
            
            goodfeats_name<-goodfeats$Name
            
            
            goodfeats_temp<-cbind(goodfeats[,mz_ind],goodfeats[,time_ind],goodfeats[,which(colnames(goodfeats)%in%sample_names_vec)]) #goodfeats[,-c(1:time_ind)])
            
            #save(goodfeats_temp,goodfeats,goodfeats_name,file="goodfeats_temp.Rda")
            cnames_temp<-colnames(goodfeats_temp)
            cnames_temp<-c("mz","time",cnames_temp[-c(1:2)])
            colnames(goodfeats_temp)<-cnames_temp
            
            goodfeats<-goodfeats_temp
            
            rm(goodfeats_temp)
           
            #      #save(goodfeats,goodfeats_temp,mz_ind,time_ind,classlabels_orig,analysistype,alphabetical.order,col_vec,file="pca1.Rda")
            
            num_sig_feats<-nrow(goodfeats)
            if(num_sig_feats>=3 & pca.stage2.eval==TRUE){
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/PCAplots_selectedfeats.pdf"
                
                #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                #pdf(temp_filename_1)
                pdf(temp_filename_1,width=plots.width,height=plots.height)
              }
              
              plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
              
              
              text(5, 8, "PCA using selected features after feature selection")
              text(5, 7, "The figures include: ")
              text(5, 6, "a. pairwise PC score plots ")
              text(5, 5, "b. scores for individual samples on each PC")
              text(5, 4, "c. Lineplots using PC scores for data with repeated measurements")
              
              
              par(mfrow=c(1,1),family="sans",cex=cex.plots)
              
              rownames(goodfeats)<-goodfeats$Name
              
              get_pcascoredistplots(X=goodfeats,Y=classlabels_orig,feature_table_file=NA,parentoutput_dir=getwd(),
                                    class_labels_file=NA,sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,
                                    plots.res=300, alphacol=0.3,col_vec=col_vec,pairedanalysis=pairedanalysis,
                                    pca.cex.val=pca.cex.val,legendlocation=legendlocation,pca.ellipse=pca.ellipse,
                                    ellipse.conf.level=ellipse.conf.level,filename="selected",paireddesign=paireddesign,
                                    lineplot.col.opt=lineplot.col.opt,lineplot.lty.option=lineplot.lty.option,
                                    timeseries.lineplots=timeseries.lineplots,pcacenter=pcacenter,pcascale=pcascale,
                                    alphabetical.order=alphabetical.order,study.design=analysistype,lme.modeltype=modeltype) #,silent=TRUE)
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
            }
          }
          
        }
        
       
        
        
      }
      
      
      class_label_A<-class_labels_levels[1]
      class_label_B<-class_labels_levels[2]
      
      #goodfeats_allfields<-{}
      
      
      
      if(length(which(sel.diffdrthresh==TRUE))>1){
        
        goodfeats<-as.data.frame(goodfeats)
        mzvec<-goodfeats$mz
        timevec<-goodfeats$time
        
        if(length(mzvec)>4){
          max_per_row<-3
          
          
          par_rows<-ceiling(9/max_per_row)
          
        }else{
          max_per_row<-length(mzvec)
          par_rows<-1
        }
        
        
        goodfeats<-as.data.frame(goodfeats)
        
        cnamesd1<-colnames(goodfeats)
        time_ind<-which(cnamesd1=="time")
        
       # goodfeats_allfields<-as.data.frame(goodfeats)
        
        
        file_ind<-1
        
        
        mz_ind<-which(cnamesd1=="mz")
        
       
        goodfeats_temp<-cbind(goodfeats[,mz_ind],goodfeats[,time_ind],goodfeats[,-c(1:time_ind)])
       
        cnames_temp<-colnames(goodfeats_temp)
        cnames_temp[1]<-"mz"
        cnames_temp[2]<-"time"
        colnames(goodfeats_temp)<-cnames_temp
        
        
        
        
       
        #if(length(class_labels_levels)<10)
        if(analysismode=="classification" && nrow(goodfeats)>=1 && length(goodip)>=1)
        {
          
          if(is.na(rocclassifier)==FALSE){
          
          if(length(class_labels_levels)==2){
            
            #print("Generating ROC curve using top features on training set")
            
            
          # save(kfold,goodfeats_temp,classlabels,svm_kernel,pred.eval.method,match_class_dist,rocfeatlist,rocfeatincrement,file="rocdebug.Rda")
            
           # roc_res<-try(get_roc(dataA=goodfeats_temp,classlabels=classlabels,classifier=rocclassifier,kname="radial",
                               #  rocfeatlist=rocfeatlist,rocfeatincrement=rocfeatincrement,mainlabel="Training set ROC curve using top features"),silent=TRUE)
           if(output.device.type=="pdf"){
             roc_newdevice=FALSE
           }else{
             roc_newdevice=TRUE
           }
            roc_res<-try(get_roc(dataA=goodfeats_temp,classlabels=classlabels,classifier=rocclassifier,kname="radial",
                                 rocfeatlist=rocfeatlist,rocfeatincrement=rocfeatincrement,
                             mainlabel="Training set ROC curve using top features",newdevice=roc_newdevice),silent=TRUE)
            
           # print(roc_res)
            
          }
          
          
          subdata=t(goodfeats[,-c(1:time_ind)])
          
        # save(kfold,subdata,goodfeats,classlabels,svm_kernel,pred.eval.method,match_class_dist,file="svmdebug.Rda")
          
          svm_model<-try(svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
          
          #svm_model<-try(svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
          #svm_model<-try(svm(x=subdata,y=(classlabels),type="nu-classification",cross=kfold,kernel=svm_kernel),silent=TRUE)
          
          #svm_model<-try(svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
          
          classlabels<-as.data.frame(classlabels)
          
          if(is(svm_model,"try-error")){
            print("SVM could not be performed. Please try lowering the kfold or set kfold=total number of samples for Leave-one-out CV. Skipping to the next step.")
            print(svm_model)
            termA<-(-1)
            pred_acc<-termA
            permut_acc<-(-1)
          }else{
            
            pred_acc<-svm_model$avg_acc
            
            #print("Accuracy is:")
            #print(pred_acc)
            
            if(is.na(cv.perm.count)==FALSE){
            print("Calculating permuted CV accuracy")
            
            permut_acc<-{}
            #permut_acc<-lapply(1:100,function(j){
            numcores<-num_nodes #round(detectCores()*0.5)
            cl <- parallel::makeCluster(getOption("cl.cores", num_nodes))
            clusterEvalQ(cl,library(e1071))
            clusterEvalQ(cl,library(pROC))
            clusterEvalQ(cl,library(ROCR))
            clusterEvalQ(cl,library(CMA))
            clusterExport(cl,"svm_cv",envir = .GlobalEnv)
            permut_acc<-parLapply(cl,1:cv.perm.count,function(p1){
              
              rand_order<-sample(1:dim(classlabels)[1],size=dim(classlabels)[1])
              classlabels_permut<-classlabels[rand_order,]
              classlabels_permut<-as.data.frame(classlabels_permut)
              svm_permut_res<-try(svm_cv(v=kfold,x=subdata,y=classlabels_permut,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
              
              #svm_permut_res<-try(svm(x=subdata,y=(classlabels_permut),type="nu-classification",cross=kfold,kernel=svm_kernel),silent=TRUE)
              #svm_permut_res<-svm_cv(v=kfold,x=subdata,y=classlabels_permut,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist)
              
              
              if(is(svm_permut_res,"try-error")){
                
                cur_perm_acc<-NA
              }else{
                cur_perm_acc<-svm_permut_res$avg_acc #tot.accuracy #
              }
              return(cur_perm_acc)
            })
            
            stopCluster(cl)
            
            permut_acc<-unlist(permut_acc)
            permut_acc<-mean(permut_acc,na.rm=TRUE)
            permut_acc<-round(permut_acc,2)
            
            print("mean Permuted accuracy is:")
            print(permut_acc)
            }else{
              permut_acc<-(-1)
              
            }
            
          }
          
          
          }else{
            termA<-(-1)
            pred_acc<-termA
            permut_acc<-(-1)
            
          }
          
          termA<-100*pred_acc
          
          if(featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="limma2wayrepeat" | featselmethod=="lmreg" | featselmethod=="logitreg"
             | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="wilcox" | featselmethod=="ttest" |  featselmethod=="poissonreg" | featselmethod=="lmregrepeat")
          {
            if(fdrmethod=="none"){
              exp_fp<-(dim(data_m_fc)[1]*fdrthresh)+1
            }else{
              exp_fp<-(feat_sigfdrthresh[lf]*fdrthresh)+1
            }
          }
          
          
          
          termB<-(dim(parent_data_m)[1]*dim(parent_data_m)[1])/(dim(data_m_fc)[1]*dim(data_m_fc)[1]*100)
          
          
          res_score<-(100*(termA-permut_acc))-(feat_weight*termB*exp_fp)
          res_score<-round(res_score,2)
          
          
          
          if(lf==0)
          {
            best_logfc_ind<-lf
            
            best_feats<-goodip
            best_cv_res<-res_score
            best_acc<-pred_acc
            best_limma_res<-data_limma_fdrall_withfeats[goodip,] #[sel.diffdrthresh==TRUE,]
            
            
            
          }else{
            
            if(res_score>best_cv_res){
              
              best_logfc_ind<-lf
              
              best_feats<-goodip
              best_cv_res<-res_score
              best_acc<-pred_acc
              best_limma_res<-data_limma_fdrall_withfeats[goodip,] #[sel.diffdrthresh==TRUE,]
            }
            
          }
          
          pred_acc=round(pred_acc,2)
          res_score_vec[lf]<-res_score
          if(pred.eval.method=="CV"){
            feat_sigfdrthresh_cv[lf]<-pred_acc
            feat_sigfdrthresh_permut[lf]<-permut_acc
            acc_message=(paste(kfold,"-fold CV accuracy: ", pred_acc,sep=""))
            if(is.na(cv.perm.count)==FALSE){
            perm_acc_message=(paste("Permuted ",kfold,"-fold CV accuracy: ", permut_acc,sep=""))
            }
            
          }else{
            if(pred.eval.method=="AUC"){
              feat_sigfdrthresh_cv[lf]<-pred_acc
              feat_sigfdrthresh_permut[lf]<-permut_acc
              acc_message=(paste("ROC area under the curve (AUC) is : ", pred_acc,sep=""))
              if(is.na(cv.perm.count)==FALSE){
              perm_acc_message=(paste("Permuted ROC area under the curve (AUC) is : ", permut_acc,sep=""))
              }
            }else{
              if(pred.eval.method=="BER"){
                feat_sigfdrthresh_cv[lf]<-pred_acc
                feat_sigfdrthresh_permut[lf]<-permut_acc
                acc_message=(paste(kfold, "-fold CV balanced accuracy rate is: ", pred_acc,sep=""))
                if(is.na(cv.perm.count)==FALSE){
                perm_acc_message=(paste("Permuted balanced accuracy rate is : ", permut_acc,sep=""))
                }
              }
            }
          }
          
       #   print("########################################")
        #  cat("", sep="\n\n")
          #print(paste("Summary for method: ",featselmethod,sep=""))
          #print(paste("Relative standard deviation (RSD) threshold: ", log2.fold.change.thresh," %",sep=""))
          cat("Analysis summary:",sep="\n")
          if(is.na(factor1_msg)==FALSE){
            cat(factor1_msg,sep="\n")
          }
          if(is.na(factor2_msg)==FALSE){
            cat(factor2_msg,sep="\n")
          }
          cat(paste("Number of samples: ", dim(data_m_fc)[2],sep=""),sep="\n")
          cat(paste("Number of features in the original dataset: ", num_features_total,sep=""),sep="\n")
         # cat(rsd_filt_msg,sep="\n")
          cat(paste("Number of features left after preprocessing: ", dim(data_m_fc)[1],sep=""),sep="\n")
          cat(paste("Number of selected features: ", length(goodip),sep=""),sep="\n")
          if(is.na(rocclassifier)==FALSE){
            cat(acc_message,sep="\n")
              if(is.na(cv.perm.count)==FALSE){
               cat(perm_acc_message,sep="\n") 
              }
          }
         # cat("", sep="\n\n")
          
          #print("ROC done")
          best_subset<-{}
          best_acc<-0
          
          xvec<-{}
          yvec<-{}
          #for(i in 2:max_varsel)
      if(is.na(rocclassifier)==FALSE){ 
        
        
          if(nrow(goodfeats_temp)<length(rocfeatlist)){
            
            max_cv_varsel<-1:nrow(goodfeats_temp)
          }else{
            max_cv_varsel<-rocfeatlist #nrow(goodfeats_temp)
          }
          
          
          cv_yvec<-lapply(max_cv_varsel,function(i)
          {
            
            subdata<-t(goodfeats_temp[1:i,-c(1:2)])
            svm_model<-try(svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist),silent=TRUE)
            
            #svm_model<-svm_cv(v=kfold,x=subdata,y=classlabels,kname=svm_kernel,errortype=pred.eval.method,conflevel=95,match_class_dist=match_class_dist)
            
            
            if(is(svm_model,"try-error")){
              
              res1<-NA
              
            }else{
              
              
              
              res1<-svm_model$avg_acc
              
              
            }
            
            return(res1)
          })
          
          xvec<-max_cv_varsel
          
          yvec<-unlist(cv_yvec)
          
         
          
          
          if(pred.eval.method=="CV"){
            ylab_text=paste(pred.eval.method," accuracy (%)",sep="")
            
          }else{
            if(pred.eval.method=="BER"){
              ylab_text=paste("Balanced accuracy"," (%)",sep="")
            }else{
              
              ylab_text=paste("AUC"," (%)",sep="")
            }
          }
          
          
          if(length(yvec)>0){
            
            
            if(output.device.type!="pdf"){
              
              temp_filename_1<-"Figures/kfoldCV_forward_selection.png"
              
              png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
            }else{
             # temp_filename_1<-"Figures/kfoldCV_forward_selection.pdf"
              
              #pdf(temp_filename_1)
              
            }
            
            
            
            try(plot(x=xvec,y=yvec,main="k-fold CV classification accuracy based on forward selection of top features",xlab="Feature index",ylab=ylab_text,type="b",col="#0072B2",cex.main=0.7),silent=TRUE)
            
            
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
            }else{
             # try(dev.off(),silent=TRUE)
              
            }
            
            cv_mat<-cbind(xvec,yvec)
            colnames(cv_mat)<-c("Feature Index",ylab_text)
            
            write.table(cv_mat,file="Tables/kfold_cv_mat.txt",sep="\t")
          }
        }
          
          if(pairedanalysis==TRUE)
          {
            
            if(featselmethod=="pls" | featselmethod=="spls"){
              classlabels_sub<-classlabels_sub[,-c(1)]
              classlabels_temp<-cbind(classlabels_sub)
            }else{
              classlabels_sub<-classlabels_sub[,-c(1)]
              classlabels_temp<-cbind(classlabels_sub)
              
            }
            
          }else{
            classlabels_temp<-cbind(classlabels_sub,classlabels)
          }
          
          
          num_sig_feats<-nrow(goodfeats)
          
          if(num_sig_feats<3){
            
            pca.stage2.eval=FALSE
            
          }
          
          if(pca.stage2.eval==TRUE)
          {
            
            
            pca_comp<-min(10,dim(X)[2])
            
            #dev.off()
            
            # print("plotting")
            #pdf("sig_features_evaluation.pdf", height=2000,width=2000)
            library(pcaMethods)
            
            p1<-pcaMethods::pca(X,method="rnipals",center=TRUE,scale="uv",cv="q2",nPcs=pca_comp)
            
            if(output.device.type!="pdf"){
              
              temp_filename_1<-"Figures/PCAdiagnostics_selectedfeats.png"
              
              png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
            }
            
            
            
            p2<-plot(p1,col=c("darkgrey","grey"),main="PCA diagnostics after variable selection")
            
            print(p2)
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
            }
            #dev.off()
            
          }
          
          classlabels_orig<-classlabels_orig_parent
          
          
          if(pairedanalysis==TRUE){
            
            classlabels_orig<-classlabels_orig[,-c(2)]
            
            
          }else{
            
            if(featselmethod=="lmreg" || featselmethod=="logitreg" || featselmethod=="poissonreg"){
              classlabels_orig<-classlabels_orig[,c(1:2)]
              classlabels_orig<-as.data.frame(classlabels_orig)
            }
          }
          
          
          
          classlabels_orig_wgcna<-classlabels_orig
          
          
          goodfeats_temp<-cbind(goodfeats[,mz_ind],goodfeats[,time_ind],goodfeats[,-c(1:time_ind)])
          cnames_temp<-colnames(goodfeats_temp)
          cnames_temp<-c("mz","time",cnames_temp[-c(1:2)])
          colnames(goodfeats_temp)<-cnames_temp
          
          goodfeats_temp_with_names<-merge(names_with_mz_time,goodfeats_temp,by=c("mz","time"))
          
          
          goodfeats_temp_with_names<-goodfeats_temp_with_names[match(paste(goodfeats_temp$mz,"_",goodfeats_temp$time,sep=""),paste(goodfeats_temp_with_names$mz,"_",goodfeats_temp_with_names$time,sep="")),]
          
            
        save(goodfeats,goodfeats_temp,names_with_mz_time,goodfeats_temp_with_names,file="goodfeats_pca.Rda")
          
          rownames(goodfeats_temp)<-goodfeats_temp_with_names$Name
          
          
          if(num_sig_feats>=3 & pca.stage2.eval==TRUE){
            if(output.device.type!="pdf"){
              
              temp_filename_1<-"Figures/PCAplots_selectedfeats.pdf"
              
              #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              #pdf(temp_filename_1)
              pdf(temp_filename_1,width=plots.width,height=plots.height)
            }
            
            plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
            
            
            text(5, 8, "PCA using selected features after feature selection")
            text(5, 7, "The figures include: ")
            text(5, 6, "a. pairwise PC score plots ")
            text(5, 5, "b. scores for individual samples on each PC")
            text(5, 4, "c. Lineplots using PC scores for data with repeated measurements")
            
            
            par(mfrow=c(1,1),family="sans",cex=cex.plots)
            
            
            
            get_pcascoredistplots(X=goodfeats_temp,Y=classlabels_orig_pca,
                                  feature_table_file=NA,parentoutput_dir=getwd(),class_labels_file=NA,
                                  sample.col.opt=sample.col.opt,plots.width=2000,plots.height=2000,plots.res=300, alphacol=0.3,col_vec=col_vec,pairedanalysis=pairedanalysis,pca.cex.val=pca.cex.val,legendlocation=legendlocation,pca.ellipse=pca.ellipse,ellipse.conf.level=ellipse.conf.level,filename="selected",paireddesign=paireddesign,
                                  lineplot.col.opt=lineplot.col.opt,lineplot.lty.option=lineplot.lty.option,timeseries.lineplots=timeseries.lineplots,pcacenter=pcacenter,pcascale=pcascale,alphabetical.order=alphabetical.order,study.design=analysistype,lme.modeltype=modeltype) #,silent=TRUE)
            
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
            }
          }
          
          
          ####savelist=ls(),file="timeseries.Rda")
          
          #if(FALSE)
          {
            #if(FALSE)
            {
              if(log2transform==TRUE || input.intensity.scale=="log2"){
                
                if(znormtransform==TRUE){
                  ylab_text_2="scale normalized"
                }else{
                  if(quantile_norm==TRUE){
                    
                    ylab_text_2="quantile normalized"
                  }else{
                    if(eigenms_norm==TRUE){
                      
                      ylab_text_2="EigenMS normalized"
                    }else{
                      
                      if(sva_norm==TRUE){
                        
                        ylab_text_2="SVA normalized"
                      }else{
                        ylab_text_2=""
                      }
                    }
                  }
                }
                ylab_text=paste("log2 intensity ",ylab_text_2,sep="")
              }else{
                if(znormtransform==TRUE){
                  ylab_text_2="scale normalized"
                }else{
                  if(quantile_norm==TRUE){
                    
                    ylab_text_2="quantile normalized"
                  }else{
                    #ylab_text_2=""
                    if(medcenter==TRUE){
                      
                      ylab_text_2="median centered"
                    }else{
                      
                      if(lowess_norm==TRUE){
                        ylab_text_2="LOWESS normalized"
                        
                      }else{
                        if(rangescaling==TRUE){
                          ylab_text_2="range scaling normalized"
                          
                        }else{
                          
                          if(paretoscaling==TRUE){
                            ylab_text_2="pareto scaling normalized"
                            
                          }else{
                            
                            if(mstus==TRUE){
                              ylab_text_2="MSTUS normalized"
                              
                            }else{
                              
                              if(vsn_norm==TRUE){
                                ylab_text_2="VSN normalized"
                                
                              }else{
                                ylab_text_2=""
                                
                              }
                              
                            }
                          }
                          
                        }
                        
                      }
                      
                    }
                    
                  }
                }
                ylab_text=paste("Intensity ",ylab_text_2,sep="")
              }
              
            }
            
            #ylab_text_2=""
            #ylab_text=paste("Abundance",ylab_text_2,sep="")
            
            par(mfrow=c(1,1),family="sans",cex=cex.plots)
            
            
            
            if(pairedanalysis==TRUE || timeseries.lineplots==TRUE)
            {
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/Lineplots_selectedfeats.pdf"
                
                #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                #pdf(temp_filename_1)
                pdf(temp_filename_1,width=plots.width,height=plots.height)
               # par(mfrow=c(1,1))
                
                par(mfrow=c(1,1),family="sans",cex=cex.plots)
              }
              
              
              #plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
              
              
              #text(5, 8, "Lineplots using selected features")
            #  text(5, 7, "The error bars represent the 95% \nconfidence interval in each group (or timepoint)")
              
              
           #  save(goodfeats_temp,classlabels_orig,lineplot.col.opt,col_vec,pairedanalysis,
             #      pca.cex.val,pca.ellipse,ellipse.conf.level,legendlocation,ylab_text,error.bar,
             #     cex.plots,lineplot.lty.option,timeseries.lineplots,analysistype,goodfeats_name,alphabetical.order,
             #     multiple.figures.perpanel,plot.ylab_text,plots.height,plots.width,file="debuga_lineplots.Rda")
              
              
              #try(
                var_sum_list<-get_lineplots(X=goodfeats_temp,Y=classlabels_orig,feature_table_file=NA,
                                parentoutput_dir=getwd(),class_labels_file=NA,
                                lineplot.col.opt=lineplot.col.opt,alphacol=alphacol,col_vec=col_vec,
                                pairedanalysis=pairedanalysis,point.cex.val=pca.cex.val,
                                legendlocation=legendlocation,pca.ellipse=pca.ellipse,
                                ellipse.conf.level=ellipse.conf.level,filename="selected",
                                ylabel=plot.ylab_text,error.bar=error.bar,cex.plots=cex.plots,
                                lineplot.lty.option=lineplot.lty.option,timeseries.lineplots=timeseries.lineplots,
                                name=goodfeats_name,study.design=analysistype,
                              alphabetical.order=alphabetical.order,multiple.figures.perpanel=multiple.figures.perpanel,
                              plot.height = plots.height,plot.width=plots.width)
                #,silent=TRUE)  #,silent=TRUE)
              #save(var_sum_list,file="var_sum_list.Rda")
              var_sum_mat<-{}
             # for(i in 1:length(var_sum_list))
              #{
               #   var_sum_mat<-rbind(var_sum_mat,var_sum_list[[i]]$df_write_temp)
                
              #}
               # var_sum_mat<-ldply(var_sum_list,rbind)
                                   
               # write.table(var_sum_mat,file="Tables/data_summary.txt",sep="\t",row.names=FALSE)
                
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
            }
            
            
            
            
          }
          
          
     #     save(goodfeats_temp,classlabels_orig,lineplot.col.opt,alphacol,col_vec,pairedanalysis,pca.cex.val,legendlocation,pca.ellipse,ellipse.conf.level,plot.ylab_text,error.bar,cex.plots,
     #          lineplot.lty.option,timeseries.lineplots,goodfeats_name,analysistype,alphabetical.order,multiple.figures.perpanel,plots.height,plots.width,file="var_sum.Rda")
        
            var_sum_list<-get_data_summary(X=goodfeats_temp,Y=classlabels_orig,feature_table_file=NA,
                                        parentoutput_dir=getwd(),class_labels_file=NA,
                                        lineplot.col.opt=lineplot.col.opt,alphacol=alphacol,col_vec=col_vec,
                                        pairedanalysis=pairedanalysis,point.cex.val=pca.cex.val,
                                        legendlocation=legendlocation,pca.ellipse=pca.ellipse,
                                        ellipse.conf.level=ellipse.conf.level,filename="selected",
                                        ylabel=plot.ylab_text,error.bar=error.bar,cex.plots=cex.plots,
                                        lineplot.lty.option=lineplot.lty.option,timeseries.lineplots=timeseries.lineplots,
                                        name=goodfeats_name,study.design=analysistype,
                                        alphabetical.order=alphabetical.order,multiple.figures.perpanel=multiple.figures.perpanel,plot.height = plots.height,plot.width=plots.width)
          
          
        
          if(nrow(goodfeats)<1){
            
            print(paste("No features selected for ",featselmethod,sep=""))
          }
          #else
          {
            
            
            #write.table(goodfeats_temp,file="Tables/boxplots_file.normalized.txt",sep="\t",row.names=FALSE)
            
            goodfeats<-goodfeats[,-c(1:time_ind)]
            
            
            goodfeats_raw<-data_matrix_beforescaling_rsd[goodip,]
            #write.table(goodfeats_raw,file="Tables/boxplots_file.raw.txt",sep="\t",row.names=FALSE)
            
            goodfeats_raw<-goodfeats_raw[match(paste(goodfeats_temp$mz,"_",goodfeats_temp$time,sep=""),paste(goodfeats_raw$mz,"_",goodfeats_raw$time,sep="")),] 
            
            goodfeats_name<-as.character(goodfeats_name)
       #    save(goodfeats_name,goodfeats_temp,classlabels_orig,output_dir,boxplot.col.opt,cex.plots,ylab_text,file="boxplotdebug.Rda")
            
         if(pairwise.correlation.analysis==TRUE)
            {
           
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
                
                temp_filename_1<-"Figures/Pairwise.correlation.plots.pdf"
                
               # pdf(temp_filename_1)
                pdf(temp_filename_1,width=plots.width,height=plots.height)
              }
              
              par(mfrow=c(1,1),family="sans",cex=cex.plots,cex.main=0.7)
              
             # cor1<-WGCNA::cor(t(goodfeats_temp[,-c(1:2)]))
              rownames(goodfeats_temp)<-goodfeats_name
              
              #Pairwise correlations between selected features
              cor1<-WGCNA::cor(t(goodfeats_temp[,-c(1:2)]),nThreads=num_nodes,method=cor.method,use = 'p')
              
              corpval1=apply(cor1,2,function(x){corPvalueStudent(x,n=ncol(goodfeats_temp[,-c(1:2)]))})
             
              fdr_adjust_pvalue<-try(suppressWarnings(fdrtool(as.vector(cor1[upper.tri(cor1)]),statistic="correlation",verbose=FALSE,plot=FALSE)),silent=TRUE)
              
              if(is(fdr_adjust_pvalue,"try-error")){
                
                print(fdr_adjust_pvalue)
              }
              cor1[(abs(cor1)<abs.cor.thresh)]<-0
              newnet <- cor1
              newnet[upper.tri(newnet)][fdr_adjust_pvalue$qval > cor.fdrthresh] <- 0
              
              newnet[lower.tri(newnet)] <- t(newnet)[lower.tri(newnet)]
              newnet <- as.matrix(newnet)
              
              corqval1=newnet
              diag(corqval1)<-0
              upperTriangle<-upper.tri(cor1, diag=F)
              lowerTriangle<-lower.tri(cor1, diag=F)
              corqval1[upperTriangle]<-fdr_adjust_pvalue$qval
              corqval1[lowerTriangle]<-corqval1[upperTriangle]
              
              cor1=newnet
              rm(newnet)
              
           #   rownames(cor1)<-paste(goodfeats_temp[,c(1)],goodfeats_temp[,c(2)],sep="_")
            #  colnames(cor1)<-rownames(cor1)
              
              #dendrogram="none",
              h1<-heatmap.2(cor1,col=rev(brewer.pal(11,"RdBu")),Rowv=TRUE,Colv=TRUE,scale="none",key=TRUE, symkey=FALSE, density.info="none", trace="none",main="Pairwise correlations between selected features",cexRow = 0.5,cexCol = 0.5,cex.main=0.7)
              
              upperTriangle<-upper.tri(cor1, diag=F) #turn into a upper triangle
              cor1.upperTriangle<-cor1 #take a copy of the original cor-mat
              cor1.upperTriangle[!upperTriangle]<-NA#set everything not in upper triangle o NA
              correlations_melted<-na.omit(melt(cor1.upperTriangle, value.name ="correlationCoef")) #use melt to reshape the matrix into triplets, na.omit to get rid of the NA rows
              colnames(correlations_melted)<-c("from", "to", "weight")
              
             # save(correlations_melted,cor1,file="correlations_melted.Rda")
              correlations_melted<-as.data.frame(correlations_melted)
              
              correlations_melted$from<-paste("X",correlations_melted$from,sep="")
              correlations_melted$to<-paste("Y",correlations_melted$to,sep="")
              
              write.table(correlations_melted,file="Tables/pairwise.correlations.selectedfeatures.linkmatrix.txt",sep="\t",row.names=FALSE)
              
              
              
              if(ncol(cor1)>1000){
              netres<-plot_graph(correlations_melted,filename="sigfeats_top1000pairwisecor",interactive=FALSE,maxnodesperclass=1000,label.cex=network.label.cex,mtext.val="Top 1000 pairwise correlations between selected features")
              }
              netres<-try(plot_graph(correlations_melted,filename="sigfeats_pairwisecorrelations",interactive=FALSE,maxnodesperclass=NA,label.cex=network.label.cex,mtext.val="Pairwise correlations between selected features"),silent=TRUE)
              
             
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
            }
            
            
      
            if(output.device.type!="pdf"){
              
              try(dev.off(),silent=TRUE)
              
              temp_filename_1<-"Figures/Boxplots.selectedfeats.normalized.pdf"
              
              if(boxplot.type=="simple"){
                pdf(temp_filename_1,height=plots.height,width=plots.width)
              }
            }
            
            goodfeats_name<-as.character(goodfeats_name)
        #   save(goodfeats_name,goodfeats_temp,classlabels_orig,output_dir,boxplot.col.opt,cex.plots,ylab_text,plot.ylab_text,
         #        analysistype,boxplot.type,alphabetical.order,goodfeats_name,add.pvalues,add.jitter,file="boxplotdebug.Rda")
            
            par(mfrow=c(1,1),family="sans",cex=cex.plots)
            
           
           # plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
            
            
          #  text(5, 8, "Boxplots of selected features using the\n normalized intensities/abundance levels",cex=1.5,font=2)
            
            #plot.ylab_text1=paste("(Normalized) ",ylab_text,sep="")
            
            #classlabels_paired<-cbind(as.character(classlabels[,1]),as.character(subject_inf),as.character(classlabels[,2]))
           
            #classlabels_paired<-as.data.frame(classlabels_paired)
            
        if(generate.boxplots==TRUE){    
          
        #  print("Generating boxplots")
                      if(normalization.method!="none"){
                        plot.ylab_text1=paste("(Normalized) ",ylab_text,sep="")
                                  if(pairedanalysis==TRUE){
                                    
                                   #classlabels_paired<-cbind(classlabels[,1],subject_inf,classlabels[,2])
                                    
                                    res<-get_boxplots(X=goodfeats_temp,Y=classlabels_orig,parentoutput_dir=output_dir,boxplot.col.opt=boxplot.col.opt,
                                                      newdevice=FALSE,cex.plots=cex.plots*3,ylabel=plot.ylab_text1,name=goodfeats_name,add.pvalues=add.pvalues,add.jitter=add.jitter,
                                                      alphabetical.order=alphabetical.order,boxplot.type=boxplot.type,study.design=gsub(analysistype,pattern="repeat",replacement=""),
                                                      multiple.figures.perpanel=multiple.figures.perpanel,numnodes=num_nodes,
                                                      plot.height = plots.height,plot.width=plots.width,
                                                      filename="Figures/Boxplots.selectedfeats.normalized",alphacol = alpha.col,ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                                                      boxplot.strip.position ="bottom",
                                                      remove.xaxis.labels=TRUE,
                                                      replace.outliers =FALSE)
                                    
                                  }else{
                                  
                                  res<-get_boxplots(X=goodfeats_temp,Y=classlabels_orig,parentoutput_dir=output_dir,boxplot.col.opt=boxplot.col.opt,
                                              newdevice=FALSE,cex.plots=cex.plots*3,ylabel=plot.ylab_text1,name=goodfeats_name,add.pvalues=add.pvalues,add.jitter=add.jitter,
                                               alphabetical.order=alphabetical.order,boxplot.type=boxplot.type,study.design=analysistype,
                                               multiple.figures.perpanel=multiple.figures.perpanel,numnodes=num_nodes,
                                              plot.height = plots.height,plot.width=plots.width,
                                               filename="Figures/Boxplots.selectedfeats.normalized",
                                              alphacol = alpha.col,ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                                              boxplot.strip.position ="bottom",
                                              remove.xaxis.labels=TRUE,replace.outliers =FALSE)
                                  }
                        
                      }else{
                        
                        plot.boxplots.raw=TRUE
                        goodfeats_raw=goodfeats_temp
                      }
                        
                        if(output.device.type!="pdf"){
                          
                          try(dev.off(),silent=TRUE)
                        }
                        
                        
                                
                            if(plot.boxplots.raw==TRUE){
                              if(output.device.type!="pdf"){
                                
                                temp_filename_1<-"Figures/Boxplots.selectedfeats.raw.pdf"
                                if(boxplot.type=="simple"){
                                  pdf(temp_filename_1,height=plots.height,width=plots.width)
                                }
                              }
                          #    save(goodfeats_raw,goodfeats_temp,classlabels_raw_boxplots,classlabels_orig,
                           #          output_dir,boxplot.col.opt,cex.plots,ylab_text,boxplot.type,ylab_text_raw,
                            #        analysistype,multiple.figures.perpanel,alphabetical.order,goodfeats_name,plots.height,plots.width,file="boxplotrawdebug.Rda")
                                
                                par(mfrow=c(1,1),family="sans",cex=cex.plots)
                                            par(mfrow=c(1,1),family="sans",cex=cex.plots)
                                
                                #get_boxplots(X=goodfeats_raw,Y=classlabels_raw_boxplots,parentoutput_dir=output_dir,boxplot.col.opt=boxplot.col.opt,alphacol=0.3,newdevice=FALSE,cex.plots=cex.plots,ylabel=" Intensity",name=goodfeats_name,add.pvalues=add.pvalues,
                                         #    add.jitter=add.jitter,alphabetical.order=alphabetical.order,boxplot.type=boxplot.type,study.design=analysistype)
                                plot.ylab_text1=paste("",ylab_text,sep="")
                                
                                if(pairedanalysis==TRUE){
                                  
                                  #classlabels_paired<-cbind(classlabels[,1],subject_inf,classlabels[,2])
                                  
                                  get_boxplots(X=goodfeats_raw,Y=classlabels_orig,parentoutput_dir=output_dir,boxplot.col.opt=boxplot.col.opt,
                                               newdevice=FALSE,cex.plots=cex.plots*3,ylabel=ylab_text_raw,name=goodfeats_name,add.pvalues=add.pvalues,add.jitter=add.jitter,
                                               alphabetical.order=alphabetical.order,boxplot.type=boxplot.type,
                                               study.design=gsub(analysistype,pattern="repeat",replacement=""),multiple.figures.perpanel=multiple.figures.perpanel,numnodes=num_nodes,
                                               plot.height = plots.height,plot.width=plots.width,
                                               filename="Figures/Boxplots.selectedfeats.raw",alphacol = alpha.col,ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                                               boxplot.strip.position ="bottom",remove.xaxis.labels=TRUE,replace.outliers =FALSE)
                                  
                                
                                }else{
                                get_boxplots(X=goodfeats_raw,Y=classlabels_orig,parentoutput_dir=output_dir,boxplot.col.opt=boxplot.col.opt,
                                             newdevice=FALSE,cex.plots=cex.plots*3,ylabel=ylab_text_raw,name=goodfeats_name,add.pvalues=add.pvalues,add.jitter=add.jitter,
                                             alphabetical.order=alphabetical.order,boxplot.type=boxplot.type,
                                             study.design=analysistype,multiple.figures.perpanel=multiple.figures.perpanel,numnodes=num_nodes,plot.height = plots.height,plot.width=plots.width,
                                             filename="Figures/Boxplots.selectedfeats.raw",alphacol = alpha.col,ggplot.type1=ggplot.type1,facet.nrow=facet.nrow,
                                             boxplot.strip.position ="bottom",remove.xaxis.labels=TRUE,replace.outliers =FALSE)
                                
                                }
                                
                                #try(dev.off(),silent=TRUE)
                                
                                if(output.device.type!="pdf"){
                                  
                                  try(dev.off(),silent=TRUE)
                                }
                                
                            }
          
        }
            
            if(FALSE)
              {
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/Barplots_selectedfeats.pdf"
                
                #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                #pdf(temp_filename_1,bg="transparent") #, height = 5.5, width = 3)
                pdf(temp_filename_1,width=plots.width,height=plots.height)
              }
              
              
              
              plot(0:10, type = "n", xaxt="n", yaxt="n", bty="n", xlab = "", ylab = "")
              
              
              text(5, 8, "Barplots of selected features using the\n normalized intensities/adundance levels")
              
              par(mfrow=c(1,1),family="sans",cex=cex.plots,pty="s")
              try(get_barplots(feature_table_file,class_labels_file,X=goodfeats_temp,Y=classlabels_orig,parentoutput_dir=output_dir
                               ,newdevice=FALSE,ylabel=ylab_text,cex.val=cex.plots,barplot.col.opt=barplot.col.opt,error.bar=error.bar),silent=TRUE)
              
              ###savelist=ls(),file="getbarplots.Rda")
              if(featselmethod=="limma2way" | featselmethod=="limma2wayrepeat" | featselmethod=="pls2wayrepeat" | featselmethod=="spls2wayrepeat" | featselmethod=="pls2way" | featselmethod=="spls2way" | featselmethod=="lm2wayanova" | featselmethod=="lm2wayanovarepeat")
              {
                #if(ggplot.type1==TRUE){
                  barplot.xaxis="Factor2"
               # }else{
                  
                  
               # }
                
              }
              
              get_barplots(feature_table_file,class_labels_file,X=goodfeats_temp,Y=classlabels_orig,parentoutput_dir=output_dir,
                           newdevice=FALSE,ylabel=plot.ylab_text,cex.plots=cex.plots,barplot.col.opt=barplot.col.opt,error.bar=error.bar,
                           barplot.xaxis=barplot.xaxis,alphabetical.order=alphabetical.order,name=goodfeats_name,study.design=analysistype)
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
                      if(FALSE){    
                          if(output.device.type!="pdf"){
                            
                            temp_filename_1<-"Figures/Individual_sample_plots_selectedfeats.pdf"
                            
                            #png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
                            #pdf(temp_filename_1)
                            
                            pdf(temp_filename_1,width=plots.width,height=plots.height)
                          }
                          
                          #  par(mfrow=c(2,2))
                          par(mfrow=c(1,1),family="sans",cex=cex.plots)
                          #try(get_individualsampleplots(feature_table_file,class_labels_file,X=goodfeats_temp,Y=classlabels_orig,parentoutput_dir=output_dir,newdevice=FALSE,ylabel=ylab_text,cex.val=cex.plots,sample.col.opt=sample.col.opt),silent=TRUE)
                          get_individualsampleplots(feature_table_file,class_labels_file,X=goodfeats_temp,Y=classlabels_orig,parentoutput_dir=output_dir,newdevice=FALSE,ylabel=ylab_text,cex.plots=cex.plots,sample.col.opt=individualsampleplot.col.opt,alphabetical.order=alphabetical.order,name=goodfeats_name)
                          
                          
                          
                          if(output.device.type!="pdf"){
                            
                            try(dev.off(),silent=TRUE)
                          }
                      }
              
            }
            if(globalclustering==TRUE){
              
              print("Performing global clustering using EM")
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/GlobalclusteringEM.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              m1<-Mclust(t(data_m_fc_withfeats[,-c(1:2)]))
              s1<-m1$classification #summary(m1)
              
              EMcluster<-m1$classification
              
              col_vec <- colorRampPalette(brewer.pal(10, "RdBu"))(length(levels(as.factor(classlabels_orig[,2]))))
              #col_vec<-topo.colors(length(levels(as.factor(classlabels_orig[,2])))) #patientcolors #heatmap_cols[1:length(levels(classlabels_orig[,2]))]
              t1<-table(EMcluster,classlabels_orig[,2])
              
              par(mfrow=c(1,1))
              plot(t1,col=col_vec,main="EM cluster labels\n using all features",cex.axis=1,ylab="Class",xlab="Cluster number")
              
              par(xpd=TRUE)
              try(legend("bottomright",legend=levels(classlabels_orig[,2]),text.col=col_vec,pch=13,cex=0.4),silent=TRUE)
              
              par(xpd=FALSE)
              
            #  save(m1,EMcluster,classlabels_orig,file="EMres.Rda")
              
              t1<-cbind(EMcluster,classlabels_orig[,2])
              
              write.table(t1,file="Tables/EM_clustering_labels_using_allfeatures.txt",sep="\t")
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
              
              print("Performing global clustering using HCA")
              
              if(output.device.type!="pdf"){
                
                temp_filename_1<-"Figures/GlobalclusteringHCA.png"
                
                png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
              }
              
              #if(FALSE)
              {
                
                #p1<-heatmap.2(as.matrix(data_m_fc_withfeats[,-c(1:2)]),scale="row",symkey=FALSE,col=topo.colors(n=256))
                
                if(heatmap.col.opt=="RdBu"){
                  
                  heatmap.col.opt="redblue"
                }
                
                heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
                heatmap_cols<-rev(heatmap_cols)
                
                if(heatmap.col.opt=="topo"){
                  heatmap_cols<-topo.colors(256)
                  heatmap_cols<-rev(heatmap_cols)
                }else
                {
                  if(heatmap.col.opt=="heat"){
                    heatmap_cols<-heat.colors(256)
                    heatmap_cols<-rev(heatmap_cols)
                  }else{
                    
                    if(heatmap.col.opt=="yellowblue"){
                      
                      heatmap_cols<-colorRampPalette(c("yellow","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
                      #heatmap_cols<-blue2yellow(256) #colorRampPalette(c("yellow","blue"))(256)
                      heatmap_cols<-rev(heatmap_cols)
                    }else{
                      
                      if(heatmap.col.opt=="redblue"){
                        
                        heatmap_cols <- colorRampPalette(brewer.pal(10, "RdBu"))(256)
                        heatmap_cols<-rev(heatmap_cols)
                      }else{
                        
                        #my_palette <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
                        if(heatmap.col.opt=="redyellowgreen"){
                          
                          heatmap_cols <- colorRampPalette(c("red", "yellow", "green"))(n = 299)
                          heatmap_cols<-rev(heatmap_cols)
                        }else{
                          if(heatmap.col.opt=="yellowwhiteblue"){
                            
                            heatmap_cols<-colorRampPalette(c("yellow2","white","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
                            heatmap_cols<-rev(heatmap_cols)
                          }else{
                            
                            if(heatmap.col.opt=="redwhiteblue"){
                              
                              heatmap_cols<-colorRampPalette(c("red","white","blue"))(256) #colorRampPalette(c("yellow","white","blue"))(256)
                              heatmap_cols<-rev(heatmap_cols)
                            }else{
                              
                              
                              
                              heatmap_cols <- colorRampPalette(brewer.pal(10, heatmap.col.opt))(256)
                              heatmap_cols<-rev(heatmap_cols)
                              
                            }
                            
                          }
                          
                        }
                        
                      }
                      
                    }
                  }
                  
                  
                }
                
                
                
                #col_vec<-heatmap_cols[1:length(levels(classlabels_orig[,2]))]
                c1<-WGCNA::cor(as.matrix(data_m_fc_withfeats[,-c(1:2)]),method=cor.method,use="pairwise.complete.obs") #cor(d1[,-c(1:2)])
                d2<-as.dist(1-c1)
                clust1<-hclust(d2)
                
                hr <- try(hclust(as.dist(1-WGCNA::cor(t(data_m_fc_withfeats),method=cor.method,use="pairwise.complete.obs"))),silent=TRUE) #metabolites
                #hc <- try(hclust(as.dist(1-WGCNA::cor(data_m,method=cor.method,use="pairwise.complete.obs"))),silent=TRUE) #samples
                
                
                h73<-heatmap.2(as.matrix(data_m_fc_withfeats[,-c(1:2)]), Rowv=as.dendrogram(hr), Colv=as.dendrogram(clust1),  
                               col=heatmap_cols, scale="row",key=TRUE, symkey=FALSE, density.info="none", trace="none",
                               cexRow=1, cexCol=1,xlab="",ylab="", main="Global clustering\n using all features",
                               ColSideColors=patientcolors,labRow = FALSE, labCol = FALSE)
                
                # par(xpd=TRUE)
                #legend("bottomleft",legend=levels(classlabels_orig[,2]),text.col=unique(patientcolors),pch=13,cex=0.4)
                #par(xpd=FALSE)
                
                clust_res<-cutreeDynamic(distM=as.matrix(d2),dendro=clust1,cutHeight = 0.95,minClusterSize = 2,deepSplit = 4,verbose = FALSE)
                
                #mycl_samples <- cutree(clust1, h=max(clust1$height)/2)
                
                HCAcluster<-clust_res
                
                c2<-cbind(clust1$labels,HCAcluster)
                
                rownames(c2)<-c2[,1]
                
                c2<-as.data.frame(c2)
                
                t1<-table(HCAcluster,classlabels_orig[,2])
                
                plot(t1,col=col_vec,main="HCA (Cutree Dynamic) cluster labels\n using all features",cex.axis=1,ylab="Class",xlab="Cluster number")
                
                par(xpd=TRUE)
                try(legend("bottomright",legend=levels(classlabels_orig[,2]),text.col=col_vec,pch=13,cex=0.4),silent=TRUE)
                par(xpd=FALSE)
                
                t1<-cbind(HCAcluster,classlabels_orig[,2])
                write.table(t1,file="Tables/HCA_clustering_labels_using_allfeatures.txt",sep="\t")
                
          
              }
              
              
              
              if(output.device.type!="pdf"){
                
                try(dev.off(),silent=TRUE)
              }
            }
            
          }
          #dev.off()
        }
        else
        {
          #goodfeats_allfields<-as.data.frame(goodfeats)
          
          goodfeats<-goodfeats[,-c(1:time_ind)]
          
          
        }
        
      }
      
      if(length(goodip)>0){
        
        try(dev.off(),silent=TRUE)
      }
    }
    else{
      try(dev.off(),silent=TRUE)
      break;
    }
    
    
    if(analysismode=="classification" & WGCNAmodules==TRUE){
      classlabels_temp<-classlabels_orig_wgcna #cbind(classlabels_sub[,1],classlabels)
      #print(classlabels_temp)
      data_temp<-data_matrix_beforescaling[,-c(1:2)]
      
      
      cl<-makeCluster(num_nodes)
      
      #clusterExport(cl,"do_rsd")
      #feat_rsds<-parApply(cl,data_temp,1,do_rsd)
      #rm(data_temp)
      #feat_rsds<-abs(feat_rsds) #round(max_rsd,2)
      #print(summary(feat_rsds))
      #if(length(which(feat_rsds>0))>0)
      {
        X<-data_m_fc_withfeats #data_matrix[which(feat_rsds>=wgcnarsdthresh),]
        
        #	print(head(X))
        #		print(dim(X))
        
        
        if(output.device.type!="pdf"){
          
          temp_filename_1<-"Figures/WGCNA_preservation_plot.png"
          
          png(temp_filename_1,width=plots.width,height=plots.height,res=plots.res,type=plots.type,units="in")
        }
        
        #  #save(X,classlabels_temp,data_m_fc_withfeats,goodip,file="wgcna.Rda")
        
        print("Performing WGCNA: generating preservation plot")
        #preservationres<-try(do_wgcna(X=X,Y=classlabels_temp,sigfeats=data_m_fc_withfeats[goodip,c(1:2)]),silent=TRUE)
        #pres<-try(do_wgcna(X=X,Y=classlabels_temp,sigfeats=data_m_fc_withfeats[goodip,c(1:2)]),silent=TRUE)
        pres<-try(do_wgcna(X=X,Y=classlabels_temp,sigfeats=data_m_fc_withfeats[goodip,c(1:2)]),silent=TRUE)
        
        #pres<-do_wgcna(X=X,Y=classlabels_temp,sigfeats=data_m_fc_withfeats[goodip,c(1:2)]) #,silent=TRUE)
        
        if(is(pres,"try-error")){
          
          print("WGCNA could not be performed. Error: ")
          print(pres)
        }
        
        if(output.device.type!="pdf"){
          
          try(dev.off(),silent=TRUE)
        }
      }
    }	
    #print(lf)
    
    #print("next iteration")
    #dev.off()
  }
  
  setwd(parentoutput_dir)
  summary_res<-cbind(log2.fold.change.thresh_list,feat_eval,feat_sigfdrthresh,feat_sigfdrthresh_cv,feat_sigfdrthresh_permut,res_score_vec)
  
  if(fdrmethod=="none"){
    exp_fp<-round(fdrthresh*feat_eval)
  }else{
    exp_fp<-round(fdrthresh*feat_sigfdrthresh)
  }
  rank_num<-order(summary_res[,5],decreasing=TRUE)
  
  ##save(allmetabs_res,file="allmetabs_res.Rda")
  
  
  if(featselmethod=="limma" | featselmethod=="limma2way" | featselmethod=="limma2wayrepeat" | featselmethod=="lmreg" | featselmethod=="logitreg" 
     | featselmethod=="lm2wayanova" | featselmethod=="lm1wayanova" | featselmethod=="lm1wayanovarepeat" | featselmethod=="lm2wayanovarepeat" | featselmethod=="wilcox" | featselmethod=="ttest" | featselmethod=="poissonreg" | featselmethod=="limma1wayrepeat" | featselmethod=="lmregrepeat")
  {
    summary_res<-cbind(summary_res,exp_fp)
    
    #print("HERE13134")
    type.statistic="pvalue"
    if(length(allmetabs_res)>0){	
      
      #stat_val<-(-1)*log10(allmetabs_res[,4])
      
      
      stat_val<-allmetabs_res[,4]
      
    }
    
    
    colnames(summary_res)<-c("RSD.thresh","Number of features left after RSD filtering","Number of features selected",paste(pred.eval.method,"-accuracy",sep=""),paste(pred.eval.method," permuted accuracy",sep=""),"Score","Expected_False_Positives")
  }else{
    #exp_fp<-round(fdrthresh*feat_sigfdrthresh)
    
    #if(featselmethod=="MARS" | featselmethod=="RF" | featselmethod=="pls" | featselmethod=="o1pls" | featselmethod=="o2pls"){
    
    exp_fp<-rep(NA,dim(summary_res)[1])
    #}
  #  print("HERE13135")
    if(length(allmetabs_res)>0){
      stat_val<-(allmetabs_res[,4])
    }
    type.statistic="other"
    summary_res<-cbind(summary_res,exp_fp)
    colnames(summary_res)<-c("RSD.thresh","Number of features left after RSD filtering","Number of features selected",paste(pred.eval.method,"-accuracy",sep=""),paste(pred.eval.method," permuted accuracy",sep=""),"Score","Expected_False_Positives")
    
  }
  
  featselmethod<-parentfeatselmethod
  file_name<-paste(parentoutput_dir,"/Results_summary_",featselmethod,".txt",sep="")
  write.table(summary_res,file=file_name,sep="\t",row.names=FALSE)
  
  
  if(output.device.type=="pdf"){
    
    try(dev.off(),silent=TRUE)
  }
  
  #print("##############Level 1: processing complete###########")
  
  
  if(length(best_feats)>1)
  {
    
    mz_index<-best_feats
    
    #par(mfrow=c(1,1),family="sans",cex=cex.plots)
    #                get_boxplots(X=goodfeats_raw,Y=classlabels_orig,parentoutput_dir=output_dir,boxplot.col.opt=boxplot.col.opt,alphacol=0.3,newdevice=FALSE,cex=cex.plots,ylabel="raw Intensity",name=goodfeats_name,add.pvalues=add.pvalues,add.jitter=add.jitter,boxplot.type=boxplot.type)
    
    setwd(output_dir)
    
    ###save(goodfeats,goodfeats_temp,classlabels_orig,classlabels_response_mat,output_dir,xlab_text,ylab_text,goodfeats_name,file="debugscatter.Rda")
    
    if(analysismode=="regression"){
      pdf("Figures/Scatterplots.pdf")
      
      if(is.na(xlab_text)==TRUE){
        
        xlab_text=""
      }
      ylab_text=gsub(ylab_text,pattern="Raw ",replacement="")
    #  save(goodfeats_temp,classlabels_orig,output_dir,ylab_text,xlab_text,goodfeats_name,cex.plots,scatterplot.col.opt,file="scdebug.Rda")
      get_scatter_plots(X=goodfeats_temp,Y=classlabels_orig,parentoutput_dir=output_dir,newdevice=FALSE,ylabel=ylab_text,xlabel=xlab_text,
                        name=goodfeats_name,cex.plots=cex.plots,scatterplot.col.opt=scatterplot.col.opt)
      dev.off()
    }
    setwd(parentoutput_dir)
    
    
    
    
    if(analysismode=="classification"){
      
      
      
      log2.fold.change.thresh=log2.fold.change.thresh_list[best_logfc_ind]
      
      #print(paste("Best results found at RSD threshold ", log2.fold.change.thresh,sep=""))
      
      #print(best_acc)
      #print(paste(kfold,"-fold CV accuracy ", best_acc,sep=""))
      if(FALSE){
      if(pred.eval.method=="CV"){
        
        print(paste(kfold,"-fold CV accuracy: ", best_acc,sep=""))
      }else{
        if(pred.eval.method=="AUC"){
          
          print(paste("Area under the curve (AUC) is : ", best_acc,sep=""))
        }
      }
      }
      
    #  data_m<-parent_data_m
     # data_m_fc<-data_m #[which(abs(mean_groups)>log2.fold.change.thresh),]
      
      data_m_fc_withfeats<-data_matrix[,c(1:2)]
      data_m_fc_withfeats<-cbind(data_m_fc_withfeats,data_m_fc)
      
      
      #when using a feature table generated by apLCMS
      
      rnames<-paste("mzid_",seq(1,dim(data_m_fc)[1]),sep="")
      #print(best_limma_res[1:3,])
      
      goodfeats<-best_limma_res[order(best_limma_res$mz),-c(1:2)]
      
      #goodfeats<-best_limma_res[,-c(1:2)]
      
      goodfeats_all<-goodfeats
      
      goodfeats<-goodfeats_all
      rm(goodfeats_all)
    }
    
    try(unlink("Rplots.pdf"),silent=TRUE)
    
    
    if(globalcor==TRUE){
      
     
      
      
      if(length(best_feats)>2){
        if(is.na(abs.cor.thresh)==FALSE){
          #setwd(parentoutput_dir)
         # print("##############Level 2: Metabolome wide correlation network analysis of differentially expressed metabolites###########")
          #print(paste("Generating metabolome-wide ",cor.method," correlation network using RSD threshold ", log2.fold.change.thresh," results",sep=""))
          #print(parentoutput_dir)
          #print(output_dir)
          setwd(output_dir)
          data_m_fc_withfeats<-as.data.frame(data_m_fc_withfeats)
          
          goodfeats<-as.data.frame(goodfeats)
          #print(goodfeats[1:4,])
          sigfeats_index<-which(data_m_fc_withfeats$mz%in%goodfeats$mz)
          sigfeats<-sigfeats_index
          if(globalcor==TRUE){
            
            #outloc<-paste(parentoutput_dir,"/Allcornetworksigfeats","log2fcthresh",log2.fold.change.thresh,"/",sep="")
            #outloc<-paste(parentoutput_dir,"/Stage2","/",sep="")
            
            #dir.create(outloc)
            #setwd(outloc)
            
            #dir.create("CorrelationAnalysis")
            #setwd("CorrelationAnalysis")
            if(networktype=="complete"){
              
              if(output.device.type=="pdf"){
                mwan_newdevice=FALSE
              }else{
                mwan_newdevice=TRUE
              }
              
              #gohere
           #   save(data_matrix,sigfeats_index,output_dir,max.cor.num,net_node_colors,net_legend,cor.method,abs.cor.thresh,cor.fdrthresh,file="r1.Rda")
              mwan_fdr<-try(do_cor(data_matrix,subindex=sigfeats_index,targetindex=NA,outloc=output_dir,networkscope="global",cor.method,abs.cor.thresh,cor.fdrthresh,
                               max.cor.num,net_node_colors,net_legend,newdevice=TRUE),silent=TRUE)
            }else{
              if(networktype=="GGM"){
                mwan_fdr<-try(get_partial_cornet(data_matrix, sigfeats.index=sigfeats_index,targeted.index=NA,networkscope="global",
                                             cor.method,abs.cor.thresh,cor.fdrthresh,outloc=output_dir,net_node_colors,net_legend,newdevice=TRUE),silent=TRUE)
              }else{
                print("Invalid option. Please use complete or GGM.")
              }
            }
            
            #print("##############Level 2: processing complete###########")
          }else{
            #print("##############Skipping Level 2: global correlation analysis###########")
            
          }
          
          
          #temp_data_m<-cbind(allmetabs_res[,c("mz","time")],stat_val)
          
          
          
          
          if(analysismode=="classification"){
            #  classlabels_temp<-cbind(classlabels_sub[,1],classlabels)
            #do_wgcna(X=data_matrix,Y=classlabels,sigfeats.index=sigfeats_index)
          }
          
          #print("##############Level 3: processing complete###########")
          #print("#########################")
        }
        
        
      }
      else{
        cat(paste("Can not perform network analysis. Too few metabolites.",sep=""),sep="\n")
      }
    }
    
  }
  
  if(FALSE){
    if(length(featselmethod)>1){
      abs.cor.thresh=NA
      globalcor=FALSE
    }
  }
  
  
  ###save(stat_val,allmetabs_res,check_names,metab_annot,kegg_species_code,database,reference_set,type.statistic,file="fcsdebug.Rda")
  
  
  setwd(output_dir)
  
  unlink("fdrtoolB.pdf",force=TRUE)
  
  if(is.na(target.data.annot)==FALSE){
    
    #dir.create("NetworkAnalysis")
    #setwd("NetworkAnalysis")
    
    colnames(target.data.annot)<-c("mz","time","KEGGID")
    if(length(check_names)<1){
      
      allmetabs_res<-cbind(stat_val,allmetabs_res)
      metab_data<-merge(allmetabs_res,target.data.annot,by=c("mz","time"))
      dup.feature.check=TRUE
    }else{
      
      allmetabs_res_withnames<-cbind(stat_val,allmetabs_res_withnames)
      metab_data<-merge(allmetabs_res_withnames,target.data.annot,by=c("Name"))
      dup.feature.check=FALSE
    }
    
    ###save(stat_val,allmetabs_res,check_names,metab_annot,kegg_species_code,database,metab_data,reference_set,type.statistic,file="fcsdebug.Rda")
    
    
    if(length(check_names)<1){
      metab_data<-metab_data[,c("KEGGID","stat_val","mz","time")]
      colnames(metab_data)<-c("KEGGID","Statistic","mz","time")
      
    }else{
      
      metab_data<-metab_data[,c("KEGGID","stat_val")]
      colnames(metab_data)<-c("KEGGID","Statistic")
    }
    
    # ##save(metab_annot,kegg_species_code,database,metab_data,reference_set,type.statistic,file="fcsdebug.Rda")
    
    
    #metab_data: KEGGID, Statistic
    fcs_res<-get_fcs(kegg_species_code=kegg_species_code,database=database,target.data=metab_data,target.data.annot=target.data.annot,reference_set=reference_set,type.statistic=type.statistic,fcs.min.hits=fcs.min.hits)
    
    ###save(fcs_res,file="fcs_res.Rda")
    
    write.table(fcs_res,file="Tables/functional_class_scoring.txt",sep="\t",row.names=TRUE)	
    if(length(fcs_res)>0){
      if(length(which(fcs_res$pvalue<pvalue.thresh))>10){
        
        fcs_res_filt<-fcs_res[which(fcs_res$pvalue<pvalue.thresh)[1:10],]
      }else{
        fcs_res_filt<-fcs_res[which(fcs_res$pvalue<pvalue.thresh),]
      }
      fcs_res_filt<-fcs_res_filt[order(fcs_res_filt$pvalue,decreasing=FALSE),]
      
      fcs_res_filt$Name<-gsub(as.character(fcs_res_filt$Name),pattern=" - Homo sapiens \\(human\\)",replacement="")
      
      
      fcs_res_filt$pvalue=(-1)*log10(fcs_res_filt$pvalue)
      
      fcs_res_filt<-fcs_res_filt[order(fcs_res_filt$pvalue,decreasing=FALSE),]
      
      
      print(Sys.time())
      
      p=ggbarplot(fcs_res_filt,x="Name",y="pvalue",orientation="horiz",ylab="(-)log10pvalue",xlab="",color="orange",fill="orange",title=paste("Functional classes significant at p<",pvalue.thresh," threhsold",sep=""))
      p=p+font("title",size=10)
      p=p+font("x.text",size=10)
      p=p+font("y.text",size=10)
      p=p + geom_hline(yintercept = (-1)*log10(pvalue.thresh), linetype="dotted",size=0.7)
      print(Sys.time())
      
      pdf("Figures/Functional_Class_Scoring.pdf")
      print(p)
      dev.off()
    }
    
    
    
    
    
    print(paste(featselmethod, " processing done.",sep=""))
    
  }
  
  
  setwd(parentoutput_dir)
  
  
  
  
  #print("Note A: Please note that log2 fold-change based filtering is only applicable to two-class comparison. 
  #log2fcthresh of 0 will remove only those features that have exactly sample mean intensities between the two groups.
  #More features will be filtered prior to FDR as log2fcthresh increases.")
  
  #print("Note C: Please make sure all the packages are installed. You can use the command install.packages(packagename) to install packages.")
  #print("Eg: install.packages(\"mixOmics\"),install.packages(\"snow\"), install.packages(\"e1071\"), biocLite(\"limma\"), install.packages(\"gplots\").")
  #print("Eg: install.packages("mixOmics""),install.packages("snow"), install.packages("e1071"), biocLite("limma"), install.packages("gplots").")
  ##############################
  ##############################
  ###############################
  
  
  
  if(length(best_feats)>0){
    
    goodfeats<-as.data.frame(goodfeats)
    #goodfeats<-data_matrix_beforescaling[which(data_matrix_beforescaling$mz%in%goodfeats$mz),]
  }else{
    goodfeats-{}
  }
  
  cur_date<-Sys.time()
  cur_date<-gsub(x=cur_date,pattern="-",replacement="")
  cur_date<-gsub(x=cur_date,pattern=":",replacement="")
  cur_date<-gsub(x=cur_date,pattern=" ",replacement="")
  if(saveRda==TRUE){
    fname<-paste("Analysis_",featselmethod,"_",cur_date,".Rda",sep="")
    ###savelist=ls(),file=fname)
  }
  
  ################################
  
  fname_del<-paste(output_dir,"/Rplots.pdf",sep="")
  try(unlink(fname_del),silent=TRUE)
  
  
  
  if(removeRda==TRUE)
  {
    
    setwd(output_dir)
   # save(removeRda,file="removeRda.Rda")
    unlink("*.Rda",force=TRUE,recursive=TRUE)
    #unlink("pairwise_results/*.Rda",force=TRUE,recursive=TRUE)
    
  }

  cat("",sep="\n")
  
  return(list("diffexp_metabs"=goodfeats_allfields,  "mw.an.fdr"=mwan_fdr,"targeted.an.fdr"=targetedan_fdr,
              "classlabels"=classlabels_orig,"all_metabs"=allmetabs_res_withnames,"roc_res"=roc_res))
  
  

  
  
  
  }




find.Overlapping <- function (dataA, dataB, mz.thresh = 10, time.thresh = 30, best_one=FALSE)
{
  data_a <- as.data.frame(dataA)
  data_b <- as.data.frame(dataB)
  rm(dataA)
  rm(dataB)
  
  colnames(data_a)[1] = "mz"
  colnames(data_b)[1] = "mz"
  if (is.na(time.thresh) == FALSE) {
    colnames(data_a)[2] = "time"
    colnames(data_b)[2] = "time"
    mznames = c("index.A", "mz.data.A", "time.data.A", "index.B",
                "mz.data.B", "time.data.B", 'mz.difference(ppm)', "time.difference(s)")
    print("Using the 1st columns as 'mz' and 2nd columsn as 'retention time'")
  }else {
    mznames = c("index.A", "mz.data.A", "index.B", "mz.data.B", 'mz.difference(ppm)')
    print("Using the 1st columns as 'mz'")
  }
  
  mz_groups <- mclapply(1:dim(data_a)[1], function(j) {
    commat = {}
    
    ppmb = (mz.thresh) * (data_a$mz[j]/1e+06)
    getbind_same <- which(abs(data_b$mz - data_a$mz[j]) <= ppmb)
    if (is.na(time.thresh) == FALSE) {
      if (length(getbind_same) > 0) {
        
        tmp = suppressWarnings(cbind(cbind(j, data_a[j, c(1, 2)]),cbind(getbind_same, data_b[getbind_same, c(1, 2)])))
        tmp[,"mzdiff"]=(abs(tmp[,2]-tmp[,5])/tmp[,2])*10^6
        tmp[,"timediff"]=abs(tmp[,3]-tmp[,6])
        colnames(tmp)=mznames
        tmp = tmp[tmp$time.difference<=time.thresh,]
        if(best_one==TRUE){
          if(dim(tmp)[1]>0){
            commat=tmp[which(tmp$time.difference==min(tmp$time.difference)),]
          }
        }else{
          commat = tmp
        }
        
      }
      
    } else {
      if (length(getbind_same) > 0) {
        
        tmp = suppressWarnings(cbind(as.data.frame(cbind(j, data_a[j, c(1)])),as.data.frame(cbind(getbind_same, data_b[getbind_same, 1]))))
        tmp[,"mzdiff"]=(abs(tmp[,2]-tmp[,4])/tmp[,2])*10^6
        colnames(tmp)=mznames
        commat = tmp
        
      }
    }
    return(as.data.frame(commat))
  },mc.cores=detectCores())
  
  commat = data.frame()
  if (length(mz_groups) > 0) {
    
    for(j in 1:length(mz_groups)){
      if(dim(mz_groups[[j]])[1]>0){
        commat <- rbind(commat,mz_groups[[j]])
      }
    }
    if(dim(commat)[1]>0){
      rownames(commat)=1:dim(commat)[1]
    }else{
      
    }
    return(commat)
  }else{
    return(commat)
  }
  
}


generate_distribution_concentration<-function(targeted_table,seq,outloc,groupcheck=FALSE,targetID=NA,min_num_nonmissing=3){
  
  #summarize the number of batches
  num_batches<- length(unique(seq[,4]))
  
  
  #check batchwise distribution
  pdf(paste(outloc,"batchwise_concentration_distribution.pdf",sep="/"))
  for(ii in 1:dim(targeted_table)[1]){
    
    inten_study<-c()
    batch_study<-c()
    inten_qstd<-c()
    batch_qstd<-c()
    for(jj in 1:num_batches){
      study_list=as.character(seq[seq[,4]==jj & grepl('study',seq[,3],ignore.case = TRUE),1])
      qstd_list=as.character(seq[seq[,4]==jj & grepl('qstd',seq[,3],ignore.case = TRUE),1])
      study_list<-which(colnames(targeted_table)%in%study_list)
      qstd_list<-which(colnames(targeted_table)%in%qstd_list)
      
      
      
      tmp_intensity_study<-as.numeric(targeted_table[ii,study_list])
      tmp_intensity_study<-tmp_intensity_study[!tmp_intensity_study==0]
      tmp_intensity_qstd<-as.numeric(targeted_table[ii,qstd_list])
      tmp_intensity_qstd<-tmp_intensity_qstd[!tmp_intensity_qstd==0]
      
      if(length(tmp_intensity_study)>=min_num_nonmissing){
        inten_study<-c(inten_study,tmp_intensity_study)
        batch_study<-c(batch_study,rep(paste("Batch",jj,sep=""),times=length(tmp_intensity_study)))
        inten_qstd<-c(inten_qstd,tmp_intensity_qstd)
        batch_qstd<-c(batch_qstd,rep(paste("Batch",jj,sep=""),times=length(tmp_intensity_qstd)))
      }
    }
    if(length(inten_study)>0){
      plotdata_study<-data.frame(inten_study,batch_study)
      plotdata_study$batch_study<-factor(plotdata_study$batch_study,levels=as.character(unique(plotdata_study$batch_study)))
      plotdata1<-cbind(plotdata_study,"black")
      colnames(plotdata1)<-c("inten","batch","col")
      if(length(inten_qstd)>0){
        plotdata_qstd<-data.frame(inten_qstd,batch_qstd)
        plotdata_qstd$batch_qstd<-factor(plotdata_qstd$batch_qstd,levels=as.character(unique(plotdata_qstd$batch_qstd)))
        plotdata2<-cbind(plotdata_qstd,"red")
        colnames(plotdata2)<-c("inten","batch","col")
        plotdata<-rbind(plotdata1,plotdata2)
      }else{
        plotdata<-plotdata1
      }
      
      if(length(grep("time_error",colnames(targeted_table)))>0){
        subtitle=paste(
          paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
          paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
          paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
          sep="\n")
      }else{
        subtitle=paste(
          paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
          paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
          paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
          sep="\n")
      }
      
      #draw the plot
      print(ggplot() +
              stat_boxplot(geom='errorbar',width=0.2) +
              geom_boxplot(data=plotdata_study, aes(x=batch_study, y=inten_study,fill=batch_study)) +
              geom_point(data=plotdata, aes(x=batch, y=inten,fill=batch,color=col)) +
              scale_y_continuous(name="concentration") +
              scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
              coord_flip() +
              labs(subtitle=subtitle,
                   title=as.character(targeted_table[ii,"Chemical_name"])) +
              theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                    axis.line.y = element_line(size = 0.5, colour = "black"),
                    axis.line = element_line(size=1, colour = "black"),
                    panel.grid.major = element_blank(),
                    panel.grid.minor = element_blank(),
                    panel.border = element_blank(),
                    panel.background = element_blank(),
                    plot.title=element_text(size = 20),
                    legend.title=element_text(size=13),
                    legend.text=element_text(size=10),
                    text=element_text(size = 16),
                    #plot.margin=margin(10,5,10,1),
                    axis.text.x=element_text(colour="black", size = 10),
                    axis.text.y=element_text(colour="black", size = 10))+
              scale_colour_manual(name ='Category',
                                  values =c('black'='black','red'='red'), labels = c('Sample','QSTD'))+
              guides(fill="none"))
    }
    
  }
  dev.off()
  
  
  
  #check overall distribution
  pdf(paste(outloc,"overall_concentration_distribution.pdf",sep="/"))
  for(ii in 1:dim(targeted_table)[1]){
    study_list=as.character(seq[grepl('study',seq[,3],ignore.case = TRUE),1])
    qstd_list=as.character(seq[grepl('qstd',seq[,3],ignore.case = TRUE),1])
    
    study_list<-which(colnames(targeted_table)%in%study_list)
    qstd_list<-which(colnames(targeted_table)%in%qstd_list)
    
    
    tmp_intensity_study<-as.numeric(targeted_table[ii,study_list])
    tmp_intensity_study<-tmp_intensity_study[!tmp_intensity_study==0]
    tmp_intensity_qstd<-as.numeric(targeted_table[ii,qstd_list])
    tmp_intensity_qstd<-tmp_intensity_qstd[!tmp_intensity_qstd==0]
    if(length(tmp_intensity_study)>=min_num_nonmissing){
      plotdata_study<-cbind(as.data.frame(tmp_intensity_study),"black")
      colnames(plotdata_study)<-c("intensity","col")
      if(length(tmp_intensity_qstd)>0){
        plotdata_qstd<- cbind(as.data.frame(tmp_intensity_qstd),"red")
        colnames(plotdata_qstd)<-c("intensity","col")
        plotdata<-rbind(plotdata_study,plotdata_qstd)
      }else{
        plotdata<-plotdata_study
      }
      
      if(any(is.na(targetID))){
        
        if(length(grep("time_error",colnames(targeted_table)))>0){
          subtitle=paste(
            paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
            paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
            paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
            sep="\n")
        }else{
          subtitle=paste(
            paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
            paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
            paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
            sep="\n")
        }
        
        
        print(ggplot() +
                stat_boxplot(geom='errorbar',width=0.2) +
                geom_boxplot(data=plotdata_study, aes(x="", y=intensity)) +
                geom_point(data=plotdata, aes(x="", y=intensity,color=col)) +
                scale_y_continuous(name="concentration") +
                scale_x_discrete(name="")+
                coord_flip() +
                labs(subtitle=subtitle,
                     title=as.character(targeted_table[ii,"Chemical_name"])) +
                theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                      axis.line.y = element_line(size = 0.5, colour = "black"),
                      axis.line = element_line(size=1, colour = "black"),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank(),
                      panel.border = element_blank(),
                      panel.background = element_blank(),
                      plot.title=element_text(size = 20),
                      legend.title=element_text(size=13),
                      legend.text=element_text(size=10),
                      text=element_text(size = 16),
                      #plot.margin=margin(10,5,10,1),
                      axis.text.x=element_text(colour="black", size = 10),
                      axis.text.y=element_text(colour="black", size = 10))+
                scale_colour_manual(name ='Category',
                                    values =c('black'='black','red'='red'), labels = c('Sample','QSTD'))+
                guides(fill="none"))
        
      }else{
        if(!any(as.character(seq[,2])%in%targetID)){
          stop("There is none of targetIDs that can find a match in class label file.", call.=TRUE)
        }
        if(length(targetID)>10){
          stop("The maximum number of allowed targetID is 10.", call.=TRUE)
        }
        plotdata_target<-seq[as.character(seq[,2])%in%targetID,c(1,2)]
        plotdata_target<-cbind(plotdata_target,as.numeric(targeted_table[ii,as.character(plotdata_target[,1])]))
        colnames(plotdata_target)<-c("FileName","SampleID","intensity")
        plotdata_target<-plotdata_target[!plotdata_target$intensity==0,]
        if(length(plotdata_target$intensity)>0){
          col=c(palette()[-c(1,2)],c("darkorange1","brown","gold1","deeppink1"))
          col<-col[1:length(plotdata_target$intensity)]
          plotdata_target<-cbind(plotdata_target,col)
          plotdata_target$col<-factor(plotdata_target$col,levels=as.character(unique(plotdata_target$col)))
          col_len<-c('black','red',as.character(plotdata_target$col))
          names(col_len)<-c('black','red',as.character(plotdata_target$col))
          plotdata[,"size"]=1
          plotdata=rbind(plotdata,cbind(plotdata_target[,c("intensity","col")],size=8))
          
          if(length(grep("time_error",colnames(targeted_table)))>0){
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
              sep="\n")
          }else{
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
              sep="\n")
          }
          
          print(ggplot() +
                  stat_boxplot(geom='errorbar',width=0.2) +
                  geom_boxplot(data=plotdata_study, aes(x="", y=intensity)) +
                  geom_point(data=plotdata, aes(x="", y=intensity,color=col,size=size)) +
                  scale_y_continuous(name="concentration") +
                  scale_x_discrete(name="")+
                  coord_flip() +
                  labs(subtitle=subtitle,
                       title=as.character(targeted_table[ii,"Chemical_name"])) +
                  theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                        axis.line.y = element_line(size = 0.5, colour = "black"),
                        axis.line = element_line(size=1, colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_blank(),
                        plot.title=element_text(size = 20),
                        legend.title=element_text(size=13),
                        legend.text=element_text(size=10),
                        text=element_text(size = 16),
                        #plot.margin=margin(10,5,10,1),
                        axis.text.x=element_text(colour="black", size = 10),
                        axis.text.y=element_text(colour="black", size = 10))+
                  scale_colour_manual(name ='Category',
                                      values =col_len, labels = c('Sample','QSTD',as.character(plotdata_target$SampleID)))+
                  guides(fill="none",size="none"))
        }else{
          
          if(length(grep("time_error",colnames(targeted_table)))>0){
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
              sep="\n")
          }else{
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
              sep="\n")
          }
          
          print(ggplot() +
                  stat_boxplot(geom='errorbar',width=0.2) +
                  geom_boxplot(data=plotdata_study, aes(x="", y=intensity)) +
                  geom_point(data=plotdata, aes(x="", y=intensity,color=col)) +
                  scale_y_continuous(name="intensity") +
                  scale_x_discrete(name="")+
                  coord_flip() +
                  labs(subtitle=subtitle,
                       title=as.character(targeted_table[ii,"Chemical_name"])) +
                  theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                        axis.line.y = element_line(size = 0.5, colour = "black"),
                        axis.line = element_line(size=1, colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_blank(),
                        plot.title=element_text(size = 20),
                        legend.title=element_text(size=13),
                        legend.text=element_text(size=10),
                        text=element_text(size = 16),
                        #plot.margin=margin(10,5,10,1),
                        axis.text.x=element_text(colour="black", size = 10),
                        axis.text.y=element_text(colour="black", size = 10))+
                  scale_colour_manual(name ='Category',
                                      values =c('black'='black','red'='red'), labels = c('Sample','QSTD'))+
                  guides(fill="none"))
        }
      }
    }
  }
  dev.off()
  
  
  #check group intensity distribution
  if(groupcheck==TRUE){
    if(length(grep("group",colnames(seq),ignore.case =TRUE))==0){
      #stop("There is no column called 'group' in class label file. Please assign 'Group' to the name of the column with group label in class label file", call.=TRUE)
      Group<-rep(1,nrow(seq))
      seq<-cbind(seq,Group)
    }
    print(head(seq))
    colnames(seq)[grep("group",colnames(seq),ignore.case =TRUE)]='Group'
    seq_group=seq[!is.na(seq$Group),]
    group=unique(as.character(seq_group$Group))
    pdf(paste(outloc,"groupwise_intensity_distribution.pdf",sep="/"))
    for(ii in 1:dim(targeted_table)[1]){
      inten_group<-c()
      label_group<-c()
      name_group<-c()
      for(jj in 1:length(group)){
        group_list=as.character(seq_group[seq_group$Group==group[jj],1])
        
        group_list<-which(colnames(targeted_table)%in%group_list)
        
        
        
        tmp_intensity_group<-as.numeric(targeted_table[ii,group_list])
        group_list<-group_list[!tmp_intensity_group==0]
        tmp_intensity_group<-tmp_intensity_group[!tmp_intensity_group==0]
        if(length(tmp_intensity_study)>=min_num_nonmissing){
          inten_group<-c(inten_group,tmp_intensity_group)
          label_group<-c(label_group,rep(group[jj],length(tmp_intensity_group)))
          name_group<-c(name_group,group_list)
        }
      }
      if(length(inten_group)>0){
        plotdata_group<-data.frame(name_group,inten_group,label_group)
        plotdata_group$label_group<-factor(plotdata_group$label_group,levels=as.character(unique(plotdata_group$label_group)))
        plotdata<-cbind(plotdata_group,"black")
        colnames(plotdata)<-c("name","inten","group","col")
        plotdata$col<-as.character(plotdata$col)
        plotdata<-merge(plotdata,seq[,c(1,2)],by.x='name',by.y='FileName',all.x=TRUE)
        
        colnames(plotdata)[ncol(plotdata)]="sampleID"
        
        if(!any(is.na(targetID))){
          if(!any(as.character(seq_group[,2])%in%targetID)){
            stop("There is none of targetIDs that can find a match in class label file.", call.=TRUE)
          }
          if(length(targetID)>10){
            stop("The maximum number of allowed targetID is 10.", call.=TRUE)
          }
          if(any(plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]))){
            plotdata=cbind(plotdata,size=1)
            plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),"size"]=8
            col=c(palette()[-c(1,2)],c("darkorange1","brown","gold1","deeppink1"))
            col<-col[1:dim(plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),])[1]]
            plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),"col"]=col
            plotdata$col<-factor(plotdata$col,levels=as.character(unique(plotdata$col)))
            col_len<-c('black',as.character(col))
            names(col_len)<-c('black',as.character(col))
            
            #draw the plot
            if(length(grep("time_error",colnames(targeted_table)))>0){
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
                sep="\n")
            }else{
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
                sep="\n")
            }
            
            print(ggplot() +
                    stat_boxplot(geom='errorbar',width=0.2) +
                    geom_boxplot(data=plotdata, aes(x=group, y=inten,fill=group)) +
                    geom_point(data=plotdata, aes(x=group, y=inten,fill=group,color=col,size=size)) +
                    scale_y_continuous(name="intensity") +
                    scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
                    coord_flip() +
                    labs(subtitle=subtitle,
                         title=as.character(targeted_table[ii,"Chemical_name"])) +
                    theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                          axis.line.y = element_line(size = 0.5, colour = "black"),
                          axis.line = element_line(size=1, colour = "black"),
                          panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank(),
                          panel.border = element_blank(),
                          panel.background = element_blank(),
                          plot.title=element_text(size = 20),
                          legend.title=element_text(size=13),
                          legend.text=element_text(size=10),
                          text=element_text(size = 16),
                          #plot.margin=margin(10,5,10,1),
                          axis.text.x=element_text(colour="black", size = 10),
                          axis.text.y=element_text(colour="black", size = 10))+
                    scale_colour_manual(name ='Category',
                                        values =col_len, labels = c('Sample',as.character(plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),"sampleID"])))+
                    guides(fill="none",size="none"))
          }else{
            if(length(grep("time_error",colnames(targeted_table)))>0){
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
                sep="\n")
            }else{
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
                sep="\n")
            }
            
            print(ggplot() +
                    stat_boxplot(geom='errorbar',width=0.2) +
                    geom_boxplot(data=plotdata, aes(x=group, y=inten,fill=group)) +
                    geom_point(data=plotdata, aes(x=group, y=inten,fill=group,color=col)) +
                    scale_y_continuous(name="intensity") +
                    scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
                    coord_flip() +
                    labs(subtitle=subtitle,
                         title=as.character(targeted_table[ii,"Chemical_name"])) +
                    theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                          axis.line.y = element_line(size = 0.5, colour = "black"),
                          axis.line = element_line(size=1, colour = "black"),
                          panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank(),
                          panel.border = element_blank(),
                          panel.background = element_blank(),
                          plot.title=element_text(size = 20),
                          legend.title=element_text(size=13),
                          legend.text=element_text(size=10),
                          text=element_text(size = 16),
                          #plot.margin=margin(10,5,10,1),
                          axis.text.x=element_text(colour="black", size = 10),
                          axis.text.y=element_text(colour="black", size = 10))+
                    scale_colour_manual(name ='Category',
                                        values =c('black'='black'), labels = c('Sample'))+
                    guides(fill="none"))
          }
          
          
        }else{
          #draw the plot
          if(length(grep("time_error",colnames(targeted_table)))>0){
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
              sep="\n")
          }else{
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
              sep="\n")
          }
          
          print(ggplot() +
                  stat_boxplot(geom='errorbar',width=0.2) +
                  geom_boxplot(data=plotdata, aes(x=group, y=inten,fill=group)) +
                  geom_point(data=plotdata, aes(x=group, y=inten,fill=group,color=col)) +
                  scale_y_continuous(name="intensity") +
                  scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
                  coord_flip() +
                  labs(subtitle=subtitle,
                       title=as.character(targeted_table[ii,"Chemical_name"])) +
                  theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                        axis.line.y = element_line(size = 0.5, colour = "black"),
                        axis.line = element_line(size=1, colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_blank(),
                        plot.title=element_text(size = 20),
                        legend.title=element_text(size=13),
                        legend.text=element_text(size=10),
                        text=element_text(size = 16),
                        #plot.margin=margin(10,5,10,1),
                        axis.text.x=element_text(colour="black", size = 10),
                        axis.text.y=element_text(colour="black", size = 10))+
                  scale_colour_manual(name ='Category',
                                      values =c('black'='black'), labels = c('Sample'))+
                  guides(fill="none"))
        }
        
      }
      
    }
    dev.off()
  }
  
}

generate_distribution<-function(targeted_table,seq,outloc,groupcheck=FALSE,targetID=NA,min_num_nonmissing=3){
  
  #summarize the number of batches
  num_batches<- length(unique(seq[,4]))
  
  #check batchwise distribution
  pdf(paste(outloc,"batchwise_intensity_distribution.pdf",sep="/"))
  for(ii in 1:dim(targeted_table)[1]){
    
    inten_study<-c()
    batch_study<-c()
    inten_qstd<-c()
    batch_qstd<-c()
    for(jj in 1:num_batches){
      study_list=as.character(seq[seq[,4]==jj & grepl('study',seq[,3],ignore.case = TRUE),1])
      qstd_list=as.character(seq[seq[,4]==jj & grepl('qstd',seq[,3],ignore.case = TRUE),1])
      tmp_intensity_study<-as.numeric(targeted_table[ii,study_list])
      tmp_intensity_study<-tmp_intensity_study[!tmp_intensity_study==0]
      tmp_intensity_qstd<-as.numeric(targeted_table[ii,qstd_list])
      tmp_intensity_qstd<-tmp_intensity_qstd[!tmp_intensity_qstd==0]
      if(length(tmp_intensity_study)>=min_num_nonmissing){
        inten_study<-c(inten_study,tmp_intensity_study)
        batch_study<-c(batch_study,rep(paste("Batch",jj,sep=""),times=length(tmp_intensity_study)))
        inten_qstd<-c(inten_qstd,tmp_intensity_qstd)
        batch_qstd<-c(batch_qstd,rep(paste("Batch",jj,sep=""),times=length(tmp_intensity_qstd)))
      }
    }
    if(length(inten_study)>0){
      plotdata_study<-data.frame(inten_study,batch_study)
      plotdata_study$batch_study<-factor(plotdata_study$batch_study,levels=as.character(unique(plotdata_study$batch_study)))
      plotdata1<-cbind(plotdata_study,"black")
      colnames(plotdata1)<-c("inten","batch","col")
      if(length(inten_qstd)>0){
        plotdata_qstd<-data.frame(inten_qstd,batch_qstd)
        plotdata_qstd$batch_qstd<-factor(plotdata_qstd$batch_qstd,levels=as.character(unique(plotdata_qstd$batch_qstd)))
        plotdata2<-cbind(plotdata_qstd,"red")
        colnames(plotdata2)<-c("inten","batch","col")
        plotdata<-rbind(plotdata1,plotdata2)
      }else{
        plotdata<-plotdata1
      }
      
      if(length(grep("time_error",colnames(targeted_table)))>0){
        subtitle=paste(
          paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
          paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
          paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
          sep="\n")
      }else{
        subtitle=paste(
          paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
          paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
          paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
          sep="\n")
      }
      
      #draw the plot
      print(ggplot() +
              stat_boxplot(geom='errorbar',width=0.2) +
              geom_boxplot(data=plotdata_study, aes(x=batch_study, y=inten_study,fill=batch_study)) +
              geom_point(data=plotdata, aes(x=batch, y=inten,fill=batch,color=col)) +
              scale_y_continuous(name="intensity") +
              scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
              coord_flip() +
              labs(subtitle=subtitle,
                   title=as.character(targeted_table[ii,"Chemical_name"])) +
              theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                    axis.line.y = element_line(size = 0.5, colour = "black"),
                    axis.line = element_line(size=1, colour = "black"),
                    panel.grid.major = element_blank(),
                    panel.grid.minor = element_blank(),
                    panel.border = element_blank(),
                    panel.background = element_blank(),
                    plot.title=element_text(size = 20),
                    legend.title=element_text(size=13),
                    legend.text=element_text(size=10),
                    text=element_text(size = 16),
                    #plot.margin=margin(10,5,10,1),
                    axis.text.x=element_text(colour="black", size = 10),
                    axis.text.y=element_text(colour="black", size = 10))+
              scale_colour_manual(name ='Category',
                                  values =c('black'='black','red'='red'), labels = c('Sample','QSTD'))+
              guides(fill="none"))
    }
    
  }
  dev.off()
  
  
  
  #check overall distribution
  pdf(paste(outloc,"overall_intensity_distribution.pdf",sep="/"))
  for(ii in 1:dim(targeted_table)[1]){
    study_list=as.character(seq[grepl('study',seq[,3],ignore.case = TRUE),1])
    qstd_list=as.character(seq[grepl('qstd',seq[,3],ignore.case = TRUE),1])
    tmp_intensity_study<-as.numeric(targeted_table[ii,study_list])
    tmp_intensity_study<-tmp_intensity_study[!tmp_intensity_study==0]
    tmp_intensity_qstd<-as.numeric(targeted_table[ii,qstd_list])
    tmp_intensity_qstd<-tmp_intensity_qstd[!tmp_intensity_qstd==0]
    if(length(tmp_intensity_study)>=min_num_nonmissing){
      plotdata_study<-cbind(as.data.frame(tmp_intensity_study),"black")
      colnames(plotdata_study)<-c("intensity","col")
      if(length(tmp_intensity_qstd)>0){
        plotdata_qstd<- cbind(as.data.frame(tmp_intensity_qstd),"red")
        colnames(plotdata_qstd)<-c("intensity","col")
        plotdata<-rbind(plotdata_study,plotdata_qstd)
      }else{
        plotdata<-plotdata_study
      }
      
      if(any(is.na(targetID))){
        
        if(length(grep("time_error",colnames(targeted_table)))>0){
          subtitle=paste(
            paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
            paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
            paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
            sep="\n")
        }else{
          subtitle=paste(
            paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
            paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
            paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
            sep="\n")
        }
        
        
        print(ggplot() +
                stat_boxplot(geom='errorbar',width=0.2) +
                geom_boxplot(data=plotdata_study, aes(x="", y=intensity)) +
                geom_point(data=plotdata, aes(x="", y=intensity,color=col)) +
                scale_y_continuous(name="intensity") +
                scale_x_discrete(name="")+
                coord_flip() +
                labs(subtitle=subtitle,
                     title=as.character(targeted_table[ii,"Chemical_name"])) +
                theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                      axis.line.y = element_line(size = 0.5, colour = "black"),
                      axis.line = element_line(size=1, colour = "black"),
                      panel.grid.major = element_blank(),
                      panel.grid.minor = element_blank(),
                      panel.border = element_blank(),
                      panel.background = element_blank(),
                      plot.title=element_text(size = 20),
                      legend.title=element_text(size=13),
                      legend.text=element_text(size=10),
                      text=element_text(size = 16),
                      #plot.margin=margin(10,5,10,1),
                      axis.text.x=element_text(colour="black", size = 10),
                      axis.text.y=element_text(colour="black", size = 10))+
                scale_colour_manual(name ='Category',
                                    values =c('black'='black','red'='red'), labels = c('Sample','QSTD'))+
                guides(fill="none"))
        
      }else{
        if(!any(as.character(seq[,2])%in%targetID)){
          stop("There is none of targetIDs that can find a match in class label file.", call.=TRUE)
        }
        if(length(targetID)>10){
          stop("The maximum number of allowed targetID is 10.", call.=TRUE)
        }
        plotdata_target<-seq[as.character(seq[,2])%in%targetID,c(1,2)]
        plotdata_target<-cbind(plotdata_target,as.numeric(targeted_table[ii,as.character(plotdata_target[,1])]))
        colnames(plotdata_target)<-c("FileName","SampleID","intensity")
        plotdata_target<-plotdata_target[!plotdata_target$intensity==0,]
        if(length(plotdata_target$intensity)>0){
          col=c(palette()[-c(1,2)],c("darkorange1","brown","gold1","deeppink1"))
          col<-col[1:length(plotdata_target$intensity)]
          plotdata_target<-cbind(plotdata_target,col)
          plotdata_target$col<-factor(plotdata_target$col,levels=as.character(unique(plotdata_target$col)))
          col_len<-c('black','red',as.character(plotdata_target$col))
          names(col_len)<-c('black','red',as.character(plotdata_target$col))
          plotdata[,"size"]=1
          plotdata=rbind(plotdata,cbind(plotdata_target[,c("intensity","col")],size=8))
          
          if(length(grep("time_error",colnames(targeted_table)))>0){
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
              sep="\n")
          }else{
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
              sep="\n")
          }
          
          print(ggplot() +
                  stat_boxplot(geom='errorbar',width=0.2) +
                  geom_boxplot(data=plotdata_study, aes(x="", y=intensity)) +
                  geom_point(data=plotdata, aes(x="", y=intensity,color=col,size=size)) +
                  scale_y_continuous(name="intensity") +
                  scale_x_discrete(name="")+
                  coord_flip() +
                  labs(subtitle=subtitle,
                       title=as.character(targeted_table[ii,"Chemical_name"])) +
                  theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                        axis.line.y = element_line(size = 0.5, colour = "black"),
                        axis.line = element_line(size=1, colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_blank(),
                        plot.title=element_text(size = 20),
                        legend.title=element_text(size=13),
                        legend.text=element_text(size=10),
                        text=element_text(size = 16),
                        #plot.margin=margin(10,5,10,1),
                        axis.text.x=element_text(colour="black", size = 10),
                        axis.text.y=element_text(colour="black", size = 10))+
                  scale_colour_manual(name ='Category',
                                      values =col_len, labels = c('Sample','QSTD',as.character(plotdata_target$SampleID)))+
                  guides(fill="none",size="none"))
        }else{
          
          if(length(grep("time_error",colnames(targeted_table)))>0){
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
              sep="\n")
          }else{
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
              sep="\n")
          }
          
          print(ggplot() +
                  stat_boxplot(geom='errorbar',width=0.2) +
                  geom_boxplot(data=plotdata_study, aes(x="", y=intensity)) +
                  geom_point(data=plotdata, aes(x="", y=intensity,color=col)) +
                  scale_y_continuous(name="intensity") +
                  scale_x_discrete(name="")+
                  coord_flip() +
                  labs(subtitle=subtitle,
                       title=as.character(targeted_table[ii,"Chemical_name"])) +
                  theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                        axis.line.y = element_line(size = 0.5, colour = "black"),
                        axis.line = element_line(size=1, colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_blank(),
                        plot.title=element_text(size = 20),
                        legend.title=element_text(size=13),
                        legend.text=element_text(size=10),
                        text=element_text(size = 16),
                        #plot.margin=margin(10,5,10,1),
                        axis.text.x=element_text(colour="black", size = 10),
                        axis.text.y=element_text(colour="black", size = 10))+
                  scale_colour_manual(name ='Category',
                                      values =c('black'='black','red'='red'), labels = c('Sample','QSTD'))+
                  guides(fill="none"))
        }
      }
    }
  }
  dev.off()
  
  
  #check group intensity distribution
  if(groupcheck==TRUE){
    if(length(grep("group",colnames(seq),ignore.case =TRUE))==0){
      stop("There is no column called 'group' in class label file. Please assign 'Group' to the name of the column with group label in class label file", call.=TRUE)
    }
    colnames(seq)[grep("group",colnames(seq),ignore.case =TRUE)]='Group'
    seq_group=seq[!is.na(seq$Group),]
    group=unique(as.character(seq_group$Group))
    pdf(paste(outloc,"groupwise_intensity_distribution.pdf",sep="/"))
    for(ii in 1:dim(targeted_table)[1]){
      inten_group<-c()
      label_group<-c()
      name_group<-c()
      for(jj in 1:length(group)){
        group_list=as.character(seq_group[seq_group$Group==group[jj],1])
        tmp_intensity_group<-as.numeric(targeted_table[ii,group_list])
        group_list<-group_list[!tmp_intensity_group==0]
        tmp_intensity_group<-tmp_intensity_group[!tmp_intensity_group==0]
        if(length(tmp_intensity_study)>=min_num_nonmissing){
          inten_group<-c(inten_group,tmp_intensity_group)
          label_group<-c(label_group,rep(group[jj],length(tmp_intensity_group)))
          name_group<-c(name_group,group_list)
        }
      }
      if(length(inten_group)>0){
        plotdata_group<-data.frame(name_group,inten_group,label_group)
        plotdata_group$label_group<-factor(plotdata_group$label_group,levels=as.character(unique(plotdata_group$label_group)))
        plotdata<-cbind(plotdata_group,"black")
        colnames(plotdata)<-c("name","inten","group","col")
        plotdata$col<-as.character(plotdata$col)
        plotdata<-merge(plotdata,seq[,c(1,2)],by.x='name',by.y='FileName',all.x=TRUE)
        
        colnames(plotdata)[ncol(plotdata)]="sampleID"
        
        if(!any(is.na(targetID))){
          if(!any(as.character(seq_group[,2])%in%targetID)){
            stop("There is none of targetIDs that can find a match in class label file.", call.=TRUE)
          }
          if(length(targetID)>10){
            stop("The maximum number of allowed targetID is 10.", call.=TRUE)
          }
          if(any(plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]))){
            plotdata=cbind(plotdata,size=1)
            plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),"size"]=8
            col=c(palette()[-c(1,2)],c("darkorange1","brown","gold1","deeppink1"))
            col<-col[1:dim(plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),])[1]]
            plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),"col"]=col
            plotdata$col<-factor(plotdata$col,levels=as.character(unique(plotdata$col)))
            col_len<-c('black',as.character(col))
            names(col_len)<-c('black',as.character(col))
            
            #draw the plot
            if(length(grep("time_error",colnames(targeted_table)))>0){
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
                sep="\n")
            }else{
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
                sep="\n")
            }
            
            print(ggplot() +
                    stat_boxplot(geom='errorbar',width=0.2) +
                    geom_boxplot(data=plotdata, aes(x=group, y=inten,fill=group)) +
                    geom_point(data=plotdata, aes(x=group, y=inten,fill=group,color=col,size=size)) +
                    scale_y_continuous(name="intensity") +
                    scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
                    coord_flip() +
                    labs(subtitle=subtitle,
                         title=as.character(targeted_table[ii,"Chemical_name"])) +
                    theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                          axis.line.y = element_line(size = 0.5, colour = "black"),
                          axis.line = element_line(size=1, colour = "black"),
                          panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank(),
                          panel.border = element_blank(),
                          panel.background = element_blank(),
                          plot.title=element_text(size = 20),
                          legend.title=element_text(size=13),
                          legend.text=element_text(size=10),
                          text=element_text(size = 16),
                          #plot.margin=margin(10,5,10,1),
                          axis.text.x=element_text(colour="black", size = 10),
                          axis.text.y=element_text(colour="black", size = 10))+
                    scale_colour_manual(name ='Category',
                                        values =col_len, labels = c('Sample',as.character(plotdata[plotdata$name%in%as.character(seq_group[as.character(seq_group[,2])%in%targetID,1]),"sampleID"])))+
                    guides(fill="none",size="none"))
          }else{
            if(length(grep("time_error",colnames(targeted_table)))>0){
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
                sep="\n")
            }else{
              subtitle=paste(
                paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
                paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
                paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
                sep="\n")
            }
            
            print(ggplot() +
                    stat_boxplot(geom='errorbar',width=0.2) +
                    geom_boxplot(data=plotdata, aes(x=group, y=inten,fill=group)) +
                    geom_point(data=plotdata, aes(x=group, y=inten,fill=group,color=col)) +
                    scale_y_continuous(name="intensity") +
                    scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
                    coord_flip() +
                    labs(subtitle=subtitle,
                         title=as.character(targeted_table[ii,"Chemical_name"])) +
                    theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                          axis.line.y = element_line(size = 0.5, colour = "black"),
                          axis.line = element_line(size=1, colour = "black"),
                          panel.grid.major = element_blank(),
                          panel.grid.minor = element_blank(),
                          panel.border = element_blank(),
                          panel.background = element_blank(),
                          plot.title=element_text(size = 20),
                          legend.title=element_text(size=13),
                          legend.text=element_text(size=10),
                          text=element_text(size = 16),
                          #plot.margin=margin(10,5,10,1),
                          axis.text.x=element_text(colour="black", size = 10),
                          axis.text.y=element_text(colour="black", size = 10))+
                    scale_colour_manual(name ='Category',
                                        values =c('black'='black'), labels = c('Sample'))+
                    guides(fill="none"))
          }
          
          
        }else{
          #draw the plot
          if(length(grep("time_error",colnames(targeted_table)))>0){
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm","  ","time error:",round(targeted_table[ii,"time_error"],1),"s",sep=""),
              sep="\n")
          }else{
            subtitle=paste(
              paste("mz:",round(targeted_table[ii,"mz"],5),"  ","time:",round(targeted_table[ii,"time"],1),sep=""),
              paste("reference mz:",round(targeted_table[ii,"ref_mz"],5),"  ","reference time:",round(targeted_table[ii,"ref_time"],1),sep=""),
              paste("mz error:",round(targeted_table[ii,"mz_error"]),"ppm",sep=""),
              sep="\n")
          }
          
          print(ggplot() +
                  stat_boxplot(geom='errorbar',width=0.2) +
                  geom_boxplot(data=plotdata, aes(x=group, y=inten,fill=group)) +
                  geom_point(data=plotdata, aes(x=group, y=inten,fill=group,color=col)) +
                  scale_y_continuous(name="intensity") +
                  scale_x_discrete(name="",limits = rev(levels(plotdata_study$batch_study)))+
                  coord_flip() +
                  labs(subtitle=subtitle,
                       title=as.character(targeted_table[ii,"Chemical_name"])) +
                  theme(axis.line.x = element_line(size = 0.5, colour = "black"),
                        axis.line.y = element_line(size = 0.5, colour = "black"),
                        axis.line = element_line(size=1, colour = "black"),
                        panel.grid.major = element_blank(),
                        panel.grid.minor = element_blank(),
                        panel.border = element_blank(),
                        panel.background = element_blank(),
                        plot.title=element_text(size = 20),
                        legend.title=element_text(size=13),
                        legend.text=element_text(size=10),
                        text=element_text(size = 16),
                        #plot.margin=margin(10,5,10,1),
                        axis.text.x=element_text(colour="black", size = 10),
                        axis.text.y=element_text(colour="black", size = 10))+
                  scale_colour_manual(name ='Category',
                                      values =c('black'='black'), labels = c('Sample'))+
                  guides(fill="none"))
        }
        
      }
      
    }
    dev.off()
  }
  
}


calculate_concentration<-function(targeted_table,ref,seq,outloc,missing= 0.3,batch_qstd_missing=0.4){
  
  count=max(grep("_error",colnames(targeted_table)))
  
  #summarize the number of batches
  num_batches<- length(unique(seq[,4]))
  
  #create list object with each batch in slot
  qstd_sample_mapping<- seq[grepl('qstd',seq[,3],ignore.case = TRUE),]
  qstd_int<- targeted_table[,as.character(qstd_sample_mapping[,1])]
  
  
  #show error if number of reference samples is not 6x number of batches
  #if(ncol(qstd_int)/6 != length(unique(sample.mapping[,4]))){
  #    stop("Number of reference samples is not multiple of number of batches", call.=TRUE)
  #}
  
  print(paste("Number of batches: ",length(unique(seq[,4])), sep= ""))
  write.table(paste("Number of batches: ",length(unique(seq[,4])), sep= ""), paste(outloc,"step2_summary.txt",sep="/"), sep="\t", row.names=FALSE, col.names =FALSE)
  print(paste("Number of reference standards(QSTD samples): ",ncol(qstd_int), paste= ""))
  write.table(paste("Number of reference standards: ",ncol(qstd_int), sep= ""), paste(outloc,"step2_summary.txt",sep="/"), sep="\t", append = TRUE, row.names=FALSE, col.names =FALSE)
  
  
  #calculating response factor
  #create list of reference sample response factors for targeted, q-standard table
  rf_ls<- c()
  for(ii in 1:num_batches){
    batch_qs<- qstd_sample_mapping[qstd_sample_mapping[,4]==ii,]
    qstd_int_batch <- qstd_int[,as.character(batch_qs[,1])]
    qstd_int_batch[qstd_int_batch==0]<-NA
    pass <- apply(is.na(qstd_int_batch),1,sum)/dim(qstd_int_batch)[2]<batch_qstd_missing
    tmp <- rowMeans(qstd_int_batch,na.rm=TRUE)
    tmp[!(pass)]<-0
    rf_ls<-cbind(rf_ls, tmp)
  }
  
  
  ######restart here
  
  if(num_batches>1){
    #count number of zeroes in each row
    prop_missing<-rowSums(rf_ls==0)/num_batches
    #samples with number of missing values above proportion theshold (Qstd) and with no reference concentration
    remove_i<- unique(c(which(prop_missing> missing), which(is.na(targeted_table[,4]))))
    
    #updated data after removing missing values
    if(length(remove_i)!=0){
      rf_ls<-rf_ls[-remove_i,]
      targeted_table<- targeted_table[-remove_i,]
    }
    
    #replace missing values with group average (not including zeroes)
    rf_ls[rf_ls==0]<-NA
    #calculate means across study
    row_means<- rowMeans(rf_ls, na.rm=TRUE)
    
    #replace NA with row mean
    rf_ls_final<- rf_ls
    
    for(ii in 1:nrow(rf_ls)){
      sub_rf<- rf_ls[ii,]
      jj<- which(is.na(sub_rf), arr.ind=TRUE)
      if(length(jj)>0){
        rf_ls_final[ii,jj]<- row_means[ii]
      }
    }
    
    #evaluate CV
    cv_res<- rowSds(rf_ls_final)/rowMeans(rf_ls_final)*100
    print(paste("Average QSTD CV for all targets: ",round(mean(cv_res),2),"%", sep=""))
    write.table(paste("Average QSTD CV for all targets: ",round(mean(cv_res),2),"%", sep=""), paste(outloc,"step2_summary.txt",sep="/"), sep="\t", append = TRUE, row.names=FALSE, col.names =FALSE)
    
    pdf(paste(outloc,"CV_distribution_Qstd_intensity.pdf",sep="/"))
    hist(cv_res, breaks=40, xlab="CV", main="Distribution of QSTD Intensity CV")
    dev.off()
    
    rf_ls_final<-as.data.frame(rf_ls_final)
    colnames(rf_ls_final)=paste("Batch",seq(1:dim(rf_ls_final)[2]),sep="")
    CV<-cv_res
    qstd_avg_table<- cbind(targeted_table[,c(3,1,2)], CV, rf_ls_final)
    write.table(qstd_avg_table, paste(outloc,"Batchwise_Qstd_average_intensity.txt",sep="/"), sep= "\t", row.names=FALSE)
    #rf_df<- read.table("batchwise_response_factor.txt", sep= "\t", header=TRUE)
    
  }else{
    #samples with number of missing values above proportion theshold (Qstd) and with no reference concentration
    remove_i<- unique(c(which(is.na(targeted_table[,4]))))
    
    #updated data after removing missing values
    if(length(remove_i)!=0){
      rf_ls<-rf_ls[-remove_i,]
      targeted_table<- targeted_table[-remove_i,]
    }
    
    
    #remove all the targets with missing values
    rf_ls_final<- rf_ls[!rf_ls==0]
    targeted_table<- targeted_table[!rf_ls==0,]
    
    rf_ls_final<-as.data.frame(rf_ls_final)
    colnames(rf_ls_final)=paste("Batch",seq(1:dim(rf_ls_final)[2]),sep="")
    qstd_avg_table<- cbind(targeted_table[,c(3,1,2)], rf_ls_final)
    write.table(qstd_avg_table, paste(outloc,"Batchwise_Qstd_average_intensity.txt",sep="/"), sep= "\t", row.names=FALSE)
    
  }
  
  #create rf matrix
  rf_final<-{}
  for (ii in 1:nrow(rf_ls_final)){
    l1<- targeted_table[ii,4]/rf_ls_final[ii,]
    rf_final<- rbind(rf_final,l1)
  }
  
  rf_table<- cbind.data.frame(targeted_table[,c(3,1,2)], rf_final)
  write.table(rf_table, paste(outloc,"Batchwise_response_factors.txt",sep="/"), sep= "\t", row.names=FALSE)
  
  #calculate concentrations in each batch
  
  
  #includes q-standards
  res_concentrations<- data.frame(matrix(0, ncol=1, nrow=nrow(targeted_table)))
  for (ii in 1:num_batches){
    batch_feature_table<- targeted_table[, as.character(seq[seq[,4]==ii,1])]
    res_1<- c()
    for(jj in 1:nrow(batch_feature_table)){
      res_1<- rbind(res_1, rf_final[jj,ii]* batch_feature_table[jj,])
    }
    res_concentrations<- cbind(res_concentrations, res_1)
  }
  res_concentrations<- res_concentrations[,-1]
  
  final_concentrations<- cbind(targeted_table[1:(count+2)],res_concentrations)
  
  #create sample mapping
  sample_only_concentrations<- cbind(final_concentrations[,c(1:(count+2))],final_concentrations[,as.character(seq[grepl('study',seq[,3],ignore.case = TRUE),1])])
  sample_mean_concentration_batchwise<-final_concentrations[,c(1:(count+2))]
  
  for (ii in 1:num_batches){
    res_tmp <- final_concentrations[,as.character(seq[seq[,4]==ii & grepl('study',seq[,3],ignore.case = TRUE),1])]
    res_tmp[res_tmp==0] <- NA
    sample_mean_concentration_batchwise <- cbind(sample_mean_concentration_batchwise,apply(res_tmp,1,mean,na.rm=TRUE))
  }
  colnames(sample_mean_concentration_batchwise)[(count+3):((count+2)+num_batches)]=paste("Batch",seq(1:num_batches),sep="")
  sample_mean_concentration_batchwise[,(count+3):((count+2)+num_batches)][is.na(sample_mean_concentration_batchwise[,(count+3):((count+2)+num_batches)])] <- 0
  
  write.table(final_concentrations, paste(outloc,"Final_concentrations_with_Qstd_and_study.txt",sep="/"), sep= "\t", row.names=FALSE)
  write.table(sample_only_concentrations, paste(outloc,"Final_concentrations_with_study_only.txt",sep="/"), sep= "\t", row.names=FALSE)
  write.table(sample_mean_concentration_batchwise, paste(outloc,"Final_average_concentrations_with_study_only.txt",sep="/"), sep= "\t", row.names=FALSE)
  
  return(final_concentrations)
}


draw_keggmap<-function(targeted_table,outloc,foldchange.thresh=2,minhit=3,highcolor='red',lowcolor='blue',percent_node=0.2){
  
  suppressMessages(library(pathview))
  
  if(length(grep('keggid',colnames(targeted_table),ignore.case=TRUE))==0){
    stop("No KEGG ID was detected in reference list. To draw kegg map, please add one more column named 'KEGGID' to reference list for KEGG ID.")
  }
  
  iddata=targeted_table[,"KEGGID"]
  
  targeted_table[,'map'] <- unlist(mclapply(1:length(iddata), function(j) {
    API=paste("http://rest.kegg.jp/get/",as.character(iddata[j]),sep="")
    content<-try(readLines(API),silent=TRUE)
    if (class(content) == "try-error") {
      return(NA)
    }else{
      return(paste(gsub('^.*(map[0-9]*).*$','\\1',content[grep('map[0-9]',content)],perl=TRUE),collapse=","))
    }
  },mc.cores=detectCores()))
  
  totalmap=unique(unlist(strsplit(paste(targeted_table[,"map"][grep("map",targeted_table[,"map"])],collapse=","), ",")))
  mapdata=data.frame(mapID=totalmap)
  
  for(ii in 1:length(totalmap)){
    mapdata[ii,"ref_mz_time"]=paste(paste(round(targeted_table[grep(totalmap[ii],targeted_table[,"map"]),"ref_mz"],5),round(targeted_table[grep(totalmap[ii],targeted_table[,"map"]),"ref_time"],1),sep="_"),collapse="/")
    mapdata[ii,"mz_time"]=paste(paste(round(targeted_table[grep(totalmap[ii],targeted_table[,"map"]),"mz"],5),round(targeted_table[grep(totalmap[ii],targeted_table[,"map"]),"time"],1),sep="_"),collapse="/")
    mapdata[ii,"keggid"]=paste(as.character(targeted_table[grep(totalmap[ii],targeted_table[,"map"]),"KEGGID"]),collapse="/")
    mapdata[ii,"foldchange"]=paste(targeted_table[grep(totalmap[ii],targeted_table[,"map"]),"foldchange"],collapse="/")
  }
  
  write.table(mapdata, paste(outloc,"keggmapdata.txt",sep="/"), sep= "\t", row.names=FALSE)
  
  suppressWarnings(dir.create(paste(outloc,"KEGGmaps",sep="/"),,showWarnings = FALSE))
  
  print_png <- function(i,mapdata,foldchange.thresh,lowcolor,highcolor,minhit,outloc){
    
    #load the required packages
    library(pathview)
    
    if(as.character(mapdata[i,1])%in%c('map01100','map01110','map01130','map01120','map00121','map01060')){
      
    }else{
      cpd.data=as.numeric(unlist(strsplit(as.character(mapdata[i,"foldchange"]), "/")))
      names(cpd.data)=unlist(strsplit(as.character(mapdata[i,"keggid"]), "/"))
      cpd.data=cpd.data[!duplicated(cpd.data)]
      if(length(cpd.data)<minhit){
        
      }else{
        log.cpd.data <- log(cpd.data,base = foldchange.thresh)
        pathwayid=gsub("map","",as.character(mapdata[i,"mapID"]))
        suffix=paste("highlighted","_",length(log.cpd.data),'hits',sep="")
        setwd(paste(outloc,"KEGGmaps",sep="/"))
        try(pathview(gene.data =NULL, cpd.data=log.cpd.data, pathway.id=pathwayid, cpd.idtype='kegg', same.layer=TRUE, plot.col.key =TRUE,new.signature=FALSE,low = list(cpd = lowcolor), mid =list(cpd = "grey"),high=list(cpd = highcolor),out.suffix=suffix,species = "ko"),silent=TRUE)
        unlink(paste(paste("ko",pathwayid,sep=""),"png",sep="."), recursive = FALSE)
        unlink(paste(paste("ko",pathwayid,sep=""),"xml",sep="."), recursive = FALSE)
        print(getwd())
      }
    }
  }
  
  nu_cores <- detectCores()
  cl <- makeCluster(ceiling(nu_cores*as.numeric(percent_node)))
  parLapply(cl,1:nrow(mapdata),print_png,mapdata=mapdata,foldchange.thresh=foldchange.thresh,lowcolor=lowcolor,highcolor=highcolor,minhit=minhit,outloc=outloc)
  stopCluster(cl)
  
}



quant<- function(Xmat=NA,Ymat=NA,Wmat=NA,Zmat=NA,feature_table,class_file,ref_list,foldchange_list,outloc,
                 num_replicates=1,
                 summarize_replicates=FALSE,
                 rep.max.missing.thresh=0.6,
                 summary.method="mean",
                 mass_error= 10,
                 time_error= 30,
                 percent_node=0.6,
                 foldchange_thresh=2,
                 steps="123",
                 min_num_nonmissing=3,
                 targetID=NA,
                 minhit=3,
                 groupcheck=TRUE,
                 highcolor='red',
                 lowcolor='blue',summary.na.replacement="zeros",missing.val=0,normalization.method="none",alphabetical.order=FALSE
) {
  theme_set(theme_classic())
  
  #read in data tables
  if(!is.na(feature_table)){
    feature.table<- read.table(feature_table, sep= "\t", header=TRUE)
  }else{
    if(is.data.frame(Xmat)){
      feature.table<-Xmat
    }else{
      stop("There is no feature table file. Please provide the path of feature table file or feature table R object.", call.=TRUE)
    }
  }
  if(is.numeric(feature.table[,1])==FALSE){
    stop('Please double check the mz column in your feature table, it is not numeric.')
  }
  if(is.numeric(feature.table[,2])==FALSE){
    stop('Please double check the time column in your feature table, it is not numeric.')
  }
  
  parallel:::setDefaultClusterOptions(setup_strategy = "sequential")
  
  #read in sample id mapping
  if(!is.na(class_file)){
    sample.mapping<- read.table(class_file, sep= "\t", header= TRUE)
  }else{
    if(is.data.frame(Ymat)){
      sample.mapping<-Ymat
    }else{
      stop("There is no class label file. Please provide the path of class label file or class label R object.", call.=FALSE)
    }
  }
  colnames(sample.mapping)[1:4]=c("FileName","SampleID","Sample_type","Batch")
  
  
  #read in reference standardization list
  if(!is.na(ref_list)){
    ref_table<- read.table(ref_list, sep= "\t", header= TRUE, quote= "\"")
  }else{
    if(is.data.frame(Wmat)){
      ref_table<-Wmat
    }else{
      stop("There is no reference standardization list. Please provide the path of reference standardization list or list R object.", call.=FALSE)
    }
  }
  colnames(ref_table)[c(1,2,3,4)]=c("ref_mz","ref_time","Chemical_name","Qstd3")
  if(is.numeric(ref_table$ref_mz)==FALSE){
    stop('Please double check the mz column in your reference standardization list, it is not numeric.')
  }
  if(is.numeric(ref_table$ref_time)==FALSE){
    stop('Please double check the time column in your reference standardization list, it is not numeric.')
  }
  if(is.numeric(ref_table$Qstd3)==FALSE){
    stop('Please double check the Qstd column in your reference standardization list, it is not numeric.')
  }
  
  if(length(grep("3",steps))!=0){
    #read in fold change list
    if(!is.na(foldchange_list)){
      foldchange_table<- read.table(foldchange_list, sep= "\t", header= TRUE, quote= "\"")
    }else{
      if(is.data.frame(Zmat)){
        foldchange_table<-Zmat
      }else{
        stop("There is no fold change list. Please provide the path of fold change list or list R object.", call.=FALSE)
      }
    }
  }
  
  #check if the file name can match with feature table
  match1 <- setdiff(colnames(feature.table[,-c(1,2)]),as.character(sample.mapping[,1]))
  match2 <- setdiff(as.character(sample.mapping[,1]),colnames(feature.table[,-c(1,2)]))
  if(length(match1)!=0 && length(match2)!=0){
    stop("The file name in class file can't be matched with the name in feature table. Please check if the fileName has '.' symbol. If so, please use '_' to replace it.", call.=FALSE)
  }else{
    feature.table=feature.table[,c("mz","time",as.character(sample.mapping[,1]))]
  }
  
  suppressWarnings(dir.create(outloc,showWarnings = FALSE))
  setwd(outloc)
  
  if(summarize_replicates==TRUE){
    capture.output(avg_feature_table<-data_preprocess(X=feature.table,feature_table_file=NA,parentoutput_dir=outloc,
                                                      
                                                      class_labels_file=NA,num_replicates=num_replicates,feat.filt.thresh=NA,summarize.replicates=TRUE,
                                                      summary.method=summary.method,all.missing.thresh=NA,group.missing.thresh=NA,
                                                      log2transform=FALSE,medcenter=FALSE,znormtransform=FALSE,quantile_norm=FALSE,
                                                      lowess_norm=FALSE,madscaling=FALSE,missing.val=missing.val,samplermindex=NA, 
                                                      rep.max.missing.thresh=rep.max.missing.thresh,summary.na.replacement=summary.na.replacement,
                                                      normalization.method = normalization.method,alphabetical.order=alphabetical.order), file='/dev/null')
    avg_feature_table<-avg_feature_table$data_matrix_afternorm_scaling
    unlink(paste(outloc,"Stage1",sep="/"), recursive = TRUE)
  }else{
    avg_feature_table<-feature.table
  }
  #create average sample mapfile
  sample.mapping<- sample.mapping[as.character(sample.mapping[,1])%in%colnames(avg_feature_table)[-c(1,2)],]
  
  ######################## pre-processing ############################
  
  #create feature table with reference masses
  #matches ref list massess with feature table
  capture.output(overlap<- find.Overlapping(ref_table[,c(1,2)], avg_feature_table, mz.thresh = mass_error, time.thresh = time_error), file='/dev/null')
  
  #show error if there is no match between feature table and reference list
  if(length(overlap)==0){
    stop("There is no match between feature table and reference list.",call.=FALSE)
  }
  
  #calculate ppm error between reference mass and feature table
  mz_error<- overlap$`mz.difference(ppm)`
  #merges detected metabolites in reference list with feature table; includes all samples
  if(is.null(overlap$time.difference)){
    if(length(grep("3",steps))!=0){
      foldchange=foldchange_table[overlap$index.B,3]
      r_targeted_table<- cbind(ref_table[overlap$index.A,], foldchange , mz_error, avg_feature_table[overlap$index.B,])
    }else{
      r_targeted_table<- cbind(ref_table[overlap$index.A,], mz_error, avg_feature_table[overlap$index.B,])
    }
  }else{
    if(length(grep("3",steps))!=0){
      foldchange=foldchange_table[overlap$index.B,3]
      r_targeted_table<- cbind(ref_table[overlap$index.A,], foldchange, mz_error, overlap$time.difference, avg_feature_table[overlap$index.B,])
      colnames(r_targeted_table)[match("overlap$time.difference",colnames(r_targeted_table))]='time_error'
    }else{
      r_targeted_table<- cbind(ref_table[overlap$index.A,], mz_error, overlap$time.difference, avg_feature_table[overlap$index.B,])
      colnames(r_targeted_table)[match("overlap$time.difference",colnames(r_targeted_table))]='time_error'
    }
  }
  
  ###################################################################
  
  #check distribution
  if(length(grep("1",steps))!=0){
    print("1. Plotting the intensity distribution of samples and qstd.")
    outloc1=paste(outloc,"/step1",sep="")
    suppressWarnings(dir.create(outloc1,showWarnings = FALSE))
    generate_distribution(targeted_table=r_targeted_table,seq=sample.mapping,outloc=outloc1,groupcheck=groupcheck,targetID=targetID,min_num_nonmissing=min_num_nonmissing)
    print("Step 1 complete")
  }
  
  #calculate the concentration
  if(length(grep("2",steps))!=0){
    print("2. Calculating the concentration for all samples.")
    outloc2=paste(outloc,"/step2",sep="")
    suppressWarnings(dir.create(outloc2,showWarnings = FALSE))
    final_study_qstd_conc=calculate_concentration(targeted_table=r_targeted_table,ref=ref_table,seq=sample.mapping,outloc=outloc2)
    
    generate_distribution_concentration(targeted_table=final_study_qstd_conc,seq=sample.mapping,outloc=outloc2,groupcheck=groupcheck,targetID=targetID,min_num_nonmissing=min_num_nonmissing)
    
    print("Step 2 complete")
  }
  
  #draw kegg map
  if(length(grep("3",steps))!=0){
    print("3. Pulling the KEGG maps out from KEGG website.")
    outloc3=paste(outloc,"/step3",sep="")
    suppressWarnings(dir.create(outloc3,showWarnings = FALSE))
    draw_keggmap(targeted_table=r_targeted_table,outloc=outloc3,foldchange.thresh=foldchange_thresh,minhit=minhit,highcolor=highcolor,lowcolor=lowcolor,percent_node=percent_node)
    print("Step 3 complete")
  }
  
  #suppressWarnings(dir.create(paste(outloc,"KEGGmaps",sep="/")))
  #try(file.rename(paste(getwd(),list.files(pattern=".png"),sep="/"),paste(paste(outloc,"KEGGmaps",sep="/"),list.files(pattern=".png"),sep="/")),silent=TRUE)
  
}



.onAttach <- function(libname, pkgname) {
  # to show a startup message
  #packageStartupMessage("xmsPANDA v1.2 successfully loaded.")
  
  suppressMessages(library(RColorBrewer))
  #suppressMessages(library(data.table))
  suppressMessages(library(plyr))
  suppressMessages(library(parallel))
  suppressMessages(library(CMA))
  suppressMessages(library(ggplot2))
  #suppressMessages(library(extrafont))
  
}

.onLoad <- function(libname, pkgname) {
  # something to run
  packageStartupMessage("xmsPANDA v1.3.1 (04/12/2021) successfully loaded.")
  suppressMessages(library(RColorBrewer))
  #suppressMessages(library(data.table))
  suppressMessages(library(plyr))
  suppressMessages(library(parallel))
  suppressMessages(library(CMA))
  suppressMessages(library(ggplot2))
  # suppressMessages(library(extrafont))
}
